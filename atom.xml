<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
  <id>http://www.zhangsj.xyz/blog/</id>
  <title>zhangsj的个人博客</title>
  <subtitle>Java学习</subtitle>
  <author>
    <name>zhangsj</name>
  </author>
  <updated>2022-04-13T01:21:16.422Z</updated>
  <generator>@mr-hope/vuepress-plugin-feed</generator>
  <link rel="self" href="http://www.zhangsj.xyz/blog/atom.xml"/>
  <link rel="alternate" href="http://www.zhangsj.xyz/blog/"/>
  <rights>&lt;a href="https://beian.miit.gov.cn/" target="_blank"&gt;晋ICP备2021007439号&lt;/a&gt;</rights>
  <category term="algo"/>
  <category term="business"/>
  <category term="note"/>
  <category term="随笔"/>
  <category term="expierence"/>
  <category term="fubuhi"/>
  <category term="java"/>
  <category term="mulu"/>
  <category term="concurrent"/>
  <category term="thread"/>
  <category term="mysql"/>
  <category term="jvm"/>
  <category term="mq"/>
  <category term="redis"/>
  <category term="soa"/>
  <category term="fubushi"/>
  <category term="分布式"/>
  <category term="spring"/>
  <category term="personal-planning"/>
  <category term="tool"/>
  <category term="js"/>
  <contributor>
    <name>zhangsj</name>
  </contributor>
  <contributor>
    <name>狼爷、zsj</name>
  </contributor>
  <contributor>
    <name>HorstXu</name>
  </contributor>
  <contributor>
    <name>Dean Wang</name>
  </contributor>
  <contributor>
    <name>lanqiu5ge</name>
  </contributor>
  <contributor>
    <name>徐刘根</name>
  </contributor>
  <contributor>
    <name>Felix zyf</name>
  </contributor>
  <contributor>
    <name>SexyCode</name>
  </contributor>
  <entry>
    <title type="html">home</title>
    <id>http://www.zhangsj.xyz/blog/</id>
    <link href="http://www.zhangsj.xyz/blog/"/>
    <updated>2022-03-24T05:27:46.000Z</updated>
    <author>
      <name>zhangsj</name>
    </author>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-01-08T08:18:19.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">关于网站</title>
    <id>http://www.zhangsj.xyz/blog/about/worklife/</id>
    <link href="http://www.zhangsj.xyz/blog/about/worklife/"/>
    <updated>2022-02-25T04:35:55.000Z</updated>
    <content type="html"><![CDATA[<h1 id="关于网站"> 关于网站</h1>
<p>网站使用 <a href="https://v1.vuepress.vuejs.org/zh/guide/" target="_blank" rel="noopener noreferrer">VuePress</a> 建站工具构建，使用主题 <a href="https://github.com/Mister-Hope/vuepress-theme-hope/" target="_blank" rel="noopener noreferrer">vuepress-theme-hope</a></p>
<p>19 年，springbatch，azkaban，银行业务票据管理系统</p>
<p>20 疫情原因，在家待了两个月，参加工作岗前培训了两个月，内容 vue，oracle 等国家局的前后端框架，成都出差半年多，参与异地数据转换，一直干医保业务，主要是登记类业务</p>
<p>21 去贵州出差，成都出差 2 个多月，基础结算子系统，出差完后开发山西新医保核心业务系统；七月底来到北京从事北京新医保的开发，</p>
<p>22 半年休息了一个礼拜不到，准备休息一段时间放松一下自己，然后换新工作；</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-24T10:20:04.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">intro</title>
    <id>http://www.zhangsj.xyz/blog/about/</id>
    <link href="http://www.zhangsj.xyz/blog/about/"/>
    <updated>2022-02-26T01:14:14.000Z</updated>
    <content type="html"><![CDATA[<div><p>相关信息</p>
<p>姓名: 张士敬</p>
<p>职业：软件开发工程师</p>
<p>大学：太原理工大学</p>
<p>性别: 男</p>
<p>年龄: 20~30</p>
<p>婚姻情况: 未婚</p>
<p>爱好: 历史、篮球、编程、书法</p>
<p>照片: 无</p>
</div>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-24T10:20:04.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">algorithm-content</title>
    <id>http://www.zhangsj.xyz/blog/algo/</id>
    <link href="http://www.zhangsj.xyz/blog/algo/"/>
    <updated>2022-04-12T10:55:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="算法目录"> 算法目录</h2>
<ul>
<li><a href="./docs/algo/二叉树的最大深度.html">二叉树的最大深度</a></li>
<li><a href="./docs/algo/八种排序算法总结.html">八种排序算法总结</a></li>
<li><a href="./docs/algo/算法-八皇后.html">算法-八皇后</a></li>
<li><a href="./docs/algo/链表判断有环、递归反转.html">链表判断有环、递归反转</a></li>
</ul>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="algo"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-04-12T10:55:02.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">algo</title>
    <id>http://www.zhangsj.xyz/blog/algo/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</id>
    <link href="http://www.zhangsj.xyz/blog/algo/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <updated>2022-04-12T10:55:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="binary-tree-deep"> binary tree deep</h2>
<p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的路径上的节点数。</p>
<p>说明:</p>
<p>叶子节点是指没有子节点的节点。</p>
<div><pre><code>给定二叉树` [3,9,20,null,null,15,7]`

    3
   / \
  9  20
    /  \
   15   7

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>返回它的最大深度 3 。</p>
<p><strong>解题思路</strong></p>
<p>要求二叉树的最大深度，我们可以先求出左子树和右子树的深度 l 和 r</p>
<p>那就可以计算出二叉树的最大深度了：max( l,r )+1</p>
<p>而左子树和右子树的最大深度又可以以同样的方式进行计算。</p>
<p>因此我们可以用「深度优先搜索」的方法来计算二叉树的最大深度。</p>
<p>具体而言，在计算当前二叉树的最大深度时，可以先递归计算出其左子树和右子树的最大深度，然后在 O(1) 时间内计算出当前二叉树的最大深度。递归在访问到空节点时退出。</p>
<p>:::: 递归求最大深度</p>
<div><pre><code>
<span>class</span> <span>TreeNode</span> <span>{</span>
    <span>Node</span> left<span>;</span>
    <span>Node</span> right<span>;</span>
<span>}</span>

<span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>int</span> <span>maxDepth</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>
           <span>//递归终止情况：节点为空</span>
            <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span>
            <span>{</span>
                <span>return</span> <span>0</span><span>;</span>
            <span>}</span>
            <span>else</span><span>{</span>
             <span>int</span> ldpeth <span>=</span> <span>maxDepth</span><span>(</span>root<span>.</span>left<span>)</span><span>;</span>
             <span>int</span> rdpeth <span>=</span> <span>maxDepth</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>
              <span>return</span> <span>Math</span><span>.</span><span>max</span><span>(</span>ldpeth <span>,</span> rdpeth <span>)</span> <span>+</span> <span>1</span><span>;</span>
            <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>通过
执行用时：100 ms，在所有 C# 提交中击败了 43.46%的用户
内存消耗：25.7 MB，在所有 C# 提交中击败了 10.73%的用户</p>
<p>时间复杂度：O(n) O( n )其中 n 为二叉树节点的个数。每个节点在递归中只被遍历一次。
空间复杂度：O(n) 空间复杂度：O( height ) 其中 height 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。</p>
<h2 id="广度优先搜索"> 广度优先搜索</h2>
<p>思路解析</p>
<p>此时我们广度优先搜索的队列里存放的是「当前层的所有节点」。</p>
<p>每次拓展下一层的时候，不同于广度优先搜索的每次只从队列里拿出一个节点，我们需要将队列里的所有节点都拿出来进行拓展，这样能保证每次拓展完的时候队列里存放的是当前层的所有节点，即我们是一层一层地进行拓展，最后我们用一个变量 ans 来维护拓展的次数，该二叉树的最大深度即为 ans。</p>
<div><pre><code>
<span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>void</span> <span>merge</span><span>(</span><span>int</span><span>[</span><span>]</span> nums1<span>,</span> <span>int</span> m<span>,</span> <span>int</span><span>[</span><span>]</span> nums2<span>,</span> <span>int</span> n<span>)</span> <span>{</span>
        <span>int</span> p1 <span>=</span> <span>0</span><span>,</span> p2 <span>=</span> <span>0</span><span>;</span>
        <span>int</span><span>[</span><span>]</span> sorted <span>=</span> <span>new</span> <span>int</span><span>[</span>m <span>+</span> n<span>]</span><span>;</span>
        <span>int</span> cur<span>;</span>
        <span>while</span> <span>(</span>p1 <span>&lt;</span> m <span>||</span> p2 <span>&lt;</span> n<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>p1 <span>==</span> m<span>)</span> <span>{</span>
                cur <span>=</span> nums2<span>[</span>p2<span>++</span><span>]</span><span>;</span>
            <span>}</span> <span>else</span> <span>if</span> <span>(</span>p2 <span>==</span> n<span>)</span> <span>{</span>
                cur <span>=</span> nums1<span>[</span>p1<span>++</span><span>]</span><span>;</span>
            <span>}</span> <span>else</span> <span>if</span> <span>(</span>nums1<span>[</span>p1<span>]</span> <span>&lt;</span> nums2<span>[</span>p2<span>]</span><span>)</span> <span>{</span>
                cur <span>=</span> nums1<span>[</span>p1<span>++</span><span>]</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                cur <span>=</span> nums2<span>[</span>p2<span>++</span><span>]</span><span>;</span>
            <span>}</span>
            sorted<span>[</span>p1 <span>+</span> p2 <span>-</span> <span>1</span><span>]</span> <span>=</span> cur<span>;</span>
        <span>}</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>!=</span> m <span>+</span> n<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
            nums1<span>[</span>i<span>]</span> <span>=</span> sorted<span>[</span>i<span>]</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id="深度优先遍历"> 深度优先遍历</h2>
<p>指对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。</p>
<p>二叉树的深度优先遍历分为：先序遍历，中序遍历和后序遍历</p>
<ul>
<li>先序遍历：先访问根，在访问左子树，最后访问右子树，总结就是“根左右”；</li>
<li>中序遍历：先访问左子树，再访问根，最后访问右子树，总结就是“左根右”；</li>
<li>后序遍历：先访问左子树，再访问右子树，最后访问根，总结就是“左右根”。</li>
</ul>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="algo"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-04-12T10:55:02.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">8sort-algo</title>
    <id>http://www.zhangsj.xyz/blog/algo/%E5%85%AB%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <link href="http://www.zhangsj.xyz/blog/algo/%E5%85%AB%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <updated>2022-04-12T10:55:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="_8sort-algo"> 8sort-algo</h2>
<blockquote>
<p>原地排序：是否使用了利用辅助的空间。
稳定排序：数列值相等的元素排序后相对顺序不变</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/80025882a2694b9e9a7cf955c07760ab.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y2I5aScLuW5vemtgi7nlLc=,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="堆排序-不稳定-原地"> 堆排序(不稳定,原地)</h2>
<h4 id="思路"> 思路</h4>
<p>1）数组构建成二叉堆。(小到大排序,则构建最大堆)；
2）循环删除堆顶元素,替换到二叉堆的末尾,调整堆产生新的堆顶。</p>
<h4 id="代码"> 代码</h4>
<div><pre><code><span>class</span> <span>T</span><span>{</span>
<span>/**
 * 下沉调整
 * @param arr 待调整的堆
 * @param parent 要下沉的父节点
 */</span>
<span>public</span> <span>static</span> <span>void</span> <span>downAdjust</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>,</span> <span>int</span> parent<span>,</span><span>int</span> length<span>)</span> <span>{</span>
    <span>//temp保存父节点值,用于最后的赋值</span>
    <span>int</span> temp <span>=</span> arr<span>[</span>parent<span>]</span><span>;</span>
    <span>int</span> child<span>=</span> <span>2</span> <span>*</span> parent<span>+</span><span>1</span><span>;</span>
    <span>while</span> <span>(</span>child<span>&lt;</span> length<span>)</span> <span>{</span>
        <span>//如果有右孩子,且右孩子大于左孩子的值,则定位到右孩子</span>
        <span>if</span> <span>(</span>child<span>+</span> <span>1</span> <span>&lt;</span> length <span>&amp;&amp;</span> arr<span>[</span>child<span>+</span> <span>1</span><span>]</span> <span>></span> arr<span>[</span>child<span>]</span><span>)</span> <span>{</span>
            childIndex<span>++</span><span>;</span>
        <span>}</span>
        <span>//如果父节点小于任何一个孩子的值,则直接跳出</span>
        <span>if</span> <span>(</span>temp <span>>=</span> arr<span>[</span>child<span>]</span><span>)</span> <span>{</span>
            <span>break</span><span>;</span>
        <span>}</span>
        <span>//无须真正交换,单向赋值即可</span>
        arr<span>[</span>parent<span>]</span> <span>=</span> array<span>[</span>child<span>]</span><span>;</span>
        parent<span>=</span> child<span>;</span>
        child<span>=</span> <span>2</span> <span>*</span> parent<span>+</span> <span>1</span><span>;</span>
    <span>}</span>
    arr<span>[</span>parent<span>]</span> <span>=</span> temp<span>;</span>

<span>}</span>
<span>/**
 * 堆排序（升序）
 * @param arr待调整的堆
 */</span>
<span>public</span> <span>static</span> <span>void</span> <span>heapSort</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>)</span> <span>{</span>
    <span>//1. 把无序数组构建成最大堆</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>(</span>arr<span>.</span>length <span>-</span><span>2</span><span>)</span><span>/</span> <span>2</span><span>;</span> i <span>>=</span> <span>0</span><span>;</span> i<span>--</span><span>)</span> <span>{</span>
        <span>downAdjust</span><span>(</span>arr<span>,</span>i<span>,</span>arr<span>.</span>length<span>)</span><span>;</span>
    <span>}</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Arrays</span><span>.</span><span>toString</span><span>(</span>arr<span>)</span><span>)</span><span>;</span>
    <span>//2. 循环删除堆顶元素,移到集合尾部,调整堆产生新的堆顶</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> arr<span>.</span>length<span>;</span> i <span>></span> <span>0</span><span>;</span> i<span>--</span><span>)</span> <span>{</span>
        <span>//最后1个元素和第一个元素进行交换</span>
  <span>swap</span><span>(</span>arr<span>,</span><span>0</span><span>,</span>i<span>)</span><span>;</span>
        <span>//“下沉”调整最大堆</span>
        <span>downAdjust</span><span>(</span>arr<span>,</span> <span>0</span><span>,</span> i<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>public</span> <span>static</span> <span>void</span> <span>swap</span><span>(</span><span>int</span><span>[</span><span>]</span> a<span>,</span><span>int</span> i<span>,</span><span>int</span> j<span>)</span> <span>{</span>
 <span>int</span> temp <span>=</span> a<span>[</span>i<span>]</span><span>;</span>
 a<span>[</span>i<span>]</span> <span>=</span> a<span>[</span>j<span>]</span><span>;</span>
 a<span>[</span>j<span>]</span> <span>=</span> temp<span>;</span>
<span>}</span>

<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>new</span> <span>int</span><span>[</span><span>]</span> <span>{</span><span>1</span><span>,</span><span>3</span><span>,</span><span>2</span><span>,</span><span>6</span><span>,</span><span>5</span><span>,</span><span>7</span><span>,</span><span>8</span><span>,</span><span>9</span><span>,</span><span>10</span><span>,</span><span>0</span><span>}</span><span>;</span>
    <span>heapSort</span><span>(</span>arr<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Arrays</span><span>.</span><span>toString</span><span>(</span>arr<span>)</span><span>)</span><span>;</span>
<span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br></div></div><h2 id="快速排序"> 快速排序</h2>
<p>快速排序是一种原地排序,只需要一个很小的栈作为辅助空间,空间复杂度为 O(log2n),所以适合在数据集比较大的时候使用。</p>
<h4 id="思路-双边循环法"> 思路 (双边循环法)</h4>
<p>使用递归方法</p>
<ol>
<li>找一个基线条件(递归结束条件)区间不可再分；</li>
<li>每一轮挑选一个基准元素,比基准元素大的元素移动到数列一边,小的元素移动到数列的另一边；</li>
<li>然后分别对得到的子数组第二步的操作,直到符合基线条件。</li>
</ol>
<h4 id="代码-双边循环法"> 代码 (双边循环法)</h4>
<div><pre><code><span>class</span> <span>T</span><span>{</span>
<span>public</span> <span>static</span> <span>void</span> <span>quickSort</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>,</span> <span>int</span> startIndex<span>,</span><span>int</span> endIndex<span>)</span> <span>{</span>
    <span>// 递归结束条件：startIndex大于或等于endIndex时</span>
    <span>if</span> <span>(</span>startIndex <span>>=</span> endIndex<span>)</span> <span>{</span>
        <span>return</span><span>;</span>
    <span>}</span>
    <span>// 得到基准元素位置</span>
    <span>int</span> pivotIndex <span>=</span> <span>partition</span><span>(</span>arr<span>,</span>startIndex<span>,</span> endIndex<span>)</span><span>;</span>
    <span>//根据基准元素,分成两部分进行递归排序</span>
    <span>quickSort</span><span>(</span>arr<span>,</span> startIndex<span>,</span> pivotIndex <span>-</span> <span>1</span><span>)</span><span>;</span>
    <span>quickSort</span><span>(</span>arr<span>,</span> pivotIndex <span>+</span> <span>1</span><span>,</span> endIndex<span>)</span><span>;</span>
<span>}</span>

    <span>/**
     * 分治（双边循环法）
     * 让数列中的元素依据自身大小,分别交换到基准元素的左右两边。
     * @param arr         待交换的数组
     * @param startIndex  起始下标
     * @param endIndex    结束下标
     */</span>
    <span>private</span> <span>static</span> <span>int</span> <span>partition</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>,</span><span>int</span> startIndex<span>,</span><span>int</span> endIndex<span>)</span><span>{</span>
        <span>// 取第一个位置（也可以选择随机位置）的元素作为基准元素</span>
        <span>int</span> pivot <span>=</span> arr<span>[</span>startIndex<span>]</span><span>;</span>
        <span>int</span> left <span>=</span> startIndex<span>;</span>
        <span>int</span> right <span>=</span> endIndex<span>;</span>

        <span>while</span> <span>(</span>left <span>!=</span> right<span>)</span><span>{</span>
            <span>//控制right指针比较并左移</span>
            <span>while</span><span>(</span>left <span>&lt;</span> right <span>&amp;&amp;</span> arr<span>[</span>right<span>]</span> <span>>=</span> pivot<span>)</span><span>{</span>
                right<span>--</span><span>;</span>
            <span>}</span>
            <span>//控制left指针比较并右移</span>
            <span>while</span> <span>(</span>left <span>&lt;</span> right <span>&amp;&amp;</span> arr<span>[</span>left<span>]</span> <span>&lt;=</span> pivot<span>)</span><span>{</span>
                left<span>++</span><span>;</span>
            <span>}</span>
            <span>//交换left 和 right指针所指向的元素</span>
            <span>if</span><span>(</span>left<span>&lt;</span>right<span>)</span><span>{</span>
                <span>int</span> tmp <span>=</span> arr<span>[</span>left<span>]</span><span>;</span>
                arr<span>[</span>left<span>]</span> <span>=</span> arr<span>[</span>right<span>]</span><span>;</span>
                arr<span>[</span>right<span>]</span> <span>=</span> tmp<span>;</span>
            <span>}</span>
        <span>}</span>

        <span>//pivot和指针重合点交换</span>
        arr<span>[</span>startIndex<span>]</span> <span>=</span> arr<span>[</span>left<span>]</span><span>;</span>
        arr<span>[</span>left<span>]</span> <span>=</span> pivot<span>;</span>

        <span>return</span> left<span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>int</span><span>[</span><span>]</span> <span>{</span><span>4</span><span>,</span><span>4</span><span>,</span><span>6</span><span>,</span><span>5</span><span>,</span><span>3</span><span>,</span><span>2</span><span>,</span><span>8</span><span>,</span><span>1</span><span>}</span><span>;</span>
        <span>quickSort</span><span>(</span>arr<span>,</span><span>0</span><span>,</span>arr<span>.</span>length<span>-</span><span>1</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Arrays</span><span>.</span><span>toString</span><span>(</span>arr<span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br></div></div><p><strong>单边循环法</strong></p>
<h4 id="思路-单边循环法"> 思路 (单边循环法)</h4>
<p>1）设置一个 mark 指针指向数列起始位置,这个 mark 指针代表小于基准元素的<strong>区域边界</strong>。</p>
<p>2）从基准元素的下一个位置开始遍历数组。</p>
<p>如果遍历到的元素大于基准元素,就继续往后遍历。</p>
<p>如果遍历到的元素小于基准元素,则需要做两件事：</p>
<ul>
<li>mark 指针右移一位,小于 pivot 的区域边界增大；</li>
<li>让最新遍历到的元素和 mark 指针所在的元素交互位置。</li>
</ul>
<h4 id="代码-单边循环法"> 代码 (单边循环法)</h4>
<div><pre><code><span>class</span> <span>T</span><span>{</span>
    <span>private</span> <span>static</span> <span>int</span> <span>partitionV2</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>,</span> <span>int</span> startIndex<span>,</span> <span>int</span> endIndex<span>)</span><span>{</span>
        <span>int</span> pivot <span>=</span> arr<span>[</span>startIndex<span>]</span><span>;</span>
        <span>int</span> mark <span>=</span> startIndex<span>;</span>

        <span>//从基准元素的下一个位置开始遍历数组</span>
        <span>for</span><span>(</span><span>int</span> i<span>=</span>startIndex<span>+</span><span>1</span><span>;</span> i<span>&lt;=</span>endIndex<span>;</span> i<span>++</span><span>)</span><span>{</span>
            <span>//遍历到的元素小于基准元素</span>
            <span>if</span><span>(</span>arr<span>[</span>i<span>]</span><span>&lt;</span>pivot<span>)</span><span>{</span>
                <span>//mark指针右移1位,小于pivot的区域边界增大了1;</span>
                mark<span>++</span><span>;</span>
                <span>//让最新遍历到的元素和mark指针所在位置的元素交换位置</span>
                <span>int</span> p <span>=</span> arr<span>[</span>mark<span>]</span><span>;</span>
                arr<span>[</span>mark<span>]</span> <span>=</span> arr<span>[</span>i<span>]</span><span>;</span>
                arr<span>[</span>i<span>]</span> <span>=</span> p<span>;</span>
            <span>}</span>
            <span>//最后把pivot元素交换到mark指针所在位置,该数列的分治就宣告结束了。</span>
            arr<span>[</span>startIndex<span>]</span> <span>=</span> arr<span>[</span>mark<span>]</span><span>;</span>
            arr<span>[</span>mark<span>]</span> <span>=</span> pivot<span>;</span>
            <span>return</span> mark<span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h2 id="冒泡排序"> 冒泡排序</h2>
<h4 id="思路-2"> 思路</h4>
<ol>
<li>比较相邻的两个数据,前一个元素比后一个元素大就交换位置</li>
<li>从前往后,两两比较,得到最大数</li>
<li>重复操作,直到最后一个值结束,得到的新数组就是有序的了</li>
</ol>
<h4 id="代码-2"> 代码</h4>
<div><pre><code><span>public</span> <span>class</span> <span>BubbleSort</span> <span>{</span>
 <span>public</span> <span>static</span> <span>void</span> <span>sort</span><span>(</span><span>int</span> <span>[</span><span>]</span> arr<span>)</span><span>{</span>
      <span>for</span><span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span> i<span>&lt;</span>arr<span>.</span>length<span>-</span><span>1</span><span>;</span> i<span>++</span><span>)</span><span>{</span><span>//表示趟数,一共arr.length-1次。</span>
          <span>for</span><span>(</span><span>int</span> j<span>=</span>arr<span>.</span>length<span>-</span><span>1</span><span>;</span> j <span>></span> i  <span>;</span> j<span>--</span><span>)</span><span>{</span>
           <span>if</span> <span>(</span> arr<span>[</span>j<span>-</span><span>1</span><span>]</span><span>></span>arr<span>[</span>j<span>]</span><span>)</span> <span>{</span>
            <span>swap</span><span>(</span>arr<span>,</span> j<span>,</span> j<span>-</span><span>1</span><span>)</span><span>;</span>
    <span>}</span>
          <span>}</span>
      <span>}</span>
  <span>}</span>
 <span>//优化后版本</span>
 <span>public</span> <span>static</span> <span>void</span> <span>sortV2</span><span>(</span><span>int</span> <span>[</span><span>]</span> arr<span>)</span><span>{</span>
      <span>for</span><span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>-</span><span>1</span><span>;</span> i<span>++</span><span>)</span><span>{</span><span>//趟数</span>
       <span>boolean</span> isSorted <span>=</span> <span>true</span><span>;</span>
          <span>for</span><span>(</span><span>int</span> j<span>=</span><span>0</span><span>;</span> j <span>&lt;</span> arr<span>.</span>length <span>-</span> i <span>-</span> <span>1</span>  <span>;</span> j<span>++</span><span>)</span><span>{</span>
           <span>if</span> <span>(</span>arr<span>[</span>j<span>]</span> <span>&lt;</span> arr<span>[</span>j<span>+</span><span>1</span><span>]</span><span>)</span> <span>{</span>
            <span>swap</span><span>(</span>arr<span>,</span> j<span>,</span> j<span>-</span><span>1</span><span>)</span><span>;</span>
            isSorted <span>=</span> <span>false</span><span>;</span>
    <span>}</span>
          <span>}</span>
          <span>if</span><span>(</span>isSorted<span>)</span> <span>break</span><span>;</span>
      <span>}</span>
  <span>}</span>
 <span>public</span> <span>static</span> <span>void</span> <span>swap</span><span>(</span><span>int</span><span>[</span><span>]</span> a<span>,</span><span>int</span> i<span>,</span><span>int</span> j<span>)</span> <span>{</span>
  <span>int</span> temp <span>=</span> a<span>[</span>i<span>]</span><span>;</span>
  a<span>[</span>i<span>]</span> <span>=</span> a<span>[</span>j<span>]</span><span>;</span>
  a<span>[</span>j<span>]</span> <span>=</span> temp<span>;</span>
 <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h2 id="选择排序"> 选择排序</h2>
<h4 id="思路-3"> 思路</h4>
<p>假设<strong>最开始的值为最小值</strong>
遍历数组,与最开始的元素一一比较,得到最小元素的位置然后交换元素。</p>
<h4 id="代码-3"> 代码</h4>
<div><pre><code><span>package</span> <span>sort</span><span>;</span>
<span>/*
 * created by sj 2019年8月16日
 */</span>
<span>public</span> <span>class</span> <span>SelectSort</span> <span>{</span>
 <span>public</span> <span>static</span> <span>void</span> <span>sort</span><span>(</span><span>int</span><span>[</span><span>]</span> a<span>)</span> <span>{</span>
  <span>int</span> minIndex <span>=</span> <span>0</span><span>;</span>
  <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span>  a<span>.</span>length <span>-</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
   minIndex <span>=</span> i<span>;</span> <span>//最小元素下标初始值设为最开始的元素</span>
   <span>for</span> <span>(</span><span>int</span> j <span>=</span> i<span>+</span><span>1</span><span>;</span> j <span>&lt;</span>  a<span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span><span>//寻到最小的数,保存下标</span>
    <span>if</span><span>(</span>a<span>[</span>j<span>]</span><span>&lt;</span>a<span>[</span>minIndex<span>]</span><span>)</span>
     minIndex <span>=</span> j<span>;</span>
   <span>}</span>
   <span>swap</span><span>(</span>a<span>,</span> minIndex<span>,</span> i<span>)</span><span>;</span><span>//交换</span>
  <span>}</span>
 <span>}</span>

 <span>public</span> <span>static</span> <span>void</span> <span>swap</span><span>(</span><span>int</span><span>[</span><span>]</span> a<span>,</span><span>int</span> i<span>,</span><span>int</span> j<span>)</span> <span>{</span>
  <span>int</span> temp <span>=</span> a<span>[</span>i<span>]</span><span>;</span>
  a<span>[</span>i<span>]</span> <span>=</span> a<span>[</span>j<span>]</span><span>;</span>
  a<span>[</span>j<span>]</span> <span>=</span> temp<span>;</span>
 <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id="插入排序"> 插入排序</h2>
<h4 id="思路-4"> 思路</h4>
<p>从第二个元素开始插入前面的数列,让前面的数列一直保持有序。当遇到小于当前元素的值就停止交换。</p>
<h4 id="代码-4"> 代码</h4>
<div><pre><code><span>package</span> <span>sort</span><span>;</span>

<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Arrays</span><span>;</span>

<span>/*
 * created by sj 2019年8月16日
 */</span>
<span>public</span> <span>class</span> <span>InsertSort</span> <span>{</span>
 <span>public</span> <span>static</span> <span>void</span>  <span>sort</span><span>(</span><span>int</span> a<span>[</span><span>]</span> <span>)</span><span>{</span>
     <span>for</span><span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span>i <span>&lt;</span> a<span>.</span>length<span>-</span><span>1</span><span>;</span>i<span>++</span><span>)</span><span>{</span>
         <span>for</span><span>(</span><span>int</span> j <span>=</span> i <span>+</span> <span>1</span><span>;</span> j <span>></span> <span>0</span> <span>&amp;&amp;</span> a<span>[</span>j<span>-</span><span>1</span><span>]</span> <span>></span> a<span>[</span>j<span>]</span>  <span>;</span> j<span>--</span><span>)</span><span>{</span>
           <span>swap</span><span>(</span>a<span>,</span> j <span>-</span> <span>1</span><span>,</span> j<span>)</span><span>;</span>
         <span>}</span>
     <span>}</span>
  <span>}</span>

 <span>public</span> <span>static</span> <span>void</span> <span>swap</span><span>(</span><span>int</span><span>[</span><span>]</span> a<span>,</span><span>int</span> i<span>,</span><span>int</span> j<span>)</span> <span>{</span>
  <span>int</span> temp <span>=</span> a<span>[</span>i<span>]</span><span>;</span>
  a<span>[</span>i<span>]</span> <span>=</span> a<span>[</span>j<span>]</span><span>;</span>
  a<span>[</span>j<span>]</span> <span>=</span> temp<span>;</span>
 <span>}</span>

 <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
  <span>int</span><span>[</span><span>]</span> a <span>=</span> <span>{</span><span>3</span><span>,</span><span>5</span><span>,</span><span>7</span><span>,</span><span>1</span><span>,</span><span>8</span><span>,</span><span>6</span><span>}</span><span>;</span>
  <span>sort</span><span>(</span>a<span>)</span><span>;</span>
  <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Arrays</span><span>.</span><span>toString</span><span>(</span>a<span>)</span><span>)</span><span>;</span>
 <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h2 id="桶排序"> 桶排序</h2>
<h3 id="原理"> 原理</h3>
<p>桶排序<strong>利用函数的映射关系</strong></p>
<p>一句话总结：划分多个范围相同的区间,每个子区间自排序,最后合并。</p>
<p>桶排序是计数排序的扩展版本,计数排序可以看成每个桶只存储相同元素,而桶排序每个桶存储一定范围的元素,通过映射函数,将待排序数组中的元素映射到各个对应的桶中,对每个桶中的元素进行排序,最后将非空桶中的元素逐个放入原序列中。</p>
<p>桶排序需要尽量保证元素分散均匀,否则当所有数据集中在同一个桶中时,桶排序失效。</p>
<p><img src="./img/1-2.png" alt="" loading="lazy"></p>
<h3 id="核心代码"> 核心代码</h3>
<div><pre><code><span>class</span> <span>T</span><span>{</span>
<span>public</span> <span>static</span> <span>void</span> <span>bucketSort</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>)</span><span>{</span>

    <span>// 计算最大值与最小值</span>
    <span>int</span> max <span>=</span> <span>Integer</span><span>.</span>MIN_VALUE<span>;</span>
    <span>int</span> min <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE<span>;</span>
    <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span><span>{</span>
        max <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>max<span>,</span> arr<span>[</span>i<span>]</span><span>)</span><span>;</span>
        min <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>min<span>,</span> arr<span>[</span>i<span>]</span><span>)</span><span>;</span>
    <span>}</span>

    <span>// 计算桶的数量</span>
    <span>int</span> bucketNum <span>=</span> <span>(</span>max <span>-</span> min<span>)</span> <span>/</span> arr<span>.</span>length <span>+</span> <span>1</span><span>;</span>
    <span>ArrayList</span><span><span>&lt;</span><span>ArrayList</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> bucketArr <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span>bucketNum<span>)</span><span>;</span>
    <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> bucketNum<span>;</span> i<span>++</span><span>)</span><span>{</span>
        bucketArr<span>.</span><span>add</span><span>(</span><span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>// 将每个元素放入桶</span>
    <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span><span>{</span>
        <span>int</span> num <span>=</span> <span>(</span>arr<span>[</span>i<span>]</span> <span>-</span> min<span>)</span> <span>/</span> <span>(</span>arr<span>.</span>length<span>)</span><span>;</span>
        bucketArr<span>.</span><span>get</span><span>(</span>num<span>)</span><span>.</span><span>add</span><span>(</span>arr<span>[</span>i<span>]</span><span>)</span><span>;</span>
    <span>}</span>

    <span>// 对每个桶进行排序</span>
    <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> bucketArr<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span><span>{</span>
        <span>Collections</span><span>.</span><span>sort</span><span>(</span>bucketArr<span>.</span><span>get</span><span>(</span>i<span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>// 将桶中的元素赋值到原序列</span>
 <span>int</span> index <span>=</span> <span>0</span><span>;</span>
 <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> bucketArr<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span><span>{</span>
  <span>for</span><span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> bucketArr<span>.</span><span>get</span><span>(</span>i<span>)</span><span>.</span><span>size</span><span>(</span><span>)</span><span>;</span> j<span>++</span><span>)</span><span>{</span>
   arr<span>[</span>index<span>++</span><span>]</span> <span>=</span> bucketArr<span>.</span><span>get</span><span>(</span>i<span>)</span><span>.</span><span>get</span><span>(</span>j<span>)</span><span>;</span>
  <span>}</span>
 <span>}</span>
<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><h2 id="计数排序"> 计数排序</h2>
<p>根据原始数列的取值范围,创建一个<code>统计数组</code>,用来统计原始数列中每一个可能的整数值所出现的次数。</p>
<p>原始数列中的整数值,和统计数组的下标是一一对应的,以数列的最小值作为偏移量。</p>
<p>比如原始数列的最小值是 90,那么整数 95 对应的统计数组下标就是 95-90=5.</p>
<p>每一个桶代表一个区间范围,里面可以承载一个或多个元素。</p>
<h4 id="思路-5"> 思路</h4>
<p>算出数列最大值和最小值,并算出差值,初始化桶,桶个数有多种方式,<code>区间跨度= 差值 / （桶的数量-1）</code> 最后一个桶只包含数列最大值,其余桶区间跨度按照比例分配。</p>
<p>将原始数组中的元素放进相应的桶中,桶内部的元素分别排序,输出所有元素。</p>
<p>时间复杂度：n+m 空间复杂度：m</p>
<h4 id="代码-5"> 代码</h4>
<div><pre><code><span>public</span> <span>class</span> <span>T</span> <span>{</span>
    <span>public</span> <span>static</span> <span>double</span><span>[</span><span>]</span> <span>bucketSort</span><span>(</span><span>double</span><span>[</span><span>]</span> array<span>)</span> <span>{</span>
        <span>// 1.得到数列的最大值和最小值,并算出差值d</span>
        <span>double</span> max <span>=</span> array<span>[</span><span>0</span><span>]</span><span>;</span>
        <span>double</span> min <span>=</span> array<span>[</span><span>0</span><span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> array<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>array<span>[</span>i<span>]</span> <span>></span> max<span>)</span> <span>{</span>
                max <span>=</span> array<span>[</span>i<span>]</span><span>;</span>
            <span>}</span>
            <span>if</span> <span>(</span>array<span>[</span>i<span>]</span> <span>&lt;</span> min<span>)</span> <span>{</span>
                min <span>=</span> array<span>[</span>i<span>]</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>double</span> d <span>=</span> max <span>-</span> min<span>;</span>

        <span>// 2.初始化桶</span>
        <span>int</span> bucketNum <span>=</span> array<span>.</span>length<span>;</span> <span>//我们这里创建的桶数等于原始数列的元素数量</span>
        <span>List</span><span><span>&lt;</span><span>LinkedList</span><span>&lt;</span><span>Double</span><span>></span><span>></span></span> bucketList <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span>bucketNum<span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> bucketNum<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            bucketList<span>.</span><span>add</span><span>(</span><span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>Double</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>

        <span>// 3.遍历原始数组,将每个元素放入桶中</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> array<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>int</span> num <span>=</span> <span>(</span><span>int</span><span>)</span> <span>(</span><span>(</span>array<span>[</span>i<span>]</span> <span>-</span> min<span>)</span> <span>*</span> <span>(</span>bucketNum <span>-</span> <span>1</span><span>)</span> <span>/</span> d<span>)</span><span>;</span>
            bucketList<span>.</span><span>get</span><span>(</span>num<span>)</span><span>.</span><span>add</span><span>(</span>array<span>[</span>i<span>]</span><span>)</span><span>;</span>
        <span>}</span>

        <span>// 4.对每个通内部进行排序</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> bucketList<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>// JDK底层采用了归并排序或归并的优化版本</span>
            <span>Collections</span><span>.</span><span>sort</span><span>(</span>bucketList<span>.</span><span>get</span><span>(</span>i<span>)</span><span>)</span><span>;</span>
        <span>}</span>

        <span>// 5.输出全部元素</span>
        <span>double</span><span>[</span><span>]</span> sortedArray <span>=</span> <span>new</span> <span>double</span><span>[</span>array<span>.</span>length<span>]</span><span>;</span>
        <span>int</span> index <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>LinkedList</span><span><span>&lt;</span><span>Double</span><span>></span></span> list <span>:</span> bucketList<span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>double</span> element <span>:</span> list<span>)</span> <span>{</span>
                sortedArray<span>[</span>index<span>]</span> <span>=</span> element<span>;</span>
                index<span>++</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> sortedArray<span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>double</span><span>[</span><span>]</span> array <span>=</span> <span>new</span> <span>double</span><span>[</span><span>]</span> <span>{</span> <span>4.12</span><span>,</span> <span>6.421</span><span>,</span> <span>0.0023</span><span>,</span> <span>3.0</span><span>,</span> <span>2.123</span><span>,</span> <span>8.122</span><span>,</span> <span>4.12</span><span>,</span> <span>10.09</span> <span>}</span><span>;</span>
        <span>double</span><span>[</span><span>]</span> sortedArray <span>=</span> <span>bucketSort</span><span>(</span>array<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Arrays</span><span>.</span><span>toString</span><span>(</span>sortedArray<span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br></div></div><p><img src="https://img-blog.csdnimg.cn/20190828222358183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTgzNTI3,size_16,color_FFFFFF,t_70" alt="各个排序的算法复杂度" loading="lazy"></p>
<h2 id="原地、稳定"> 原地、稳定</h2>
<table>
<thead>
<tr>
<th>排序方式</th>
<th>是否原地</th>
<th>是否稳定</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>插入</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>选择</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>归并</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>堆</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>桶</td>
<td>×</td>
<td>×</td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="algo"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-04-12T10:55:02.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">linked-list-algorithm</title>
    <id>http://www.zhangsj.xyz/blog/algo/%E9%93%BE%E8%A1%A8%E5%88%A4%E6%96%AD%E6%9C%89%E7%8E%AF%E3%80%81%E9%80%92%E5%BD%92%E5%8F%8D%E8%BD%AC/</id>
    <link href="http://www.zhangsj.xyz/blog/algo/%E9%93%BE%E8%A1%A8%E5%88%A4%E6%96%AD%E6%9C%89%E7%8E%AF%E3%80%81%E9%80%92%E5%BD%92%E5%8F%8D%E8%BD%AC/"/>
    <updated>2022-04-12T10:55:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="链表算法"> 链表算法</h2>
<p>判断链表是否有环</p>
<p>定义一个临时变量引用指向当前的节点</p>
<p>定义一个 hashmap。Key 与 value 当时当前的节点。</p>
<p>该节点存在于 hashmap 中，node.get(tmp) ，则确定有环， 没有就存放该的节点。</p>
<h1 id="单链表反转"> 单链表反转</h1>
<p>从当前链表的首节点开始循环遍历，一直到链表的最后一个节点，会逐个改变所遍历的节点的指针域，另其指向前一个节点。</p>
<p>具体的实现方法也很简单，借助三个指针即可。首先我们定义 3 个指针并分别命名为 begn，mid，end。他们的初始指向如图 3 所示：</p>
<p><a href="docs/algo/img/1-1.png"></a></p>
<h2 id="递归反转"> 递归反转</h2>
<p>链表的尾节点开始，依次向前遍历，遍历过程一次改变各节点的指向，即另其指向前一个节点。</p>
<div><pre><code><span>class</span> <span>Node</span> <span>{</span>
 <span>private</span> <span>int</span> <span>Data</span><span>;</span><span>// 数据域</span>
 <span>private</span> <span>Node</span> <span>Next</span><span>;</span><span>// 指针域</span>
 <span>public</span> <span>Node</span><span>(</span><span>int</span> <span>Data</span><span>)</span> <span>{</span>
  <span>// super();</span>
  <span><span>this<span>.</span></span>Data</span> <span>=</span> <span>Data</span><span>;</span>
 <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><pre><code><span>public</span> <span>class</span> javatest1 <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Node</span> head <span>=</span> <span>new</span> <span>Node</span><span>(</span><span>0</span><span>)</span><span>;</span>
        <span>Node</span> node1 <span>=</span> <span>new</span> <span>Node</span><span>(</span><span>1</span><span>)</span><span>;</span>
        <span>Node</span> node2 <span>=</span> <span>new</span> <span>Node</span><span>(</span><span>2</span><span>)</span><span>;</span>
        <span>Node</span> node3 <span>=</span> <span>new</span> <span>Node</span><span>(</span><span>3</span><span>)</span><span>;</span>
        head<span>.</span><span>setNext</span><span>(</span>node1<span>)</span><span>;</span>
        node1<span>.</span><span>setNext</span><span>(</span>node2<span>)</span><span>;</span>
        node2<span>.</span><span>setNext</span><span>(</span>node3<span>)</span><span>;</span>

        <span>// 调用反转方法</span>
        head <span>=</span> <span>Reverse1</span><span>(</span>head<span>)</span><span>;</span>
         <span>while</span> <span>(</span><span>null</span> <span>!=</span> head<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>head<span>.</span><span>getData</span><span>(</span><span>)</span> <span>+</span> <span>" "</span><span>)</span><span>;</span>
            head <span>=</span> head<span>.</span><span>getNext</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>/**
     * 递归，在反转当前节点之前先反转后续节点
     */</span>
    <span>public</span> <span>static</span> <span>Node</span> <span>Reverse1</span><span>(</span><span>Node</span> head<span>)</span> <span>{</span>
        <span>// head看作是前一结点，head.getNext()是当前结点，reHead是反转后新链表的头结点</span>
        <span>if</span> <span>(</span>head <span>==</span> <span>null</span> <span>||</span> head<span>.</span><span>getNext</span><span>(</span><span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>return</span> head<span>;</span><span>// 若为空链或者当前结点的下一个节点在尾结点，则直接还回</span>
        <span>}</span>
        <span>Node</span> reHead <span>=</span> <span>Reverse1</span><span>(</span>head<span>.</span><span>getNext</span><span>(</span><span>)</span><span>)</span><span>;</span><span>// 先反转后续节点head.getNext()</span>
        head<span>.</span><span>getNext</span><span>(</span><span>)</span><span>.</span><span>setNext</span><span>(</span>head<span>)</span><span>;</span><span>// 将当前结点的指针域指向前一结点</span>
        head<span>.</span><span>setNext</span><span>(</span><span>null</span><span>)</span><span>;</span><span>// 前一结点的指针域令为null;</span>
        <span>return</span> reHead<span>;</span><span>// 反转后新链表的头结点</span>
    <span>}</span>
<span>}</span>


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div>]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="algo"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-04-12T10:55:02.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">8Queens</title>
    <id>http://www.zhangsj.xyz/blog/algo/%E7%AE%97%E6%B3%95-%E5%85%AB%E7%9A%87%E5%90%8E/</id>
    <link href="http://www.zhangsj.xyz/blog/algo/%E7%AE%97%E6%B3%95-%E5%85%AB%E7%9A%87%E5%90%8E/"/>
    <updated>2022-04-12T10:55:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="八皇后"> 八皇后</h2>
<div><pre><code><span>package</span> <span>interview</span><span>;</span>

<span>public</span> <span>class</span> BHH <span>{</span>
 <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> board <span>=</span> <span>new</span> <span>int</span><span>[</span><span>8</span><span>]</span><span>[</span><span>8</span><span>]</span><span>;</span>

 <span>boolean</span> <span>check</span><span>(</span><span>int</span> x<span>,</span> <span>int</span> y<span>)</span> <span>{</span>
  <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> y<span>;</span> i<span>++</span><span>)</span> <span>{</span>
   <span>if</span> <span>(</span>board<span>[</span>x<span>]</span><span>[</span>i<span>]</span> <span>==</span> <span>1</span><span>)</span> <span>{</span>
    <span>return</span> <span>false</span><span>;</span>
   <span>}</span>
   <span>//检查左侧斜向</span>
   <span>if</span><span>(</span>x<span>-</span><span>1</span><span>-</span>i <span>>=</span> <span>0</span> <span>&amp;&amp;</span> board<span>[</span>x<span>-</span><span>1</span><span>-</span>i<span>]</span><span>[</span>y<span>-</span><span>1</span><span>-</span>i<span>]</span> <span>==</span> <span>1</span><span>)</span> <span>{</span>
    <span>return</span> <span>false</span><span>;</span>
   <span>}</span>
   <span>//检查右侧斜向</span>
   <span>if</span> <span>(</span>x<span>+</span>i<span>+</span><span>1</span> <span>&lt;</span> <span>8</span> <span>&amp;&amp;</span> board<span>[</span>x<span>+</span>i<span>+</span><span>1</span><span>]</span><span>[</span>y<span>-</span><span>1</span><span>-</span>i<span>]</span> <span>==</span> <span>1</span><span>)</span> <span>{</span>
    <span>return</span> <span>false</span><span>;</span>
   <span>}</span>
  <span>}</span>
  <span>return</span> <span>true</span><span>;</span>
 <span>}</span>


 <span>boolean</span> <span>settleQ</span><span>(</span><span>int</span> y<span>)</span> <span>{</span>
  <span>if</span> <span>(</span>y <span>==</span> <span>8</span><span>)</span> <span>return</span> <span>true</span><span>;</span>
  <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>8</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
   <span>for</span><span>(</span><span>int</span> x<span>=</span><span>8</span><span>;</span> x<span>&lt;</span><span>8</span><span>;</span> x<span>++</span><span>)</span> <span>{</span>
    board<span>[</span>x<span>]</span><span>[</span>y<span>]</span><span>=</span><span>0</span><span>;</span>
   <span>}</span>

   <span>if</span> <span>(</span><span>check</span><span>(</span>i<span>,</span> y<span>)</span><span>)</span> <span>{</span>
    board<span>[</span>i<span>]</span><span>[</span>y<span>]</span> <span>=</span> <span>1</span><span>;</span>
    <span>if</span> <span>(</span><span>settleQ</span><span>(</span>y<span>+</span><span>1</span><span>)</span><span>)</span> <span>{</span>
     <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
   <span>}</span>
  <span>}</span>
  <span>return</span> <span>true</span><span>;</span>
 <span>}</span>

 <span>void</span> <span>print</span><span>(</span><span>)</span> <span>{</span>
  <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>8</span><span>;</span> i<span>++</span><span>)</span> <span>{</span><span>//纵坐标</span>
   <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> <span>8</span><span>;</span> j<span>++</span><span>)</span> <span>{</span><span>//横坐标</span>
    <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>board<span>[</span>j<span>]</span><span>[</span>i<span>]</span><span>)</span><span>;</span>
   <span>}</span>
   <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span>
  <span>}</span>
 <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div>]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="algo"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-04-12T10:55:02.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">提问的智慧</title>
    <id>http://www.zhangsj.xyz/blog/exam/T-shaped_talents/</id>
    <link href="http://www.zhangsj.xyz/blog/exam/T-shaped_talents/"/>
    <updated>2022-04-12T12:32:31.000Z</updated>
    <content type="html"><![CDATA[<h2 id="提问的智慧"> 提问的智慧</h2>
<p>不要说大家有没有遇到这种问题，而是</p>
<p>自己在什么场景（时间、环境）做了什么事儿，我希望的结果是？但是目前出现的结果又是，异常栈信息如下。</p>
<p>找对相应的负责人，分工合作，不要自己一个人扛着。</p>
<p>把问题讲清楚</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-04-12T12:32:31.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">医院上传</title>
    <id>http://www.zhangsj.xyz/blog/exam/med/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <link href="http://www.zhangsj.xyz/blog/exam/med/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <updated>2022-02-25T04:39:47.000Z</updated>
    <content type="html"><![CDATA[<h2 id="医院上传"> 医院上传</h2>
<h2 id="实时未分解交易"> 实时未分解交易</h2>
<p>未支付成功的票据 xx</p>
<h2 id="补录"> 补录</h2>
<p>Xx</p>
<h2 id="比对失败"> 比对失败</h2>
<p>Xx</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-06T03:25:25.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">引出问题</title>
    <id>http://www.zhangsj.xyz/blog/exam/capability/%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%AA%E5%90%8A%E7%82%B8%E5%A4%A9%E7%9A%84%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F/</id>
    <link href="http://www.zhangsj.xyz/blog/exam/capability/%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%AA%E5%90%8A%E7%82%B8%E5%A4%A9%E7%9A%84%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F/"/>
    <updated>2022-03-22T05:51:18.000Z</updated>
    <content type="html"><![CDATA[<h2 id="引出问题"> 引出问题</h2>
<p><a href="https://www.bilibili.com/video/BV1cZ4y1M7t8/?spm_id_from=333.788.recommend_more_video.0" target="_blank" rel="noopener noreferrer">【硬核干货】介绍一个吊炸天的思维方式！不用谢！
</a></p>
<p>多刷知乎，回答问题，</p>
<p>考虑你的答案，让他们更有逻辑，更有价值，别人能够听懂，废话很多不重要，80%的废话+20%的核心内容会让你的回答更有说服力，让人更愿意读下去，干巴巴的教条是大家都不愿意读的；</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-02T04:19:55.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">med business</title>
    <id>http://www.zhangsj.xyz/blog/exam/med/</id>
    <link href="http://www.zhangsj.xyz/blog/exam/med/"/>
    <updated>2022-03-01T05:15:03.000Z</updated>
    <content type="html"><![CDATA[<h1 id="med"> med</h1>
<p>手工报销初审(上传)</p>
<h3 id="数据来源"> 数据来源</h3>
<ol>
<li>补录</li>
<li>院端上传</li>
<li>门诊实时结算未分解</li>
</ol>
<p>注：院端上传</p>
<h2 id="补支、追回"> 补支、追回</h2>
<p>后期审核发现中心报销费用异常，需要追回已审核支付的数据。操作员可在已经结算支付的单位手工报销交易上增加现金追回记录功能。</p>
<p><img src="./image/手工报销费用追回录入-业务流程.png" alt="" loading="lazy"></p>
<p>(1) 经办人员根据条件查询需要追回的报销信息；
(2) 对结算信息进行追回处理。</p>
<h3 id="_1-1-1-15-3-界面设计"> 1.1.1.15.3 界面设计</h3>
<p>(1) 根据输入的查询条件查询并显示已经支付的手工报销费用交易。
(2) 选择需要记录现金追回的交易记录，系统自动提示最大可追回现金金额(报销总金额)。
(3) 输入需要追回的现金金额，其不能超过该交易的当前最大可追回现金金额，并录入追回原因。
(4) 保存该交易的现金追回信息，系统记录操作日志。
(5) 现金追回也应该记录历史，审核前可修改，审核后不可修改。发财务前可删除。对于职工和超转人员，能自动计算各基金项的追回金额</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="business"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-06T03:25:25.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">every day 10 min</title>
    <id>http://www.zhangsj.xyz/blog/exam/capability/expression/</id>
    <link href="http://www.zhangsj.xyz/blog/exam/capability/expression/"/>
    <updated>2022-03-22T16:26:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="every-day-10-min"> every day 10 min</h2>
<p><a href="https://www.bilibili.com/video/BV1xb4y1i7FQ?spm_id_from=333.1007.top_right_bar_window_history.content.click" target="_blank" rel="noopener noreferrer">每天 10 分钟快速提升表达能力 ‼️ 简单初学版-保姆级别教程</a></p>
<p>笔记</p>
<p>表达遵循二八定律，百分之八十的废话讲得让人想听 + 百分之二十的核心内容</p>
<p>一共四周</p>
<h2 id="第一周-建立自信"> 第一周:建立自信</h2>
<p>大声夸张地朗读古诗，千万不要重复，一口气读完，七天不重样</p>
<p>《满江红》《长歌行》《雨霖铃》《沁园春雪》《岳阳楼记》《将进酒》《蜀道难》</p>
<h2 id="第二周-提升反应-应变能力"> 第二周:提升反应&amp;应变能力</h2>
<p>每天一天演讲稿，自己打一个圆场</p>
<h2 id="第三周-提升瞬时记忆能力"> 第三周:提升瞬时记忆能力</h2>
<p>《一件未织完的毛衣》《一楼水果》《八元五角的母爱》《一分钟》《语言的魅力》《青衣》《生命的姿势》</p>
<p>先看一遍 然后开始用自己的话讲一遍，一定要顺着讲完不要半途而废</p>
<h2 id="第四周-提升即兴表达能力"> 第四周:提升即兴表达能力</h2>
<p>两个练习</p>
<p>专治不想说废话的人和坚决不开口的人</p>
<p>我觉得梳子可好用了，一梳能把头发梳顺，梳子齿要是长一点就好了吧啦吧啦</p>
<h2 id="推荐工具"> 推荐工具</h2>
<p>论否</p>
<h2 id="小结"> 小结</h2>
<p>看来，我们以后要多讲废话，让废话都变得让人想听，我们再处理人际关系方面就能得到很大的提升(真的是不喜欢说废话，结果就成了别人严重的内向)</p>
<p>但其实换位思考也能理解，你平时不和他们闲聊，他们会觉得你不想和他们说话，只说必要的话就会给人一种强势，高冷的感觉；</p>
<p>希望大家在家庭，事业，爱情方面向更好的方向发展；</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-02T04:19:55.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">exam</title>
    <id>http://www.zhangsj.xyz/blog/exam/</id>
    <link href="http://www.zhangsj.xyz/blog/exam/"/>
    <updated>2022-03-24T05:27:46.000Z</updated>
    <content type="html"><![CDATA[<h2 id="生活-随笔"> 生活 随笔</h2>
<p>生活</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="note"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-24T06:03:53.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">启动项目报错</title>
    <id>http://www.zhangsj.xyz/blog/exam/trouble/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <link href="http://www.zhangsj.xyz/blog/exam/trouble/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <updated>2022-03-10T00:50:59.000Z</updated>
    <content type="html"><![CDATA[<h2 id="启动项目报错"> 启动项目报错</h2>
<h2 id="error-java-outofmemoryerror-insufficient-memory"> <code>Error:java: OutOfMemoryError: insufficient memory</code></h2>
<p>idea</p>
<p>修改Compiler下面的Compiler Process heap size 参数</p>
<p>点击file，选择Invalidate Caches 进行清理一下。</p>
<h2 id="idea运行报错error-running-application-command-line-is-too-long的解决方法"> Idea运行报错Error running ‘Application‘: Command line is too long的解决方法</h2>
<p>首先找到项目里面的idea/workspace.xml文件，然后再找到
<code>&lt;component name=&quot;PropertiesComponent&quot;&gt;&lt;/component &gt;</code></p>
<p>标签，标签如下所示</p>
<p>然后再在component 标签里加一行 <property name="dynamic.classpath" value="true" />，就是变成下面这样</p>
<p>C:\WINDOWS\system32\drivers\etc</p>
<p>工作、生活娱乐的电脑要分开</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-03-10T00:50:59.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">愚人记事</title>
    <id>http://www.zhangsj.xyz/blog/exam/wcyg/today&amp;apos;s%20topic%20is%20&amp;apos;new%20age&amp;apos;/</id>
    <link href="http://www.zhangsj.xyz/blog/exam/wcyg/today&apos;s%20topic%20is%20&apos;new%20age&apos;/"/>
    <updated>2022-03-17T12:34:10.000Z</updated>
    <content type="html"><![CDATA[<p>&quot;today's topic is 'new age'&quot;</p>
<p>------愚人记事.</p>
<div>
<p>昨夜无眠。</p>
<p>和朋友鬼扯到一点。</p>
<p>找资料间,无意听到背景音乐是enya的。</p>
<p>一时下不了手关闭.</p>
<p>听着enya的音乐到凌晨五点才沉沉睡去.</p>
<p>几年了,</p>
<p>除却sarah的scabrough fair外,</p>
<p>我的硬盘再也没存有任何 new age style 的任何曲目,</p>
<p>特别是enya相关的.</p>
<p>熟悉的watermark,</p>
<p>冲破几年的封印,</p>
<p>随着音乐流淌,</p>
<p>慢慢地浮现出来.</p>
<p>不知道那张我跑遍了大半个城市才买到的cd,</p>
<p>现在怎么样了.</p>
<p>被珍藏还是被遗弃?</p>
<p>是否和我的爱一样?</p>
<p>曾以为</p>
<p>new age会成为我的topic中的主旋律，</p>
<p>也曾以为</p>
<p>new age不会再在我的topic中出现了。</p>
<p>其实</p>
<p>我并不排斥那种少有鲜明主题的旋律,</p>
<p>只是当时我也需要时间,</p>
<p>一如接受其他的...</p>
<p>其实</p>
<p>我也很喜欢enya的那份恬静和随意流淌的自我.</p>
<p>只是当时我找不到我的的心，</p>
<p>不懂得我自己。</p>
<p>&quot;today's topic is 'new age'&quot;</p>
<p>.....</p>
<p>&quot;xxxxxxxxx xxxxxxxxx！&quot;。</p>
<p>如果有一种状况叫迷失的话,</p>
<p>大抵也是如此吧.</p>
<p>无论我喜欢或者不喜欢,</p>
<p>都不是为了自已.</p>
<p>为博伊一笑.</p>
<p>即兴挥就洋洋千余言的乐评,被戏为乐贫.</p>
<p>唯一带点安慰的是还有个年度最佳称号.</p>
<p>在我还不懂enya时，</p>
<p>我努力地去欣赏,</p>
<p>并尝试努力去接受,</p>
<p>然而始终对不上 channel.</p>
<p>在我不再去听enya时.</p>
<p>却渐渐地理解这种style,</p>
<p>我想我可以对上channel了,</p>
<p>虽然错过了开播的时间。</p>
<p>有些心境对某人来说是很轻易就能达到的</p>
<p>但对另一些人来说</p>
<p>需要经过一番努力</p>
<p>在时光交错的现实与过去里</p>
<p>我遍历过很多次凸点集合</p>
<p>做了好多次迭代替换</p>
<p>虽然我知道就算能求出最优解</p>
<p>也已经没有回去的路了</p>
<p>但只想找回失落的心</p>
<p>找回真实的感觉</p>
<p>重听enya</p>
<p>重新再欣赏new age</p>
<p>也重新定义了new age的位置</p>
<p>它不会成为我的topic的主旋律</p>
<p>但也是不可或缺的旋律</p>
<p>也是一种存在的体现。</p>
<p>因为</p>
<p>喜欢是一种来自心底深层次的感觉，</p>
<p>是两个具有共同品质的物件的共鸣形式.</p>
<p>不管是对音乐还是和人.</p>
</div>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="随笔"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2021-08-18T00:00:00.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">yanyu</title>
    <id>http://www.zhangsj.xyz/blog/exam/yanyu/</id>
    <link href="http://www.zhangsj.xyz/blog/exam/yanyu/"/>
    <updated>2022-03-01T05:15:03.000Z</updated>
    <content type="html"><![CDATA[<h2 id="yanyulijie"> yanyulijie</h2>
<h2 id="言语理解与表达方法"> 言语理解与表达方法</h2>
<p>第三次学习重点内容</p>
<p>① 中心理解题中心句及分述句的特征
② 细节判断题解题思维及错误选项特征</p>
<p>第一、二节回顾</p>
<h2 id="行文脉络"> 行文脉络</h2>
<ol>
<li>总分</li>
<li>分总</li>
<li>总分总</li>
<li>分总分</li>
<li>分分</li>
</ol>
<p>理论要点：把握中心句及分述句的特征</p>
<h3 id="中心句特征"> 中心句特征</h3>
<p>观点(对策、结论、评论)</p>
<ol>
<li>背景问题，提出对策</li>
<li>背景问题，提出结论</li>
<li>背景或问题，给出的评价，错误的观点引出正确的观点。</li>
</ol>
<h3 id="分述句特征"> 分述句特征</h3>
<p>1、举例子：“比如”、“例如”、“。。。就是例证”等
2、调查报告、数据资料
3、正反论证
4、原因解释
5、并列分述</p>
<p>以大多数人的努力程度之低，还远远谈不上拼天赋</p>
<p><a href="https://www.bilibili.com/video/BV1Zf4y167qh?spm_id_from=333.1007.top_right_bar_window_history.content.click" target="_blank" rel="noopener noreferrer">言语理解与表达方法精讲 曾经被全网疯传的粉笔 980 系统班 粉笔郭熙精品</a></p>
<h3 id="对语言文字的综合分析能力"> 对语言文字的综合分析能力</h3>
<ol>
<li>基于材料而不是常识</li>
<li>先看题目再看材料</li>
<li>分句阅读</li>
<li>消除音读(念其他的，视幅)</li>
<li>注意力，视幅，音读，复读</li>
<li>三个思维
1 递进关系(后面的)
2 转折(后面的)
3 因果(结论)
4 必要条件(才之前的，必须，应该，应当，需要，除非)
5 并列关系
6 总分，分总结构(排同求异)解决方案
7 反而论证：否则，不然忽略看，如果不，如果没有反推
8 援引，正如 xx 所以后，有人说 xx 但是后</li>
<li>结合语境</li>
</ol>
<p>情感分析</p>
<h2 id="四大类题"> 四大类题</h2>
<h3 id="一、概括理解题"> 一、概括理解题</h3>
<p>一、提问方式：</p>
<p>这段文字(主要/旨在/重在/意图/说明)的是。。。
这段文字的主旨、主题、观点是。。。
对这段文字概括最恰当的是。。。</p>
<h3 id="_1-解题思路"> 1. 解题思路</h3>
<p>寻找中心句
有中心句-同义替换
无中心句-全面概括</p>
<h3 id="_2-解题技巧"> 2. 解题技巧</h3>
<p>重点词语(关联词、主题词、程度词)
行文脉络(中心句、分述句)
导语，程度词
选项中出现 A 与(和、及)B 的不同/差别、差异、区别，文段应为并列结构
正确答案没有对原文进行加工</p>
<p>因为之后的语句没有必要阅读，
加以说明论述</p>
<h3 id="转折关系"> 转折关系</h3>
<p><strong>典型标志词</strong>：虽然。。。但是；尽管。。。可是；不过；然而；却；其实、事实上，实际上。。。</p>
<p><strong>非典型标志词</strong>：殊不知，截然不同，截然相反，全新的研究，一种误读，相对而言</p>
<p><strong>错误选项特征：</strong></p>
<p>1 转折前的内容
2 例子、原因、背景。。。
3 无中生有
4 绝对表述
5 与文意相驳</p>
<p><strong>略读句子特征：</strong></p>
<p>例子：比如、例如、诸如、譬如等
原因：因为、由于、：、---等
背景：近年来、随着、在。。。背景(研究)下等</p>
<p>做题步骤</p>
<ol>
<li>审提问方式。文段+主要/主旨/旨在/概括</li>
<li>阅读文段，依赖画出逻辑连接词(看看要不晚上明显行文架构)</li>
<li>确定中心句，对核心句进行处理（找到<strong>核心的核心</strong>）</li>
<li>匹配选项，对选项进行区分，与核心句进行匹配</li>
</ol>
<h3 id="重点词语之主题词"> 重点词语之主题词</h3>
<p>1 文段围绕<strong>其</strong>展开
2 一般<strong>高频</strong>出现(代词)
3 多为<strong>名词</strong>
4 前有<strong>引入</strong>或后又<strong>解释说明</strong></p>
<h2 id="细节理解题"> 细节理解题</h2>
<p><strong>牢记四不：</strong></p>
<p>① 太绝对的不选，
② 概念不一致的不选，(偷换概念)
③ 太片面的不选，
④ 无中生有的不选”。</p>
<h3 id="表达连贯题"> 表达连贯题</h3>
<p>(语句衔接，结语推断，语句排序)</p>
<p>最后一句，全文。逻辑</p>
<h3 id="表达准确题"> 表达准确题</h3>
<p>(逻辑填空题)含义色彩搭配</p>
<p>实践</p>
<ol>
<li>解决方案是重点，有原词的优先</li>
<li>排除法，之后对着句子细推，不可以草率，看哪个更合适</li>
<li>解决方案中引出的新词是关键</li>
<li>绝对性句子需要在原文中找到相同绝对性句子做支撑。</li>
<li>排序的都读读，小心</li>
<li>有转折的，选词时注意褒贬性的反转来选</li>
<li>否定证据，与他所举的例子相反的例子</li>
<li>找到填空的依据句或关键词，确定他们与所填空的关系，解释，反义，并列，递进等等。</li>
<li>不要着急排除可能，还说得过去的选项，慢点来，可以提高正确率，注意关键词优先法则，找证据，仔细理解作者意图和词的意思在判断</li>
<li>一些常见词的搭配优先</li>
<li>排序题，注意排除法时先用一些选项之间的逻辑排，直接定开头可能错误率太高了，之后在根据选项内容之间的解释说明前后排。</li>
<li>病句
付诸于
领属，数量，动词，形容词，名次
原因，时间，地点，范围，情态，对象
导致……造成的
是否单一对应</li>
<li>主谓宾问题，圈词看是否合适</li>
<li>圈词，圈出关键字可以提示，提高正确率
核心时关键字，逻辑，依据法。没有依据就是蒙的，正确率无法保障。</li>
</ol>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="expierence"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-01-30T09:23:34.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">新人入职注意事项</title>
    <id>http://www.zhangsj.xyz/blog/exam/yanyu/%E6%96%B0%E4%BA%BA%E5%85%A5%E8%81%8C/</id>
    <link href="http://www.zhangsj.xyz/blog/exam/yanyu/%E6%96%B0%E4%BA%BA%E5%85%A5%E8%81%8C/"/>
    <updated>2022-04-12T12:32:31.000Z</updated>
    <content type="html"><![CDATA[<h2 id="新人入职注意事项"> 新人入职注意事项</h2>
<p>新人java 入职新公司一脸懵逼，不知从何下手，不知如何融入项目，也不知道如何看项目问题</p>
<p>我这几年待过一些公司，最近入职了一下新公司，闲来没事，发现网上有很多小白去新公司，不知从何下手，导致劝退，或者很慌的。</p>
<p>说说我的一些建议和一些个人经验吧</p>
<p>项目都不知道是干什么的，千万不要一开始就选择看代码看技术，项目的技术往往是结合业务相关联的</p>
<ol>
<li>公司入职java，前天或前一周，正常来说是不会接手开始做项目。环境配启动项目，不要浪费太多时间，最多半天到一天时间，以前有个同事搭个环境要两三天
首先要体现自己的专业性： 自己常用的开发工具和安装文件要有云存储和备份。自常用工具要快速安装搭建。最重要的云笔记要经常编写。如记录地址，代码 账号等参数。非常重要</li>
<li>首先认清楚自己待的项目团队的人员大概的分布情况，可以选择吃饭的时候问，或者问hr、老大等人。了解哪些人是搞前端，哪些人搞后台，有些公司会带人去介绍，有些不会。</li>
<li>再了解目前的项目团队主要负责的项目情况:</li>
<li>项目进度，目前是做到哪一步，自己在团队的定位是什么 是普通小白还是主力开发。</li>
<li>了解项目是做什么的，具体的核心业务是什么，主要是要知道这个项目具体是做什么用的。一些公司有些人搞了一个月，还不不知道项目具体是干什么的。</li>
<li>了解项目产品，有文档看文档，没文档请教产品经理 或者懂的人。首先站在用户的角度去使用现有的这个项目流程，让别人演示一遍给你看，每一个模块讲一讲是干什么的，站在用户思维去用，才能发现产品的好不好使用。</li>
<li>当你大概自己会简单操作和使用现有的产品再去看项目的结构代码</li>
<li>项目首先看结构是传统项目，还是多maven，还是微服务，前端有几端 如：pc端，微信端，app端什么的。再看看pom.xml 用了大概那些等等，模块的划分，工具类目录，项目的核心配置，mybatis写法, 接口风格，等大概的情况了解</li>
<li>不要去一开始就去看某个代码的实现技术实现什么的，接口的代码等等，别人写的东西一开始也没必要去看，除非是交接，但是前提还是要清楚业务。一般简单了解一下就可以了。</li>
<li>这时候差不多对项目的产品和项目的架构情况有一个大致初步的判断和了解。</li>
<li>打开数据库文档 或者数据表，分模块和业务去看，如：用户主表有哪些，用户扩展的表简单了解。其他模块的主表是什么情况， 模块与用户的关联是怎么情况。了解数据库表的基本情况和设计风格，不懂业务也没有关系，只是了解大概的情况，这些业务有哪些表。</li>
<li>前面这么多步骤，随着项目的复杂度 大概2天到一周，完全可以知道这个项目整体情况 。从项目是干什么的，项目后台架构是如何，数据表大概情况。</li>
<li>知道这些后就完事了。当老大问你看的怎么样了，你就掌握的情况通说出来，那些不对的，项目不懂的也都可以说出来。</li>
<li>接下来一般会安排小问题 小<code>bug</code>，小业务去让你去改，这个时候就可以随着慢慢地融入去开发。</li>
</ol>
<h2 id="融入去开发"> 融入去开发</h2>
<p>融入去开发，最重要的一点不懂就问，不懂的列出来，善于去思考。</p>
<p>吃饭的时间、抽烟的时间，下班的时间多请教！不要怕别人以为你不行，一个项目不懂的人多了去了，很多人只负责自己的模块，其他的人也不懂。没有谁会拒绝一个虚心请教的人，除非你问增删改查怎么写 不要待了几天啥都不知道，往往劝退就是在这个时候，</p>
<p>我第一天下午没事 一般就能知道这个项目大概的一个情况，第二天以用户的使用去操作系统，第三天在去具体了解业务实现过程。后面有任务就做，没任务就看业务。不是看代码。 新手去了一个公司，往往一股脑就跑项目，看代码，搞了几天 别人都不知道你在搞什么。</p>
<h2 id="最重要的是知道业务"> 最重要的是知道业务</h2>
<p>最重要的是知道业务，随着业务去看代码的实现。 当具备这些的时候去大部分的公司 能快速上手是没有问题的，少则2，3天，多则一周。大多公司不会让你熟悉半个月、一个月，除非是交接啊或者是很大的项目。</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-03-17T16:44:46.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">yewu</title>
    <id>http://www.zhangsj.xyz/blog/exam/yewu/%E5%8C%BB%E4%BF%9D/</id>
    <link href="http://www.zhangsj.xyz/blog/exam/yewu/%E5%8C%BB%E4%BF%9D/"/>
    <updated>2022-03-22T16:26:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="yewu"> yewu</h2>
<h2 id="正常的业务"> 正常的业务</h2>
<p>08.0 3 到 03.19北京新医保核心业务的开发，</p>
<p>负责业务模块</p>
<p>手工报销结算模块：</p>
<p>票据扫描，票据文件报盘导入，提供两定接口，院端自费信息上传接口，院端上传的自费信息进行预结算，结算；添加相应的规则校验；手工报销费用补支、追回及其审核发财务；</p>
<p>手工报销结算模块(医照人员)模块：单位报盘自费信息导入，数据审核，补支、追回及其审核模块；对明细进行分割，各个分笔的费用进行金额的分割；预结算，将个人信息，就诊的信息，明细信息调支付方式，得出最后可以结算信息，(报销的金额，各项医保基金支出的金额)，如统筹基金，大额基金，军残基金；</p>
<p>结算，将预结算算出的结算信息保存，同时保存参保人的待遇累计信息；</p>
<p>北京医保不同点</p>
<p>单位将单位参保人自费的信息进行汇总，通过报盘导入，</p>
<p>金额是单位将明细的金额进行分类，保存的是分类项金额，不是具体的明细金额</p>
<p>灵活就业，纯手工录入七大项金额；就诊，明细信息需要机构传入，然后，再经办模块直接结算；</p>
<p>模式增加了单位和机构的工作量；</p>
<p>校验规则比较多；</p>
<p>上传模块还可以进行批量结算，初审时，多次门诊交易可以结成一笔结算信息；</p>
<h2 id="还做了一个批量导出的功能"> 还做了一个批量导出的功能</h2>
<p>项目前期给监管平台做的大数据批量导出的功能，前端查询模块查询业务数据，有导出功能，选择条件，将数据导出 excel 文件，每天业务量数据很大，每天都好几千万的数据。还要实现进度条的功能</p>
<ol>
<li>使用 easyexcel 框架，分批次导出，50 万作为一个 excel 的导出文件，假如有 1000 万条数据，需要 for 循环 20 次，每次循环，去用 limit 分批次查询，当所有 excel 文件生成，将 20 个 excel 文件打包，给前端提供压缩文件的地址</li>
<li>使用流式查询，防止内存的溢出</li>
<li>使用 redis 保存该用户各个导出文件的进度，前端专门画了一个页面去查看用户所有导出事件文件生成的进度，<code>redis</code> 结构使用 <code>hash</code> 结构，key 使用用户的 id，<code>value</code> 中的 <code>hash</code> 的 <code>key</code>，导出文件的文件名，value 是导出文件的生成的进度，当压缩文件生成完，<code>value</code> 为压缩文件的地址，前端使用定时器，不停的调查询接口，查询缓存中保存的进度</li>
</ol>
<p>用户正在导出的数据过多，可以添加限制次数，前端可以判断 value 值是文件地址时，显示可导出，导出按钮将文件下载。</p>
<h2 id="注"> 注</h2>
<p>每次向文件里面追加数据，类似与 <code>aof</code></p>
<p>调用 <code>ArrayList.clear()</code>，或者把对象置空,使用 <code>JProfile</code> 进行内存检测</p>
<p>通过 <code>JProfile</code> 内存分析.最终问题定位完毕.</p>
<p>原因如下：100W 数据  生成一个文件的过程中，等文件生成完毕之后才能把数据库中的数据备份到历史表中，这个时候才能进行事务的提交，也就是执行 commit()， 并且删除原表数据，100W 数据按照 3000 一批写入文件，每批次只是通过 <code>PreparedStatement.addBatch()</code>;加入到批次里面去,并没有执行 <code>PreparedStatement.executeBatch()</code>,而是在 <code>commit()</code> 之前统一调用的 <code>PreparedStatement.executeBatch()</code>，这样的话 <code>PreparedStatement</code> 就会缓存 100W 条数据信息，造成了内存溢出.</p>
<h2 id="改进"> 改进</h2>
<p><code>Spring Batch</code> 做批量。根据数据库的时间或者 ID 来进行批量处理后生成文件。然后将生成的文件放到某一个存储位置</p>
<h2 id="审核不通过-逻辑修改"> 审核不通过，逻辑修改</h2>
<p>审核不通过时，对上传的信息做特殊处理，根据医院就诊 id，分组</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-22T08:21:24.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">zhuanzhang</title>
    <id>http://www.zhangsj.xyz/blog/exam/yewu/%E8%BD%AC%E8%B4%A6%E5%BC%95%E5%8F%91%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E6%80%9D%E8%80%83/</id>
    <link href="http://www.zhangsj.xyz/blog/exam/yewu/%E8%BD%AC%E8%B4%A6%E5%BC%95%E5%8F%91%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E6%80%9D%E8%80%83/"/>
    <updated>2022-03-22T16:26:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="转账引发的一致性思考"> 转账引发的一致性思考</h2>
<p>A 账户给 B 账户转账 100 元(A、B 处于同一个库中)，</p>
<p>如果 A 的账户发生扣款，B 的账户却没有到账，这就出现了数据的不一致！</p>
<p>为了保证数据的一致性，数据库的事务机制会让 A 账户扣款和 B 在账户到账的两个操作要么同时成功，如果有一个操作失败，则多个操作同时回滚，这就是事务的原子性，为了保证事务操作的原子性，就必须实现基于日志的 REDO/UNDO 机制。</p>
<p>但是，仅有原子性还不够，因为我们的系统是运行在多线程环境下，如果多个事务并行，即使保证了每一个事务的原子性，仍然会出现数据不一致的情况。</p>
<p>例如</p>
<p>A 账户原来有 200 元的余额， A 账户给 B 账户转账 100 元，先读取 A 账户的余额，然后在这个值上减去 100 元，但是在这两个操作之间，A 账户又给 C 账户转账 100 元，那么最后的结果应该是 A 减去了 200 元。但事实上，A 账户给 B 账户最终完成转账后，A 账户只减掉了 100 元，因为 A 账户向 C 账户转账减掉的 100 元被覆盖了！</p>
<p>所以为了保证并发情况下的一致性，又引入的隔离性，即多个事务并发执行后的状态，和它们串行执行后的状态是等价的！</p>
<p>隔离性又有多种隔离级别，为了实现隔离性(最终都是为了保证一致性)数据库又引入了悲观锁、乐观锁等等……本文的主题是分布式事务，所以本地事务就只是简单回顾一下，需要记住的一点是，事务是为了保证数据的一致性</p>
<h2 id="事务隔离性理解"> 事务隔离性理解：</h2>
<p>H1：当 A 转给 B 100 之后，</p>
<p>H2:A 又转给 C 100，</p>
<p>但是在 H2 未提交之前，A 查询到的余额还是 H1，所以 A 此时余额只减少了 100 元，与实际应该减少 200 元，并发情况下数据不一致。</p>
<h2 id="分布式事务"> 分布式事务</h2>
<p>与本地事务不同的是，分布式事务需要保证的是分布式环境下，不同数据库表中的数据的一致性问题。分布式事务的解决方案有多种，如 XA 协议、TCC 三阶段提交、基于消息队列等等，本文只会涉及基于消息队列的解决方案。</p>
<p>本地事务讲到了一致性，分布式事务不可避免的面临着一致性的问题！回到最开始跨行转账的例子，如果 A 银行用户向 B 银行用户转账，正常流程应该是</p>
<blockquote>
<ol>
<li>A 银行对转出账户执行检查校验，进行金额扣减。</li>
<li>A 银行同步调用 B 银行转账接口。</li>
<li>B 银行对转入账户进行检查校验，进行金额增加。</li>
<li>B 银行返回处理结果给 A 银行。</li>
</ol>
</blockquote>
<p>在正常情况对一致性要求不高的场景，这样的设计是可以满足需求的。但是像银行这样的系统，如果这样实现大概早就破产了吧。我们先看看这样的设计最主要的问题：</p>
<ol>
<li>同步调用远程接口，如果接口比较耗时，会导致主线程阻塞时间较长。</li>
<li>流量不能很好控制，A 银行系统的流量高峰可能压垮 B 银行系统(当然 B 银行肯定会有自己的限流机制)。</li>
<li>如果“第 1 步”刚执行完，系统由于某种原因宕机了，那会导致 A 银行账户扣款了，但是 B 银行没有收到接口的调用，这就出现了两个系统数据的不一致。</li>
<li>如果在执行“第 3 步”后，B 银行由于某种原因宕机了而无法正确回应请求(实际上转账操作在 B 银行系统已经执行且入库)，这时候 A 银行等待接口响应会异常，误以为转账失败而回滚“第 1 步”操作，这也会出现了两个系统数据的不一致。
   对于问题的 1、2 都很好解决，如果对消息队列熟悉的朋友应该很快能想到可以引入消息中间件进行异步和削峰处理，</li>
</ol>
<p>于是又重新设计了一个方案，流程如下：</p>
<ol>
<li>A 银行对账户进行检查校验，进行金额扣减。</li>
<li>将对 B 银行的请求异步写入队列，主线程返回。</li>
<li>启动后台程序从队列获取待处理数据。</li>
<li>后台程序对 B 银行接口进行远程调用。</li>
<li>B 银行对转入账户进行检查校验，进行金额增加。</li>
<li>B 银行处理完成回调 A 银行接口通知处理结果。</li>
</ol>
<p>所以，我们这里最核心的就是</p>
<ul>
<li>A 银行通过本地事务保证日志记录+后台线程轮询保证消息不丢失。</li>
<li>B 银行通过本地事务保证日志记录从而保证消息不重复消费！B 银行在回调 A 银行的接口时会通知处理结果，如果转账失败，A 银行会根据处理结果进行回滚。</li>
</ul>
<p><a href="https://blog.csdn.net/ZrZrZr666666/article/details/113388852?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164549796916781683945697%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164549796916781683945697&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-113388852.pc_search_result_positive&amp;utm_term=%E8%BD%AC%E8%B4%A6+%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7&amp;spm=1018.2226.3001.4187" target="_blank" rel="noopener noreferrer">参考：转账引发数据一致性思考</a></p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="fubuhi"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2021-11-21T00:00:00.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">string</title>
    <id>http://www.zhangsj.xyz/blog/java/basic/Java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BC%98%E5%8C%96%E5%A4%84%E7%90%86/</id>
    <link href="http://www.zhangsj.xyz/blog/java/basic/Java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BC%98%E5%8C%96%E5%A4%84%E7%90%86/"/>
    <updated>2022-04-11T06:31:58.000Z</updated>
    <content type="html"><![CDATA[<h2 id="java性能优化之字符串优化处理"> Java性能优化之字符串优化处理</h2>
<h3 id="string对象"> string对象</h3>
<p>String对象时JAVA中重要的数据类型，在大部分情况下我们都会用到String对象。</p>
<h2 id="string-s-new-string-111-会创建几个对象"> String s = new String(&quot;111 &quot;)会创建几个对象？</h2>
<p>String不可变吗？</p>
<div><pre><code><span>public</span> <span>class</span> <span>App</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>String</span> a <span>=</span> <span>"111"</span><span>;</span>
        a <span>=</span> <span>"222"</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>有的人会认为上面这段代码应该输出：111</p>
<p>这样才和上面的不变性吻合。</p>
<p>哈哈哈，但是并不是这样滴。</p>
<p>222</p>
<p>这不对呀，不是不变吗？怎么变了呢？</p>
<p>其实在JVM的运行中，会单独给一块地分给String。</p>
<p>上面的：</p>
<div><pre><code><span>Stirng</span> a<span>=</span><span>"111"</span>；
</code></pre>
<div><span>1</span><br></div></div><p>我们知道字符串的分配和其他对象分配一样，是需要消耗高昂的时间和空间的，而且字符串我们使用的非常多。JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：</p>
<p>使用字符串常量池。每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性我们可以十分肯定常量池中一定不存在两个相同的字符串。</p>
<p>这里先去JVM给常量池里找，找到了就不用创建对象了，直接把对象的引用地址赋给a。找不到会重新创建一个对象，然后把对象的引用地址赋给a。同理a=&quot;222&quot;;也是先找，找不到就重新创建一个对象，然后把对象的引用地址赋给a。</p>
<p>大家有没有发现我上面的描述中“引用地址”。比如说 Object obj = new Object();很多人喜欢成obj为对象，其实obj不是对象，他只是一个变量，然后这个变量里保存一个Object对象的引用地址罢了。</p>
<p>引用类型声明的变量是指该变量在内存中实际存储的是一个引用地址，实体在堆中。</p>
<p>所以网上很多文章老喜欢这么说</p>
<div><pre><code><span>User</span> user <span>=</span> <span>new</span> <span>User</span><span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>创建了一个user对象，老喜欢把user称之为对象。这里不接受反驳。</p>
<p>所以上面<code>String a = &quot;111&quot;;</code>表达的是变量a里保存了“111
”这个对象的引用地址。变量是可以变的，不能变的是“111”。</p>
<p>String 为什么是不可变的？</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="java"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-04-11T06:31:58.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">解释Serializable 接口的作用</title>
    <id>http://www.zhangsj.xyz/blog/java/basic/HASHCODE%E5%92%8CEQUALS%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <link href="http://www.zhangsj.xyz/blog/java/basic/HASHCODE%E5%92%8CEQUALS%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <updated>2022-04-11T06:31:58.000Z</updated>
    <content type="html"><![CDATA[<h2 id="解释serializable-接口的作用"> 解释Serializable 接口的作用</h2>
<p>在JAVA中的这个Serializable是给JVM看的，告诉JVM，代码不做这个类的序列化了，JVM给我序列化，序列化就是变成二进制流，例如云计算、HADOOP、特别是Hadoop完全就是分布式环境，那么就是涉及到对象要在网络中传输，里面的全是二进制流，当然你来做着这个序列化操作也可以，但是这个类里面可能还有一个类，如果你把外面的类对象的PERSON变成二进制，那么里面也要序列化（这要用到深度遍历，很麻烦），干脆告诉JVM，让他来帮你做。</p>
<h2 id="礼貌"> 礼貌</h2>
<p>礼貌点总是没错的，这也很容易做到。主动打招呼，站直、做好、男生不要翘二郎腿，不亢不卑，面试时双眼直视对方，但也不能直勾勾地盯着人家妹子或者帅哥看，会引起面试官的不适，要适合而止，游刃有余！</p>
<p>了解ID发号器是什么、为什么、如何做？</p>
<h2 id="数据库集群、分库分表"> 数据库集群、分库分表</h2>
<p>数据库达到一定规模的时候，主键ID的唯一性，这一点很好理解。这是因为，我们的一张表被分割到不同机器上的数据库中，如果还依靠与数据库自带的自增功能的话很难保证ID唯一性！</p>
<p>可以看出，USER表中的一百万数据备份到两个数据库中，在每个一个数据库内部主键ID是自增的，</p>
<p>1、使用UUID</p>
<p>本地生成的，所以相对性能较高、时延低、扩展性高，完全不受分库分表的影响！</p>
<p>无法保证趋势递增，</p>
<p>UUID过长，往往用三十二位字符串表示，占用数据库空间较大，做主键的时候索引中主键ID占据的空间较大；</p>
<p>UUID作为主键建立索引查询效率低，常见的优化方案转换为64整数存储；</p>
<p>由于使用实现版本的不一样，在高并发情况下可能会出UUID重复的情况；</p>
<h2 id="vesta框架简介"> VESTA框架简介</h2>
<p>通用的ID产生器，互联网俗称统一发号器，它具有全局唯一、粗略有序、可反解和可制造等特性，它支持三种发布模式：嵌入发布模式、中心服务器发布模式、REST发布模式，根据业务的性能需求，它可以产生最大峰值型和最小粒度型的两种类型的ID，它的实现架构使其具有高性能，可用和可伸缩等互联网产品需要的质量属性，是一款通用的高性能的发号器产品。</p>
<h2 id="hashmap多线程下发生死循环原因及解决"> HashMap多线程下发生死循环原因及解决</h2>
<p>HASHMAP在多线程环境下，同时进行PUT操作，并且同时进行扩容时，会出现链表环，导致死循环</p>
<p>因为JDK8之前采用的是头插法，新加入的冲突元素将会查到原有链表的头部。</p>
<p>扩容之后，链表的元素顺序会反过来，这也是造成死循环的原因之一</p>
<p>JDK8解决之前版本出现的死循环：</p>
<p>JDK8后是直接把节点放到扩容后原有链表的尾部</p>
<p>链表转换为树，</p>
<p>对树进行操作时</p>
<p>面试题 ConcurrentHashMap 的工作原理及代码实现,如何统计所有的元素个数</p>
<p>面试题什么是ABA问题,出现ABA问题JDK是如何解决的</p>
<p>若线程A第一次读取的值为A，线程T1准备对A执行写操作，但这段时间，线程T2完成了A到B到A的更改，当线程A准备写时，A已经不是原来的A了；</p>
<p>举个栗子：</p>
<p>一个单链表，T1和T2分别取出A</p>
<p>T1把A改成ACD，此时A-&gt;next=C</p>
<p>但是T2不知道，当T2尝试把A换成B时，由于B-&gt;next是null（T1以为A-&gt;next也是null呢）替换后就会造成C、D游离状态。</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-04-11T06:31:58.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">hashmap</title>
    <id>http://www.zhangsj.xyz/blog/java/basic/hashmap/</id>
    <link href="http://www.zhangsj.xyz/blog/java/basic/hashmap/"/>
    <updated>2022-04-12T10:55:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="hashmap的内部结构-线程不安全、基于jdk7"> HASHMAP的内部结构（线程不安全、基于JDK7）</h2>
<p>hashmap是无序的，因为每次根据 key 的 hashcode 映射到 Entry 数组上，所以遍历出来的顺序并不是写入的顺序。</p>
<p>HSAHMAP底层是基于数组和链表实现的，两个重要的参数：容量和负载因子；容量的默认大小的16，负载因子是0.75，当HashMap的size&gt;16*0.75时就会发生扩容（容量和负载因子都可以自由调整）。</p>
<p>内部包含了一个ENTRY类型的数组TABLE。</p>
<div><pre><code><span>static</span> <span>class</span> <span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>implements</span> <span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>{</span>
    <span>transient</span> <span>Entry</span><span>[</span><span>]</span> table<span>;</span>
    <span>final</span> <span>K</span> key<span>;</span>
    <span>V</span> value<span>;</span>
    <span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span> next<span>;</span>
    <span>int</span> hash<span>;</span>

    <span>Entry</span><span>(</span><span>int</span> h<span>,</span> <span>K</span> k<span>,</span> <span>V</span> v<span>,</span> <span>Entry</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span> n<span>)</span> <span>{</span>
        value <span>=</span> v<span>;</span>
        next <span>=</span> n<span>;</span>
        key <span>=</span> k<span>;</span>
        hash <span>=</span> h<span>;</span>
    <span>}</span>

    <span>public</span> <span>final</span> <span>K</span> <span>getKey</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> key<span>;</span>
    <span>}</span>

    <span>public</span> <span>final</span> <span>V</span> <span>getValue</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> value<span>;</span>
    <span>}</span>

    <span>public</span> <span>final</span> <span>V</span> <span>setValue</span><span>(</span><span>V</span> newValue<span>)</span> <span>{</span>
        <span>V</span> oldValue <span>=</span> value<span>;</span>
        value <span>=</span> newValue<span>;</span>
        <span>return</span> oldValue<span>;</span>
    <span>}</span>

    <span>public</span> <span>final</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>!</span><span>(</span>o <span>instanceof</span> <span>Map<span>.</span>Entry</span><span>)</span><span>)</span>
            <span>return</span> <span>false</span><span>;</span>
        <span>Map<span>.</span>Entry</span> e <span>=</span> <span>(</span><span>Map<span>.</span>Entry</span><span>)</span> o<span>;</span>
        <span>Object</span> k1 <span>=</span> <span>getKey</span><span>(</span><span>)</span><span>;</span>
        <span>Object</span> k2 <span>=</span> e<span>.</span><span>getKey</span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>k1 <span>==</span> k2 <span>||</span> <span>(</span>k1 <span>!=</span> <span>null</span> <span>&amp;&amp;</span> k1<span>.</span><span>equals</span><span>(</span>k2<span>)</span><span>)</span><span>)</span> <span>{</span>
            <span>Object</span> v1 <span>=</span> <span>getValue</span><span>(</span><span>)</span><span>;</span>
            <span>Object</span> v2 <span>=</span> e<span>.</span><span>getValue</span><span>(</span><span>)</span><span>;</span>
            <span>if</span> <span>(</span>v1 <span>==</span> v2 <span>||</span> <span>(</span>v1 <span>!=</span> <span>null</span> <span>&amp;&amp;</span> v1<span>.</span><span>equals</span><span>(</span>v2<span>)</span><span>)</span><span>)</span>
                <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>final</span> <span>int</span> <span>hashCode</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>Objects</span><span>.</span><span>hashCode</span><span>(</span><span>getKey</span><span>(</span><span>)</span><span>)</span> <span>^</span> <span>Objects</span><span>.</span><span>hashCode</span><span>(</span><span>getValue</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>final</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>getKey</span><span>(</span><span>)</span> <span>+</span> <span>"="</span> <span>+</span> <span>getValue</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div><h2 id="hashmap-特性"> HashMap 特性</h2>
<ol>
<li>存储键值对实现快速存取，允许为null。key值不可重复，若key值重复则覆盖。</li>
<li>非同步，线程不安全。</li>
<li>底层是hash表，不保证有序(比如插入的顺序，自然顺序)</li>
</ol>
<p>Treemap默认按照key的字典顺序来排序(升序) ，也可以自定义排序规则:要实现Comparator接口。</p>
<p>ArrayList，linkedList插入和检索顺序是一样的。</p>
<p>LinkedHashMap实现顺序性</p>
<h2 id="hashmap的底层原理"> HashMap的底层原理</h2>
<p>基于hashing的原理，jdk8后采用数组+链表+红黑树的数据结构。</p>
<p>我们通过put和get存储和获取对象。</p>
<p>当我们给put()方法传递键和值时，先对键做一个hashCode()的计算来得到它在bucket数组中的位置来存储Entry对象。</p>
<p>当获取对象时，通过get获取到bucket的位置，再通过键对象的equals()方法找到正确的键值对，然后在返回值对象。</p>
<h2 id="put方法实现"> put方法实现</h2>
<ol>
<li>计算关于key的hashcode值（与Key.hashCode的高16位做异或运算）</li>
<li>如果散列表为空时，调用resize()初始化散列表</li>
<li>如果没有发生碰撞，直接添加元素到散列表中去</li>
<li>如果发生了碰撞(hashCode值相同)，进行三种判断
<ul>
<li>若key地址相同或者equals后内容相同，则替换旧值</li>
<li>如果是红黑树结构，就调用树的插入方法</li>
<li>链表结构，循环遍历直到链表中某个节点为空，尾插法进行插入，插入之后判断链表个数是否到达变成红黑树的阙值8；也可以遍历到有节点与插入元素的哈希值和内容相同，进行覆盖。</li>
</ul>
</li>
</ol>
<h3 id="扩容机制"> 扩容机制</h3>
<p>如果桶满了大于阀值，则resize进行扩容</p>
<ol>
<li>初始化数组table</li>
<li>当数组table的size达到阙值时即++size &gt; load factor * capacity 时，也是在putVal函数中</li>
</ol>
<p>扩容需要重新分配一个新数组，新数组是老数组的2倍长，然后遍历整个老结构，把所有的元素挨个重新hash分配到新结构中去。</p>
<div><p>ps</p>
<p>可见底层数据结构用到了数组，到最后会因为容量问题都需要进行扩容操作</p>
</div>
<h2 id="get方法实现"> get方法实现</h2>
<p>对key的hashCode进行hashing，与运算计算下标获取bucket位置，如果在桶的首位上就可以找到就直接返回，否则在树中找或者链表中遍历找。</p>
<p>如果有hash冲突，则利用equals方法去遍历链表查找节点。</p>
<h2 id="hash方法实现"> hash方法实现</h2>
<p>对key的hashCode做hash操作，与高16位做异或运算</p>
<p>还有平方取中法，除留余数法，伪随机数法</p>
<h3 id="异或运算原因"> 异或运算原因</h3>
<p>为什么不直接将key作为哈希值而是与高16位做异或运算？</p>
<p>因为数组位置的确定用的是与运算，仅仅最后四位有效，设计者将key的哈希值与高16为做异或运算使得在做&amp;运算确定数组的插入位置时，此时的低位实际是高位与低位的结合，增加了随机性，减少了哈希碰撞的次数。</p>
<p>HashMap默认初始化长度为16，并且每次自动扩展或者是手动初始化容量时，必须是2的幂。</p>
<h3 id="_2次幂原因"> 2次幂原因</h3>
<p>为什么是16？为什么必须是2的幂？如果输入值不是2的幂比如10会怎么样？</p>
<ol>
<li>
<p>为了数据的均匀分布，减少哈希碰撞。因为确定数组位置是用的位运算，若数据不是2的次幂则会增加哈希碰撞的次数和浪费数组空间。(PS:其实若不考虑效率，求余也可以就不用位运算了也不用长度必需为2的幂次) <code>hash % length 等于 hash &amp; ( length - 1)</code></p>
</li>
<li>
<p>输入数据若不是2的幂，HashMap通过一通位移运算和或运算得到的肯定是2的幂次数，并且是离那个数最近的数字,</p>
</li>
</ol>
<p>按位与运算规则:相同的二进制数位上,都是1的时候,结果为1.否则为0;</p>
<h3 id="解决hash冲突"> 解决hash冲突</h3>
<div><pre><code><span>static</span> <span>final</span> <span>int</span> <span>hash</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>
	<span>int</span> h<span>;</span>
	<span>return</span> <span>(</span>key <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> <span>(</span>h <span>=</span> key<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>16</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>key 的 hashCode 赋值给 h，然后与 h 无符号右移 16 位后的二进制进行按位异或得到最后的 hash 值。</p>
<p>会产生哈希碰撞，若key值相同则替换旧值，不然链接到链表后面，链表长度超过阙值8就转为红黑树存储</p>
<p>HashCode相同，通过equals比较内容获取值对象</p>
<h3 id="扩容"> 扩容</h3>
<p>如果HashMap的大小超过了负载因子(load factor)定义的容量</p>
<p>超过阙值会进行扩容操作，概括的讲就是扩容后的数组大小是原数组的2倍，将原来的元素 rehash 放入到新的散列表中去。</p>
<p>扩容这个过程涉及到 rehash、复制数据等操作，非常消耗性能。所以开发中尽量减少扩容的次数，可以通过创建 HashMap 集合对象时指定初始容量来尽量避免。</p>
<h3 id="rehash方法-不需要重新计算hash"> rehash方法：不需要重新计算hash</h3>
<p>因为每次扩容都是翻倍，扩容之后结点要么就在原来的位置，与原来计算的 (n - 1) &amp; hash 的结果相比，只是多了一个 bit 位，rehash设计为结点要么就在原来的位置，要么就被分配到 <strong>“原位置 + 旧容量”</strong> 这个位置。</p>
<p>元素桶位置，新增的 1bit 是0还是 1是随机的，在 resize 的过程中保证了 rehash 之后每个桶上的结点数一定小于等于原来桶上的结点数，保证了rehash之后不会出现更严重的 hash 冲突，均匀的把之前的冲突的结点分散到新的桶中了。</p>
<h2 id="hashtable"> hashtable</h2>
<p>Hashtable没有自定义哈希算法，而直接采用的key的hashCode()。</p>
<h2 id="loadfactor"> loadFactor</h2>
<p>loadFactor表示HashMap的拥挤程度，影响hash操作到同一个数组位置的概率。</p>
<p>默认loadFactor等于0.75，当HashMap里面容纳的元素已经达到HashMap数组长度的75%时，表示HashMap太挤了，需要扩容，在HashMap的构造器中可以定制loadFactor。</p>
<h2 id="红黑树"> 红黑树</h2>
<h3 id="二叉查找树"> 二叉查找树</h3>
<p>二叉查找树就是左结点小于根节点，右结点大于根节点的一种排序树，也叫二叉搜索树。也叫BST，英文Binary Sort Tree。</p>
<p>二叉查找树比普通树查找更快，查找、插入、删除的时间复杂度为<code>O（logN）</code>。但是二叉查找树有一种极端的情况，就是会变成一种线性链表似的结构。此时时间复杂度就变成了<code>O（N）</code>，为了解决这种情况，出现了二叉平衡树。</p>
<h3 id="avl"> avl</h3>
<p>平衡二叉树全称平衡二叉搜索树，也叫AVL树。是一种自平衡的树。</p>
<p>AVL树也规定了左结点小于根节点，右结点大于根节点。并且还规定了左子树和右子树的高度差不得超过1。</p>
<p>这样保证了它不会成为线性的链表。</p>
<p>AVL树的查找稳定，查找、插入、删除的时间复杂度都为O（logN），但是由于要维持自身的平衡，所以进行插入和删除结点操作的时候，需要对结点进行频繁的旋转。</p>
<h3 id="redblack树"> RedBlack树</h3>
<p>红黑树的使用场景
java中使用到红黑树的有TreeSet和JDK1.8的HashMap。</p>
<p>红黑树也叫RB树，RB-Tree。是一种自平衡的二叉查找树，它的节点的颜色为红色和黑色。它不严格控制左、右子树高度或节点数之差小于等于1。也是一种解决二叉查找树极端情况的数据结构。</p>
<p>当链表长度大于8时，遍历查找效率较慢，故引入红黑树;因为红黑树在插入新数据之后，可能会通过左旋、右旋、变色来保持平衡，故链路较短时，不适合用红黑树。</p>
<p>红黑树的特性：</p>
<ol>
<li>节点是红色或黑色。</li>
<li>根节点是黑色。</li>
<li>每个叶子节点都是黑色的空节点（NIL节点）。</li>
<li>每个红色节点的两个子节点都是黑色。也就是说从每个叶子到根的所有路径上不能有两个连续的红色节点)。</li>
<li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li>
</ol>
<p>旋转的目的是将节点多的一支出让节点给另一个节点少的一支，旋转操作在插入和删除操作中经常会用到，所以要熟记。</p>
<p>它们非常相似，真正的区别在于在任何添加/删除操作时完成的旋转操作次数。保证平衡性的最大目的就是降低术的高度，因为树的查找性能取决于树的高度，所以树的高度越低搜索的效率越高！</p>
<p>这也是为什么存在二叉树、搜索二叉树等，各类树的目的。</p>
<p>红黑树在查找方面和AVL树操作几乎相同。 但是在插入和删除操作上，AVL树每次插入删除会进行大量的平衡度计算，红黑树没有像avl严格的高度平衡，它只要求部分地达到平衡要求，结合变色，降低了对旋转的要求，从而提高了性能。</p>
<p>红黑树能够以<code>O(log^2n)</code>的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。</p>
<h2 id="平时在使用hashmap时一般使用什么类型的元素作为key"> 平时在使用HashMap时一般使用什么类型的元素作为Key？</h2>
<p>选择<code>Integer</code>，<code>String</code>这种不可变的类型，像对<code>String</code>的一切操作都是新建一个<code>String</code>对象，对新的对象进行拼接分割等，这些类已经很规范的覆写了<code>hashCode()</code>以及<code>equals()</code>方法。作为不可变类天生是线程安全的，</p>
<h2 id="hashmap"> HashMap</h2>
<p>JDK1.7版本，HashMap的数据结构是什么？</p>
<p>数组+单向链表</p>
<p>什么叫做Hash桶</p>
<p>数组中的单向链表</p>
<p>HashMap的数组长度为什么必须是2的幂？</p>
<p>计算元素存在数组中下标的算法：hash值 &amp; 数组长度-1</p>
<p>如果数组长度不是2的幂，减1后二进制的某一位有可能出现0，导致数组某个位置永远存不到数据</p>
<p>HashMap的默认负载因子是多少，作用是什么？</p>
<p>默认负载因子是0.75</p>
<p>作用：数组长度*负载因子=阈值（扩容条件）</p>
<p>HashMap的默认负载因子为什么是0.75？</p>
<p>取得了时间和空间的平衡</p>
<p>假设负载因子过大，导致数组装满后才扩容，牺牲时间，利用空间</p>
<p>假设负载因子过小，导致数组装载较少内容就扩容，牺牲空间，利用时间</p>
<p>HashMax数组最大长度是多少？</p>
<p>1 &lt;&lt; 30</p>
<p>HashMap数组最大长度为什么是1 &lt;&lt; 30？</p>
<p>因为数组长度必须是2的幂并且HashMap数组最大长度的变量为int类型，所有1&lt;&lt;30</p>
<p>什么叫做Hash碰撞/冲突？</p>
<p>两个对象的hash值一样，导致在数组中的下标一样</p>
<p>HashMap何时扩容？</p>
<p>元素个数&gt;=阈值，并且存入数据的位置不等于null</p>
<h2 id="hashmap扩容机制是什么"> HashMap扩容机制是什么？</h2>
<ol>
<li>如果节点的NEXT属性为NULL，则说明这个一个最正常的节点，不是桶内链表，也不是红黑树，这样的节点可以直接计算索引位置，然后插入。</li>
<li>如果是一颗红黑树，会使用SPLIT方法进行处理，原理就是将红黑树拆分成两个TREENODE链表，然后判断每个链表的长度是否小于等于六，如果是，九江TREENODE转换成桶内链表，否则再转换成红黑树。</li>
<li>如果是桶内链表，则将链表拷贝到新数组中，保证链表的顺序不变。</li>
</ol>
<p>原来的2倍，在REHASH之后，元素的存放位置要么是在原位置，要么是在原位置的基础上向下移动之前容量个数的位置。比如：上次容量是16，下次扩容后容量变成了16*2=32。如果一个元素原先在下表为七的位置上，那么扩容后，该元素要么还在七的位置上，要么就在七加十六的位置上。</p>
<p>HashMap存入null键的位置？</p>
<p>hash数组下标为0的位置</p>
<p>什么叫做Hash回环？</p>
<p>多线程下会出现Hash回环</p>
<p>线程1：不断添加数据，导致不断扩容</p>
<p>线程2：不断遍历</p>
<p>出现Hash回环，活该，HashMap明确说明该集合不是个线程安全的集合，多线程下应该使用ConcurrentHashMap</p>
<p>JDK1.7版本和JDK1.8版本的HashMap的区别</p>
<p>JDK1.7：数组+链表，头插法，通过散列算法获取hash值</p>
<p>JDK1.8：数组+链表+红黑树，尾插法，通过低16位^高16位让hash值更加散列</p>
<p>JDK1.8版本HashMap为什么添加红黑树的数据结构？</p>
<p>因为链表查询慢，红黑树查询快</p>
<p>JDK1.8版本什么时候由数组+链表变成数组+红黑树</p>
<p>链表长度&gt;8并且数组长度&gt;64时，从数组+链表变成数组+红黑树</p>
<p>JDK1.8版本为什么链表长度大于8时，变成数组+红黑树</p>
<p>因为泊松部分（统计概率学），当红黑树里的数据小于6
时，又会将数组+红黑树变会数组+链表；而且根据统计，链表中节点数是8的概率已经接近千分之一，而且此时链表的性能已经很差了。</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="java"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-03-01T02:01:51.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">basic mulu</title>
    <id>http://www.zhangsj.xyz/blog/java/basic/</id>
    <link href="http://www.zhangsj.xyz/blog/java/basic/"/>
    <updated>2022-02-26T14:37:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="java基础目录"> java基础目录</h2>
<ul>
<li><a href="./hashmap.html">hashmap</a></li>
<li><a href="./java的异常.html">java异常</a></li>
</ul>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="mulu"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-26T14:37:30.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">Java 8特性 - Collectors toMap</title>
    <id>http://www.zhangsj.xyz/blog/java/basic/jdk8%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <link href="http://www.zhangsj.xyz/blog/java/basic/jdk8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <updated>2022-03-03T12:48:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="java-8特性-collectors-tomap"> Java 8特性 - Collectors toMap</h2>
<p>tomap</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-03-03T12:48:10.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">referencequeue</title>
    <id>http://www.zhangsj.xyz/blog/java/concurrent/4-reference-types/</id>
    <link href="http://www.zhangsj.xyz/blog/java/concurrent/4-reference-types/"/>
    <updated>2022-03-22T16:26:25.000Z</updated>
    <content type="html"><![CDATA[<h1 id="referencequeue"> referencequeue</h1>
<h2 id="_1-强引用"> 1. 强引用</h2>
<p>强引用是使用最普遍的引用。</p>
<p>如果一个对象具有强引用，那垃圾收集器绝不会回收它。</p>
<p>但是如果这个<code>strongReference</code>是全局变量时，就需要在不用这个对象时赋值为 null，因为强引用不会被垃圾回收。</p>
<p>例如：<code>ArrayList</code>的 <code>Clear</code> 方法：</p>
<p>在 ArrayList 类中定义了一个 elementData 数组，在调用 clear 方法清空数组时，每个数组元素被赋值为 null。不同于 elementData=null，强引用仍然存在，避免在后续调用 add()等方法添加元素时进行内存的重新分配。使用如 clear()方法内存数组中存放的引用类型进行内存释放特别适用，这样就可以及时释放内存。</p>
<div><pre><code><span>public</span> <span>void</span> <span>clear</span><span>(</span><span>)</span> <span>{</span>
    modCount<span>++</span><span>;</span>
    <span>// clear to let 垃圾收集器 do its work</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span>
        elementData<span>[</span>i<span>]</span> <span>=</span> <span>null</span><span>;</span>
    size <span>=</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="_2-软引用"> 2. 软引用</h2>
<p>SoftReference 的主要特点就是在当内存不够的时候，垃圾收集器会回收软引用所引用的对象。</p>
<p>在内存敏感的项目中将某些数据设置成 SoftReference 可以避免内存的溢出。</p>
<h2 id="_3-弱引用"> 3. 弱引用</h2>
<p>当一个对象仅被弱引用指向, 而没有任何其他强引用指向的时候, 如果这时垃圾收集器运行, 那么这个对象就会被回收，不论当前的内存空间是否足够，这个对象都会被回收。</p>
<p>引用队列注册引用的对象，在适当的可达的改变被监听</p>
<h2 id="_4-phantomreference-虚引用"> 4. PhantomReference 虚引用</h2>
<p>虚引用顾名思义，就是形同虚设。</p>
<p>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾收集器回收。</p>
<p>与其他几种引用都不同，虚引用并不会决定对象的生命周期。</p>
<h3 id="应用场景"> 应用场景</h3>
<p>虚引用主要用来跟踪对象被垃圾收集器回收的活动。</p>
<p>如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="concurrent"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-01-30T09:23:34.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">exception</title>
    <id>http://www.zhangsj.xyz/blog/java/basic/java%E7%9A%84%E5%BC%82%E5%B8%B8/</id>
    <link href="http://www.zhangsj.xyz/blog/java/basic/java%E7%9A%84%E5%BC%82%E5%B8%B8/"/>
    <updated>2022-02-26T03:15:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="检查型异常-checkedexception"> 检查型异常(CheckedException)</h2>
<p>在 Java 中所有不是 RuntimeException 派生的 Exception 都是检查型异常。</p>
<p>当函数中存在抛出检查型异常的操作时该函数的函数声明中必须包含 throws 语句。调用改函数的函数也必须对该异常进行处理，如不进行处理则必须在调用函数上声明 throws 语句。</p>
<p>检查型异常是 JAVA 独有的，在<code>编译期对异常的处理</code>有强制的要求。</p>
<p>在 JDK 代码中大量的异常属于检查型异常，包括 IOException，SQLException,ClassNotFoundException,NoSuchMetodException 等等。</p>
<h2 id="非检查型异常-uncheckedexception"> 非检查型异常(UncheckedException)</h2>
<p>如除数是 0 和数组下标越界等，其产生频繁，处理麻烦，若显示申明或者捕获将会对程序的可读性和运行效率影响很大。所以由系统自动检测并将它们交给缺省的异常处理程序。当然如果你有处理要求也可以显示捕获它们。</p>
<p>对 Checked 异常处理方法有两种</p>
<p>1 当前方法知道如何处理该异常，则用 try...catch 块来处理该异常。
2 当前方法不知道如何处理，则在定义该方法是声明抛出该异常。</p>
<p>在 Java 中所有 <code>RuntimeException</code> 的派生类都是非检查型异常，与检查型异常对比，非检查型异常可以不在函数声明中添加 throws 语句，调用函数上也不需要强制处理。</p>
<p>常见的 NullPointException，ClassCastException 是常见的非检查型异常。</p>
<div><pre><code>Java.lang.NullPointerException
Java.lang.IndexOutOfBoundsException
Java.lang.ArithmeticException
Java.lang.ArrayStoreExcetpion
Java.lang.ClassCastException
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>非检查型异常可以不使用 try...catch 进行处理，但是如果有异常产生，则异常将由 JVM 进行处理。对于 RuntimeException 的子类最好也使用异常处理机制。虽然 RuntimeException 的异常可以不使用 try...catch 进行处理，但是如果一旦发生异常，则肯定会导致程序<code>中断执行</code>，所以，为了保证程序再出错后依然可以执行，在开发代码时最好使用 try...catch 的异常处理机制进行处理。</p>
<h2 id="error"> Error</h2>
<p>当程序发生不可控的错误时，通常做法是通知用户并中止程序的执行。与异常不同的是 Error 及其子类的对象不应被抛出。</p>
<p>Error 是 throwable 的子类，代表编译时间和系统错误，用于指示合理的应用程序不应该试图捕获的严重问题。</p>
<p>Error 由 Java 虚拟机生成并抛出，包括动态链接失败，虚拟机错误等。程序对其不做处理。</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="java"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-24T10:20:04.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">common-concurrency-classes-under-java8-concurrent-packages</title>
    <id>http://www.zhangsj.xyz/blog/java/concurrent/Java%208%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B8%8B%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B9%B6%E5%8F%91%E7%B1%BB/</id>
    <link href="http://www.zhangsj.xyz/blog/java/concurrent/Java%208%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B8%8B%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B9%B6%E5%8F%91%E7%B1%BB/"/>
    <updated>2022-04-12T12:32:31.000Z</updated>
    <content type="html"><![CDATA[<p>Java 8并发包下常见的并发类</p>
<h2 id="阻塞队列"> 阻塞队列：</h2>
<p><code>BlockingQueue</code>：阻塞队列接口</p>
<p><code>BlockingDeque</code>：双端阻塞队列接口</p>
<p><code>ArrayBlockingQueue</code>：阻塞队列，数组实现</p>
<p><code>LinkedBlockingDeque</code>：阻塞双端队列，链表实现</p>
<p><code>LinkedBlockingQueue</code>：阻塞队列，链表实现</p>
<p><code>DelayQueue</code>：阻塞队列，并且元素是 Delay 的子类，保证元素在达到一定时间后才可以取得到</p>
<p><code>PriorityBlockingQueue</code>：优先级阻塞队列</p>
<p><code>SynchronousQueue</code>：同步队列，但是队列长度为 0，生产者放入队列的操作会被阻塞，直到消费者过来取，所以这个队列根本不需要空间存放元素；有点像一个独木桥，一次只能一人通过，还不能在桥上停留</p>
<h2 id="非阻塞队列"> 非阻塞队列：</h2>
<p><code>ConcurrentLinkedDeque</code>：非阻塞双端队列，链表实现</p>
<p><code>ConcurrentLinkedQueue</code>：非阻塞队列，链表实现</p>
<h2 id="转移队列"> 转移队列：</h2>
<p><code>TransferQueue</code>：转移队列接口，生产者要等消费者消费的队列，生产者尝试把元素直接转移给消费者</p>
<p><code>LinkedTransferQueue</code>：转移队列的链表实现，它比 SynchronousQueue 更快</p>
<h2 id="其它容器"> 其它容器：</h2>
<p><code>ConcurrentMap</code>：并发 Map 的接口，定义了 putIfAbsent(k,v)、remove(k,v)、replace(k,oldV,newV)、replace(k,v) 这四个并发场景下特定的方法</p>
<p><code>ConcurrentHashMap</code>：并发 HashMap</p>
<p><code>ConcurrentNavigableMap</code>：NavigableMap 的实现类，返回最接近的一个元素</p>
<p><code>ConcurrentSkipListMap</code>：它也是 NavigableMap 的实现类(要求元素之间可以比较)，同时它比 ConcurrentHashMap 更加 scalable——ConcurrentHashMap 并不保证它的操作时间，并且你可以自己来调整它的 load factor；但是 ConcurrentSkipListMap 可以保证 O(log n) 的性能，同时不能自己来调整它的并发参数，只有你确实需要快速的遍历操作，并且可以承受额外的插入开销的时候，才去使用它</p>
<p><code>ConcurrentSkipListSet</code>：和上面类似，只不过 map 变成了 set</p>
<p><code>CopyOnWriteArrayList</code>：copy-on-write 模式的 array list，每当需要插入元素，不在原 list 上操作，而是会新建立一个 list，适合读远远大于写并且写时间并苛刻的场景</p>
<p><code>CopyOnWriteArraySet</code>：和上面类似，list 变成 set 而已</p>
<h2 id="同步设备"> 同步设备</h2>
<p>这些类大部分都是帮助做线程之间同步的，简单描述，就像是提供了一个篱笆，线程执行到这个篱笆的时候都得等一等，等到条件满足以后再往后走。</p>
<p><code>CountDownLatch</code>：一个线程调用 await 方法以后，会阻塞地等待计数器被调用 countDown 直到变成 0，功能上和下面的 CyclicBarrier 有点像</p>
<p><code>CyclicBarrier</code>：也是计数等待，只不过它是利用 await 方法本身来实现计数器“+1” 的操作，一旦计数器上显示的数字达到 Barrier 可以打破的界限，就会抛出 BrokenBarrierException，线程就可以继续往下执行；请参见我写过的这篇文章 《同步、异步转化和任务执行》中的 Barrier 模式</p>
<p><code>Semaphore</code>：功能上很简单，acquire() 和 release() 两个方法，一个尝试获取许可，一个释放许可，Semaphore 构造方法提供了传入一个表示该信号量所具备的许可数量。</p>
<p><code>Exchanger</code>：这个类的实例就像是两列飞驰的火车(线程)之间开了一个神奇的小窗口，通过小窗口(exchange 方法)可以让两列火车安全地交换数据。</p>
<p><code>Phaser</code>：功能上和第 1、2 个差不多，但是可以重用，且更加灵活，稍微有点复杂(CountDownLatch 是不断-1，CyclicBarrier 是不断+1，而 Phaser 定义了两个概念，phase 和 party)，我在下面画了张图，希望能够帮助理解：</p>
<p>一个是 phase，表示当前在哪一个阶段，每碰到一次 barrier 就会触发 advance 操作(触发前调用 onAdvance 方法)，一旦越过这道 barrier 就会触发 phase+1，这很容易理解； 另一个是 party，很多文章说它就是线程数，但是其实这并不准确，它更像一个用于判断 advance 是否被允许发生的计数器： 任何时候都有一个 party 的总数，即注册(registered)的 party 数，它可以在 Phaser 构造器里指定，也可以任意时刻调用方法动态增减； 每一个 party 都有 unarrived 和 arrived 两种状态，可以通过调用 arriveXXX 方法使得它从 unarrived 变成 arrived； 每一个线程到达 barrier 后会等待(调用 arriveAndAwaitAdvance 方法)，一旦所有 party 都到达(即 arrived 的 party 数量等于 registered 的数量)，就会触发 advance 操作，同时 barrier 被打破，线程继续向下执行，party 重新变为 unarrived 状态，重新等待所有 party 的到达； 在绝大多数情况下一个线程就只负责操控一个 party 的到达，因此很多文章说 party 指的就是线程，但是这是不准确的，因为一个线程完全可以操控多个 party，只要它执行多次的 arrive 方法。</p>
<h2 id="原子对象"> 原子对象</h2>
<p>这些对象都的行为在不使用同步的情况下保证了原子性。值得一提的有两点：</p>
<p>weakCompareAndSet 方法：compareAndSet 方法很明确，但是这个是啥？根据 JSR 规范，调用 weakCompareAndSet 时并不能保证 happen-before 的一致性，因此允许存在重排序指令等等虚拟机优化导致这个操作失败(较弱的原子更新操作)，但是从 Java 源代码看，它的实现其实和 compareAndSet 是一模一样的；</p>
<p>lazySet 方法：延时设置变量值，这个等价于 set 方法，但是由于字段是 volatile 类型的，因此次字段的修改会比普通字段(非 volatile 字段)有稍微的性能损耗，所以如果不需要立即读取设置的新值，那么此方法就很有用。</p>
<p>AtomicBoolean.class</p>
<p>AtomicInteger.class</p>
<p>AtomicIntegerArray.class</p>
<p>AtomicIntegerFieldUpdater.class</p>
<p>AtomicLong.class</p>
<p>AtomicLongArray.class</p>
<p>AtomicLongFieldUpdater.class</p>
<p>AtomicMarkableReference.class，它是用来高效表述 Object-boolean 这样的对象标志位数据结构的，一个对象引用+一个 bit 标志位</p>
<p>AtomicReference.class</p>
<p>AtomicReferenceArray.class</p>
<p>AtomicReferenceFieldUpdater.class</p>
<p>AtomicStampedReference.class，它和前面的 AtomicMarkableReference 类似，但是它是用来高效表述 Object-int 这样的“ 对象+版本号” 数据结构，特别用于解决 ABA 问题(ABA 问题这篇文章里面也有介绍)</p>
<h2 id="锁"> 锁</h2>
<p>AbstractOwnableSynchronizer.class，这三个 AbstractXXXSynchronizer 都是为了创建锁和相关的同步器而提供的基础，锁，还有前面提到的同步设备都借用了它们的实现逻辑</p>
<p>AbstractQueuedLongSynchronizer.class，AbstractOwnableSynchronizer 的子类，所有的同步状态都是用 long 变量来维护的，而不是 int，在需要 64 位的属性来表示状态的时候会很有用</p>
<p>AbstractQueuedSynchronizer.class，为实现依赖于先进先出队列的阻塞锁和相关同步器(信号量、事件等等)提供的一个框架，它依靠 int 值来表示状态</p>
<p>Lock.class，Lock 比 synchronized 关键字更灵活，而且在吞吐量大的时候效率更高，根据 JSR-133 的定义，它 happens-before 的语义和 synchronized 关键字效果是一模一样的，它唯一的缺点似乎是缺乏了从 lock 到 finally 块中 unlock 这样容易遗漏的固定使用搭配的约束，除了 lock 和 unlock 方法以外，还有这样两个值得注意的方法：</p>
<p>lockInterruptibly：如果当前线程没有被中断，就获取锁；否则抛出 InterruptedException，并且清除中断</p>
<p>tryLock，只在锁空闲的时候才获取这个锁，否则返回 false，所以它不会 block 代码的执行</p>
<p>ReadWriteLock.class，读写锁，读写分开，读锁是共享锁，写锁是独占锁；对于读-写都要保证严格的实时性和同步性的情况，并且读频率远远大过写，使用读写锁会比普通互斥锁有更好的性能。</p>
<p>ReentrantLock.class，可重入锁(lock 行为可以嵌套，但是需要和 unlock 行为一一对应)，有几点需要注意：</p>
<p>构造器支持传入一个表示是否是公平锁的 boolean 参数，公平锁保证一个阻塞的线程最终能够获得锁，因为是有序的，所以总是可以按照请求的顺序获得锁；不公平锁意味着后请求锁的线程可能在其前面排列的休眠线程恢复前拿到锁，这样就有可能提高并发的性能</p>
<p>还提供了一些监视锁状态的方法，比如 isFair、isLocked、hasWaiters、getQueueLength 等等</p>
<p>ReentrantReadWriteLock.class，可重入读写锁</p>
<p>Condition.class，使用锁的 newCondition 方法可以返回一个该锁的 Condition 对象，如果说锁对象是取代和增强了 synchronized 关键字的功能的话，那么 Condition 则是对象 wait/notify/notifyAll 方法的替代。在下面这个例子中，lock 生成了两个 condition，一个表示不满，一个表示不空：</p>
<p>还有三个月就三年工作经验了。</p>
<p>T型人才</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="concurrent"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-04-12T12:32:31.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">brief-analysis-of-queue-synchronizer-aqs-and-reentrantlock-lock-principles</title>
    <id>http://www.zhangsj.xyz/blog/java/concurrent/Java%E4%B8%AD%E7%9A%84%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8AQS%E5%92%8CReentrantLock%E9%94%81%E5%8E%9F%E7%90%86%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/</id>
    <link href="http://www.zhangsj.xyz/blog/java/concurrent/Java%E4%B8%AD%E7%9A%84%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8AQS%E5%92%8CReentrantLock%E9%94%81%E5%8E%9F%E7%90%86%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/"/>
    <updated>2022-03-30T16:33:06.000Z</updated>
    <content type="html"><![CDATA[<h2 id="java多线程编程-14-java-中的队列同步器aqs和reentrantlock锁原理简要分析"> Java多线程编程-（14）-Java 中的队列同步器AQS和ReentrantLock锁原理简要分析</h2>
<h3 id="一、lock接口"> 一、Lock接口</h3>
<p>在上一篇文章中：Java多线程编程-（5 ）-使用Lock对象实现同步以及线程间通信介绍了如何使用Lock实现和synchronized关键字类似的同步功能，只是Lock在使用时需要显式地获取和释放锁，synchronized实现的隐式的获取所和释放锁。</p>
<p>虽然Lock它缺少了（通过synchronized块或者方法所提供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性，何以见得，举个简单的实例：</p>
<p>假设我们需要先获得锁A，然后在获取锁B，当锁B获得后，释放锁A同时获取锁C，当锁C获得后，在释放B同时获得锁D。。。是不是已经被绕晕了，很显然如果使用synchronized实现的话，不但其过程复杂难以控制，并且稍微出错可以说是一种灾难性的后果。</p>
<p>Lock接口提供的 synchronized 关键字不具备的主要特性</p>
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">``</td>
<td>尝试非阻塞地获取锁</td>
</tr>
<tr>
<td style="text-align:center">能被中断地获取锁</td>
<td>与synchronized</td>
</tr>
<tr>
<td style="text-align:center">不同，获取锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放</td>
<td></td>
</tr>
</tbody>
</table>
<p>而关于Lock接口的使用，也在上一篇的内容中详细的介绍了关系Lock接口的使用案例。下边几张图显示了Lock相关类在Java 8 concurrent并发包下的大致位置和关系。</p>
<p>1、Java 8中 <code>locks</code> 包下的类：</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="concurrent"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-03-22T16:26:25.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">aqs</title>
    <id>http://www.zhangsj.xyz/blog/java/concurrent/aqs-source-code-reading-notes/</id>
    <link href="http://www.zhangsj.xyz/blog/java/concurrent/aqs-source-code-reading-notes/"/>
    <updated>2022-04-11T06:31:58.000Z</updated>
    <content type="html"><![CDATA[<h1 id="aqs"> AQS</h1>
<h2 id="概述"> 概述</h2>
<p>AbstractQueuedSynchronizer，是 JDK 提供的一个同步框架，内部维护着 FIFO 双向队列，即 CLH 同步队列。</p>
<p>AQS 依赖它来完成同步状态的管理(voliate 修饰的 state，用于标志是否持有锁)。如果获取同步状态 state 失败时，会将当前线程及等待信息等构建成一个 Node，将 Node.js 放到 FIFO 队列里，同时阻塞当前线程，当线程将同步状态 state 释放时，会把 FIFO 队列中的首节的唤醒，使其获取同步状态 state。</p>
<p>很多 JUC 包下的锁都是基于 AQS 实现的</p>
<p>如下脑图：</p>
<p><img src="./image/aqs-2.png" alt="" loading="lazy"></p>
<h2 id="node-js-内部类"> Node.js 内部类</h2>
<div><pre><code><span>static</span> <span>final</span> <span>class</span> <span>Node</span> <span>{</span>
        <span>/** 共享节点 */</span>
        <span>static</span> <span>final</span> <span>Node</span> SHARED <span>=</span> <span>new</span> <span>Node</span><span>(</span><span>)</span><span>;</span>

        <span>/** 独占节点 */</span>
        <span>static</span> <span>final</span> <span>Node</span> EXCLUSIVE <span>=</span> <span>null</span><span>;</span>

        <span>/** 因为超时或者中断，节点会被设置成取消状态，被取消的节点不会参与到竞争中，会一直是取消
            状态不会改变 */</span>
        <span>static</span> <span>final</span> <span>int</span> CANCELLED <span>=</span>  <span>1</span><span>;</span>

        <span>/** 后继节点处于等待状态，如果当前节点释放了同步状态或者被取消，会通知后继节点，使其得以
            运行 */</span>
        <span>static</span> <span>final</span> <span>int</span> SIGNAL    <span>=</span> <span>-</span><span>1</span><span>;</span>

        <span>/** 节点在等待条件队列中，节点线程等待在condition上，当其他线程对condition调用了signal
            后，该节点将会从等待队列中进入同步队列中，获取同步状态 */</span>
        <span>static</span> <span>final</span> <span>int</span> CONDITION <span>=</span> <span>-</span><span>2</span><span>;</span>

        <span>/**
         * 下一次共享式同步状态获取会无条件的传播下去
         */</span>
        <span>static</span> <span>final</span> <span>int</span> PROPAGATE <span>=</span> <span>-</span><span>3</span><span>;</span>

        <span>/** 等待状态 */</span>
        <span>volatile</span> <span>int</span> waitStatus<span>;</span>

        <span>/** 前驱节点 */</span>
        <span>volatile</span> <span>Node</span> prev<span>;</span>

        <span>/** 后继节点 */</span>
        <span>volatile</span> <span>Node</span> next<span>;</span>

        <span>/** 获取同步状态的线程 */</span>
        <span>volatile</span> <span>Thread</span> thread<span>;</span>

        <span>/**
         * 下一个条件队列等待节点
         */</span>
        <span>Node</span> nextWaiter<span>;</span>

        <span>final</span> <span>boolean</span> <span>isShared</span><span>(</span><span>)</span> <span>{</span>
            <span>return</span> nextWaiter <span>==</span> SHARED<span>;</span>
        <span>}</span>

        <span>final</span> <span>Node</span> <span>predecessor</span><span>(</span><span>)</span> <span>throws</span> <span>NullPointerException</span> <span>{</span>
            <span>Node</span> p <span>=</span> prev<span>;</span>
            <span>if</span> <span>(</span>p <span>==</span> <span>null</span><span>)</span>
                <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>
            <span>else</span>
                <span>return</span> p<span>;</span>
        <span>}</span>

        <span>Node</span><span>(</span><span>)</span> <span>{</span>    <span>// </span>
            <span>Used</span> <span>to</span> <span>establish</span> initial head or SHARED markesr
            dsfjsdl
        <span>}</span>

        <span>Node</span><span>(</span><span>Thread</span> thread<span>,</span> <span>Node</span> mode<span>)</span> <span>{</span>     <span>// Used by addWaiter</span>
            <span>this</span><span>.</span>nextWaiter <span>=</span> mode<span>;</span>
            <span>this</span><span>.</span>thread <span>=</span> thread<span>;</span>
        <span>}</span>

        <span>Node</span><span>(</span><span>Thread</span> thread<span>,</span> <span>int</span> waitStatus<span>)</span> <span>{</span> <span>// Used by Condition</span>
            <span>this</span><span>.</span>waitStatus <span>=</span> waitStatus<span>;</span>
            <span>this</span><span>.</span>thread <span>=</span> thread<span>;</span>
        <span>}</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br></div></div><h2 id="fifo-结构图"> FIFO 结构图</h2>
<p><img src="./image/aqs-1.png" alt="" loading="lazy"></p>
<h2 id="独占式同步状态过程"> 独占式同步状态过程</h2>
<h3 id="acquire"> acquire</h3>
<p>独占式获取同步状态</p>
<div><pre><code>public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) {
        selfInterrupt();
    }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="tryacquire"> tryAcquire</h3>
<p>尝试去获取锁，获取成功返回 true，否则返回 false。该方法由继承 AQS 的子类自己实现。采用了模板方法设计模式。</p>
<p>如：ReentrantLock 的 Sync 内部类，Sync 的子类：NonfairSync 和 FairSync</p>
<div><pre><code>protected boolean tryAcquire(int arg) {
     throw new UnsupportedOperationException();
 }
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="addwaiter"> addWaiter</h3>
<div><pre><code>private Node addWaiter(Node mode) {
       // 新建Node节点
       Node node = new Node(Thread.currentThread(), mode);
       // 尝试快速添加尾结点
       Node pred = tail;
       if (pred != null) {
           node.prev = pred;
           // CAS方式设置尾结点
           if (compareAndSetTail(pred, node)) {
               pred.next = node;
               return node;
           }
       }
       // 如果上面添加失败，这里循环尝试添加，直到添加成功为止
       enq(node);
       return node;
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="enq"> enq</h3>
<div><pre><code>    private Node enq(final Node node) {
        // 一直for循环，直到插入Node成功为止
        for (;;) {
            Node t = tail;
            if (t == null) {
                // CAS设置首节点
                if (compareAndSetHead(new Node()))
                    tail = head;
            } else {
                node.prev = t;
                // CAS设置尾结点
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id="acquirequeued"> acquireQueued</h3>
<div><pre><code> final boolean acquireQueued(final Node node, int arg) {
        // 操作是否成功标志
        boolean failed = true;
        try {
            // 线程中断标志
            boolean interrupted = false;
            // 不断的自旋循环
            for (;;) {
                // 当前节点的prev节点
                final Node p = node.predecessor();
                // 判断prev是否是头结点 &amp;&amp; 是否获取到同步状态
                if (p == head &amp;&amp; tryAcquire(arg)) {
                    // 以上条件成立，将当前节点设置成头结点
                    setHead(node);
                    // 将prev节点移除队列中
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                // 自旋过程中，判断当前线程是否需要阻塞 &amp;&amp; 阻塞当前线程并且检验线程中断状态
                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                // 取消获取同步状态
                cancelAcquire(node);
        }
    }
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h3 id="shouldparkafterfailedacquire"> shouldParkAfterFailedAcquire</h3>
<div><pre><code> private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        // 拿到当前节点的prev节点的等待状态
        int ws = pred.waitStatus;

        if (ws == Node.SIGNAL)
            /*
             * 如果prev的status是signal，表示当prev释放了同步状态或者取消了，会通知当前节
             * 点，所以当前节点可以安心的阻塞了（相当睡觉会有人叫醒他）
             */
            return true;
        if (ws &gt; 0) {
            /*
             * status &gt; 0，表示为取消状态，需要将取消状态的节点从队列中移除
             * 直到找到一个状态不是取消的节点为止
             */
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus &gt; 0);
            pred.next = node;
        } else {
            /*
             * 除了以上情况，通过CAS将prev的status设置成signal
             */
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h3 id="parkandcheckinterrupt"> parkAndCheckInterrupt</h3>
<div><pre><code>private final boolean parkAndCheckInterrupt() {
    // 阻塞当前线程
    LockSupport.park(this);
    // 返回当前线程的中断状态
    return Thread.interrupted();
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>Sun.misc.Unsafe</p>
<p>甲 不动，乙类 可改
医师服务费 其他</p>
<p>参考文献：
<a href="https://mp.weixin.qq.com/s/PdB_1-C2FGl91vN3SM5ZVg" target="_blank" rel="noopener noreferrer">2 万月薪必会知识：AQS</a></p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="concurrent"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-01-30T09:23:34.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">concurrent-content</title>
    <id>http://www.zhangsj.xyz/blog/java/concurrent/</id>
    <link href="http://www.zhangsj.xyz/blog/java/concurrent/"/>
    <updated>2022-02-26T14:37:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="并发目录"> 并发目录</h2>
<ul>
<li><a href="./4-reference-types.html">四种引用类型</a></li>
<li><a href="./aqs-source-code-reading-notes.html">AbstractQueuedSynchronizer</a></li>
<li><a href="./synchronized-principle-analysis-and-optimization.html">synchronized</a></li>
<li><a href="./java线程间的通信方式.html">线程间的通信方式</a></li>
<li><a href="./thread-life-cycle.html">线程生命周期，五大状态转换分析</a></li>
<li><a href="./threadlocal.html">threadLocal</a></li>
<li><a href="./threadpool-code-analysis.html">theadpool</a></li>
<li><a href="./乐观锁和悲观锁.html">乐观锁&amp;悲观锁</a></li>
</ul>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="mulu"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-25T04:26:56.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">the-way-the-thread-communicates</title>
    <id>http://www.zhangsj.xyz/blog/java/concurrent/java%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</id>
    <link href="http://www.zhangsj.xyz/blog/java/concurrent/java%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
    <updated>2022-03-22T16:26:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="java-线程的通信方式"> Java 线程的通信方式</h2>
<p>通信的目的是为了更好的协作，线程无论是<code>交替</code>式执行，还是<code>接力</code>式执行，都需要进行通信告知。</p>
<h2 id="使用-volatile-保证可见性-synchronized"> 使用 volatile 保证可见性 synchronized</h2>
<p>Volatile 有两大特性，一是可见性(让线程之间进行通信)，二是有序性，禁止指令重排序</p>
<p>所有 volatile 修饰的变量一旦被某个线程更改，必须立即刷新到主内存
所有 volatile 修饰的变量在使用之前必须重新读取主内存的值</p>
<h2 id="等待-通知机制-是基于-wait-和-notify-方法来实现的"> 等待/通知机制 是基于 wait 和 notify 方法来实现的</h2>
<p>在一个线程内调用该线程锁对象的 wait 方法，线程将进入等待队列进行等待直到被通知或者被唤醒。</p>
<p>因为调用 wait 方法时，必须要先释放锁，如果没有持有锁将会抛出异常。</p>
<h2 id="join-方式"> join 方式</h2>
<p>Join 可以理解成是线程合并，当在一个线程调用另一个线程的 join 方法时，当前线程阻塞等待被调用 join 方法的线程执行完毕才能继续执行，所以 join 的好处能够保证线程的执行顺序，但是如果调用线程的 join 方法其实已经失去了并行的意义，虽然存在多个线程，但是本质上还是串行的，join 实现其实也是基于 wait/notify(等待通知机制)。</p>
<h2 id="threadlocal-方式"> threadLocal 方式</h2>
<p>ThreadLocal使用场合主要解决多线程中数据因并发产生不一致问题。</p>
<p>每个线程的中并发访问的数据提供一个副本，通过访问副本来运行业务，这样的结果是耗费了内存，单大大减少了线程同步所带来性能消耗，也减少了线程并发控制的复杂度。</p>
<p>ThreadLocal不能使用原子类型，只能使用Object类型。ThreadLocal的使用比synchronized要简单得多。</p>
<p>实现每一个线程都有自己的共享变量,绑定自己的值,cpu 下一次轮询，还能获取自己上次的状态。</p>
<p>ThreadLocal 方式的线程通信，不像以上三种方式是多个线程之间的通信，它更像是一个线程内部的通信，将当前线程和一个 map 绑定，在当前线程内可以任意存取数据，减省了方法调用间参数的传递。</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="concurrent"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-21T11:53:59.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">thread-life-cycle</title>
    <id>http://www.zhangsj.xyz/blog/java/concurrent/thread-life-cycle/</id>
    <link href="http://www.zhangsj.xyz/blog/java/concurrent/thread-life-cycle/"/>
    <updated>2022-04-12T10:55:02.000Z</updated>
    <content type="html"><![CDATA[<h1 id="thread"> thread</h1>
<h1 id="线程生命周期-五大状态转换分析"> 线程生命周期，五大状态转换分析</h1>
<h2 id="前言"> 前言</h2>
<p>本章学习完成，你将会对线程的生命周期有清楚的认识，并且明白不同状态之间是如何转换的，以及对 java 线程状态枚举类解读。</p>
<h2 id="一、线程生命周期"> 一、线程生命周期</h2>
<p>一个完整的线程生命周期，要经过 新建(new)、就绪(Runnable)、运行(Running)、阻塞(Blocked)和死亡(Dead)5 种状态。</p>
<p><img src="./image/1-1.png" alt="" loading="lazy"></p>
<h3 id="_1-new-阶段"> 1.new 阶段</h3>
<p>New 阶段就是你 new Thread()创建线程对象时候的阶段。</p>
<p>是创建了一个 Therad 对象</p>
<p>只有当我们真正把线程启动起来的时候，此时才会在 JVM 进程</p>
<p>我们 new 了一个 Thread 对象之后就需要调用 Thread.start()来启动线程，此时线程会从 new 阶段转换到 Runnable 阶段。</p>
<p>线程流程图-new_to_runnable：</p>
<p><img src="./image/1-2.png" alt="" loading="lazy"></p>
<h3 id="_2-runnable-阶段"> 2. Runnable 阶段</h3>
<p>只有调用 Thread.start()方法才能使线程从 new 阶段转换到 Runnable 阶段。</p>
<p>当然我们从字面意思也可以知道此时线程是处于可执行转状态而不是真正的执行中状态了，此时的线程只能等 CPU 翻牌子，翻到了他才能真正的跑起来。</p>
<p>Java.lang.Thread.start</p>
<p>Java.lang.Thread.State</p>
<div><pre><code>    public enum State {
        /**
         * Thread state for a thread which has not yet started.
         * 还没有start的线程状态
         */
        NEW,

        /**
         * Thread state for a runnable thread.  A thread in the runnable
         * state is executing in the Java virtual machine but it may
         * be waiting for other resources from the operating system
         * such as processor.
         */
        RUNNABLE,

        /**
         * Thread state for a thread blocked waiting for a monitor lock.
         * A thread in the blocked state is waiting for a monitor lock
         * to enter a synchronized block/method or
         * reenter a synchronized block/method after calling
         * {@link Object#wait() Object.wait}.
         */
        BLOCKED,

        /**
         * Thread state for a waiting thread.
         * A thread is in the waiting state due to calling one of the
         * following methods:
         * &lt;ul&gt;
         *   &lt;li&gt;{@link Object#wait() Object.wait} with no timeout&lt;/li&gt;
         *   &lt;li&gt;{@link #join() Thread.join} with no timeout&lt;/li&gt;
         *   &lt;li&gt;{@link LockSupport#park() LockSupport.park}&lt;/li&gt;
         * &lt;/ul&gt;
         *
         * &lt;p&gt;A thread in the waiting state is waiting for another thread to
         * perform a particular action.
         *
         * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;
         * on an object is waiting for another thread to call
         * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on
         * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;
         * is waiting for a specified thread to terminate.
         */
        WAITING,

        /**
         * Thread state for a waiting thread with a specified waiting time.
         * A thread is in the timed waiting state due to calling one of
         * the following methods with a specified positive waiting time:
         * &lt;ul&gt;
         *   &lt;li&gt;{@link #sleep Thread.sleep}&lt;/li&gt;
         *   &lt;li&gt;{@link Object#wait(long) Object.wait} with timeout&lt;/li&gt;
         *   &lt;li&gt;{@link #join(long) Thread.join} with timeout&lt;/li&gt;
         *   &lt;li&gt;{@link LockSupport#parkNanos LockSupport.parkNanos}&lt;/li&gt;
         *   &lt;li&gt;{@link LockSupport#parkUntil LockSupport.parkUntil}&lt;/li&gt;
         * &lt;/ul&gt;
         */
        TIMED_WAITING,

        /**
         * Thread state for a terminated thread.
         * The thread has completed execution.
         */
        TERMINATED;
    }
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br></div></div><h3 id="_3-running-阶段"> 3.Running 阶段</h3>
<p>这个阶段的线程已经获取到了<strong>CPU 调度执行权</strong>，也就是说处于运行中状态了。</p>
<p>在该阶段中，线程可以向前或者向后发生转换：</p>
<ul>
<li>由于 CPU 的调度器轮询导致该线程放弃执行，就会进入 Runnable 阶段。</li>
<li>线程主动调用 yield，放弃 CPU 执行权，就会进入 Runnable 阶段(这种方式并不是百分百生效的，在 CPU 资源不紧张的时候不会生效)。</li>
<li>调用 sleep、wait 方法，进入 Blocked 阶段(这里讲的 Blocked 阶段和线程的 Blocked 状态需要区分开，这边讲的是一个比较广义的 Blocked 的阶段)</li>
<li>进行某个阻塞的 IO 操作而进入 Blocked 阶段</li>
<li>为了获取某个锁资源而加入到该锁到阻塞队列中而进入 Blocked 阶段</li>
<li>线程执行完成或者调用 stop 方法或者判断某个逻辑标识，直接进入 Terminated 阶段</li>
</ul>
<h3 id="wait"> wait</h3>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="thread"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-01-30T09:23:34.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">synchronized</title>
    <id>http://www.zhangsj.xyz/blog/java/concurrent/synchronized-principle-analysis-and-optimization/</id>
    <link href="http://www.zhangsj.xyz/blog/java/concurrent/synchronized-principle-analysis-and-optimization/"/>
    <updated>2022-04-11T06:31:58.000Z</updated>
    <content type="html"><![CDATA[<h2 id="可见性"> 可见性</h2>
<h3 id="概念"> 概念</h3>
<p>可见性是指一个线程对共享变量进行修改，另一个线程先立即获取到修改后的最新值。</p>
<h3 id="可见性演示"> 可见性演示</h3>
<p>一个线程根据 <code>boolean</code> 类型的标记 flag， while 循环，另一个线程改变这个 flag 变量的值，另一个线程并不会停止循环。</p>
<p>多个线程都会访问的数据，我们称为线程的共享数据</p>
<div><pre><code><span>/**
演示:
一个线程对共享变量的修改,另一个线程不能立即得到最新值
*/</span>
<span>public</span> <span>class</span> <span>Test01Visibility</span> <span>{</span>

<span>// 共享数据</span>
<span>private</span> <span>static</span> <span>boolean</span> run <span>=</span> <span>true</span><span>;</span>

<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>
    <span>Thread</span> t1 <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
        <span>while</span> <span>(</span>run<span>)</span> <span>{</span>
        <span>}</span>
    <span>}</span><span>)</span><span>;</span>
    t1<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
    <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>
    <span>Thread</span> t2 <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
        run <span>=</span> <span>false</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"时间到，线程2设置为false"</span><span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
    t2<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><div><p>总结</p>
<p>并发编程时，会出现可见性问题，当一个线程对共享变量进行了修改，另外的线程并没有立即看到修改 后的最新值。Synchronized volatile 可解决</p>
</div>
<h2 id="原子性"> 原子性</h2>
<h3 id="概念-2"> 概念</h3>
<p>在一次或多次操作中，要么所有的操作都执行并且不会受其他因素干扰而中断，要么所有的操作都不执行。</p>
<h3 id="演示"> 演示</h3>
<div><pre><code><span>/**
案例演示:5个线程各执行1000次 i++;
*/</span>
<span>public</span> <span>class</span> <span>Test02Atomicity</span> <span>{</span>
    <span>private</span> <span>static</span> <span>int</span> number <span>=</span> <span>0</span><span>;</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>
    <span>Runnable</span> increment <span>=</span> <span>(</span><span>)</span> <span>-></span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>1000</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            number<span>++</span><span>;</span>
        <span>}</span>
    <span>}</span><span>;</span>
    <span>ArrayList</span><span><span>&lt;</span><span>Thread</span><span>></span></span> ts <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>5</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>Thread</span> t <span>=</span> <span>new</span> <span>Thread</span><span>(</span>increment<span>)</span><span>;</span>
        t<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        ts<span>.</span><span>add</span><span>(</span>t<span>)</span><span>;</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>Thread</span> t <span>:</span> ts<span>)</span> <span>{</span>
        t<span>.</span><span>join</span><span>(</span><span>)</span><span>;</span>
     <span>}</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"number = "</span> <span>+</span> number<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>使用 javap 反汇编 class 文件，得到下面的字节码指令：</p>
<p><img src="./img/1-2-1.png" alt="" loading="lazy"></p>
<p>其中，对于 number++ 而言(number 为静态变量)，实际会产生如下的 JVM 字节码指令：由此可见 number++是由多条语句组成，以上多条指令在一个线程的情况下是不会出问题的，但是在多 线程情况下就可能会出现问题。比如一个线程在执行 13: iadd 时，另一个线程又执行 9: getstatic。会导 致两次 number++，实际上只加了 1。</p>
<div><p>总结</p>
<p>并发编程时，会出现原子性问题，当一个线程对共享变量操作到一半时，另外的线程也有可能来操作共享变量，干扰了前一个线程的操作。</p>
</div>
<h2 id="有序性"> 有序性</h2>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-0"><label for="task-item-0"> 学习什么是有序性问题</label></li>
</ul>
<h3 id="有序性概念"> 有序性概念</h3>
<p>有序性(Ordering)：是指程序中代码的执行顺序，Java 在编译时和运行时会对代码进行优化，会导致 程序最终的执行顺序不一定就是我们编写代码时的顺序。</p>
<h3 id="有序性演示"> 有序性演示</h3>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>int</span> a <span>=</span> <span>10</span><span>;</span>
    <span>int</span> b <span>=</span> <span>20</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>Jcstress 是 java 并发压测工具。<a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress" target="_blank" rel="noopener noreferrer">https://wiki.openjdk.java.net/display/CodeTools/jcstress</a> 修改 pom 文件，添加依赖：</p>
<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>
    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.openjdk.jcstress<span><span><span>&lt;/</span>groupId</span><span>></span></span>
    <span><span><span>&lt;</span>artifactId</span><span>></span></span>jcstress-core<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
    <span><span><span>&lt;</span>version</span><span>></span></span>${jcstress.version}<span><span><span>&lt;/</span>version</span><span>></span></span>
<span><span><span>&lt;/</span>dependency</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>9</span>: getstatic <span>#12 // Field number:I</span>
<span>12</span>: iconst_1
<span>13</span>: iadd
<span>14</span>: putstatic <span>#12 // Field number:I</span>
代码
Test03Orderliness.java
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span>package</span> <span>com<span>.</span>itheima<span>.</span>concurrent_problem</span><span>;</span>
<span>import</span> <span>org<span>.</span>openjdk<span>.</span>jcstress<span>.</span>annotations<span>.</span></span><span>*</span><span>;</span>
<span>import</span> <span>org<span>.</span>openjdk<span>.</span>jcstress<span>.</span>infra<span>.</span>results<span>.</span></span><span>I_Result</span><span>;</span>

<span>@JCStressTest</span>
<span>@Outcome</span><span>(</span>id <span>=</span> <span>{</span><span>"1"</span><span>,</span><span>"4"</span><span>}</span>， expect <span>=</span> <span>Expect</span><span>.</span>ACCEPTABLE， desc <span>=</span> <span>"ok"</span><span>)</span>
<span>@Outcome</span><span>(</span>id <span>=</span> <span>"0"</span>， expect <span>=</span> <span>Expect</span><span>.</span>ACCEPTABLE_INTERESTING， desc <span>=</span> <span>"danger"</span><span>)</span>
<span>@State</span>
<span>public</span> <span>class</span> <span>Test03Orderliness</span> <span>{</span>
    <span>int</span> num <span>=</span> <span>0</span><span>;</span>
    <span>boolean</span> ready <span>=</span> <span>false</span><span>;</span>
    <span>// 线程一执行的代码</span>
    <span>@Actor</span>
    <span>public</span> <span>void</span> <span>actor1</span><span>(</span><span>I_Result</span> r<span>)</span> <span>{</span>
        <span>if</span><span>(</span>ready<span>)</span> <span>{</span>
            r<span>.</span>r1 <span>=</span> num <span>+</span> num<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            r<span>.</span>r1 <span>=</span> <span>1</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>// 线程2执行的代码</span>
    <span>@Actor</span>
    <span>public</span> <span>void</span> <span>actor2</span><span>(</span><span>I_Result</span> r<span>)</span> <span>{</span>
        num <span>=</span> <span>2</span><span>;</span>
        ready <span>=</span> <span>true</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>I_Result 是一个对象，有一个属性r1用来保存结果，在多线程情况下可能出现几种结果？</p>
<p>情况 1：线程1先执行 actor1，这时 ready = false，所以进入 else 分支结果为 1。</p>
<p>情况 2：线程2执行到actor2，执行了 num = 2;和 ready = true，线程 1 执行，这回进入 if 分支，结果为 4。</p>
<p>情况 3：线程2先执行actor2，只执行num=2；但没来得及执行 ready = true，线程 1 执行，还是进入Else分支，结果为1。</p>
<p>还有一种结果 0。</p>
<p>运行测试：</p>
<div><pre><code>mvn clean <span>install</span>
java -jar target/jcstress.jar
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><p>总结</p>
<p>程序代码在执行过程中的先后顺序，由于 Java 在编译期以及运行期的优化，导致了代码的执行顺序未必就是开发者编写代码时的顺序。</p>
</div>
<h1 id="二、java-内存模型-jmm"> 二、Java 内存模型(JMM)</h1>
<p>在介绍 Java 内存模型之前，先来看一下到底什么是计算机内存模型。</p>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-1"><label for="task-item-1"> 计算机的主要组成</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-2"><label for="task-item-2"> 学习缓存的作用</label></li>
</ul>
<h3 id="计算机结构简介"> 计算机结构简介</h3>
<p>冯诺依曼，提出计算机由五大组成部分，输入设备，输出设备存储器，控制器，运算器。</p>
<p><img src="./img/2-1-1.png" alt="" loading="lazy"></p>
<h3 id="cpu"> CPU</h3>
<p>中央处理器，是计算机的控制和运<br>
的核心，我们的程序最终都会变成指令 让 CPU
去执行，处理程序中 的数据。</p>
<h3 id="内存"> 内存</h3>
<p>我们的程序都是在内存中运行的，内存会保存程序运行时的数据，供 CPU 处理。</p>
<h3 id="缓存"> 缓存</h3>
<p>CPU的运算速度和内存的访问速度相差比较大。这就导致 CPU 每次操作内存都要耗费很多等待时间。内
存的读写速度成为了计算机运行的瓶颈。于是就有了在 CPU 和主内存之间增加缓存的设计。最靠近 CPU
的缓存称为 L1，然后依次是 L2，L3 和主内存，CPU 缓存模型如图下图所示。</p>
<p><img src="./img/2-1-4.png" alt="" loading="lazy"></p>
<p>CPU Cache 分成了三个级别: L1， L2， L3。级别越小越接近 CPU，速度也更快，同时也代表着容量越
小。</p>
<ol>
<li>L1 是最接近 CPU 的，它容量最小，例如 32K，速度最快，每个核上都有一个 L1 Cache。</li>
<li>L2 Cache 更大一些，例如 256K，速度要慢一些，一般情况下每个核上都有一个独立的 L2 Cache。</li>
<li>L3 Cache 是三级缓存中最大的一级，例如 12MB，同时也是缓存中最慢的一级，在同一个 CPU 插槽
之间的核共享一个 L3 Cache。</li>
</ol>
<p><img src="./img/2-1-5.png" alt="" loading="lazy"></p>
<p>Cache 的出现是为了解决CPU直接访问内存效率低下问题的，</p>
<p>程序在运行的过程中，CPU 接收到指令后，它会最先向CPU中的一级缓存(L1 Cache)去寻找相关的数据，如果命中缓存，CPU 进行计算时就 可以直接对 CPU Cache 中的数据进行读取和写人，</p>
<p>当运算结束之后，再将 CPUCache 中的最新数据刷新 到主内存当中，CPU 通过直接访问 Cache 的方式替代直接访问主存的方式极大地提高了 CPU 的吞吐能 力。</p>
<p>但是由于一级缓存(L1 Cache)容量较小，所以不可能每次都命中。</p>
<p>这时 CPU 会继续向下一级的二级缓存(L2 Cache)寻找，同样的道理，当所需要的数据在二级缓存中也没有的话，会继续转向 L3 Cache、内存(主存)和硬盘。</p>
<div><p>总结</p>
<p>计算机的主要组成CPU，内存，输入设备，输出设备。</p>
</div>
<h2 id="java-内存模型"> Java 内存模型</h2>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-3"><label for="task-item-3"> 学习 Java 内存模型的概念和作用</label></li>
</ul>
<h3 id="概念-3"> 概念</h3>
<p>Java Memory Molde (Java 内存模型/JMM)，千万不要和 Java 内存结构混淆</p>
<p>关于“Java 内存模型”的权威解释，请参考 <a href="https://download.oracle.com/otn-pub/jcp/memory_model1.0-pfd-spec-oth-JSpec/memory_model-1_0-pfd-spec.PDF" target="_blank" rel="noopener noreferrer">https://download.oracle.com/otn-pub/jcp/memory_model1.0-pfd-spec-oth-JSpec/memory_model-1_0-pfd-spec.PDF</a>。</p>
<p>Java 内存模型，是 Java 虚拟机规范中所定义的一种内存模型，Java 内存模型是标准化的，屏蔽掉了底层
不同计算机的区别。</p>
<p>Java 内存模型是一套规范，描述了 Java 程序中各种变量(线程共享变量)的访问规则，以及在 JVM 中将变量
存储到内存和从内存中读取变量这样的底层细节，具体如下。</p>
<ul>
<li>主内存
主内存是所有线程都共享的，都能访问的。所有的共享变量都存储于主内存。</li>
<li>工作内存
每一个线程有自己的工作内存，工作内存只存储该线程对共享变量的副本。线程对变量的所有的操 作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量，不同线程之间也不能直接 访问对方工作内存中的变量。</li>
</ul>
<p><img src="./img/2-2-1.png" alt="" loading="lazy"></p>
<h3 id="作用"> 作用</h3>
<p>Java 内存模型是一套在多线程读写共享数据时，对共享数据的可见性、有序性、和原子性的规则和保障。</p>
<p>Synchronized,volatile</p>
<h3 id="cpu-缓存-内存与-jmm的关系"> CPU 缓存，内存与 JMM的关系</h3>
<p>通过对前面的 CPU 硬件内存架构、Java 内存模型以及 Java 多线程的实现原理的了解，我们应该已经意识到，多线程的执行最终都会映射到硬件处理器上进行执行。</p>
<p>但 Java 内存模型和硬件内存架构并不完全一致。</p>
<p>对于硬件内存来说只有寄存器、缓存内存、主内存的概 念，并没有工作内存和主内存之分，也就是说 Java 内存模型对内存的划分对硬件内存并没有任何影响， 因为 JMM 只是一种抽象的概念，是一组规则，不管是工作内存的数据还是主内存的数据，对于计算机硬 件来说都会存储在计算机主内存中，当然也有可能存储到 CPU 缓存或者寄存器中，因此总体上来说， Java 内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种抽象概念划分与真实物理硬件的交 叉。</p>
<p><strong>JMM 内存模型与 CPU 硬件内存架构的关系：</strong></p>
<p><img src="./img/2-2-2.png" alt="" loading="lazy"></p>
<div><p>总结</p>
<p>Java 内存模型是一套规范，描述了 Java 程序中各种变量(线程共享变量)的访问规则，以及在 JVM 中将变量
存储到内存和从内存中读取变量这样的底层细节，Java 内存模型是对共享数据的可见性、有序性、和原
子性的规则和保障。</p>
</div>
<h2 id="主内存与工作内存之间的交互"> 主内存与工作内存之间的交互</h2>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-4"><label for="task-item-4"> 了解主内存与工作内存之间的数据交互过程</label></li>
</ul>
<p><img src="./img/2-3-1.png" alt="" loading="lazy"></p>
<p>Java 内存模型中定义了以下 8 种操作来完成，主内存与工作内存之间具体的交互协议，即一个变量如何
从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，虚拟机实现时必须保证下面
提及的每一种操作都是原子的、不可再分的。</p>
<p>对应如下的流程图：</p>
<p><img src="./img/2-3-2.png" alt="" loading="lazy"></p>
<p>注意:</p>
<ol>
<li>如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值</li>
<li>对一个变量执行 unlock 操作之前，必须先把此变量同步到主内存中</li>
</ol>
<div><p>总结</p>
<p>主内存与工作内存之间的数据交互过程</p>
</div>
<div><pre><code>lock -&gt; read -&gt; load -&gt; use -&gt; assign -&gt; store -&gt; write -&gt; unlock
</code></pre>
<div><span>1</span><br></div></div><h1 id="三、synchronized-保证三大特性"> 三、synchronized 保证三大特性</h1>
<p>Synchronized 能够保证在同一时刻最多只有一个线程执行该段代码，以达到保证并发安全的效果。</p>
<div><pre><code><span>synchronized</span> <span>(</span>锁对象<span>)</span> <span>{</span>
    <span>// 受保护资源;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="synchronized-与原子性"> synchronized 与原子性</h2>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-5"><label for="task-item-5"> 学习使用 synchronized 保证原子性的原理</label></li>
</ul>
<h3 id="案例演示"> 案例演示</h3>
<p>案例演示:5 个线程各执行 1000 次 i++;</p>
<div><pre><code><span>package</span> <span>com<span>.</span>itheima<span>.</span>demo02_concurrent_problem</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>ArrayList</span><span>;</span>
<span>/**
案例演示:5个线程各执行1000次 i++;
*/</span>
<span>public</span> <span>class</span> <span>Test01Atomicity</span> <span>{</span>
    <span>private</span> <span>static</span> <span>int</span> number <span>=</span> <span>0</span><span>;</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>
    <span>Runnable</span> increment <span>=</span> <span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>
        <span>@Override</span>
        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>1000</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
             <span>synchronized</span> <span>(</span><span>Test01Atomicity</span><span>.</span><span>class</span><span>)</span> <span>{</span>
                 number<span>++</span><span>;</span>
                <span>}</span>
             <span>}</span>  
        <span>}</span>
    <span>}</span><span>;</span>
    <span>ArrayList</span><span><span>&lt;</span><span>Thread</span><span>></span></span> ts <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>50</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>Thread</span> t <span>=</span> <span>new</span> <span>Thread</span><span>(</span>increment<span>)</span><span>;</span>
        t<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        ts<span>.</span><span>add</span><span>(</span>t<span>)</span><span>;</span>
    <span>}</span>
    <span>for</span> <span>(</span><span>Thread</span> t <span>:</span> ts<span>)</span> <span>{</span>
          t<span>.</span><span>join</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"number = "</span> <span>+</span> number<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>1000</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>synchronized</span> <span>(</span><span>Test01Atomicity</span><span>.</span><span>class</span><span>)</span> <span>{</span>
    number<span>++</span><span>;</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><h3 id="保证原子性的原理"> 保证原子性的原理</h3>
<p>对 number++;增加同步代码块后，保证同一时间只有一个线程操作 number++;。就不会出现安全问题。</p>
<div><p>总结</p>
<p>Synchronized 保证原子性的原理，synchronized 保证只有一个线程拿到锁，能够进入同步代码块。</p>
</div>
<h2 id="synchronized-与可见性"> synchronized 与可见性</h2>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-6"><label for="task-item-6"> 学习使用 synchronized 保证可见性的原理</label></li>
</ul>
<h3 id="保证可见性"> 保证可见性</h3>
<p>案例演示：</p>
<p>一个线程根据 boolean 类型的标记 flag， while 循环，另一个线程改变这个 flag 变量的值，另
一个线程并不会停止循环。</p>
<div><pre><code>
<span>package</span> <span>com<span>.</span>itheima<span>.</span>demo02_concurrent_problem</span><span>;</span>
<span>public</span> <span>class</span> <span>Test01Visibility</span> <span>{</span>
    <span>// 多个线程都会访问的数据，我们称为线程的共享数据</span>
    <span>private</span> <span>static</span> <span>boolean</span> run <span>=</span> <span>true</span><span>;</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>
        <span>Thread</span> t1 <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
            <span>while</span> <span>(</span>run<span>)</span> <span>{</span>
                <span>// 增加对象共享数据的打印，println是同步方法</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"run = "</span> <span>+</span> run<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span><span>)</span><span>;</span>
        t1<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>
        <span>Thread</span> t2 <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
            run <span>=</span> <span>false</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"时间到，线程2设置为false"</span><span>)</span><span>;</span>
        <span>}</span><span>)</span><span>;</span>
        t2<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id="保证可见性的原理"> 保证可见性的原理</h3>
<p><img src="./img/3-2-1.png" alt="" loading="lazy"></p>
<div><p>总结</p>
<p>Synchronized 保证可见性的原理，执行 synchronized 时，会对应 lock 原子操作会刷新工作内存中共享变
量的值</p>
</div>
<h2 id="synchronized-与有序性"> synchronized 与有序性</h2>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-7"><label for="task-item-7"> 学习使用 synchronized 保证有序性的原理</label></li>
</ul>
<h3 id="为什么要重排序"> 为什么要重排序</h3>
<p>为了提高程序的执行效率，编译器和 CPU 会对程序中代码进行重排序。</p>
<h3 id="as-if-serial-语义"> as-if-serial 语义</h3>
<p>As-if-serial 语义的意思是：不管编译器和 CPU 如何重排序，必须保证在单线程情况下程序的结果是正确 的。</p>
<p>以下数据有依赖关系，不能重排序。</p>
<p>写后读：</p>
<p><code>int a = 1; int b = a;</code></p>
<p>写后写：</p>
<p><code>int a = 1; int a = 2;</code></p>
<p>读后写：</p>
<p><code>int a = 1; int b = a; int a = 2;</code></p>
<p>编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如
果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。</p>
<p><code>int a = 1; int b = 2; int c = a + b;</code></p>
<p>上面 3 个操作的数据依赖关系如图所示：</p>
<p>1574136281215</p>
<p>如上图所示 a 和 c 之间存在数据依赖关系，同时 b 和 c 之间也存在数据依赖关系。因此在最终执行的指令序
列中，c 不能被重排序到 a 和 b 的前面。但 a 和 b 之间没有数据依赖关系，编译器和处理器可以重排序 a 和 b
之间的执行顺序。下图是该程序的两种执行顺序。</p>
<p>1574136462820</p>
<div><pre><code>可以这样：

int a <span>=</span> <span>1</span><span>;</span>
int b <span>=</span> <span>2</span><span>;</span>
int c <span>=</span> a + b<span>;</span>

也可以重排序这样：

int b <span>=</span> <span>2</span><span>;</span>
int a <span>=</span> <span>1</span><span>;</span>
int c <span>=</span> a + b<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="案例演示-2"> 案例演示</h3>
<div><pre><code><span>package</span> <span>com<span>.</span>itheima<span>.</span>concurrent_problem</span><span>;</span>

<span>import</span> <span>org<span>.</span>openjdk<span>.</span>jcstress<span>.</span>annotations<span>.</span></span><span>*</span><span>;</span>
<span>import</span> <span>org<span>.</span>openjdk<span>.</span>jcstress<span>.</span>infra<span>.</span>results<span>.</span></span><span>I_Result</span><span>;</span>

<span>@JCStressTest</span>
<span>@Outcome</span><span>(</span>id <span>=</span> <span>{</span><span>"1"</span>， <span>"4"</span><span>}</span>， expect <span>=</span> <span>Expect</span><span>.</span>ACCEPTABLE， desc <span>=</span> <span>"ok"</span><span>)</span>
<span>@Outcome</span><span>(</span>id <span>=</span> <span>"0"</span>， expect <span>=</span> <span>Expect</span><span>.</span>ACCEPTABLE_INTERESTING， desc <span>=</span> <span>"danger"</span><span>)</span>
<span>@State</span>
<span>public</span> <span>class</span> <span>Test03Ordering</span> <span>{</span>
    <span>int</span> num <span>=</span> <span>0</span><span>;</span>
    <span>boolean</span> ready <span>=</span> <span>false</span><span>;</span>
    <span>// 线程一执行的代码</span>
    <span>@Actor</span>
    <span>public</span> <span>void</span> <span>actor1</span><span>(</span><span>I_Result</span> r<span>)</span> <span>{</span>
        <span>if</span><span>(</span>ready<span>)</span> <span>{</span>
            r<span>.</span>r1 <span>=</span> num <span>+</span> num<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            r<span>.</span>r1 <span>=</span> <span>1</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>// 线程2执行的代码</span>
    <span>@Actor</span>
    <span>public</span> <span>void</span> <span>actor2</span><span>(</span><span>I_Result</span> r<span>)</span> <span>{</span>
        num <span>=</span> <span>2</span><span>;</span>
        ready <span>=</span> <span>true</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h3 id="保证有序性的原理"> 保证有序性的原理</h3>
<p>Synchronized 后，虽然进行了重排序，保证只有一个线程会进入同步代码块，也能保证有序性。</p>
<div><p>总结</p>
<p>Synchronized 保证有序性的原理，我们加 synchronized 后，依然会发生重排序，只不过，我们有同步
代码块，可以保证只有一个线程执行同步代码中的代码。保证有序性。</p>
</div>
<h1 id="四、synchronized-的特性"> 四、synchronized 的特性</h1>
<ul>
<li>
<p><input type="checkbox"  disabled="disabled" id="task-item-8"><label for="task-item-8"> 了解什么是可重入</label></p>
</li>
<li>
<p><input type="checkbox"  disabled="disabled" id="task-item-9"><label for="task-item-9"> 了解可重入的原理</label></p>
</li>
</ul>
<h3 id="可重入特性"> 可重入特性</h3>
<p>一个线程可以多次执行 synchronized,重复获取同一把锁。</p>
<div><pre><code>
<span>package</span> <span>com<span>.</span>itheima<span>.</span>demo03_synchronized_nature</span><span>;</span>
<span>/*
可重入特性
指的是同一个线程获得锁之后，可以直接再次获取该锁。
*/</span>
<span>public</span> <span>class</span> <span>Demo01</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Runnable</span> sellTicket <span>=</span> <span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>
        <span>@Override</span>
        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
            <span>synchronized</span> <span>(</span><span>Demo01</span><span>.</span><span>class</span><span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"我是run"</span><span>)</span><span>;</span>
                <span>test01</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>public</span> <span>void</span> <span>test01</span><span>(</span><span>)</span> <span>{</span>
            <span>synchronized</span> <span>(</span><span>Demo01</span><span>.</span><span>class</span><span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"我是test01"</span><span>)</span><span>;</span>
            <span>}</span>
          <span>}</span>
        <span>}</span><span>;</span>
        <span>new</span> <span>Thread</span><span>(</span>sellTicket<span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        <span>new</span> <span>Thread</span><span>(</span>sellTicket<span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h3 id="可重入的好处"> 可重入的好处</h3>
<ol>
<li>可以避免死锁</li>
<li>可以让我们更好的来封装代码</li>
</ol>
<h3 id="可重入原理"> 可重入原理</h3>
<p>Synchronized 的锁对象中有一个计数器(recursions 变量)会记录线程获得几次锁.</p>
<div><p>总结</p>
<p>Synchronized 是可重入锁，内部锁对象中会有一个计数器记录线程获取几次锁啦，在执行完同步代码块
时，计数器的数量会-1，知道计数器的数量为 0，就释放这个锁。</p>
</div>
<h2 id="不可中断特性"> 不可中断特性</h2>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-10"><label for="task-item-10"> 学习 synchronized 不可中断特性</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-11"><label for="task-item-11"> 学习 Lock 的可中断特性</label></li>
</ul>
<h3 id="概念-4"> 概念</h3>
<p>一个线程获得锁后，另一个线程想要获得锁，必须处于阻塞或等待状态，如果第一个线程不释放锁，第 二个线程会一直阻塞或等待，不可被中断。</p>
<h3 id="不可中断演示演示"> 不可中断演示演示</h3>
<p>Synchronized 是不可中断，处于阻塞状态的线程会一直等待锁。</p>
<CodeGroup>
<CodeGroupItem title="synchronized">
<div><pre><code>
<span>package</span> <span>com<span>.</span>itheima<span>.</span>demo03_synchronized_nature</span><span>;</span>
<span>/*
2.在Runnable定义同步代码块
3.先开启一个线程来执行同步代码块,保证不退出同步代码块
4.后开启一个线程来执行同步代码块(阻塞状态)
5.停止第二个线程
*/</span>
<span>public</span> <span>class</span> <span>Demo02_Uninterruptible</span> <span>{</span>
    <span>private</span> <span>static</span> <span>Object</span> obj <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>
<span>// 1.定义一个Runnable</span>
        <span>Runnable</span> run <span>=</span> <span>(</span><span>)</span> <span>-></span> <span>{</span>
<span>// 2.在Runnable定义同步代码块</span>
            <span>synchronized</span> <span>(</span>obj<span>)</span> <span>{</span>
                <span>String</span> name <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>;</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>name <span>+</span> <span>"进入同步代码块"</span><span>)</span><span>;</span>
<span>// 保证不退出同步代码块</span>
                <span>try</span> <span>{</span>
                    <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>888888</span><span>)</span><span>;</span>
                <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span><span>;</span>
<span>// 3.先开启一个线程来执行同步代码块</span>
        <span>Thread</span> t1 <span>=</span> <span>new</span> <span>Thread</span><span>(</span>run<span>)</span><span>;</span>
        t1<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>
<span>// 4.后开启一个线程来执行同步代码块(阻塞状态)</span>
        <span>Thread</span> t2 <span>=</span> <span>new</span> <span>Thread</span><span>(</span>run<span>)</span><span>;</span>
        t2<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
<span>// 5.停止第二个线程</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"停止线程前"</span><span>)</span><span>;</span>
        t2<span>.</span><span>interrupt</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"停止线程后"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>t1<span>.</span><span>getState</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>t2<span>.</span><span>getState</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="ReentrantLock">
<div><pre><code><span>package</span> <span>com<span>.</span>itheima<span>.</span>demo03_synchronized_nature</span><span>;</span>

<span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span></span><span>TimeUnit</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span>locks<span>.</span></span><span>Lock</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span>locks<span>.</span></span><span>ReentrantLock</span><span>;</span>

<span>/*
public class Demo03_Interruptible {
private static Lock lock = new ReentrantLock();
public static void main(String[] args) throws InterruptedException {
// test01();
test02();
}
// 演示Lock可中断
public static void test02() throws InterruptedException {
Runnable run = () -> {
String name = Thread.currentThread().getName();
boolean b = false;
try {
b = lock.tryLock(3, TimeUnit.SECONDS);
if (b) {
System.out.println(name + "获得锁,进入锁执行");
Thread.sleep(88888);
} else {
System.out.println(name + "在指定时间没有得到锁做其他操作");
}
} catch (InterruptedException e) {
e.printStackTrace();
} finally {
if (b) {
lock.unlock();
System.out.println(name + "释放锁");
}
}
};
Thread t1 = new Thread(run);
t1.start();
Thread.sleep(1000);
Thread t2 = new Thread(run);
t2.start();
// System.out.println("停止t2线程前");
// t2.interrupt();
// System.out.println("停止t2线程后");
//
// Thread.sleep(1000);
// System.out.println(t1.getState());
// System.out.println(t2.getState());
}
// 演示Lock不可中断
public static void test01() throws InterruptedException {
Runnable run = () -> {
String name = Thread.currentThread().getName();
try {
lock.lock();
System.out.println(name + "获得锁,进入锁执行");
Thread.sleep(88888);
} catch (InterruptedException e) {
    e.printStackTrace();
    } finally {
    lock.unlock();
    System.out.println(name + "释放锁");
    }
    };
    Thread t1 = new Thread(run);
    t1.start();
    Thread.sleep(1000);
    Thread t2 = new Thread(run);
    t2.start();
    System.out.println("停止t2线程前");
    t2.interrupt();
    System.out.println("停止t2线程后");
    Thread.sleep(1000);
    System.out.println(t1.getState());
    System.out.println(t2.getState());
    }
    }
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br></div></div></CodeGroupItem>
</CodeGroup>
<div><p>总结</p>
<p>不可中断是指，当一个线程获得锁后，另一个线程一直处于阻塞或等待状态，前一个线程不释放锁，后一个线程会一直阻塞或等待，不可被中断。</p>
<ul>
<li>Synchronized 属于不可被中断</li>
<li>Lock 的 lock 方法是不可中断的</li>
<li>Lock 的 tryLock 方法是可中断的</li>
</ul>
</div>
<h1 id="五、synchronized-原理"> 五、synchronized 原理</h1>
<h2 id="javap-反汇编"> javap 反汇编</h2>
<p>通过 javap 反汇编学习 synchronized 的原理</p>
<p>我们编写一个简单的 synchronized 代码，如下：</p>
<div><pre><code><span>package</span> <span>com<span>.</span>itheima<span>.</span>demo04_synchronized_monitor</span><span>;</span>
<span>public</span> <span>class</span> <span>Demo01</span> <span>{</span>
    <span>private</span> <span>static</span> <span>Object</span> obj <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>synchronized</span> <span>(</span>obj<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"1"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>public</span> <span>synchronized</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"a"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>我们要看 synchronized 的原理，但是 synchronized 是一个关键字，看不到源码。我们可以将 class 文件
进行反汇编。</p>
<p>JDK 自带的一个工具： javap ，对字节码进行反汇编，查看字节码指令。</p>
<p>在 DOS 命令行输入：</p>
<p>反汇编后的效果如下：</p>
<p>Javap -p -v -c</p>
<div><pre><code>`C:\Users\13666\IdeaProjects\HeiMa\Synchronized\target\classes\com\itheima\demo04 _synchronized_monitor\Increment.class`
</code></pre>
<div><span>1</span><br></div></div><div><pre><code>
public static void main(java.lang.String[]);
        descriptor: ([Ljava/lang/String;)V
        flags: ACC_PUBLIC, ACC_STATIC
        Code:
        stack=2, locals=4, args_size=1
        0: iconst_0
        1: istore_1
        2: getstatic #2 // Field obj:Ljava/lang/Object;
        5: dup
        6: astore_2
        7: monitorenter
        8: iinc 1, 1
        11: aload_2
        12: monitorexit
        13: goto 21
        16: astore_3
        17: aload_2
        18: monitorexit
        19: aload_3
        20: athrow
        21: return
        Exception table:
        from to target type
        8 13 16 any
        16 19 16 any
        LineNumberTable:
        line 8: 0
        line 9: 2
        line 10: 8
        line 11: 11
        line 12: 21
        LocalVariableTable:
        Start Length Slot Name Signature
        0 22 0 args [Ljava/lang/String;
        2 20 1 number I
        StackMapTable: number_of_entries = 2
        frame_type = 255 /* full_frame */
        offset_delta = 16
        locals = [ class &quot;[Ljava/lang/String;&quot;, int, class java/lang/Object ]
        stack = [ class java/lang/Throwable ]
        frame_type = 250 /* chop */
        offset_delta = 4
public synchronized void test();
        descriptor: ()V
        flags: ACC_PUBLIC, ACC_SYNCHRONIZED
        Code:
        stack=2, locals=1, args_size=1
        0: getstatic #3 // Field
        java/lang/System.out:Ljava/io/PrintStream;
        3: ldc #4 // String a
        5: invokevirtual #5 // Method
        java/io/PrintStream.println:(Ljava/lang/String;)V
        8: return
        LineNumberTable:
        line 15: 0
        line 16: 8
        LocalVariableTable:
        Start Length Slot Name Signature
        0 9 0 this
        Lcom/itheima/demo04_synchronized_monitor/Demo01;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br></div></div><p>}</p>
<p><img src="./img/5-1-1.png" alt="" loading="lazy"></p>
<h3 id="monitorenter"> monitorenter</h3>
<p>首先我们来看一下 JVM 规范中对于 monitorenter 的描述：</p>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorenter" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorenter</a></p>
<blockquote>
<p>Each object is associated with a monitor. A monitor is locked if and only if it has an owner.
The thread that executes monitorenter attempts to gain ownership of the monitor
associated with objectref， as follows: • If the entry count of the monitor associated with
objectref is zero， the thread enters the monitor and sets its entry count to one. The thread
is then the owner of the monitor. • If the thread already owns the monitor associated with
objectref， it reenters the monitor， incrementing its entry count. • If another thread
already owns the monitor associated with objectref， the thread blocks until the monitor’s
entry count is zero， then tries again to gain ownership.</p>
</blockquote>
<p>翻译过来： 每一个对象都会和一个监视器 monitor 关联。</p>
<p>监视器被占用时会被锁住，其他线程无法来获 取该 monitor。</p>
<p>当 JVM 执行某个线程的某个方法内部的 monitorenter 时，它会尝试去获取当前对象对应 的 monitor 的所有权。其过程如下：</p>
<ol>
<li>若 monior 的进入数为 0，线程可以进入 monitor，并将 monitor 的进入数置为 1。当前线程成为 monitor 的 owner(所有者)</li>
<li>若线程已拥有 monitor 的所有权，允许它重入 monitor，则进入 monitor 的进入数加 1</li>
<li>若其他线程已经占有 monitor 的所有权，那么当前尝试获取 monitor 的所有权的线程会被阻塞，直 到 monitor 的进入数变为 0，才能重新尝试获取 monitor 的所有权。</li>
</ol>
<div><p>Monitorenter 小结</p>
<p>Synchronized 的锁对象会关联一个 monitor,这个 monitor 不是我们主动创建的,是 JVM 的线程执行到这个
同步代码块,发现锁对象没有 monitor 就会创建 monitor,monitor 内部有两个重要的成员变量 owner:拥有
这把锁的线程,recursions 会记录线程拥有锁的次数,当一个线程拥有 monitor 后其他线程只能等待</p>
</div>
<h3 id="monitorexit"> monitorexit</h3>
<p>首先我们来看一下 JVM 规范中对于 monitorexit 的描述：</p>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit</a></p>
<blockquote>
<p>The thread that executes monitorexit must be the owner of the monitor associated with the
instance referenced by objectref. The thread decrements the entry count of the monitor
associated with objectref. If as a result the value of the entry count is zero， the thread
exits the monitor and is no longer its owner. Other threads that are blocking to enter the
monitor are allowed to attempt to do so.</p>
</blockquote>
<p>翻译过来：</p>
<ol>
<li>能执行 monitorexit 指令的线程一定是拥有当前对象的 monitor 的所有权的线程。</li>
<li>执行 monitorexit 时会将 monitor 的进入数减 1。当 monitor 的进入数减为 0 时，当前线程退出
monitor，不再拥有 monitor 的所有权，此时其他被这个 monitor 阻塞的线程可以尝试去获取这个
monitor 的所有权
monitorexit 释放锁。</li>
</ol>
<p>Monitorexit 插入在方法结束处和异常处，JVM 保证每个 monitorenter 必须有对应的 monitorexit。</p>
<p>问题 synchroznied 出现异常会释放锁吗?</p>
<p>会释放锁</p>
<h3 id="同步方法"> 同步方法</h3>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10</a></p>
<p>可以看到同步方法在反汇编后，会增加 ACC_SYNCHRONIZED 修饰。会隐式调用 monitorenter 和
monitorexit。在执行同步方法前会调用 monitorenter，在执行完同步方法后会调用 monitorexit。</p>
<div><p>总结</p>
<p>通过 javap 反汇编我们看到 synchronized 使用编程了 monitorentor 和 monitorexit 两个指令。</p>
<p>每个锁对象都会关联一个 monitor(监视器,它才是真正的锁对象),它内部有两个重要的成员变量：</p>
<ul>
<li>owner 会保存获得锁的线程,</li>
<li>recursions 会保存线程获得锁的次数,</li>
</ul>
<p>当执行到 monitorexit 时,recursions 会-1,当计数器减到 0 时这个线程就会释放锁。</p>
</div>
<h3 id="问题-synchronized-与-lock-的区别"> 问题：synchronized 与 Lock 的区别</h3>
<ol>
<li>synchronized 是关键字，而 Lock 是一个接口。</li>
<li>synchronized 会自动释放锁，而 Lock 必须手动释放锁。</li>
<li>synchronized 是不可中断的，Lock 可以中断也可以不中断。</li>
<li>通过 Lock 可以知道线程有没有拿到锁，而 synchronized 不能。</li>
<li>synchronized 能锁住方法和代码块，而 Lock 只能锁住代码块。</li>
<li>Lock 可以使用读锁提高多线程读效率。</li>
<li>synchronized 是非公平锁，ReentrantLock 可以控制是否是公平锁。</li>
</ol>
<h2 id="深入-jvm-源码"> 深入 JVM 源码</h2>
<p>通过 JVM 源码分析 synchronized 的原理</p>
<h3 id="jvm-源码下载"> JVM 源码下载</h3>
<p><a href="http://openjdk.java.net/" target="_blank" rel="noopener noreferrer">http://openjdk.java.net/</a> --&gt; Mercurial --&gt; jdk8 --&gt; hotspot --&gt; zip</p>
<h3 id="ide-clion-下载"> IDE(Clion )下载</h3>
<p><a href="https://www.jetbrains.com/" target="_blank" rel="noopener noreferrer">https://www.jetbrains.com/</a></p>
<h3 id="monitor-监视器锁"> monitor 监视器锁</h3>
<p>可以看出无论是 synchronized 代码块还是 synchronized 方法，其线程安全的语义实现最终依赖一个叫 monitor 的东西，那么这个神秘的东西是什么呢？下面让我们来详细介绍一下。</p>
<p>在 HotSpot 虚拟机中，monitor 是由 ObjectMonitor 实现的。其源码是用 c++来实现的，位于 HotSpot 虚 拟机源码 ObjectMonitor.hpp 文件中(src/share/vm/runtime/objectMonitor.hpp)。ObjectMonitor 主 要数据结构如下：</p>
<div><pre><code><span>ObjectMonitor</span><span>(</span><span>)</span> <span>{</span>
_header <span>=</span> <span>NULL</span><span>;</span>
_count <span>=</span> <span>0</span><span>;</span>
_waiters <span>=</span> <span>0</span>，
_recursions <span>=</span> <span>0</span><span>;</span> <span>// 线程的重入次数</span>
_object <span>=</span> <span>NULL</span><span>;</span> <span>// 存储该monitor的对象</span>
_owner <span>=</span> <span>NULL</span><span>;</span> <span>// 标识拥有该monitor的线程</span>
_WaitSet <span>=</span> <span>NULL</span><span>;</span> <span>// 处于wait状态的线程，会被加入到_WaitSet</span>
_WaitSetLock <span>=</span> <span>0</span> <span>;</span>
_Responsible <span>=</span> <span>NULL</span><span>;</span>
_succ <span>=</span> <span>NULL</span><span>;</span>
_cxq <span>=</span> <span>NULL</span><span>;</span> <span>// 多线程竞争锁时的单向列表</span>
FreeNext <span>=</span> <span>NULL</span><span>;</span>
_EntryList <span>=</span> <span>NULL</span><span>;</span> <span>// 处于等待锁block状态的线程，会被加入到该列表</span>
_SpinFreq <span>=</span> <span>0</span><span>;</span>
_SpinClock <span>=</span> <span>0</span><span>;</span>
OwnerIsThread <span>=</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><ol>
<li>_owner：初始时为 NULL。当有线程占有该 monitor 时，owner 标记为该线程的唯一标识。当线程
释放 monitor 时，owner 又恢复为 NULL。owner 是一个临界资源，JVM 是通过 CAS 操作来保证其线
程安全的。</li>
<li>_cxq：竞争队列，所有请求锁的线程首先会被放在这个队列中(单向链接)。_cxq 是一个临界资
源，JVM 通过 CAS 原子指令来修改_cxq 队列。修改前_cxq 的旧值填入了 Node.js 的 next 字段，_cxq 指
向新值(新线程)。因此_cxq 是一个后进先出的 stack(栈)。</li>
<li>_EntryList：_cxq 队列中有资格成为候选资源的线程会被移动到该队列中。</li>
<li>_WaitSet：因为调用 wait 方法而被阻塞的线程会被放在该队列中。</li>
</ol>
<p>每一个 Java 对象都可以与一个监视器 monitor 关联，我们可以把它理解成为一把锁，当一个线程想要执
行一段被 synchronized 圈起来的同步方法或者代码块时，该线程得先获取到 synchronized 修饰的对象
对应的 monitor。</p>
<p>我们的 Java 代码里不会显示地去创造这么一个 monitor 对象，我们也无需创建，事实上可以这么理解：
monitor 并不是随着对象创建而创建的。我们是通过 synchronized 修饰符告诉 JVM 需要为我们的某个对
象创建关联的 monitor 对象。每个线程都存在两个 ObjectMonitor 对象列表，分别为 free 和 used 列表。
同时 JVM 中也维护着 global locklist。当线程需要 ObjectMonitor 对象时，首先从线程自身的 free 表中申
请，若存在则使用，若不存在则从 global list 中申请。</p>
<p>ObjectMonitor 的数据结构中包含：_owner、_WaitSet 和_EntryList，它们之间的关系转换可以用下图
表示：</p>
<p><img src="./img/5-2-1.png" alt="" loading="lazy"></p>
<h3 id="monitor-竞争"> monitor 竞争</h3>
<ol>
<li>执行 monitorenter 时，会调用 InterpreterRuntime.cpp
(位于：src/share/vm/interpreter/interpreterRuntime.cpp) 的 InterpreterRuntime::monitorenter 函
数。具体代码可参见 HotSpot 源码。</li>
</ol>
<div><pre><code><span>IRT_ENTRY_NO_ASYNC</span><span>(</span><span>void</span>， InterpreterRuntime<span>::</span><span>monitorenter</span><span>(</span>JavaThread<span>*</span> thread，
BasicObjectLock<span>*</span> elem<span>)</span><span>)</span> #ifdef ASSERT thread<span>-></span><span>last_frame</span><span>(</span><span>)</span><span>.</span><span>interpreter_frame_verify_monitor</span><span>(</span>elem<span>)</span><span>;</span> #endif
<span>if</span> <span>(</span>PrintBiasedLockingStatistics<span>)</span> <span>{</span>
Atomic<span>::</span><span>inc</span><span>(</span>BiasedLocking<span>::</span><span>slow_path_entry_count_addr</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
Handle <span>h_obj</span><span>(</span>thread， elem<span>-></span><span>obj</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>assert</span><span>(</span>Universe<span>::</span><span>heap</span><span>(</span><span>)</span><span>-></span><span>is_in_reserved_or_null</span><span>(</span><span>h_obj</span><span>(</span><span>)</span><span>)</span>，
<span>"must be NULL or an object"</span><span>)</span><span>;</span>
<span>if</span> <span>(</span>UseBiasedLocking<span>)</span> <span>{</span>
<span>// Retry fast entry if bias is revoked to avoid unnecessary inflation</span>
ObjectSynchronizer<span>::</span><span>fast_enter</span><span>(</span>h_obj， elem<span>-></span><span>lock</span><span>(</span><span>)</span>， true， CHECK<span>)</span><span>;</span>
<span>}</span> <span>else</span> <span>{</span>
ObjectSynchronizer<span>::</span><span>slow_enter</span><span>(</span>h_obj， elem<span>-></span><span>lock</span><span>(</span><span>)</span>， CHECK<span>)</span><span>;</span>
<span>}</span>
<span>assert</span><span>(</span>Universe<span>::</span><span>heap</span><span>(</span><span>)</span><span>-></span><span>is_in_reserved_or_null</span><span>(</span>elem<span>-></span><span>obj</span><span>(</span><span>)</span><span>)</span>，
<span>"must be NULL or an object"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>2.对于重量级锁，monitorenter 函数中会调用 ObjectSynchronizer::slow_enter</p>
<p>3.最终调用 ObjectMonitor::enter(位于：src/share/vm/runtime/objectMonitor.cpp)，源码如下：</p>
<div><pre><code><span>void</span> ATTR ObjectMonitor<span>::</span><span>enter</span><span>(</span>TRAPS<span>)</span> <span>{</span>
<span>// The following code is ordered to check the most common cases first</span>
<span>// and to reduce RTS->RTO cache line upgrades on SPARC and IA32 processors.</span>
Thread <span>*</span> <span>const</span> Self <span>=</span> THREAD <span>;</span>
<span>void</span> <span>*</span> cur <span>;</span>
<span>// 通过CAS操作尝试把monitor的_owner字段设置为当前线程</span>
cur <span>=</span> Atomic<span>::</span><span>cmpxchg_ptr</span> <span>(</span>Self， <span>&amp;</span>_owner， <span>NULL</span><span>)</span> <span>;</span>
<span>if</span> <span>(</span>cur <span>==</span> <span>NULL</span><span>)</span> <span>{</span>
<span>// Either ASSERT _recursions == 0 or explicitly set _recursions = 0.</span>
<span>assert</span> <span>(</span>_recursions <span>==</span> <span>0</span> ， <span>"invariant"</span><span>)</span> <span>;</span>
<span>assert</span> <span>(</span>_owner <span>==</span> Self， <span>"invariant"</span><span>)</span> <span>;</span>
<span>// CONSIDER: set or assert OwnerIsThread == 1</span>
<span>return</span> <span>;</span>
<span>}</span>
<span>// 线程重入，recursions++</span>
<span>if</span> <span>(</span>cur <span>==</span> Self<span>)</span> <span>{</span>
<span>// TODO-FIXME: check for integer overflow! BUGID 6557169.</span>
_recursions <span>++</span> <span>;</span>
<span>return</span> <span>;</span>
<span>}</span>
<span>// 如果当前线程是第一次进入该monitor，设置_recursions为1，_owner为当前线程</span>
<span>if</span> <span>(</span>Self<span>-></span><span>is_lock_owned</span> <span>(</span><span>(</span>address<span>)</span>cur<span>)</span><span>)</span> <span>{</span>
<span>assert</span> <span>(</span>_recursions <span>==</span> <span>0</span>， <span>"internal state error"</span><span>)</span><span>;</span>
_recursions <span>=</span> <span>1</span> <span>;</span>
<span>// Commute owner from a thread-specific on-stack BasicLockObject address to</span>
<span>// a full-fledged "Thread *".</span>
_owner <span>=</span> Self <span>;</span>
OwnerIsThread <span>=</span> <span>1</span> <span>;</span>
<span>return</span> <span>;</span>
<span>}</span>
<span>// 省略一些代码</span>
<span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>
jt<span>-></span><span>set_suspend_equivalent</span><span>(</span><span>)</span><span>;</span>
<span>// cleared by handle_special_suspend_equivalent_condition()</span>
<span>// or java_suspend_self()</span>
<span>// 如果获取锁失败，则等待锁的释放；</span>
<span>EnterI</span> <span>(</span>THREAD<span>)</span> <span>;</span>
<span>if</span> <span>(</span><span>!</span><span>ExitSuspendEquivalent</span><span>(</span>jt<span>)</span><span>)</span> <span>break</span> <span>;</span>
<span>//</span>
<span>// We have acquired the contended monitor， but while we were</span>
<span>// waiting another thread suspended us. We don't want to enter</span>
<span>// the monitor while suspended because that would surprise the</span>
<span>// thread that suspended us.</span>
<span>//</span>
_recursions <span>=</span> <span>0</span> <span>;</span>
_succ <span>=</span> <span>NULL</span> <span>;</span>
<span>exit</span> <span>(</span>false， Self<span>)</span> <span>;</span>
jt<span>-></span><span>java_suspend_self</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
Self<span>-></span><span>set_current_pending_monitor</span><span>(</span><span>NULL</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div><p>此处省略锁的自旋优化等操作，统一放在后面 synchronzied 优化中说。
以上代码的具体流程概括如下：</p>
<ol>
<li>通过 CAS 尝试把 monitor 的 owner 字段设置为当前线程。</li>
<li>如果设置之前的 owner 指向当前线程，说明当前线程再次进入 monitor，即重入锁，执行
recursions ++ ，记录重入的次数。</li>
<li>如果当前线程是第一次进入该 monitor，设置 recursions 为 1，_owner 为当前线程，该线程成功获
得锁并返回。</li>
<li>如果获取锁失败，则等待锁的释放。</li>
</ol>
<h3 id="monitor-等待"> monitor 等待</h3>
<p>竞争失败等待调用的是 ObjectMonitor 对象的 EnterI 方法（位于：
src/share/vm/runtime/objectMonitor.cpp），源码如下所示：</p>
<div><pre><code><span>void</span> ATTR ObjectMonitor<span>::</span><span>EnterI</span> <span>(</span>TRAPS<span>)</span> <span>{</span>
Thread <span>*</span> Self <span>=</span> THREAD <span>;</span>
<span>// Try the lock - TATAS</span>
<span>if</span> <span>(</span><span>TryLock</span> <span>(</span>Self<span>)</span> <span>></span> <span>0</span><span>)</span> <span>{</span>
<span>assert</span> <span>(</span>_succ <span>!=</span> Self <span>,</span> <span>"invariant"</span><span>)</span> <span>;</span>
<span>assert</span> <span>(</span>_owner <span>==</span> Self <span>,</span> <span>"invariant"</span><span>)</span> <span>;</span>
<span>assert</span> <span>(</span>_Responsible <span>!=</span> Self <span>,</span> <span>"invariant"</span><span>)</span> <span>;</span>
<span>return</span> <span>;</span>
<span>}</span>
<span>if</span> <span>(</span><span>TrySpin</span> <span>(</span>Self<span>)</span> <span>></span> <span>0</span><span>)</span> <span>{</span>
<span>assert</span> <span>(</span>_owner <span>==</span> Self <span>,</span> <span>"invariant"</span><span>)</span> <span>;</span>
<span>assert</span> <span>(</span>_succ <span>!=</span> Self <span>,</span> <span>"invariant"</span><span>)</span> <span>;</span>
<span>assert</span> <span>(</span>_Responsible <span>!=</span> Self <span>,</span> <span>"invariant"</span><span>)</span> <span>;</span>
<span>return</span> <span>;</span>
<span>}</span>
<span>// 省略部分代码</span>
<span>// 当前线程被封装成ObjectWaiter对象node，状态设置成ObjectWaiter::TS_CXQ；</span>
ObjectWaiter <span>node</span><span>(</span>Self<span>)</span> <span>;</span>
Self<span>-></span>_ParkEvent<span>-></span><span>reset</span><span>(</span><span>)</span> <span>;</span>
node<span>.</span>_prev <span>=</span> <span>(</span>ObjectWaiter <span>*</span><span>)</span> <span>0xBAD</span> <span>;</span>
node<span>.</span>TState <span>=</span> ObjectWaiter<span>::</span>TS_CXQ <span>;</span>
<span>// 通过CAS把node节点push到_cxq列表中</span>
ObjectWaiter <span>*</span> nxt <span>;</span>
<span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>
node<span>.</span>_next <span>=</span> nxt <span>=</span> _cxq <span>;</span>
<span>if</span> <span>(</span>Atomic<span>::</span><span>cmpxchg_ptr</span> <span>(</span><span>&amp;</span>node， <span>&amp;</span>_cxq， nxt<span>)</span> <span>==</span> nxt<span>)</span> <span>break</span> <span>;</span>
<span>// Interference - the CAS failed because _cxq changed. Just retry.</span>
<span>// As an optional optimization we retry the lock.</span>
<span>if</span> <span>(</span><span>TryLock</span> <span>(</span>Self<span>)</span> <span>></span> <span>0</span><span>)</span> <span>{</span>
<span>assert</span> <span>(</span>_succ <span>!=</span> Self ， <span>"invariant"</span><span>)</span> <span>;</span>
<span>assert</span> <span>(</span>_owner <span>==</span> Self ， <span>"invariant"</span><span>)</span> <span>;</span>
<span>assert</span> <span>(</span>_Responsible <span>!=</span> Self ， <span>"invariant"</span><span>)</span> <span>;</span>
<span>return</span> <span>;</span>
<span>}</span>
<span>}</span>
<span>// 省略部分代码</span>
<span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>
<span>// 线程在被挂起前做一下挣扎，看能不能获取到锁</span>
<span>if</span> <span>(</span><span>TryLock</span> <span>(</span>Self<span>)</span> <span>></span> <span>0</span><span>)</span> <span>break</span> <span>;</span>
<span>assert</span> <span>(</span>_owner <span>!=</span> Self， <span>"invariant"</span><span>)</span> <span>;</span>
<span>if</span> <span>(</span><span>(</span>SyncFlags <span>&amp;</span> <span>2</span><span>)</span> <span>&amp;&amp;</span> _Responsible <span>==</span> <span>NULL</span><span>)</span> <span>{</span>
Atomic<span>::</span><span>cmpxchg_ptr</span> <span>(</span>Self， <span>&amp;</span>_Responsible， <span>NULL</span><span>)</span> <span>;</span>
<span>}</span>

<span>// 通过park将当前线程挂起，等待被唤醒</span>
Self<span>-></span>_ParkEvent<span>-></span><span>park</span><span>(</span><span>)</span> <span>;</span>
<span>}</span>
<span>if</span> <span>(</span><span>TryLock</span><span>(</span>Self<span>)</span> <span>></span> <span>0</span><span>)</span> <span>break</span> <span>;</span>
<span>// 省略部分代码</span>
<span>}</span>
<span>// 省略部分代码</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br></div></div><p>当该线程被唤醒时，会从挂起的点继续执行，通过 ObjectMonitor::TryLock 尝试获取锁，TryLock 方
法实现如下：</p>
<div><pre><code>    <span>int</span> ObjectMonitor<span>::</span>

    <span>TryLock</span><span>(</span>Thread <span>*</span>Self<span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>;</span> <span>;</span> <span>)</span> <span>{</span>
            <span>void</span> <span>*</span>own <span>=</span> _owner<span>;</span>
            <span>if</span> <span>(</span>own <span>!=</span> <span>NULL</span><span>)</span> <span>return</span> <span>0</span><span>;</span>
            <span>if</span> <span>(</span>Atomic<span>::</span><span>cmpxchg_ptr</span> <span>(</span>Self， <span>&amp;</span>_owner，<span>NULL</span><span>)</span> <span>==</span><span>NULL</span><span>)</span><span>{</span>
<span>// Either guarantee _recursions == 0 or set _recursions = 0.</span>
                <span>assert</span> <span>(</span>_recursions <span>==</span> <span>0</span>，<span>"invariant"</span><span>)</span><span>;</span>
                <span>assert</span> <span>(</span>_owner <span>==</span> Self，<span>"invariant"</span><span>)</span><span>;</span>
<span>// CONSIDER: set or assert that OwnerIsThread == 1</span>
                <span>return</span> <span>1</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>以上代码的具体流程概括如下：</p>
<ol>
<li>当前线程被封装成 ObjectWaiter 对象 node，状态设置成 ObjectWaiter::TS_CXQ。</li>
<li>在 for 循环中，通过 CAS 把 Node.js 节点 push 到_cxq 列表中，同一时刻可能有多个线程把自己的 node
节点 push 到_cxq 列表中。</li>
<li>Node.js 节点 push 到_cxq 列表之后，通过自旋尝试获取锁，如果还是没有获取到锁，则通过 park 将当
前线程挂起，等待被唤醒。</li>
<li>当该线程被唤醒时，会从挂起的点继续执行，通过 ObjectMonitor::TryLock 尝试获取锁。</li>
</ol>
<h3 id="monitor-释放"> monitor 释放</h3>
<p>当某个持有锁的线程执行完同步代码块时，会进行锁的释放，给其它线程机会执行同步代码，在
HotSpot 中，通过退出 monitor 的方式实现锁的释放，并通知被阻塞的线程，具体实现位于
ObjectMonitor 的 exit 方法中。(位于：src/share/vm/runtime/objectMonitor.cpp)，源码如下所
示：</p>
<div><pre><code><span>void</span> ATTR ObjectMonitor<span>::</span><span>exit</span><span>(</span>bool not_suspended， TRAPS<span>)</span> <span>{</span>
<span>void</span> ATTR ObjectMonitor<span>::</span><span>exit</span><span>(</span>bool not_suspended， TRAPS<span>)</span> <span>{</span>
        Thread <span>*</span> Self <span>=</span> THREAD <span>;</span>
<span>// 省略部分代码</span>
        <span>if</span> <span>(</span>_recursions <span>!=</span> <span>0</span><span>)</span> <span>{</span>
        _recursions<span>--</span><span>;</span> <span>// this is simple recursive enter</span>
        <span>TEVENT</span> <span>(</span>Inflated exit <span>-</span> recursive<span>)</span> <span>;</span>
        <span>return</span> <span>;</span>
        <span>}</span>
<span>// 省略部分代码</span>
        ObjectWaiter <span>*</span> w <span>=</span> <span>NULL</span> <span>;</span>
        <span>int</span> QMode <span>=</span> Knob_QMode <span>;</span>
<span>// qmode = 2：直接绕过EntryList队列，从cxq队列中获取线程用于竞争锁</span>
        <span>if</span> <span>(</span>QMode <span>==</span> <span>2</span> <span>&amp;&amp;</span> _cxq <span>!=</span> <span>NULL</span><span>)</span> <span>{</span>
        w <span>=</span> _cxq <span>;</span>
        <span>assert</span> <span>(</span>w <span>!=</span> <span>NULL</span>， <span>"invariant"</span><span>)</span> <span>;</span>
        <span>assert</span> <span>(</span>w<span>-></span>TState <span>==</span> ObjectWaiter<span>::</span>TS_CXQ， <span>"Invariant"</span><span>)</span> <span>;</span>
        <span>ExitEpilog</span> <span>(</span>Self， w<span>)</span> <span>;</span>
        <span>return</span> <span>;</span>
        <span>}</span>
<span>// qmode =3：cxq队列插入EntryList尾部；</span>
        <span>if</span> <span>(</span>QMode <span>==</span> <span>3</span> <span>&amp;&amp;</span> _cxq <span>!=</span> <span>NULL</span><span>)</span> <span>{</span>
        w <span>=</span> _cxq <span>;</span>
        <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>
        <span>assert</span> <span>(</span>w <span>!=</span> <span>NULL</span>， <span>"Invariant"</span><span>)</span> <span>;</span>
        ObjectWaiter <span>*</span> u <span>=</span> <span>(</span>ObjectWaiter <span>*</span><span>)</span> Atomic<span>::</span><span>cmpxchg_ptr</span> <span>(</span><span>NULL</span>，
        <span>&amp;</span>_cxq， w<span>)</span> <span>;</span>
        <span>if</span> <span>(</span>u <span>==</span> w<span>)</span> <span>break</span> <span>;</span>
        w <span>=</span> u <span>;</span>
        <span>}</span>
        <span>assert</span> <span>(</span>w <span>!=</span> <span>NULL</span> ， <span>"invariant"</span><span>)</span> <span>;</span>
        ObjectWaiter <span>*</span> q <span>=</span> <span>NULL</span> <span>;</span>
        ObjectWaiter <span>*</span> p <span>;</span>
        <span>for</span> <span>(</span>p <span>=</span> w <span>;</span> p <span>!=</span> <span>NULL</span> <span>;</span> p <span>=</span> p<span>-></span>_next<span>)</span> <span>{</span>
        <span>guarantee</span> <span>(</span>p<span>-></span>TState <span>==</span> ObjectWaiter<span>::</span>TS_CXQ， <span>"Invariant"</span><span>)</span> <span>;</span>
        p<span>-></span>TState <span>=</span> ObjectWaiter<span>::</span>TS_ENTER <span>;</span>
        p<span>-></span>_prev <span>=</span> q <span>;</span>
        q <span>=</span> p <span>;</span>
        <span>}</span>
        ObjectWaiter <span>*</span> Tail <span>;</span>
        <span>for</span> <span>(</span>Tail <span>=</span> _EntryList <span>;</span> Tail <span>!=</span> <span>NULL</span> <span>&amp;&amp;</span> Tail<span>-></span>_next <span>!=</span> <span>NULL</span> <span>;</span> Tail <span>=</span>
        Tail<span>-></span>_next<span>)</span> <span>;</span>
        <span>if</span> <span>(</span>Tail <span>==</span> <span>NULL</span><span>)</span> <span>{</span>
        _EntryList <span>=</span> w <span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
        Tail<span>-></span>_next <span>=</span> w <span>;</span>
        w<span>-></span>_prev <span>=</span> Tail <span>;</span>
        <span>}</span>
        <span>}</span>
<span>// qmode =4：cxq队列插入到_EntryList头部</span>
        <span>if</span> <span>(</span>QMode <span>==</span> <span>4</span> <span>&amp;&amp;</span> _cxq <span>!=</span> <span>NULL</span><span>)</span> <span>{</span>
        w <span>=</span> _cxq <span>;</span>
        <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>
        <span>assert</span> <span>(</span>w <span>!=</span> <span>NULL</span>， <span>"Invariant"</span><span>)</span> <span>;</span>
        ObjectWaiter <span>*</span> u <span>=</span> <span>(</span>ObjectWaiter <span>*</span><span>)</span> Atomic<span>::</span><span>cmpxchg_ptr</span> <span>(</span><span>NULL</span>，
        <span>&amp;</span>_cxq， w<span>)</span> <span>;</span>
        <span>if</span> <span>(</span>u <span>==</span> w<span>)</span> <span>break</span> <span>;</span>
        w <span>=</span> u <span>;</span>
        <span>}</span>
        <span>assert</span> <span>(</span>w <span>!=</span> <span>NULL</span> ， <span>"invariant"</span><span>)</span> <span>;</span>
        ObjectWaiter <span>*</span> q <span>=</span> <span>NULL</span> <span>;</span>
        ObjectWaiter <span>*</span> p <span>;</span>
        <span>for</span> <span>(</span>p <span>=</span> w <span>;</span> p <span>!=</span> <span>NULL</span> <span>;</span> p <span>=</span> p<span>-></span>_next<span>)</span> <span>{</span>
        <span>guarantee</span> <span>(</span>p<span>-></span>TState <span>==</span> ObjectWaiter<span>::</span>TS_CXQ， <span>"Invariant"</span><span>)</span> <span>;</span>
        p<span>-></span>TState <span>=</span> ObjectWaiter<span>::</span>TS_ENTER <span>;</span>
        p<span>-></span>_prev <span>=</span> q <span>;</span>
        q <span>=</span> p <span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>_EntryList <span>!=</span> <span>NULL</span><span>)</span> <span>{</span>
        q<span>-></span>_next <span>=</span> _EntryList <span>;</span>
        _EntryList<span>-></span>_prev <span>=</span> q <span>;</span>
        <span>}</span>
        _EntryList <span>=</span> w <span>;</span>
        <span>}</span>
        w <span>=</span> _EntryList <span>;</span>
        <span>if</span> <span>(</span>w <span>!=</span> <span>NULL</span><span>)</span> <span>{</span>
        <span>assert</span> <span>(</span>w<span>-></span>TState <span>==</span> ObjectWaiter<span>::</span>TS_ENTER， <span>"invariant"</span><span>)</span> <span>;</span>
        <span>ExitEpilog</span> <span>(</span>Self， w<span>)</span> <span>;</span>
        <span>return</span> <span>;</span>
        <span>}</span>
        w <span>=</span> _cxq <span>;</span>
        <span>if</span> <span>(</span>w <span>==</span> <span>NULL</span><span>)</span> <span>continue</span> <span>;</span>
        <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>
        <span>assert</span> <span>(</span>w <span>!=</span> <span>NULL</span>， <span>"Invariant"</span><span>)</span> <span>;</span>
        ObjectWaiter <span>*</span> u <span>=</span> <span>(</span>ObjectWaiter <span>*</span><span>)</span> Atomic<span>::</span><span>cmpxchg_ptr</span> <span>(</span><span>NULL</span>， <span>&amp;</span>_cxq，
        w<span>)</span> <span>;</span>
        <span>if</span> <span>(</span>u <span>==</span> w<span>)</span> <span>break</span> <span>;</span>
        w <span>=</span> u <span>;</span>
        <span>}</span>
        <span>TEVENT</span> <span>(</span>Inflated exit <span>-</span> drain cxq into EntryList<span>)</span> <span>;</span>
        <span>assert</span> <span>(</span>w <span>!=</span> <span>NULL</span> ， <span>"invariant"</span><span>)</span> <span>;</span>
        <span>assert</span> <span>(</span>_EntryList <span>==</span> <span>NULL</span> ， <span>"invariant"</span><span>)</span> <span>;</span>
        <span>if</span> <span>(</span>QMode <span>==</span> <span>1</span><span>)</span> <span>{</span>
<span>// QMode == 1 : drain cxq to EntryList， reversing order</span>
<span>// We also reverse the order of the list.</span>
        ObjectWaiter <span>*</span> s <span>=</span> <span>NULL</span> <span>;</span>
        ObjectWaiter <span>*</span> t <span>=</span> w <span>;</span>
        ObjectWaiter <span>*</span> u <span>=</span> <span>NULL</span> <span>;</span>
        <span>while</span> <span>(</span>t <span>!=</span> <span>NULL</span><span>)</span> <span>{</span>
        <span>guarantee</span> <span>(</span>t<span>-></span>TState <span>==</span> ObjectWaiter<span>::</span>TS_CXQ， <span>"invariant"</span><span>)</span> <span>;</span>
        t<span>-></span>TState <span>=</span> ObjectWaiter<span>::</span>TS_ENTER <span>;</span>
        u <span>=</span> t<span>-></span>_next <span>;</span>
        t<span>-></span>_prev <span>=</span> u <span>;</span>
        t<span>-></span>_next <span>=</span> s <span>;</span>
        s <span>=</span> t<span>;</span>
        t <span>=</span> u <span>;</span>
        <span>}</span>
        _EntryList <span>=</span> s <span>;</span>
        <span>assert</span> <span>(</span>s <span>!=</span> <span>NULL</span>， <span>"invariant"</span><span>)</span> <span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br></div></div><ol>
<li>退出同步代码块时会让_recursions 减 1，当_recursions 的值减为 0 时，说明线程释放了锁。</li>
<li>根据不同的策略(由 QMode 指定)，从 cxq 或 EntryList 中获取头节点，通过
ObjectMonitor::ExitEpilog 方法唤醒该节点封装的线程，唤醒操作最终由 unpark 完成，实现
如下：</li>
</ol>
<div><pre><code><span>}</span> <span>else</span> <span>{</span>
<span>// QMode == 0 or QMode == 2</span>
_EntryList <span>=</span> w <span>;</span>
ObjectWaiter <span>*</span> q <span>=</span> <span>NULL</span> <span>;</span>
ObjectWaiter <span>*</span> p <span>;</span>
<span>for</span> <span>(</span>p <span>=</span> w <span>;</span> p <span>!=</span> <span>NULL</span> <span>;</span> p <span>=</span> p<span>-></span>_next<span>)</span> <span>{</span>
<span>guarantee</span> <span>(</span>p<span>-></span>TState <span>==</span> ObjectWaiter<span>::</span>TS_CXQ， <span>"Invariant"</span><span>)</span> <span>;</span>
p<span>-></span>TState <span>=</span> ObjectWaiter<span>::</span>TS_ENTER <span>;</span>
p<span>-></span>_prev <span>=</span> q <span>;</span>
q <span>=</span> p <span>;</span>
<span>}</span>
<span>}</span>
<span>if</span> <span>(</span>_succ <span>!=</span> <span>NULL</span><span>)</span> <span>continue</span><span>;</span>
w <span>=</span> _EntryList <span>;</span>
<span>if</span> <span>(</span>w <span>!=</span> <span>NULL</span><span>)</span> <span>{</span>
<span>guarantee</span> <span>(</span>w<span>-></span>TState <span>==</span> ObjectWaiter<span>::</span>TS_ENTER， <span>"invariant"</span><span>)</span> <span>;</span>
<span>ExitEpilog</span> <span>(</span>Self， w<span>)</span> <span>;</span>
<span>return</span> <span>;</span>
<span>}</span>
<span>}</span>
<span>}</span>
<span>void</span> ObjectMonitor<span>::</span><span>ExitEpilog</span> <span>(</span>Thread <span>*</span> Self， ObjectWaiter <span>*</span> Wakee<span>)</span> <span>{</span>
<span>assert</span> <span>(</span>_owner <span>==</span> Self， <span>"invariant"</span><span>)</span> <span>;</span>
_succ <span>=</span> Knob_SuccEnabled <span>?</span> Wakee<span>-></span>_thread <span>:</span> <span>NULL</span> <span>;</span>
ParkEvent <span>*</span> Trigger <span>=</span> Wakee<span>-></span>_event <span>;</span>
Wakee <span>=</span> <span>NULL</span> <span>;</span>
<span>// Drop the lock</span>
OrderAccess<span>::</span><span>release_store_ptr</span> <span>(</span><span>&amp;</span>_owner， <span>NULL</span><span>)</span> <span>;</span>
OrderAccess<span>::</span><span>fence</span><span>(</span><span>)</span> <span>;</span> <span>// ST _owner vs LD in</span>
<span>unpark</span><span>(</span><span>)</span>
<span>if</span> <span>(</span>SafepointSynchronize<span>::</span><span>do_call_back</span><span>(</span><span>)</span><span>)</span> <span>{</span>
<span>TEVENT</span> <span>(</span>unpark before SAFEPOINT<span>)</span> <span>;</span>
<span>}</span>
<span>DTRACE_MONITOR_PROBE</span><span>(</span>contended__exit， this， <span>object</span><span>(</span><span>)</span>， Self<span>)</span><span>;</span>
Trigger<span>-></span><span>unpark</span><span>(</span><span>)</span> <span>;</span> <span>// 唤醒之前被pack()挂起的线程.</span>
<span>// Maintain stats and report events to JVMTI</span>
<span>if</span> <span>(</span>ObjectMonitor<span>::</span>_sync_Parks <span>!=</span> <span>NULL</span><span>)</span> <span>{</span>
ObjectMonitor<span>::</span>_sync_Parks<span>-></span><span>inc</span><span>(</span><span>)</span> <span>;</span>
<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><p>被唤醒的线程，会回到 void ATTR ObjectMonitor::EnterI (TRAPS) 的第 600 行，继续执行 monitor
的竞争。</p>
<div><pre><code><span>// park self</span>
<span>if</span> <span>(</span>_Responsible <span>==</span> Self <span>||</span> <span>(</span>SyncFlags <span>&amp;</span> <span>1</span><span>)</span><span>)</span> <span>{</span>
<span>TEVENT</span> <span>(</span>Inflated enter <span>-</span> park TIMED<span>)</span> <span>;</span>
Self<span>-></span>_ParkEvent<span>-></span><span>park</span> <span>(</span><span>(</span>jlong<span>)</span> RecheckInterval<span>)</span> <span>;</span>
<span>// Increase the RecheckInterval， but clamp the value.</span>
RecheckInterval <span>*=</span> <span>8</span> <span>;</span>
<span>if</span> <span>(</span>RecheckInterval <span>></span> <span>1000</span><span>)</span> RecheckInterval <span>=</span> <span>1000</span> <span>;</span>
<span>}</span> <span>else</span> <span>{</span>
<span>TEVENT</span> <span>(</span>Inflated enter <span>-</span> park UNTIMED<span>)</span> <span>;</span>
<span>// The lock had been free momentarily， but we lost the race to the lock.</span>
<span>// Interference -- the CAS failed.</span>
<span>// We can either return -1 or retry.</span>
<span>// Retry doesn't make as much sense because the lock was just acquired.</span>
<span>if</span> <span>(</span>true<span>)</span> <span>return</span> <span>-</span><span>1</span> <span>;</span>
<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="monitor-是重量级锁"> monitor 是重量级锁</h3>
<p>可以看到 ObjectMonitor 的函数调用中会涉及到 Atomic::cmpxchg_ptr，Atomic::inc_ptr 等内核函数， 执行同步代码块，没有竞争到锁的对象会 park()被挂起，竞争到锁的线程会 unpark()唤醒。</p>
<p>这个时候就 会存在操作系统用户态和内核态的转换，这种切换会消耗大量的系统资源。</p>
<p>所以 synchronized 是 Java 语 言中是一个重量级(Heavyweight)的操作。</p>
<h4 id="用户态和和内核态"> 用户态和和内核态</h4>
<p>用户态和和内核态是什么东西呢？要想了解用户态和内核态还需要先了解一下 Linux 系统的体系架构：</p>
<p><img src="./img/5-2-2.png" alt="" loading="lazy"></p>
<p>从上图可以看出，Linux 操作系统的体系架构分为：用户空间(应用程序的活动空间)和内核。</p>
<p>内核：本质上可以理解为一种软件，控制计算机的硬件资源，并提供上层应用程序运行的环境。</p>
<p>用户空间：上层应用程序活动的空间。应用程序的执行必须依托于内核提供的资源，包括 CPU 资源、存
储资源、I/O 资源等。</p>
<p>系统调用：为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即系统调用。</p>
<p>所有进程初始都运行于用户空间，此时即为用户运行状态(简称：用户态)；但是当它调用系统调用执
行某些操作时，例如 I/O 调用，此时需要陷入内核中运行，我们就称进程处于内核运行态（或简称为内
核态）。 系统调用的过程可以简单理解为：</p>
<ol>
<li>用户态程序将一些数据值放在寄存器中， 或者使用参数创建一个堆栈， 以此表明需要操作系统提
供的服务。</li>
<li>用户态程序执行系统调用。</li>
<li>CPU 切换到内核态，并跳到位于内存指定位置的指令。</li>
<li>系统调用处理器(system call handler)会读取程序放入内存的数据参数，并执行程序请求的服务。</li>
<li>系统调用完成后，操作系统会重置 CPU 为用户态并返回系统调用的结果。</li>
</ol>
<p>由此可见用户态切换至内核态需要传递许多变量，同时内核还需要保护好用户态在切换时的一些寄存器
值、变量等，以备内核态切换回用户态。这种切换就带来了大量的系统资源消耗，这就是在
synchronized 未优化之前，效率低的原因。</p>
<h1 id="六、jdk6-synchronized-优化"> 六、JDK6 synchronized 优化</h1>
<h2 id="cas"> CAS</h2>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-12"><label for="task-item-12"> 学习 CAS 的作用</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-13"><label for="task-item-13"> 学习 CAS 的原理</label></li>
</ul>
<h3 id="概念-5"> 概念</h3>
<p>CAS 的全成是： Compare And Swap(比较相同再交换)。是现代 CPU 广泛支持的一种对内存中的共享数
据进行操作的一种特殊指令。</p>
<p>CAS 的作用：CAS 可以将比较和交换转换为原子操作，这个原子操作直接由 CPU 保证。CAS 可以保证共 享变量赋值时的原子操作。</p>
<p>CAS 操作依赖 3 个值：内存中的值 V，旧的预估值 X，要修改的新值 B，如果旧 的预估值 X 等于内存中的值 V，就将新的值 B 保存到内存中。</p>
<h3 id="cas-和-volatile-实现无锁并发"> CAS 和 volatile 实现无锁并发</h3>
<div><pre><code><span>package</span> <span>com<span>.</span>itheima<span>.</span>demo05_cas</span><span>;</span>

<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>ArrayList</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span>concurrent<span>.</span>atomic<span>.</span></span><span>AtomicInteger</span><span>;</span>
<span>public</span> <span>class</span> <span>Demo01</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>
        <span>AtomicInteger</span> atomicInteger <span>=</span> <span>new</span> <span>AtomicInteger</span><span>(</span><span>)</span><span>;</span>
        <span>Runnable</span> mr <span>=</span> <span>(</span><span>)</span> <span>-></span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>1000</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
                atomicInteger<span>.</span><span>incrementAndGet</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span><span>;</span>
        <span>ArrayList</span><span><span>&lt;</span><span>Thread</span><span>></span></span> ts <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>5</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>Thread</span> t <span>=</span> <span>new</span> <span>Thread</span><span>(</span>mr<span>)</span><span>;</span>
            t<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
            ts<span>.</span><span>add</span><span>(</span>t<span>)</span><span>;</span>
        <span>}</span>
        <span>for</span> <span>(</span><span>Thread</span> t <span>:</span> ts<span>)</span> <span>{</span>
            t<span>.</span><span>join</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"number = "</span> <span>+</span> atomicInteger<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id="cas-原理"> CAS 原理</h3>
<p>通过刚才 AtomicInteger 的源码我们可以看到，Unsafe 类提供了原子操作。</p>
<h4 id="unsafe-类介绍"> Unsafe 类介绍</h4>
<p>Unsafe 类使 Java 拥有了像 C 语言的指针一样操作内存空间的能力，同时也带来了指针的问题。过度的使
用 Unsafe 类会使得出错的几率变大，因此 Java 官方并不建议使用的，官方文档也几乎没有。Unsafe 对
象不能直接调用，只能通过反射获得。</p>
<p><img src="./img/6-1-1.png" alt="" loading="lazy"></p>
<h4 id="unsafe-实现-cas"> Unsafe 实现 CAS</h4>
<p><img src="./img/6-1-2.png" alt="" loading="lazy"></p>
<h4 id="乐观锁和悲观锁"> 乐观锁和悲观锁</h4>
<p><strong>悲观锁</strong>从悲观的角度出发：</p>
<p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这 样别人想拿这个数据就会阻塞。因此 synchronized 我们也将其称之为悲观锁。JDK 中的 ReentrantLock 也是一种悲观锁。性能较差！</p>
<p><strong>乐观锁</strong>从乐观的角度出发:</p>
<p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，就算改了也没关系，再重试即可。所 以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去修改这个数据，如何没有人修改则更 新，如果有人修改则重试。</p>
<p>CAS 这种机制我们也可以将其称之为乐观锁。综合性能较好！</p>
<blockquote>
<p>CAS 获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。结合 CAS 和 volatile 可以
实现无锁并发，适用于竞争不激烈、多核 CPU 的场景下。</p>
</blockquote>
<ol>
<li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一。</li>
<li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响。</li>
</ol>
<div><p>总结</p>
<p>CAS 的作用： Compare And Swap，CAS 可以将比较和交换转换为原子操作，这个原子操作直接由处理 器保证。</p>
<p>CAS 的原理： CAS 需要 3 个值:内存地址 V，旧的预期值 A，要修改的新值 B，如果内存地址 V 和旧的预期值 A 相等就修改内存地址值为 B</p>
</div>
<h2 id="synchronized-锁升级过程"> synchronized 锁升级过程</h2>
<p>高效并发是从 JDK 5 到 JDK 6 的一个重要改进，HotSpot 虛拟机开发团队在这个版本上花费了大量的精力 去实现各种锁优化技术，包括偏向锁( Biased Locking )、轻量级锁( Lightweight Locking )和如适应性 自旋(Adaptive Spinning)、锁消除( Lock Elimination)、锁粗化( Lock Coarsening )等，这些技术都是为 了在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。</p>
<p>无锁--》偏向锁--》轻量级锁–》重量级锁</p>
<h2 id="java-对象的布局"> Java 对象的布局</h2>
<p>学习 Java 对象的布局</p>
<p>术语参考: <a href="http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.HTML" target="_blank" rel="noopener noreferrer">http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.HTML</a></p>
<p>在 JVM 中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。如下图所示：</p>
<p><img src="./img/6-3-1.png" alt="" loading="lazy"></p>
<h3 id="对象头"> 对象头</h3>
<p>当一个线程尝试访问 synchronized 修饰的代码块时，它首先要获得锁，那么这个锁到底存在哪里呢？</p>
<p>是 存在锁对象的对象头中的。</p>
<p>HotSpot 采用 instanceOopDesc 和 arrayOopDesc 来描述对象头，arrayOopDesc 对象用来描述数组类
型。InstanceOopDesc 的定义的在 Hotspot 源码的 instanceOop.hpp 文件中，另外，arrayOopDesc
的定义对应 arrayOop.hpp 。</p>
<div><pre><code>class instanceOopDesc <span>:</span> public oopDesc <span>{</span>
public<span>:</span>
<span>// aligned header size.</span>
<span>static</span> <span>int</span> <span>header_size</span><span>(</span><span>)</span> <span>{</span> <span>return</span> <span>sizeof</span><span>(</span>instanceOopDesc<span>)</span><span>/</span>HeapWordSize<span>;</span> <span>}</span>
<span>// If compressed, the offset of the fields of the instance may not be aligned.</span>
<span>static</span> <span>int</span> <span>base_offset_in_bytes</span><span>(</span><span>)</span> <span>{</span>
<span>// offset computation code breaks if UseCompressedClassPointers</span>
<span>// only is true</span>
        <span>return</span> <span>(</span>UseCompressedOops <span>&amp;&amp;</span> UseCompressedClassPointers<span>)</span> <span>?</span>
        <span>klass_gap_offset_in_bytes</span><span>(</span><span>)</span> <span>:</span>
        <span>sizeof</span><span>(</span>instanceOopDesc<span>)</span><span>;</span>
        <span>}</span>
<span>static</span> bool <span>contains_field_offset</span><span>(</span><span>int</span> offset<span>,</span> <span>int</span> nonstatic_field_size<span>)</span> <span>{</span>
        <span>int</span> base_in_bytes <span>=</span> <span>base_offset_in_bytes</span><span>(</span><span>)</span><span>;</span>
        <span>return</span> <span>(</span>offset <span>>=</span> base_in_bytes <span>&amp;&amp;</span>
        <span>(</span>offset<span>-</span>base_in_bytes<span>)</span> <span>&lt;</span> nonstatic_field_size <span>*</span> heapOopSize<span>)</span><span>;</span>
        <span>}</span>
        <span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>从 instanceOopDesc 代码中可以看到 instanceOopDesc 继承自 oopDesc，oopDesc 的定义载 Hotspot
源码中的 oop.hpp 文件中。</p>
<div><pre><code>class oopDesc <span>{</span>
    friend class VMStructs<span>;</span>
    private<span>:</span>
    <span>volatile</span> markOop _mark<span>;</span>
    <span>union</span> _metadata <span>{</span>
        Klass<span>*</span> _klass<span>;</span>
        narrowKlass _compressed_klass<span>;</span>
    <span>}</span> _metadata<span>;</span>
<span>// Fast access to barrier set. Must be initialized.</span>
    <span>static</span> BarrierSet<span>*</span> _bs<span>;</span>
<span>// 省略其他代码</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><img src="./img/6-3-2.png" alt="" loading="lazy"></p>
<p>在普通实例对象中，oopDesc 的定义包含两个成员，分别是 _mark 和 _metadata</p>
<p>_mark 表示对象标记、属于 markOop 类型，也就是接下来要讲解的 Mark World，它记录了对象和锁有
关的信息</p>
<p>_metadata 表示类元信息，类元信息存储的是对象指向它的类元数据(Klass)的首地址，其中 Klass 表示
普通指针、 _compressed_klass 表示压缩类指针。</p>
<div><p>小结</p>
<p>对象头由两部分组成，一部分用于存储自身的运行时数据，称之为 Mark Word，另外一部分是类型指
针，及对象指向它的类元数据的指针。</p>
</div>
<h4 id="mark-word"> Mark Word</h4>
<p>Mark Word 用于存储对象自身的运行时数据，如哈希码(HashCode)、GC 分代年龄、锁状态标志、 线程持有的锁、偏向线程 ID、偏向时间戳等等，占用内存大小与虚拟机位长一致。Mark Word 对应的类 型是 markOop 。源码位于 markOop.hpp 中。</p>
<div><pre><code><span>// Bit-format of an object header (most significant first, big endian layout</span>
below<span>)</span><span>:</span>
<span>//</span>
<span>// 32 bits:</span>
<span>// --------</span>
<span>// hash:25 ------------>| age:4 biased_lock:1 lock:2 (normal</span>
object<span>)</span>
<span>// JavaThread*:23 epoch:2 age:4 biased_lock:1 lock:2 (biased</span>
object<span>)</span>
<span>// size:32 ------------------------------------------>| (CMS free</span>
block<span>)</span>
<span>// PromotedObject*:29 ---------->| promo_bits:3 ----->| (CMS</span>
promoted object<span>)</span>
<span>//</span>
<span>// 64 bits:</span>
<span>// --------</span>
<span>// unused:25 hash:31 -->| unused:1 age:4 biased_lock:1 lock:2 (normal</span>
object<span>)</span>
<span>// JavaThread*:54 epoch:2 unused:1 age:4 biased_lock:1 lock:2 (biased</span>
object<span>)</span>
<span>// PromotedObject*:61 --------------------->| promo_bits:3 ----->| (CMS</span>
promoted object<span>)</span>
<span>// size:64 ----------------------------------------------------->| (CMS free</span>
block<span>)</span>
<span>// [JavaThread* | epoch | age | 1 | 01] lock is biased toward given</span>
thread
<span>// [0 | epoch | age | 1 | 01] lock is anonymously biased</span>
<span>//</span>
<span>// - the two lock bits are used to describe three states: locked/unlocked and</span>
monitor<span>.</span>
<span>//</span>
<span>// [ptr | 00] locked ptr points to real header on</span>
stack
<span>// [header | 0 | 01] unlocked regular object header</span>
<span>// [ptr | 10] monitor inflated lock (header is wapped</span>
out<span>)</span>
<span>// [ptr | 11] marked used by markSweep to mark an</span>
object
<span>// not valid at any other time</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><p><img src="./img/6-3-3.png" alt="" loading="lazy"></p>
<p>在 64 位虚拟机下，Mark Word 是 64bit 大小的，其存储结构如下：</p>
<p><img src="./img/6-3-4.png" alt="" loading="lazy"></p>
<p>在 32 位虚拟机下，Mark Word 是 32bit 大小的，其存储结构如下：</p>
<p><img src="./img/6-3-5.png" alt="" loading="lazy"></p>
<h4 id="klass-pointer"> klass pointer</h4>
<p>这一部分用于存储对象的类型指针，该指针指向它的类元数据，JVM 通过这个指针确定对象是哪个类的 实例。</p>
<p>该指针的位长度为 JVM 的一个字大小，即 32 位的 JVM 为 32 位，64 位的 JVM 为 64 位。</p>
<p>如果应用的对 象过多，使用 64 位的指针将浪费大量内存，统计而言，64 位的 JVM 将会比 32 位的 JVM 多耗费 50%的内 存。为了节约内存可以使用选项 -XX:+UseCompressedOops 开启指针压缩，其中，oop 即 ordinary object pointer 普通对象指针。开启该选项后，下列指针将压缩至 32 位：</p>
<ol>
<li>每个 Class 的属性指针(即静态变量)</li>
<li>每个对象的属性指针(即对象变量)</li>
<li>普通对象数组的每个元素指针</li>
</ol>
<p>当然，也不是所有的指针都会压缩，一些特殊类型的指针 JVM 不会优化，比如指向 PermGen 的 Class 对 象指针(JDK8 中指向元空间的 Class 对象指针)、本地变量、堆栈元素、入参、返回值和 NULL 指针等。 对象头 = Mark Word + 类型指针(未开启指针压缩的情况下)</p>
<p>在 32 位系统中，Mark Word = 4 bytes，类型指针 = 4bytes，对象头 = 8 bytes = 64 bits；
在 64 位系统中，Mark Word = 8 bytes，类型指针 = 8bytes，对象头 = 16 bytes = 128bits；</p>
<h3 id="实例数据"> 实例数据</h3>
<p>就是类中定义的成员变量。</p>
<h3 id="对齐填充"> 对齐填充</h3>
<p>对齐填充并不是必然存在的，也没有什么特别的意义，他仅仅起着占位符的作用。</p>
<p>由于HotSpot-VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头正好是8字节的倍数，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<h3 id="查看-java-对象布局"> 查看 Java 对象布局</h3>
<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>
    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.openjdk.jol<span><span><span>&lt;/</span>groupId</span><span>></span></span>
    <span><span><span>&lt;</span>artifactId</span><span>></span></span>jol-core<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
    <span><span><span>&lt;</span>version</span><span>></span></span>0.9<span><span><span>&lt;/</span>version</span><span>></span></span>
<span><span><span>&lt;/</span>dependency</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><p>总结</p>
<p>Java 对象由 3 部分组成，对象头，实例数据，对齐数据</p>
<p>对象头分成两部分：Mark World + Klass pointer</p>
</div>
<h2 id="偏向锁"> 偏向锁</h2>
<p>学习偏向锁的原理和好处</p>
<h3 id="什么是偏向锁"> 什么是偏向锁</h3>
<p>偏向锁是 JDK 6 中的重要引进，因为 HotSpot 作者经过研究实践发现，在大多数情况下，锁不仅不存在多 线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低，引进了偏向锁。</p>
<p>偏向锁的“偏”，就是偏心的“偏”、偏袒的“偏”，它的意思是这个锁会偏向于第一个获得它的线程，会在对 象头存储锁偏向的线程 ID，以后该线程进入和退出同步块时只需要检查是否为偏向锁、锁标志位以及 ThreadID 即可。</p>
<p><img src="./img/6-4-1.png" alt="" loading="lazy"></p>
<p>不过一旦出现多个线程竞争时必须撤销偏向锁，所以撤销偏向锁消耗的性能必须小于之前节省下来的 CAS 原子操作的性能消耗，不然就得不偿失了。</p>
<h3 id="偏向锁原理"> 偏向锁原理</h3>
<p>当线程第一次访问同步块并获取锁时，偏向锁处理流程如下：</p>
<blockquote>
<ol>
<li>虚拟机将会把对象头中的标志位设为“01”，即偏向模式。</li>
<li>同时使用 CAS 操作把获取到这个锁的线程的 ID 记录在对象的 Mark Word 之中 ，如果 CAS 操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。</li>
</ol>
</blockquote>
<p><img src="./img/6-4-2.png" alt="" loading="lazy"></p>
<p>持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁 的效率高。</p>
<h3 id="偏向锁的撤销"> 偏向锁的撤销</h3>
<ol>
<li>偏向锁的撤销动作必须等待全局安全点</li>
<li>暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态</li>
<li>撤销偏向锁，恢复到无锁(标志位为 01)或轻量级锁(标志位为 00)的状态</li>
</ol>
<p>偏向锁在 Java 6 之后是默认启用的，但在应用程序启动几秒钟之后才激活，可以使用 -</p>
<p><code>XX:BiasedLockingStartupDelay=0</code> 参数关闭延迟，如果确定应用程序中所有锁通常情况下处于竞争 状态，可以通过 <code>XX:-UseBiasedLocking=false</code> 参数关闭偏向锁。</p>
<h3 id="偏向锁好处"> 偏向锁好处</h3>
<p>偏向锁是在只有一个线程执行同步块时进一步提高性能，适用于一个线程反复获得同一锁的情况。偏向 锁可以提高带有同步但无竞争的程序性能。</p>
<p>它同样是一个带有效益权衡性质的优化，也就是说，它并不一定总是对程序运行有利，如果程序中大多 数的锁总是被多个不同的线程访问比如线程池，那偏向模式就是多余的。</p>
<p>在 JDK5 中偏向锁默认是关闭的，而到了 JDK6 中偏向锁已经默认开启。</p>
<p>但在应用程序启动几秒钟之后才 激活，可以使用 <code>-XX:BiasedLockingStartupDelay=0</code> 参数关闭延迟，如果确定应用程序中所有锁通常 情况下处于竞争状态，可以通过 <code>XX:-UseBiasedLocking=false</code> 参数关闭偏向锁。</p>
<div><p>总结</p>
<p>偏向锁的原理是什么?
偏向锁的好处是什么?</p>
</div>
<h2 id="轻量级锁"> 轻量级锁</h2>
<p>学习轻量级锁的原理和好处</p>
<h3 id="什么是轻量级锁"> 什么是轻量级锁</h3>
<p>轻量级锁是 JDK 6 之中加入的新型锁机制，它名字中的“轻量级”是相对于使用 monitor 的传统锁而言的， 因此传统的锁机制就称为“重量级”锁。</p>
<p>首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的。</p>
<p>引入轻量级锁的目的：在多线程交替执行同步块的情况下，尽量避免重量级锁引起的性能消耗，但是如 果多个线程在同一时刻进入临界区，会导致轻量级锁膨胀升级重量级锁，所以轻量级锁的出现并非是要 替代重量级锁。</p>
<h3 id="轻量级锁原理"> 轻量级锁原理</h3>
<p>当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，其步 骤如下：</p>
<p>获取锁 当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。同时使用 CAS 操 作把获取到这个锁的线程的 ID 记录在对象的 Mark Word 之中 ，如果 CAS 操作成功，持有偏向锁的线程以后每 次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。</p>
<p>偏向锁是在只有一个线程执行同步块时进一步提高性能，适用于一个线程反复获得同一锁的情况。</p>
<p>偏向锁可以 提高带有同步但无竞争的程序性能。</p>
<ol>
<li>判断当前对象是否处于无锁状态(hashcode、0、01)，如果是，则 JVM 首先将在当前线程的栈帧
中建立一个名为锁记录(Lock Record)的空间，用于存储锁对象目前的 Mark Word 的拷贝（官方
把这份拷贝加了一个 Displaced 前缀，即 Displaced Mark Word），将对象的 Mark Word 复制到栈
帧中的 Lock Record 中，将 Lock Reocrd 中的 owner 指向当前对象。</li>
<li>JVM 利用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针，如果成功表示竞争到
锁，则将锁标志位变成 00，执行同步操作。</li>
<li>如果失败则判断当前对象的 Mark Word 是否指向当前线程的栈帧，如果是则表示当前线程已经持
有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻
量级锁需要膨胀为重量级锁，锁标志位变成 10，后面等待的线程将会进入阻塞状态。</li>
</ol>
<p><img src="./img/6-5-1.png" alt="" loading="lazy"></p>
<p><img src="./img/6-5-2.png" alt="" loading="lazy"></p>
<h3 id="轻量级锁的释放"> 轻量级锁的释放</h3>
<p>轻量级锁的释放也是通过 CAS 操作来进行的，主要步骤如下：</p>
<blockquote>
<ol>
<li>取出在获取轻量级锁保存在 Displaced Mark Word 中的数据。</li>
<li>用 CAS 操作将取出的数据替换当前对象的 Mark Word 中，如果成功，则说明释放锁成功。</li>
<li>如果 CAS 操作替换失败，说明有其他线程尝试获取该锁，则需要将轻量级锁需要膨胀升级为重量级
锁。</li>
</ol>
</blockquote>
<p>对于轻量级锁，其性能提升的依据是“对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”，如 果打破这个依据则除了互斥的开销外，还有额外的 CAS 操作，因此在有多线程竞争的情况下，轻量级锁 比重量级锁更慢。</p>
<h3 id="轻量级锁好处"> 轻量级锁好处</h3>
<p>在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。</p>
<div><p>总结</p>
<p>轻量级锁的原理是什么？</p>
<p>将对象的 Mark Word 复制到栈帧中的 Lock Recod 中。Mark Word 更新为指向 Lock Record 的指针。</p>
<p>轻量级锁好处是什么？</p>
<p>在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。</p>
</div>
<h2 id="自旋锁"> 自旋锁</h2>
<p>学习自旋锁原理</p>
<h3 id="自旋锁原理"> 自旋锁原理</h3>
<div><pre><code><span>synchronized</span> <span>(</span><span>Demo01</span><span>.</span><span>class</span><span>)</span> <span>{</span>
<span>.</span><span>.</span><span>.</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"aaa"</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>前面我们讨论 monitor 实现锁的时候，知道 monitor 会阻塞和唤醒线程，线程的阻塞和唤醒需要 CPU 从 用户态转为核心态，频繁的阻塞和唤醒对 CPU 来说是一件负担很重的工作，这些操作给系统的并发性能 带来了很大的压力。</p>
<p>同时，虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态只会持续很 短的一段时间，为了这段时间阻塞和唤醒线程并不值得。如果物理机器有一个以上的处理器，能让两个 或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行 时间，看看持有锁的线程是否很快就会释放锁。</p>
<p>为了让线程等待，我们只需让线程执行一个忙循环(自 旋) , 这项技术就是所谓的自旋锁。</p>
<p>自旋锁在 JDK 1.4.2 中就已经引入 ，只不过默认是关闭的，可以使用-XX:+UseSpinning 参数来开启，在 JDK 6 中 就已经改为默认开启了。</p>
<p>自旋等待不能代替阻塞，且先不说对处理器数量的要求，自旋等待本 身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果锁被占用的时间很短，自旋等 待的效果就会非常好，反之，如果锁被占用的时间很长。</p>
<p>那么自旋的线程只会白白消耗处理器资源，而 不会做任何有用的工作，反而会带来性 能上的浪费。</p>
<p>因此，自旋等待的时间必须要有一定的限度，如果 自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。</p>
<p>自旋次数的默认值 是 10 次，用户可以使用参数-XX : PreBlockSpin 来更改。</p>
<h3 id="适应性自旋锁"> 适应性自旋锁</h3>
<p>在 JDK 6 中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上
的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持
有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持
续相对更长的时间，比如 100 次循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取
这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控
信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确，虛拟机就会变得越来越“聪明”了。</p>
<h2 id="锁消除"> 锁消除</h2>
<p>锁消除是指虚拟机即时编译器(JIT)在运行时，对一些代码上要求同步，但是被检测到不可能存在共享 数据竞争的锁进行消除。</p>
<p>锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中， 堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们 是线程私有的，同步加锁自然就无须进行。</p>
<p>变量是否逃逸，对于虚拟机来说需要使用数据流分析来确 定，但是程序员自己应该是很清楚的，怎么会在明知道不存在数据争用的情况下要求同步呢?</p>
<p>实际上有 许多同步措施并不是程序员自己加入的，同步的代码在 Java 程序中的普遍程度也许超过了大部分读者的 想象。</p>
<p>下面这段非常简单的代码仅仅是输出 3 个字符串相加的结果，无论是源码字面上还是程序语义上 都没有同步。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Demo01</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>contactString</span><span>(</span><span>"aa"</span><span>,</span> <span>"bb"</span><span>,</span> <span>"cc"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>String</span> <span>contactString</span><span>(</span><span>String</span> s1<span>,</span> <span>String</span> s2<span>,</span> <span>String</span> s3<span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>StringBuffer</span><span>(</span><span>)</span><span>.</span><span>append</span><span>(</span>s1<span>)</span><span>.</span><span>append</span><span>(</span>s2<span>)</span><span>.</span><span>append</span><span>(</span>s3<span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>StringBuffer 的 append ( ) 是一个同步方法，锁就是 this 也就是(new StringBuilder())。</p>
<p>虚拟机发现它的 动态作用域被限制在 concatString( )方法内部。</p>
<p>也就是说, new StringBuilder()对象的引用永远不会“逃 逸”到 concatString ( )方法之外，其他线程无法访问到它，因此，虽然这里有锁，但是可以被安全地消除 掉，在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了。</p>
<h2 id="锁粗化"> 锁粗化</h2>
<p>学习锁粗化的原理</p>
<p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，只在共享数据的实际作 用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线 程也能尽快拿到锁。</p>
<p>大部分情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对 象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操 作也会导致不必要的性能损耗。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Demo01</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>StringBuffer</span> sb <span>=</span> <span>new</span> <span>StringBuffer</span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>100</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            sb<span>.</span><span>append</span><span>(</span><span>"aa"</span><span>)</span><span>;</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>sb<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><p>总结</p>
<p>什么是锁粗化？</p>
<p>JVM 会探测到一连串细小的操作都使用同一个对象加锁，将同步代码块的范围放大，放到这串操作的外面，这样只需要加一次锁即可。</p>
</div>
<h2 id="平时写代码如何对-synchronized-优化"> 平时写代码如何对 synchronized 优化</h2>
<h3 id="减少-synchronized-的范围"> 减少 synchronized 的范围</h3>
<p>同步代码块中尽量短，减少同步代码块中代码的执行时间，减少锁的竞争。</p>
<div><pre><code>    <span>synchronized</span> <span>(</span><span>Demo01</span><span>.</span><span>class</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"aaa"</span><span>)</span><span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="降低-synchronized-锁的粒度"> 降低 synchronized 锁的粒度</h3>
<p>将一个锁拆分为多个锁提高并发度</p>
<div><pre><code><span>Hashtable</span> hs <span>=</span> <span>new</span> <span>Hashtable</span><span>(</span><span>)</span><span>;</span>
hs<span>.</span><span>put</span><span>(</span><span>"aa"</span><span>,</span> <span>"bb"</span><span>)</span><span>;</span>
hs<span>.</span><span>put</span><span>(</span><span>"xx"</span><span>,</span> <span>"yy"</span><span>)</span><span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><img src="./img/6-9-1.png" alt="" loading="lazy"></p>
<p><img src="./img/6-9-2.png" alt="" loading="lazy"></p>
<p><img src="./img/6-9-3.png" alt="" loading="lazy"></p>
<p>LinkedBlockingQueue 入队和出队使用不同的锁，相对于读写只有一个锁效率要高</p>
<p><img src="./img/6-9-4.png" alt="" loading="lazy"></p>
<h3 id="读写分离"> 读写分离</h3>
<p><strong>读取时不加锁，写入和删除时加锁</strong></p>
<p>ConcurrentHashMap，CopyOnWriteArrayList 和 ConyOnWriteSet</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="concurrent"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-01-28T00:00:00.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">ThreadLocal</title>
    <id>http://www.zhangsj.xyz/blog/java/concurrent/threadlocal/</id>
    <link href="http://www.zhangsj.xyz/blog/java/concurrent/threadlocal/"/>
    <updated>2022-04-11T06:31:58.000Z</updated>
    <content type="html"><![CDATA[<h2 id="threadlocal"> ThreadLocal</h2>
<h3 id="概念"> 概念</h3>
<p>类ThreadLocal主要解决的就是每个线程绑定自己的值，可以将ThreadLocal类比喻成全局存放数据的盒子，盒子中可以存储每个线程的私有变量。</p>
<p>首先，它是一个数据结构，有点像 HashMap，可以保存&quot;key : value&quot;键值对，但是一个 ThreadLocal 只能保存一个，并且各个线程的数据互不干扰。</p>
<div><pre><code><span>ThreadLocal</span><span><span>&lt;</span><span>String</span><span>></span></span> localName <span>=</span> <span>new</span> <span>ThreadLocal</span><span>(</span><span>)</span><span>;</span> localName<span>.</span><span>set</span><span>(</span><span>"zs"</span><span>)</span><span>;</span> <span>String</span> name <span>=</span> localName<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>在线程 1 中初始化了一个 ThreadLocal 对象 localName，并通过 set 方法，保存了一个值 zs，同时在线程 1 中通过 localName.get()可以拿到之前设置的值，但是如果在线程 2 中，拿到的将是一个 null。</p>
<p>这是为什么，如何实现？不过之前也说了，ThreadLocal 保证了各个线程的数据互不干扰。</p>
<p>看看 set(T value)和 get()方法的源码</p>
<div><pre><code><span>public</span> <span>class</span> <span>T</span><span>{</span>
 <span>public</span> <span>void</span> <span>set</span><span>(</span><span>T</span> value<span>)</span> <span>{</span>
    <span>Thread</span> t <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>;</span>
    <span>ThreadLocalMap</span> map <span>=</span> <span>getMap</span><span>(</span>t<span>)</span><span>;</span>
    <span>if</span> <span>(</span>map <span>!=</span> <span>null</span><span>)</span>
        map<span>.</span><span>set</span><span>(</span><span>this</span><span>,</span> value<span>)</span><span>;</span>
    <span>else</span>
        <span>createMap</span><span>(</span>t<span>,</span> value<span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>T</span> <span>get</span><span>(</span><span>)</span> <span>{</span>
    <span>Thread</span> t <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>;</span>
    <span>ThreadLocalMap</span> map <span>=</span> <span>getMap</span><span>(</span>t<span>)</span><span>;</span>
    <span>if</span> <span>(</span>map <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        <span>ThreadLocalMap<span>.</span>Entry</span> e <span>=</span> map<span>.</span><span>getEntry</span><span>(</span><span>this</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>e <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            <span>@SuppressWarnings</span><span>(</span><span>"unchecked"</span><span>)</span>
            <span>T</span> result <span>=</span> <span>(</span><span>T</span><span>)</span>e<span>.</span>value<span>;</span>
            <span>return</span> result<span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>setInitialValue</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
<span>ThreadLocalMap</span> <span>getMap</span><span>(</span><span>Thread</span> t<span>)</span> <span>{</span>
    <span>return</span> t<span>.</span>threadLocals<span>;</span>
<span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>Thread 线程类中存在 ThreadLoalMap 的对象，它也是一个类似 HashMap 的数据结构，但是在 ThreadLocal 中，并没实现 Map 接口。</p>
<p>在 ThreadLoalMap 中，也是初始化一个大小 16 的 Entry 数组，Entry 对象用来保存每一个 key-value 键值对，只不过这里的 key 永远都是 ThreadLocal 对象，通过 ThreadLocal 对象的 set 方法，结果把 ThreadLocal 对象自己当做 key，放进了 ThreadLoalMap 中。</p>
<h3 id="entry-是继承-weakreference"> Entry 是继承 WeakReference</h3>
<p>ThreadLoalMap 的 Entry 是继承 WeakReference
这里需要注意的是，</p>
<p>ThreadLoalMap 的 Entry 是继承 WeakReference，和 HashMap 很大的区别是，Entry 中没有 next 字段，所以就不存在链表的情况了。</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="thread"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-22T13:39:52.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">threadpool</title>
    <id>http://www.zhangsj.xyz/blog/java/concurrent/threadpool-code-analysis/</id>
    <link href="http://www.zhangsj.xyz/blog/java/concurrent/threadpool-code-analysis/"/>
    <updated>2022-03-01T05:15:03.000Z</updated>
    <content type="html"><![CDATA[<h1 id="threadpool"> threadpool</h1>
<h1 id="线程池-threadpoolexecutor-源码分析"> 线程池 ThreadPoolExecutor 源码分析</h1>
<h2 id="_1、构造方法"> 1、构造方法</h2>
<p>构造方法中有 4 个方法，本质上都是调用的下面这个构造方法：</p>
<div><pre><code><span>public</span> <span>class</span> <span>ThreadPoolExecutor</span> <span>extends</span> <span>AbstractExecutorService</span> <span>{</span>
    <span>public</span> <span>ThreadPoolExecutor</span><span>(</span><span>int</span> corePoolSize<span>,</span>
            <span>int</span> maximumPoolSize<span>,</span>
            <span>long</span> keepAliveTime<span>,</span>
            <span>TimeUnit</span> unit<span>,</span>
            <span>BlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span> workQueue<span>,</span>
            <span>ThreadFactory</span> threadFactory<span>,</span>
            <span>RejectedExecutionHandler</span> handler<span>)</span> <span>{</span>
     <span>if</span> <span>(</span>corePoolSize <span>&lt;</span> <span>0</span> <span>||</span>
      maximumPoolSize <span>&lt;=</span> <span>0</span> <span>||</span>
      maximumPoolSize <span>&lt;</span> corePoolSize <span>||</span>
      keepAliveTime <span>&lt;</span> <span>0</span><span>)</span>
      <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>)</span><span>;</span>
     <span>if</span> <span>(</span>workQueue <span>==</span> <span>null</span> <span>||</span> threadFactory <span>==</span> <span>null</span> <span>||</span> handler <span>==</span> <span>null</span><span>)</span>
      <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>
     <span>this</span><span>.</span>acc <span>=</span> <span>System</span><span>.</span><span>getSecurityManager</span><span>(</span><span>)</span> <span>==</span> <span>null</span> <span>?</span>
       <span>null</span> <span>:</span>
       <span>AccessController</span><span>.</span><span>getContext</span><span>(</span><span>)</span><span>;</span>
     <span>this</span><span>.</span>corePoolSize <span>=</span> corePoolSize<span>;</span>
     <span>this</span><span>.</span>maximumPoolSize <span>=</span> maximumPoolSize<span>;</span>
     <span>this</span><span>.</span>workQueue <span>=</span> workQueue<span>;</span>
     <span>this</span><span>.</span>keepAliveTime <span>=</span> unit<span>.</span><span>toNanos</span><span>(</span>keepAliveTime<span>)</span><span>;</span>
     <span>this</span><span>.</span>threadFactory <span>=</span> threadFactory<span>;</span>
     <span>this</span><span>.</span>handler <span>=</span> handler<span>;</span>
<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h2 id="线程池中定义了四种饱和策略-拒绝策略"> 线程池中定义了四种饱和策略 (拒绝策略)</h2>
<h3 id="_1、callerrunspolicy"> 1、CallerRunsPolicy</h3>
<p>绕过线程池，直接执行线程的 run 方法</p>
<div><pre><code><span>public</span> <span>static</span> <span>class</span> <span>CallerRunsPolicy</span> <span>implements</span> <span>RejectedExecutionHandler</span> <span>{</span>
 <span>public</span> <span>CallerRunsPolicy</span><span>(</span><span>)</span> <span>{</span> <span>}</span>
 <span>//使用主线程执行新任务</span>
 <span>public</span> <span>void</span> <span>rejectedExecution</span><span>(</span><span>Runnable</span> r<span>,</span> <span>ThreadPoolExecutor</span> e<span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>e<span>.</span><span>isShutdown</span><span>(</span><span>)</span><span>)</span> <span>{</span>
   <span>//此方法相同于同步方法</span>
   r<span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>
  <span>}</span>
 <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="_2、-abortpolicy-线程池默认的策略"> 2、 AbortPolicy(线程池默认的策略)</h3>
<p>抛出 RejectedExecutionException 来拒绝新任务的处理</p>
<div><pre><code>
<span>public</span> <span>static</span> <span>class</span> <span>AbortPolicy</span> <span>implements</span> <span>RejectedExecutionHandler</span> <span>{</span>
 <span>public</span> <span>AbortPolicy</span><span>(</span><span>)</span> <span>{</span> <span>}</span>

 <span>public</span> <span>void</span> <span>rejectedExecution</span><span>(</span><span>Runnable</span> r<span>,</span> <span>ThreadPoolExecutor</span> e<span>)</span> <span>{</span>
  <span>throw</span> <span>new</span> <span>RejectedExecutionException</span><span>(</span><span>"Task "</span> <span>+</span> r<span>.</span><span>toString</span><span>(</span><span>)</span> <span>+</span> <span>" rejected from "</span> <span>+</span> e<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
 <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="_3、discardpolicy"> 3、DiscardPolicy</h3>
<p>不执行任何操作，丢弃新任务</p>
<div><pre><code>
<span>public</span> <span>static</span> <span>class</span> <span>DiscardPolicy</span> <span>implements</span> <span>RejectedExecutionHandler</span> <span>{</span>
 <span>public</span> <span>DiscardPolicy</span><span>(</span><span>)</span> <span>{</span> <span>}</span>
 <span>public</span> <span>void</span> <span>rejectedExecution</span><span>(</span><span>Runnable</span> r<span>,</span> <span>ThreadPoolExecutor</span> e<span>)</span> <span>{</span> <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="_4、discardoldestpolicy"> 4、DiscardOldestPolicy</h3>
<p>此策略将丢弃最早的未处理的任务</p>
<div><pre><code><span>public</span> <span>static</span> <span>class</span> <span>DiscardOldestPolicy</span> <span>implements</span> <span>RejectedExecutionHandler</span> <span>{</span>
 <span>public</span> <span>DiscardOldestPolicy</span><span>(</span><span>)</span> <span>{</span> <span>}</span>
 <span>public</span> <span>void</span> <span>rejectedExecution</span><span>(</span><span>Runnable</span> r<span>,</span> <span>ThreadPoolExecutor</span> e<span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>e<span>.</span><span>isShutdown</span><span>(</span><span>)</span><span>)</span> <span>{</span>
   e<span>.</span><span>getQueue</span><span>(</span><span>)</span><span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>
   e<span>.</span><span>execute</span><span>(</span>r<span>)</span><span>;</span>
  <span>}</span>
 <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="_3、阻塞队列"> 3、阻塞队列</h2>
<p>咱们看下<code>ThreadPoolExecutor</code>的源码：</p>
<div><pre><code>public static ExecutorService newFixedThreadPool(int nThreads) {
 return new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,
  new LinkedBlockingQueue&lt;Runnable&gt;());
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>使用的是 LinkedBlockingQueue 作为阻塞队列，LinkedBlockingQueue 的默认构造函数允许的队列长度是 Integer.MAX_VALUE，若堆积大量的请求，可能会造成 OOM。</p>
<p>此处就是为什么《阿里巴巴 Java 开发手册》中不推荐使用 Executors 工具类创建线程池的原因，要求使用 ThreadPoolExecutor 构造函数的方式，让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p>
<h2 id="_4、execute-方法"> 4、execute 方法</h2>
<p>下面是执行流程图：</p>
<p><img src="./image/threadpool-1.png" alt="" loading="lazy"></p>
<p>Java.util.concurrent.ThreadPoolExecutor.execute</p>
<div><pre><code><span>public</span> <span>class</span> <span>ThreadPoolExecutor</span> <span>extends</span> <span>AbstractExecutorService</span> <span>{</span>
    <span>private</span> <span>final</span> <span>AtomicInteger</span> ctl <span>=</span> <span>new</span> <span>AtomicInteger</span><span>(</span><span>ctlOf</span><span>(</span>RUNNING<span>,</span> <span>0</span><span>)</span><span>)</span><span>;</span>
<span>private</span> <span>static</span> <span>int</span> <span>workerCountOf</span><span>(</span><span>int</span> c<span>)</span> <span>{</span>
 <span>return</span> c <span>&amp;</span> CAPACITY<span>;</span>
<span>}</span>
<span>//任务队列</span>
<span>private</span> <span>final</span> <span>BlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span> workQueue<span>;</span>
<span>public</span> <span>void</span> <span>execute</span><span>(</span><span>Runnable</span> command<span>)</span> <span>{</span>
    <span>//如果任务为null,则抛出异常</span>
     <span>if</span> <span>(</span>command <span>==</span> <span>null</span><span>)</span>
      <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>
     <span>//获取线程池状态和有效线程数</span>
     <span>int</span> c <span>=</span> ctl<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
     <span>//以下有3步：</span>
     <span>//步骤1：</span>
     <span>//如果线程池工作的线程小于核心线程数</span>
     <span>if</span> <span>(</span><span>workerCountOf</span><span>(</span>c<span>)</span> <span>&lt;</span> corePoolSize<span>)</span> <span>{</span>
      <span>//则增加一个线程，并把该任务交给它去执行</span>
      <span>if</span> <span>(</span><span>addWorker</span><span>(</span>command<span>,</span> <span>true</span><span>)</span><span>)</span>
       <span>//成功则返回</span>
       <span>return</span><span>;</span>
      <span>//这里说明创建核心线程失败，需要再次获取临时变量c</span>
      c <span>=</span> ctl<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
     <span>}</span>
<span>//步骤2：</span>
 <span>// 走到这里说明创建新的核心线程失败，也就是当前工作线程数大于等于corePoolSize</span>
 <span>// 线程池的运行状态是RUNNING，并且尝试将新任务加入到阻塞队列，成功返回true</span>
 <span>if</span> <span>(</span><span>isRunning</span><span>(</span>c<span>)</span> <span>&amp;&amp;</span> workQueue<span>.</span><span>offer</span><span>(</span>command<span>)</span><span>)</span> <span>{</span>
  <span>//进入到这里，是已经向任务队列投放任务成功</span>
  <span>//再次获取线程池状态和有效线程数</span>
  <span>int</span> recheck <span>=</span> ctl<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
  <span>//如果线程池状态不是RUNNING（线程池异常终止了）,将线程从工作队列中移除</span>
  <span>if</span> <span>(</span><span>!</span> <span>isRunning</span><span>(</span>recheck<span>)</span> <span>&amp;&amp;</span> <span>remove</span><span>(</span>command<span>)</span><span>)</span>
   <span>//执行饱和策略</span>
   <span>reject</span><span>(</span>command<span>)</span><span>;</span>
  <span>// 走到这里说明线程池状态可能是RUNNING</span>
  <span>// 也可能是移除线程任务失败了（失败的最大的可能是已经执行完毕了）</span>
  <span>//因为所有存活的工作线程有可能在最后一次检查之后已经终结,所以需要二次检查线程池工作线程的状态</span>
  <span>//这里博主也是看了半天，大家好好体会下</span>
  <span>else</span> <span>if</span> <span>(</span><span>workerCountOf</span><span>(</span>recheck<span>)</span> <span>==</span> <span>0</span><span>)</span>
   <span>//若当前线程池工作线程数为0，则新建一个线程并执行</span>
   <span>addWorker</span><span>(</span><span>null</span><span>,</span> <span>false</span><span>)</span><span>;</span>
 <span>}</span>
 <span>//步骤3：</span>
 <span>// 如果任务队列已满，就需要创建非核心线程</span>
 <span>// 如果新建非核心线程失败，则执行饱和策略</span>
 <span>else</span> <span>if</span> <span>(</span><span>!</span><span>addWorker</span><span>(</span>command<span>,</span> <span>false</span><span>)</span><span>)</span>
  <span>reject</span><span>(</span>command<span>)</span><span>;</span>

<span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div>]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="thread"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-01-30T09:23:34.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">detailed-explanation-of-b-tree-and-b+-tree</title>
    <id>http://www.zhangsj.xyz/blog/java/datasource/B%E6%A0%91%E3%80%81B+%E6%A0%91%E8%AF%A6%E8%A7%A3/</id>
    <link href="http://www.zhangsj.xyz/blog/java/datasource/B%E6%A0%91%E3%80%81B+%E6%A0%91%E8%AF%A6%E8%A7%A3/"/>
    <updated>2022-03-30T16:33:06.000Z</updated>
    <content type="html"><![CDATA[<h2 id="b树、b-树详解"> B树、B+树详解</h2>
<p>B-树是一种多路自平衡的搜索树（B树是一颗多路平衡查找树），它类似普通的平衡二叉树，不同的一点是B-树允许每个节点有更多的子节点。下图是 B-树的简化图.</p>
<p><a href="./img/b%E6%A0%91.png"></a></p>
<p>B-树有如下特点:</p>
<ol>
<li>所有键值分布在整颗树中（索引值和具体data都在每个节点里）；</li>
<li>任何一个关键字出现且只出现在一个结点中；</li>
<li>搜索有可能在非叶子结点结束（最好情况O(1)就能找到数据）；</li>
<li>在关键字全集内做一次查找,性能逼近二分查找</li>
</ol>
<p>B-树是一类树，包括B-树、B+树、B*树等，是一棵自平衡的搜索树，它类似普通的平衡二叉树，不同的一点是B-树允许每个节点有更多的子节点。</p>
<p>B-树是专门为外部存储器设计的，如磁盘，它对于读取和写入大块数据有良好的性能，所以一般被用在文件系统及数据库中。</p>
<p>定义只需要知道B-树允许每个节点有更多的子节点即可（多叉树）。子节点数量一般在上千，具体数量依赖外部存储器的特性。</p>
<h3 id="出现背景"> 出现背景</h3>
<p>先来看看为什么会出现B-树这类数据结构。</p>
<p>传统用来搜索的平衡二叉树有很多，如 AVL 树，红黑树等。这些树在一般情况下查询性能非常好，但当数据非常大的时候它们就无能为力了。</p>
<p>原因当数据量非常大时，内存不够用，大部分数据只能存放在磁盘上，只有需要的数据才加载到内存中。一般而言内存访问的时间约为 50 ns，而磁盘在 10 ms 左右。速度相差了近 5 个数量级，磁盘读取时间远远超过了数据在内存中比较的时间。</p>
<p>这说明程序大部分时间会阻塞在磁盘IO上。那么我们如何提高程序性能？</p>
<p>减少磁盘 IO 次数，像 AVL 树，红黑树这类平衡二叉树从设计上无法“迎合”磁盘。</p>
<div><p>相关信息</p>
<p>在磁盘中组织查找结构，从任何一个结点指向其他结点都有可能读取一次磁盘数据，再将数据写入内存进行比较。频繁的磁盘IO操作，效率是很低下的(机械运动比电子运动要慢不知道多少)。显而易见，所有的二叉树的查找结构在磁盘中都是低效的。</p>
</div>
<h2 id="b-树"> B+树</h2>
<p>B+树 是 B-树的一种变体，在 磁盘查找结构中，B + 树更适合文件系统的磁盘存储结构。</p>
<p>B-树 是 平衡多路查找树，所有结点 中 都 包含了 待查关键字的有效信息 (比如文件磁盘指针)。每 个 结点 若有 n 个关键字，则有n+1个指向其他结点的指针。</p>
<h3 id="b-树特征"> B+树特征</h3>
<ol>
<li>有m个子树的中间节点包含有m个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引；</li>
<li>所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而B 树的叶子节点并没有包括全部需要查找的信息)；</li>
<li>所有的非叶子结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)；</li>
</ol>
<h3 id="为什么说b-树比b树更适合数据库索引"> 为什么说B+树比B树更适合数据库索引？</h3>
<ol>
<li>磁盘读写代价更低，在相同数量的待查数据下，B+树查找过程中需要调用的磁盘IO操作要少于普通B-树。由于B+树所在的磁盘存储背景下，因此B+树的查找性能要好于B-树。</li>
<li>B+树的查找效率更加稳定，因为所有叶子结点都处于同一层中，而且查找所有关键字都必须走完从根结点到叶子结点的全部历程。因此同一颗B+树中，任何关键字的查找比较次数都是一样的。而B树就不一定了，可能查找到某一个非终结点就结束了。</li>
<li>B+树便于范围查询（数据库的常态），B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低；</li>
</ol>
<p>插入删除对比：B+树与B-树在插入删除操作中的效率是差不多的。</p>
<div><p>总体评价</p>
<p>在应用背景下，特别是文件结构存储中。B+树的应用要更多，其效率也要比B-树好。</p>
<p>B树的范围查找用的是中序遍历，而B+树用的是在链表上遍历；</p>
</div>
<p>参考</p>
<p><a href="https://zhuanlan.zhihu.com/p/54102723" target="_blank" rel="noopener noreferrer">漫画：什么是B+树？</a></p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="mysql"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-03-07T11:15:46.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">mysql-master-slave-replication</title>
    <id>http://www.zhangsj.xyz/blog/java/datasource/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</id>
    <link href="http://www.zhangsj.xyz/blog/java/datasource/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <updated>2022-04-12T10:55:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="mysql主从复制"> mysql主从复制</h2>
<p>MySQL主从复制是一个异步的复制过程，底层是基于数据库自带的二进制日志功能。就是一台或多台MySQL数据库（slave，即从库）从另一台MySQL数据库（</p>
<ul>
<li>master将改变纪录到二进制日志（binary log)</li>
<li>slave将master的binary log拷贝到它的中继日志（relay log）</li>
<li>slave重做中继日志中的事件，将改变应用到自己的数据库中。</li>
</ul>
<p>搭建，实现主从同步。 (两阶段提交)</p>
<p>配置-前置条件</p>
<p>提前准备好两台服务器，分别安装MySQL并启动服务成功。</p>
<ul>
<li>主库（master） 192.168.138.100</li>
<li>从库（slave） 192.168.138.101</li>
</ul>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="mysql"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-04-12T10:55:02.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">liushiquery</title>
    <id>http://www.zhangsj.xyz/blog/java/datasource/MySQL%E6%B5%81%E5%BC%8F%E6%9F%A5%E8%AF%A2/</id>
    <link href="http://www.zhangsj.xyz/blog/java/datasource/MySQL%E6%B5%81%E5%BC%8F%E6%9F%A5%E8%AF%A2/"/>
    <updated>2022-03-24T01:58:17.000Z</updated>
    <content type="html"><![CDATA[<div><p>前言</p>
<p>程序访问MySQL数据库时，当查询出来的数据量特别大时，数据库驱动把加载到的数据全部加载到内存里，就有可能会导致内存溢出（OOM）。</p>
<p>其实在MySQL数据库中提供了流式查询，允许把符合条件的数据分批一部分一部分地加载到内存中，可以有效避免OOM；</p>
<p>本文主要介绍如何使用流式查询并对比普通查询进行性能测试。</p>
</div>
<p>查询成功后不是返回一个集合而是返回一个迭代器，应用每次从迭代器去一条查询结果。流式查询的好处是能够降低内存使用。</p>
<p>如果没有流式查询，我们想要从数据库取1000W 记录而有没有足够的内存时，就不得不分页查询，而分页查询效率取决于表设计，如果设计的不好，就无法执行高效的分页查询。因此流式查询是一个数据库访问框架必须具备的功能。</p>
<p>流式查询的过程中，数据库连接是保持打开状态的，因此要注意的是：执行一个流式查询后，数据库访问框架就不负责数据库连接了，需要应用去完数据后自己关闭。</p>
<h2 id="基于mybatis实现流式查询"> 基于mybatis实现流式查询</h2>
<p>MyBatis提供了一个叫org.apache
.ibatis.cursor.Cursor
的接口类用于流式查询，这个接口继承了java.io
.Closeable和java.lang
.Iterable接口，由此可知：</p>
<ol>
<li>Cursor是可关闭的</li>
<li>Cursor是可遍历的</li>
</ol>
<p>除此之外，Cursor还提供了三个方法：</p>
<ol>
<li>isOpen
(): 用于在取数据之前判断Cursor
对象是否是打开状态只有当打开时Cursor才能取数据；</li>
<li>isConsumed():用于判断查询结果是否全部取完</li>
<li>getCurrentIndex (): 返回已经获取了多少条数据</li>
</ol>
<p>talk is cheap, show me the code</p>
<div><pre><code><span>package</span> <span>com<span>.</span>aeert<span>.</span>streamquery<span>.</span>service<span>.</span>impl</span><span>;</span>
 
<span>import</span> <span>com<span>.</span>aeert<span>.</span>streamquery<span>.</span>dao<span>.</span></span><span>ArticleDao</span><span>;</span>
<span>import</span> <span>com<span>.</span>aeert<span>.</span>streamquery<span>.</span>entity<span>.</span></span><span>ArticleEntity</span><span>;</span>
<span>import</span> <span>com<span>.</span>aeert<span>.</span>streamquery<span>.</span>service<span>.</span></span><span>ArticleService</span><span>;</span>
<span>import</span> <span>com<span>.</span>baomidou<span>.</span>mybatisplus<span>.</span>extension<span>.</span>service<span>.</span>impl<span>.</span></span><span>ServiceImpl</span><span>;</span>
<span>import</span> <span>org<span>.</span>apache<span>.</span>ibatis<span>.</span>cursor<span>.</span></span><span>Cursor</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>stereotype<span>.</span></span><span>Service</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>transaction<span>.</span>annotation<span>.</span></span><span>Transactional</span><span>;</span>
 
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Iterator</span><span>;</span>
 
<span>/**
 * @Author l'amour solitaire
 * @Description articleService
 * @Date 2020/12/22 下午7:57
 **/</span>
<span>@Service</span><span>(</span><span>"articleService"</span><span>)</span>
<span>public</span> <span>class</span> <span>ArticleServiceImpl</span> <span>extends</span> <span>ServiceImpl</span><span><span>&lt;</span><span>ArticleDao</span><span>,</span> <span>ArticleEntity</span><span>></span></span> <span>implements</span> <span>ArticleService</span> <span>{</span>
 
    <span>@Override</span>
    <span>@Transactional</span><span>(</span>rollbackFor <span>=</span> <span>Exception</span><span>.</span><span>class</span><span>)</span>
    <span>public</span> <span>void</span> <span>queryByCursor</span><span>(</span><span>)</span> <span>{</span>
        <span>try</span> <span>(</span><span>Cursor</span><span><span>&lt;</span><span>ArticleEntity</span><span>></span></span> articleEntityCursor <span>=</span> baseMapper<span>.</span><span>queryByCursor</span><span>(</span><span>)</span><span>;</span><span>)</span> <span>{</span>
            <span>Iterator</span><span><span>&lt;</span><span>ArticleEntity</span><span>></span></span> articleEntityIterator <span>=</span> articleEntityCursor<span>.</span><span>iterator</span><span>(</span><span>)</span><span>;</span>
            <span>while</span> <span>(</span>articleEntityIterator<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>articleEntityIterator<span>.</span><span>next</span><span>(</span><span>)</span><span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><blockquote>
<p>⚠️注意这里的@Transactional ，没有这个的话会抛异常 java.lang.IllegalStateException: A Cursor is already closed.
这是因为我们前面说了在取数据的过程中需要保持数据库连接，而 Mapper 方法通常在执行完后连接就关闭了，因此 Cusor 也一并关闭了。</p>
</blockquote>
<p>所以，解决这个问题的思路不复杂，保持数据库连接打开即可。我们至少有三种方案可选。这里我们用的是方案三；</p>
<h3 id="方案一-sqlsessionfactory"> 方案一：SqlSessionFactory</h3>
<p>我们可以用 SqlSessionFactory 来手工打开数据库连接，将 Controller 方法修改如下：</p>
<div><pre><code><span>@GetMapping</span><span>(</span><span>"foo/scan/1/{limit}"</span><span>)</span>
<span>public</span> <span>void</span> <span>scanFoo1</span><span>(</span><span>@PathVariable</span><span>(</span><span>"limit"</span><span>)</span> <span>int</span> limit<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
    <span>try</span> <span>(</span>
        <span>SqlSession</span> sqlSession <span>=</span> sqlSessionFactory<span>.</span><span>openSession</span><span>(</span><span>)</span><span>;</span>  <span>// 1</span>
        <span>Cursor</span><span><span>&lt;</span><span>Foo</span><span>></span></span> cursor <span>=</span> 
              sqlSession<span>.</span><span>getMapper</span><span>(</span><span>FooMapper</span><span>.</span><span>class</span><span>)</span><span>.</span><span>scan</span><span>(</span>limit<span>)</span>   <span>// 2</span>
    <span>)</span> <span>{</span>
        cursor<span>.</span><span>forEach</span><span>(</span>foo <span>-></span> <span>{</span> <span>}</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>上面的代码中，</p>
<ol>
<li>处我们开启了一个 SqlSession （实际上也代表了一个数据库连接），并保证它最后能关闭；</li>
<li>处我们使用 SqlSession 来获得 Mapper 对象。这样才能保证得到的 Cursor 对象是打开状态的。</li>
</ol>
<h3 id="方案二-transactiontemplate"> 方案二：TransactionTemplate</h3>
<p>在 Spring 中，我们可以用 TransactionTemplate 来执行一个数据库事务，这个过程中数据库连接同样是打开的。代码如下：</p>
<div><pre><code><span>@GetMapping</span><span>(</span><span>"foo/scan/2/{limit}"</span><span>)</span>
<span>public</span> <span>void</span> <span>scanFoo2</span><span>(</span><span>@PathVariable</span><span>(</span><span>"limit"</span><span>)</span> <span>int</span> limit<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
    <span>TransactionTemplate</span> transactionTemplate <span>=</span> 
            <span>new</span> <span>TransactionTemplate</span><span>(</span>transactionManager<span>)</span><span>;</span>  <span>// 1</span>
 
    transactionTemplate<span>.</span><span>execute</span><span>(</span>status <span>-></span> <span>{</span>               <span>// 2</span>
        <span>try</span> <span>(</span><span>Cursor</span><span><span>&lt;</span><span>Foo</span><span>></span></span> cursor <span>=</span> fooMapper<span>.</span><span>scan</span><span>(</span>limit<span>)</span><span>)</span> <span>{</span>
            cursor<span>.</span><span>forEach</span><span>(</span>foo <span>-></span> <span>{</span> <span>}</span><span>)</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>IOException</span> e<span>)</span> <span>{</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>上面的代码中，</p>
<ol>
<li>处我们创建了一个 TransactionTemplate 对象（此处 transactionManager 是怎么来的不用多解释，本文假设读者对 Spring 数据库事务的使用比较熟悉了），</li>
<li>处执行数据库事务，而数据库事务的内容则是调用 Mapper 对象的流式查询。注意这里的 Mapper 对象无需通过 SqlSession 创建。</li>
</ol>
<h3 id="方案三-transactional-注解"> 方案三：@Transactional 注解</h3>
<p>这个本质上和方案二一样，代码如下：</p>
<div><pre><code><span>@GetMapping</span><span>(</span><span>"foo/scan/3/{limit}"</span><span>)</span>
<span>@Transactional</span>
<span>public</span> <span>void</span> <span>scanFoo3</span><span>(</span><span>@PathVariable</span><span>(</span><span>"limit"</span><span>)</span> <span>int</span> limit<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
    <span>try</span> <span>(</span><span>Cursor</span><span><span>&lt;</span><span>Foo</span><span>></span></span> cursor <span>=</span> fooMapper<span>.</span><span>scan</span><span>(</span>limit<span>)</span><span>)</span> <span>{</span>
        cursor<span>.</span><span>forEach</span><span>(</span>foo <span>-></span> <span>{</span> <span>}</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>它仅仅是在原来方法上面加了个 <code>@Transactional</code> 注解。这个方案看上去最简洁，但请注意 Spring 框架当中注解使用的坑：只在外部调用时生效。在当前类中调用这个方法，依旧会报错。</p>
<h2 id="jdbc实现流式查询"> JDBC实现流式查询</h2>
<p>使用JDBC的<code>PreparedStatement/Statement</code>的<code>setFetchSize</code>方法设置为 <code>Integer.MIN_VALUE</code>或使用方法<code>Statement.enableStreamingResults()</code>可以实现流式查询，在执行<code>ResultSet.next()</code>方法时，会通过数据库连接一条一条的返回，这样也不会大量占用客户端的内存。</p>
<div><pre><code><span>public</span> <span>int</span> <span>execute</span><span>(</span><span>String</span> sql<span>,</span> <span>boolean</span> isStreamQuery<span>)</span> <span>throws</span> <span>SQLException</span> <span>{</span>
    <span>Connection</span> conn <span>=</span> <span>null</span><span>;</span>
    <span>PreparedStatement</span> stmt <span>=</span> <span>null</span><span>;</span>
    <span>ResultSet</span> rs <span>=</span> <span>null</span><span>;</span>
    <span>int</span> count <span>=</span> <span>0</span><span>;</span>
    <span>try</span> <span>{</span>
        <span>//获取数据库连接</span>
        conn <span>=</span> <span>getConnection</span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>isStreamQuery<span>)</span> <span>{</span>
            <span>//设置流式查询参数</span>
            stmt <span>=</span> conn<span>.</span><span>prepareStatement</span><span>(</span>sql<span>,</span> <span>ResultSet</span><span>.</span>TYPE_FORWARD_ONLY<span>,</span> <span>ResultSet</span><span>.</span>CONCUR_READ_ONLY<span>)</span><span>;</span>
            stmt<span>.</span><span>setFetchSize</span><span>(</span><span>Integer</span><span>.</span>MIN_VALUE<span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>//普通查询</span>
            stmt <span>=</span> conn<span>.</span><span>prepareStatement</span><span>(</span>sql<span>)</span><span>;</span>
        <span>}</span>

        <span>//执行查询获取结果</span>
        rs <span>=</span> stmt<span>.</span><span>executeQuery</span><span>(</span><span>)</span><span>;</span>
        <span>//遍历结果</span>
        <span>while</span><span>(</span>rs<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span><span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>rs<span>.</span><span>getString</span><span>(</span><span>1</span><span>)</span><span>)</span><span>;</span>
            count<span>++</span><span>;</span>
        <span>}</span>
    <span>}</span> <span>catch</span> <span>(</span><span>SQLException</span> e<span>)</span> <span>{</span>
        e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
    <span>}</span> <span>finally</span> <span>{</span>
        <span>close</span><span>(</span>stmt<span>,</span> rs<span>,</span> conn<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> count<span>;</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>MySQL流式查询对于内存占用方面的优化还是比较明显的，但是对于查询速度的影响较小，主要用于解决大数据量查询时的内存占用多的场景。</p>
<p><a href=""></a></p>
<div><pre><code><span>SELECT</span> <span>*</span> <span>FROM</span> bj_setl_d <span>WHERE</span> ownpay_setl_flag <span>=</span> <span>'3'</span> <span>AND</span> refd_setl_flag <span>=</span> <span>'0'</span> <span>AND</span> medfee_sumamt <span>></span> <span>'1500'</span> <span>AND</span> med_type <span>IN</span> <span>(</span> <span>11</span><span>,</span><span>12</span><span>,</span><span>13</span><span>,</span><span>14</span><span>,</span><span>19</span><span>,</span><span>51</span><span>,</span><span>53</span><span>,</span><span>91</span><span>,</span><span>1105</span><span>,</span><span>1104</span><span>,</span><span>9901</span><span>,</span><span>9903</span><span>,</span><span>9905</span><span>,</span><span>9906</span><span>,</span><span>9914</span><span>,</span><span>530102</span> <span>)</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="mysql"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2021-08-03T00:00:00.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">MySQL index</title>
    <id>http://www.zhangsj.xyz/blog/java/datasource/MySql%E7%B4%A2%E5%BC%95/</id>
    <link href="http://www.zhangsj.xyz/blog/java/datasource/MySql%E7%B4%A2%E5%BC%95/"/>
    <updated>2022-03-21T07:27:48.000Z</updated>
    <content type="html"><![CDATA[<h2 id="sql调优"> sql调优</h2>
<h3 id="使用exists代替in"> 使用exists代替in</h3>
<div><pre><code>
<span>select</span> name <span>from</span> a <span>where</span> id <span>in</span><span>(</span><span>select</span> id <span>from</span> b<span>)</span>

<span>-- 如果我们将这条语句换成下面的写法：</span>

<span>select</span> name <span>from</span> a <span>where</span> <span>exists</span><span>(</span><span>select</span> <span>1</span> <span>from</span> b <span>where</span> id <span>=</span> a<span>.</span>id<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="避免在-where-子句中对字段进行函数操作。"> 避免在 where 子句中对字段进行函数操作。</h3>
<div><pre><code><span>select</span> id <span>from</span> <span>table</span> <span>where</span> substring<span>(</span>name<span>,</span><span>1</span><span>,</span><span>2</span><span>)</span> <span>=</span> <span>'zs'</span>

<span>--或</span>

<span>select</span> id <span>from</span> <span>table</span> <span>where</span> datediff<span>(</span><span>day</span><span>,</span>datefield<span>,</span><span>'2022-07-17'</span><span>)</span> <span>>=</span> <span>0</span>    

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="like-中通配符的使用。"> like 中通配符的使用。</h3>
<p>下面的语句会导致全表扫描，尽量少用。如：</p>
<div><pre><code><span>select</span> id <span>from</span> tabel <span>where</span> name <span>like</span><span>'%zs%'</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="between-and-代替-in-少用-in-或-not-in"> between and 代替 in 少用 in 或 not in</h3>
<div><pre><code><span>select</span> name <span>from</span> tabel <span>where</span> id <span>in</span><span>(</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>,</span><span>5</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>像这种连续的数值，我们可以使用 BETWEEN AND，如：</p>
<div><pre><code><span>select</span> name <span>from</span> tabel <span>where</span> id <span>between</span> <span>1</span> <span>and</span> <span>5</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="避免在-where-子句中使用-or来链接条件。"> 避免在 where 子句中使用 or来链接条件。</h3>
<div><pre><code><span>select</span> id <span>from</span> tabel <span>where</span> name <span>=</span> <span>'zs'</span> <span>or</span> name <span>=</span> <span>'PHP'</span>

<span>-- 这种情况，我们可以这样写：</span>

<span>select</span> id <span>from</span> tabel <span>where</span> name <span>=</span> <span>'zs'</span>

<span>union</span> <span>all</span>

<span>select</span> id <span>from</span> tabel <span>where</span> name <span>=</span> <span>'PHP'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="避免在-where-子句中使用-或-操作符。"> 避免在 where 子句中使用 != 或 &lt;&gt; 操作符。</h3>
<p>避免在where子句中使用 is null 或 is not null 对字段进行判断。</p>
<p>如：</p>
<div><pre><code><span>select</span> id <span>from</span> <span>table</span> <span>where</span> name <span>is</span> <span>null</span><span>`</span>
</code></pre>
<div><span>1</span><br></div></div><p>在这个查询中，就算我们为 name 字段设置了索引，查询分析器也不会使用，因此查询效率底下。</p>
<p>为了避免这样的查询，在数据库设计的时候，尽量将可能会出现 null 值的字段设置默认值，这里如果我们将 name 字段的默认值设置为0，那么我们就可以这样查询：</p>
<div><pre><code><span>select</span> id <span>from</span> <span>table</span> <span>where</span> name <span>=</span> <span>0</span><span>`</span>
</code></pre>
<div><span>1</span><br></div></div><p>索引不存储空值，如果不限制索引列是not null，数据库会认为索引列有可能存在空值，所以不会按照索引进行计算。</p>
<h3 id="最左原则"> 最左原则</h3>
<p>复合索引中索引列按顺序查询，如果不是按照索引的最左列开始查找，则无法使用索引</p>
<h3 id="覆盖索引"> 覆盖索引</h3>
<p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p>
<p>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，
而无需回表查询。</p>
<p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。</p>
<p>再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。</p>
<h2 id="创建索引的注意事项"> 创建索引的注意事项</h2>
<p>1、选择合适的字段创建索引：</p>
<ul>
<li>不为<code>NULL</code>的字段 ：索引字段的数据应该尽量不为<code>NULL</code>，因为对于数据为 <code>NULL</code> 的字段，数据库较难优化。</li>
<li>如果字段频繁被查询，但又避免不了为 NULL ，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</li>
<li>被频繁查询的字段 ：我们创建索引的字段应该是查询操作非常频繁的字段。</li>
<li>被作为条件查询的字段 ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</li>
<li>频繁需要排序的字段 ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li>
<li>被经常频繁用于连接的字段 ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</li>
</ul>
<p>2、被频繁更新的字段应该慎重建立索引。</p>
<p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p>
<p>3、尽可能的考虑建立联合索引而不是单列索引。</p>
<p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。</p>
<p>如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p>
<p>4、注意避免冗余索引 。</p>
<p>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p>
<p>5、考虑在字符串类型的字段上使用前缀索引代替普通索引。</p>
<p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p>
<p>1.普通索引 添加INDEX</p>
<div><pre><code><span>ALTER</span> <span>TABLE</span> <span><span>`</span>table_name<span>`</span></span> <span>ADD</span> <span>INDEX</span> index_name <span>(</span> <span><span>`</span>column<span>`</span></span> <span>)</span>

</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>下面演示下给user表的name字段添加一个索引</p>
<p>2.主键索引 添加PRIMARY KEY</p>
<div><pre><code><span>ALTER</span> <span>TABLE</span> <span><span>`</span>table_name<span>`</span></span> <span>ADD</span> <span>PRIMARY</span> <span>KEY</span> <span>(</span> <span><span>`</span>column<span>`</span></span> <span>)</span>

</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>3.唯一索引 添加UNIQUE</p>
<div><pre><code><span>ALTER</span> <span>TABLE</span> <span><span>`</span>table_name<span>`</span></span> <span>ADD</span> <span>UNIQUE</span> <span>(</span> <span><span>`</span>column<span>`</span></span> <span>)</span>

</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>4.全文索引 添加FULLTEXT</p>
<div><pre><code><span>ALTER</span> <span>TABLE</span> <span><span>`</span>table_name<span>`</span></span> <span>ADD</span> FULLTEXT <span>(</span> <span><span>`</span>column<span>`</span></span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>5.如何添加多列索引</p>
<div><pre><code><span>ALTER</span> <span>TABLE</span> <span><span>`</span>table_name<span>`</span></span> <span>ADD</span> <span>INDEX</span> index_name <span>(</span> <span><span>`</span>column1<span>`</span></span><span>,</span> <span><span>`</span>column2<span>`</span></span><span>,</span> <span><span>`</span>column3<span>`</span></span> <span>)</span>

</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="mysql"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-03-18T00:00:00.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">datasource mulu</title>
    <id>http://www.zhangsj.xyz/blog/java/datasource/</id>
    <link href="http://www.zhangsj.xyz/blog/java/datasource/"/>
    <updated>2022-03-24T03:51:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="mysql目录"> MySQL目录</h2>
<ul>
<li><a href="./B树、B+树详解.html">索引结构 b&amp;b+树</a></li>
<li><a href="./mysql调优.html">sql优化</a></li>
<li><a href="./MySQL流式查询.html">Mysql流式查询</a></li>
<li><a href="./mysql事务.html">mysql事务</a></li>
<li><a href="./存储引擎.html">存储引擎</a></li>
<li><a href="./mysql调优.html">mysql调优</a></li>
</ul>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="mulu"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2021-10-01T00:00:00.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">explain</title>
    <id>http://www.zhangsj.xyz/blog/java/datasource/explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/</id>
    <link href="http://www.zhangsj.xyz/blog/java/datasource/explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/"/>
    <updated>2022-04-12T10:55:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="explain-执行计划"> explain 执行计划</h2>
<p>合理设计并利用索引</p>
<p>使用EXPLAIN关键字，可以模拟Mysql优化器执行SQL语句，分析查询语句的性能。</p>
<p>在select语句之前加上explain关键字，mysql会在查询上设置一个标记，执行查询的时候并不是真正的执行sql语句，而是返回该语句的<code>执行计划</code>。</p>
<p>注意：如果from钟包含子查询，任然会执行该子查询，将结果放入临时表。</p>
<h2 id="explain中"> explain中</h2>
<ol>
<li><code>id</code>列的编号是select的序列号，有几个select就有几个id，并且id的大小是根据select出现的先后顺序增长的。id数值越大越先执行，id相同则从上往下执行，id为null的最后执行。</li>
<li><code>select_type</code></li>
</ol>
<ul>
<li>①simple：简单查询，不包含子查询和union的查询</li>
<li>②primary：复杂查询中最外层的select。</li>
<li>③subquery：包含在select中的子查询（不在from字句中）。</li>
<li>④derived：包含在from子句中的子查询。mysql会将结果放在一个临时表中，也叫派生表。</li>
<li>⑤union：在union中的第二个和随后的select。
3、table 这一列表示explain的一行正在访问哪个表。</li>
<li>当from子句中有子查询的时候，table列是的格式，表示当前查询依赖id=N的查询。</li>
<li>当有union的时候，table列的值为&lt;union1,2&gt;的格式，1和2表示参与union的select行id。</li>
</ul>
<ol start="4">
<li>type <i>Not supported content</i></li>
</ol>
<p>这一列表示关联类型或者访问类型，也可以理解成mysql是如何决定查找表中的行，查找数据行的大概范围。性能从优到差分别为：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL，一般来说需要保证查询达到range级别，最好达到ref。</p>
<p>①null：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：再索引列中取最小值可以单独查找索引来完成，不需要在执行时访问表。</p>
<p>②：const，system：mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。用于 primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。system是 const的特例，表里只有一条元组匹配时为system。</p>
<p>③eq_ref:primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。</p>
<p>④ref：相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会 找到多个符合条件的行。</p>
<p>简单 select 查询，name是普通索引（非唯一索引）</p>
<p>⑤range：范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;= 等操作中。使用一个索引来检索给定范围的行。</p>
<p>⑥index：扫描全索引就能拿到结果，一般是扫描某个二级索引，这种扫描不会从索引树根节点开始快速查找，而是直接 对二级索引的叶子节点遍历和扫描，速度还是比较慢的，这种查询一般为使用覆盖索引，二级索引一般比较小，所以这 种通常比ALL快一些。</p>
<p>⑦ALL:即全表扫描，扫描你的聚簇索引的所有叶子节点。通常情况下这需要增加索引来进行优化了。</p>
<p>5、possible_keys</p>
<p>这一列显示查询可能使用哪些索引来查找。 explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引 对此查询帮助不大，选择了全表查询。 如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提 高查询性能，然后用 explain 查看效果。</p>
<p>6、key</p>
<p>这一列显示mysql实际采用哪个索引来优化对该表的访问。 如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，在查询中使用 force index、ignore index。</p>
<p>7、key_len</p>
<p>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。 举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成，并且每个int是4字节。通 过结果中的key_len=4可推断出查询使用了第一个列：film_id列来执行索引查找。</p>
<p>key_len计算规则如下：</p>
<p>字符串</p>
<p>char(n) 和 varchar(n)，5.0.3 以后版本中，n均代表字符数，而不是字节数，如果是utf-8，一个数字或字母占1个字节，一个汉字占3个字节</p>
<p>char(n)：如果存汉字长度就是 3n 字节</p>
<p>varchar(n)：如果存汉字则长度是 3n + 2 字节，加的2字节用来存储字符串长度，因为 varchar是变长字符串</p>
<p>数值类型</p>
<p>tinyint：1字节
smallint：2字节
int：4字节
bigint：8字节</p>
<p>时间类型</p>
<p>date：3字节</p>
<p>timestamp：4字节</p>
<p>datetime：8字节</p>
<p>如果字段允许为 NULL，需要1字节记录是否为 NULL
索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索 引。</p>
<p>8、ref</p>
<p>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id）</p>
<p>9、rows</p>
<p>这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。</p>
<h3 id="extra"> extra</h3>
<p>Using filesort：</p>
<p>MySQL 需要额外的一次传递，以找出如何按排序顺序检索行。通过根据联接类型浏览所有行并为所有匹配WHERE子句的行保存排序关键字和行的指针完成排序。然后关键字被排序，并按排序顺序检索行</p>
<p>Using temporary：</p>
<p>使用了临时表保存中间结果，性能特别查，需要重点优化;</p>
<p>Using index： 使用覆盖索引，不需要通过辅助索引树找到主键，再通过主键去主键索引树里获取其它字段值。</p>
<p>Using index condition：MySQL5.6之后新增的ICP，using index condtion就是使用了ICP（索引下推），在存储引擎层进行数据过滤，而不是在服务层过滤，利用索引现有的数据减少回表的数据。</p>
<p>Select tables optimized away：</p>
<p>使用某些聚合函数（比如 max、min）来访问存在索引的某个字段</p>
<p>Using where：</p>
<p>使用 where 语句来处理结果，并且查询的列未被索引覆盖</p>
<p>5、确定问题并采用相应的措施</p>
<ul>
<li>优化索引；</li>
<li>优化SQL语句：修改SQL、IN 查询分段、时间查询分段、基于上一次数据过滤；</li>
<li>改用其他实现方式：ES、数仓等；</li>
<li>数据碎片处理。</li>
</ul>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="mysql"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2020-09-01T00:00:00.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">mysql shiwu</title>
    <id>http://www.zhangsj.xyz/blog/java/datasource/mysql%E4%BA%8B%E5%8A%A1/</id>
    <link href="http://www.zhangsj.xyz/blog/java/datasource/mysql%E4%BA%8B%E5%8A%A1/"/>
    <updated>2022-04-12T10:55:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="mysql特性"> mysql特性</h2>
<p>原子性：事务是一个不可分割的工作单位，事务中的操作要么都成功（commit），要么都失败（rollback）。</p>
<p>一致性：事务前后数据的完整性必须保持一致。 事务执行的结果必须使数据库从一个一致性状态变到另一个一致性的状态。在多个事务并行情况下；</p>
<p>持久性：指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</p>
<p>隔离性： 事务的隔离性是多个事务并行，每个事务不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。</p>
<h2 id="mysql事务隔离级别"> mysql事务隔离级别</h2>
<table>
<thead>
<tr>
<th style="text-align:center">事务隔离级别</th>
<th>概念</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">read uncommited</td>
<td>未提交读，读到未提交数据；这些未提交的数据可能会回滚；读到的数据就是脏数据，数据库中不存在这些数据；</td>
</tr>
<tr>
<td style="text-align:center">read committed</td>
<td>读已提交，也叫不可重复读，两次读取到的数据不一致；</td>
</tr>
<tr>
<td style="text-align:center">repetable read</td>
<td>可重复读；</td>
</tr>
<tr>
<td style="text-align:center">serializable</td>
<td>串行化，读写数据都会锁住整张表，数据操作不会出错，但并发性能极低，开发中很少用到。</td>
</tr>
</tbody>
</table>
<p>MySQL 默认使用 REPEATABLE-READ 的事务隔离级别。</p>
<p>不可重复读形成原因在于数据的修改：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）。</p>
<p>幻读形成原因主要在于数据的新增或删除：在同一事务中，同样的条件，第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）。</p>
<h3 id="redo-log"> redo log</h3>
<p>redo log是重做日志，提供前滚操作，</p>
<p>记录的是数据修改之后的值，不管事务是否提交都会记录下来。在mysql服务器宕机时，InnoDB存储引擎会使用redo log恢复到掉电前的时刻，以此来保证数据的完整性。</p>
<h3 id="undo-log"> undo log</h3>
<p>undo log是回滚日志，提供回滚操作。</p>
<p>保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读</p>
<h3 id="binlog"> binlog</h3>
<p>binlog是追加日志,又称为归档日志，属于逻辑日志，</p>
<p>binlog是属于MySQL Server层面的，又称为归档日志，属于逻辑日志，是记录原始的sql语句，逻辑</p>
<p>不支持高并发，以读为主</p>
<p>共享锁，排它锁，意向锁</p>
<h2 id="mvvc机制"> mvvc机制</h2>
<p>MVCC (Multi-Version Concurrency Control) (注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)是一种基于多版本的并发控制协议，只有在InnoDB引擎下存在。</p>
<p>MVCC是为了实现事务的隔离性，通过版本号，避免同一数据在不同事务间的竞争，你可以把它当成基于多版本号的一种乐观锁。</p>
<p>当然，这种乐观锁只在事务级别提交读和可重复读有效。MVCC最大的好处，相信也是耳熟能详：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能。</p>
<div><p>OLTP</p>
<p>On-Line Transaction Processing联机事务处理过程(OLTP)，也称为面向交易的处理过程，其基本特征是前台接收的用户数据可以立即传送到计算中心进行处理，并在很短的时间内给出处理结果，是对用户操作快速响应的方式之一。</p>
</div>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="mysql"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-28T00:00:00.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">sql tiaoyou</title>
    <id>http://www.zhangsj.xyz/blog/java/datasource/mysql%E8%B0%83%E4%BC%98/</id>
    <link href="http://www.zhangsj.xyz/blog/java/datasource/mysql%E8%B0%83%E4%BC%98/"/>
    <updated>2022-03-30T16:33:16.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一、前言"> 一、前言</h2>
<p>在应用开发的早期，数据量少，开发人员开发功能时更重视功能上的实现，随着生产数据的增长，很多SQL语句开始暴露出性能问题，对生产的影响也越来越大，有时可能这些有问题的SQL就是整个系统性能的瓶颈。</p>
<h2 id="二、sql优化一般步骤"> 二、SQL优化一般步骤</h2>
<p><strong>1、通过慢查日志等定位那些执行效率较低的SQL语句</strong></p>
<p><strong>2、explain 分析SQL的执行计划</strong></p>
<p>需要重点关注 type、rows、filtered 、extra。</p>
<p>type由上至下，效率越来越高。</p>
<p>ALL 全表扫描；</p>
<p>index 索引全扫描；</p>
<p>range 索引范围扫描，常用语&lt;,&lt;=,&gt;=,between,in等操作；</p>
<p>ref 使用非唯一索引扫描或唯一索引前缀扫描，返回单条记录，常出现在关联查询中；</p>
<p>eq_ref 类似ref，区别在于使用的是唯一索引，使用主键的关联查询；</p>
<p>const/system 单条记录，系统会把匹配行中的其他列作为常数处理，如主键或唯一索引查询；</p>
<p>null MySQL不访问任何表或索引，直接返回结果；</p>
<p>虽然上至下，效率越来越高，但是根据cost模型，假设有两个索引idx1(a, b, c),idx2(a, c)，SQL为</p>
<div><pre><code><span><span>`</span>select * from t where a = 1 and b in (1, 2) order by c<span>`</span></span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>如果走idx1，那么是type为 <code>range</code> ，如果走idx2，那么type是<code>ref</code>；当需要扫描的行数，使用idx2大约是idx1的5倍以上时，会用idx1，否则会用idx2。</p>
<p><strong>Extra</strong></p>
<ul>
<li>
<p>Using filesort：MySQL 需要额外的一次传递，以找出如何按排序顺序检索行。通过根据联接类型浏览所有行并为所有匹配WHERE子句的行保存排序关键字和行的指针来完成排序。然后关键字被排序，并按排序顺序检索行；</p>
</li>
<li>
<p>Using temporary ：使用了临时表保存中间结果，性能特别差，需要重点优化；</p>
</li>
<li>
<p>Using index：表示相应的 select 操作中使用了覆盖索引（Coveing Index）,避免访问了表的数据行，效率不错！如果同时出现 using where，意味着无法直接通过索引查找来查询到符合条件的数据；</p>
</li>
<li>
<p>Using index condition ：MySQL5.6之后新增的ICP，using index condtion就是使用了ICP（索引下推），在存储引擎层进行数据过滤，而不是在服务层过滤，利用索引现有的数据减少回表的数据。</p>
</li>
</ul>
<p><strong>3、show profile 分析</strong></p>
<p>了解SQL执行的线程的状态及消耗的时间。</p>
<p>默认是关闭的，开启语句“set profiling = 1;”</p>
<div><pre><code><span>SHOW</span> PROFILES <span>;</span>
<span>SHOW</span> PROFILE <span>FOR</span> QUERY  <span>#{id};</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>4、trace</strong></p>
<p>trace分析优化器如何选择执行计划，通过trace文件能够进一步了解为什么优惠券选择A执行计划而不选择B执行计划。</p>
<div><pre><code><span>set</span> optimizer_trace<span>=</span><span>"enabled=on"</span><span>;</span>
<span>set</span> optimizer_trace_max_mem_size<span>=</span><span>1000000</span><span>;</span>
<span>select</span> <span>*</span> <span>from</span> information_schema<span>.</span>optimizer_trace<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>5、确定问题并采用相应的措施</strong></p>
<p>优化索引；</p>
<p>优化SQL语句：修改SQL、IN 查询分段、时间查询分段、基于上一次数据过滤；</p>
<p>改用其他实现方式：ES、数仓等；</p>
<p>数据碎片处理。</p>
<h2 id="三、场景分析"> 三、场景分析</h2>
<h3 id="_1、最左匹配"> 1、最左匹配</h3>
<p><strong>1）索引</strong></p>
<p>KEY <code>idx_shopid_orderno</code> (<code>shop_id</code>,<code>order_no</code>)</p>
<p><strong>2）SQL语句</strong></p>
<p>select * from _t where orderno=''</p>
<p>查询匹配从左往右匹配，要使用order_no走索引，必须查询条件携带shop_id或者索引(shop_id,order_no)调换前后顺序。</p>
<h3 id="_2、隐式转换"> 2、隐式转换</h3>
<p><strong>1）索引</strong></p>
<div><pre><code><span>KEY</span> <span><span>`</span>idx_mobile<span>`</span></span> <span>(</span><span><span>`</span>mobile<span>`</span></span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>2）SQL语句</p>
<div><pre><code><span>select</span> <span>*</span> <span>from</span> _user <span>where</span> mobile<span>=</span><span>12345678901</span>
</code></pre>
<div><span>1</span><br></div></div><p>隐式转换相当于在索引上做运算，会让索引失效。mobile是字符类型，使用了数字，应该使用字符串匹配，否则MySQL会用到隐式替换，导致索引失效。</p>
<h3 id="_3、大分页"> 3、大分页</h3>
<p>1）索引</p>
<div><pre><code><span>KEY</span> <span><span>`</span>idx_a_b_c<span>`</span></span> <span>(</span><span><span>`</span>a<span>`</span></span><span>,</span> <span><span>`</span>b<span>`</span></span><span>,</span> <span><span>`</span>c<span>`</span></span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>2）SQL语句</p>
<div><pre><code><span>select</span> <span>*</span> <span>from</span> _t <span>where</span> a <span>=</span> <span>1</span> <span>and</span> b <span>=</span> <span>2</span> <span>order</span> <span>by</span> c <span>desc</span> <span>limit</span> <span>10000</span><span>,</span> <span>10</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>对于大分页的场景，可以优先让产品优化需求，如果没有优化的，有如下两种优化方式：</p>
<p>一种是把上一次的最后一条数据，也即上面的c传过来，然后做“c &lt; xxx”处理，但是这种一般需要改接口协议，并不一定可行；‘</p>
<p>另一种是采用延迟关联的方式进行处理，减少SQL回表，但是要记得索引需要完全覆盖才有效果，SQL改动如下：</p>
<div><pre><code><span>select</span> t1<span>.</span><span>*</span> <span>from</span> _t t1<span>,</span> <span>(</span><span>select</span> id <span>from</span> _t <span>where</span> a <span>=</span> <span>1</span> <span>and</span> b <span>=</span> <span>2</span> <span>order</span> <span>by</span> c <span>desc</span> <span>limit</span> <span>10000</span><span>,</span> <span>10</span><span>)</span> t2 <span>where</span> t1<span>.</span>id <span>=</span> t2<span>.</span>id<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="_4、in-order-by"> 4、in + order by</h3>
<p>1）索引</p>
<div><pre><code><span>KEY</span> <span><span>`</span>idx_shopid_status_created<span>`</span></span> <span>(</span><span><span>`</span>shop_id<span>`</span></span><span>,</span> <span><span>`</span>order_status<span>`</span></span><span>,</span> <span><span>`</span>created_at<span>`</span></span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>2）SQL语句</p>
<div><pre><code><span>select</span> <span>*</span> <span>from</span> _order <span>where</span> shop_id <span>=</span> <span>1</span> <span>and</span> order_status <span>in</span> <span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span> <span>order</span> <span>by</span> created_at <span>desc</span> <span>limit</span> <span>10</span>
</code></pre>
<div><span>1</span><br></div></div><p>in查询在MySQL底层是通过n*m的方式去搜索，类似union，但是效率比union高。</p>
<p>in查询在进行cost代价计算时（代价 = 元组数 * IO平均值），是通过将in包含的数值，一条条去查询获取元组数的，因此这个计算过程会比较的慢，所以MySQL设置了个临界值(eq_range_index_dive_limit)，5.6之后超过这个临界值后该列的cost就不参与计算了。因此会导致执行计划选择不准确。默认是200，即in条件超过了200个数据，会导致in的代价计算存在问题，可能会导致Mysql选择的索引不准确。</p>
<p>3）处理方式</p>
<p>可以(order_status, created_at)互换前后顺序，并且调整SQL为延迟关联。</p>
<h3 id="_5、范围查询阻断-后续字段不能走索引"> 5、范围查询阻断，后续字段不能走索引</h3>
<p>1）索引</p>
<div><pre><code><span>KEY</span> <span><span>`</span>idx_shopid_created_status<span>`</span></span> <span>(</span><span><span>`</span>shop_id<span>`</span></span><span>,</span> <span><span>`</span>created_at<span>`</span></span><span>,</span> <span><span>`</span>order_status<span>`</span></span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>2）SQL语句</p>
<div><pre><code><span>select</span> <span>*</span> <span>from</span> _order <span>where</span> shop_id <span>=</span> <span>1</span> <span>and</span> created_at <span>></span> <span>'2021-01-01 00:00:00'</span> <span>and</span> order_status <span>=</span> <span>10</span>
</code></pre>
<div><span>1</span><br></div></div><p>范围查询还有“IN、between”。</p>
<h3 id="_6、不等于、不包含不能用到索引的快速搜索"> 6、不等于、不包含不能用到索引的快速搜索</h3>
<p>可以用到ICP</p>
<div><pre><code><span>select</span> <span>*</span> <span>from</span> _order <span>where</span> shop_id<span>=</span><span>1</span> <span>and</span> order_status <span>not</span> <span>in</span> <span>(</span><span>1</span><span>,</span><span>2</span><span>)</span>
<span>select</span> <span>*</span> <span>from</span> _order <span>where</span> shop_id<span>=</span><span>1</span> <span>and</span> order_status <span>!=</span> <span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>在索引上，避免使用NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT EXISTS、NOT IN、NOT LIKE等。</p>
<h3 id="_7、优化器选择不使用索引的情况"> 7、优化器选择不使用索引的情况</h3>
<p>如果要求访问的数据量很小，则优化器还是会选择辅助索引，但是当访问的数据占整个表中数据的蛮大一部分时（一般是20%左右），优化器会选择通过聚集索引来查找数据。</p>
<div><pre><code><span>select</span> <span>*</span> <span>from</span> _order <span>where</span>  order_status <span>=</span> <span>1</span>
</code></pre>
<div><span>1</span><br></div></div><p>查询出所有未支付的订单，一般这种订单是很少的，即使建了索引，也没法使用索引。</p>
<h3 id="_8、复杂查询"> 8、复杂查询</h3>
<div><pre><code><span>select</span> <span>sum</span><span>(</span>amt<span>)</span> <span>from</span> _t <span>where</span> a <span>=</span> <span>1</span> <span>and</span> b <span>in</span> <span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span> <span>and</span> c <span>></span> <span>'2020-01-01'</span><span>;</span>
<span>select</span> <span>*</span> <span>from</span> _t <span>where</span> a <span>=</span> <span>1</span> <span>and</span> b <span>in</span> <span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span> <span>and</span> c <span>></span> <span>'2020-01-01'</span> <span>limit</span> <span>10</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>如果是统计某些数据，可能改用数仓进行解决；</p>
<p>如果是业务上就有那么复杂的查询，可能就不建议继续走SQL了，而是采用其他的方式进行解决，比如使用ES等进行解决。</p>
<h3 id="_9、asc和desc混用"> 9、asc和desc混用</h3>
<p><code>sql select * from _t where a=1 order by b desc, c asc</code></p>
<h3 id="_10、大数据"> 10、大数据</h3>
<p>对于推送业务的数据存储，可能数据量会很大，如果在方案的选择上，最终选择存储在MySQL上，并且做7天等有效期的保存。</p>
<p>那么需要注意，频繁的清理数据，会照成数据碎片，需要联系DBA进行数据碎片处理。</p>
<h2 id="tiaoyou"> tiaoyou</h2>
<p>MyCat 分库分表</p>
<p>对于一个千万级别的结算，订单表，我们可以用人员编号作为分库分表键，分散 8 个库，根据最后一位的值或者不同的分库分表健的策略定位到具体的表。</p>
<p>排查所有的 SQL 语句，把用到表关联的 SQL 语句，多表关联和 group by 的语句修改，或者添加冗余字段，或者分组，关联的逻辑在 java 业务写，或者优化将复杂的操作或者计算操作、一些分组计算写入缓存</p>
<p>Mycat 只能支持一些简单的 join，如果你的表都在同一个实例的话 join 是不影响的，跟 mysql 本身 join 一样，如果不在一个实例的表进行 join 貌似只支持两张表 join，并且还不能做太大数据量的 join</p>
<p>数据库调优方面解决过的问题，比如索引对应的字段重复率太高，所以索引没用到，解决方法是建复合索引，或 redis 缓存信息没设超时时间，导致内存爆掉，解决方法是设下限。</p>
<h2 id="mycat"> mycat</h2>
<p>水平切分，一个实体库切分成多个库</p>
<p>不可能！因为只有大数据量的用户相关业务才会用到水平切割！</p>
<p>数据库集群对外的统一访问入口</p>
<p><strong>核心文件：</strong></p>
<ul>
<li>schem.xml 配置参数：逻辑库，逻辑表，数据节点。节点主机</li>
<li>rule.xml：分片规则</li>
<li>server.xml：连接 mycat 的用户信息(账号和密码)</li>
</ul>
<p><code>Order by</code> 字段必须出现在 select 中(MyCat 先将结果取出，然后排序)</p>
<p><code>Group by</code> 务必使用标准语法 select count(1),type from tab_a group by type;</p>
<p>MyCat 的一些自带函数 sum，min，max 等可以正确使用，但多分片执行的 avg 有 bug，执行的结果是错误的谨慎使用子查询，外层查询没有分片查询条件，则会在所有分片上执行(子查询内外层的表一样较为特殊)</p>
<h3 id="场景分析"> 场景分析</h3>
<p>sql优化</p>
<p>财务流水表 1000w 分页查询 limit</p>
<p>优化前 17s
优化后 300ms</p>
<p>阿里巴巴Java开发手册 第五章-MySQL数据库 （二）索引规约、第7条：</p>
<p>【推荐】利用延迟关联或者子查询优化超多分页场景</p>
<p>说明：MySQL并不是挑过offset 行，而是去offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的底下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。</p>
<p>正例：先快速定位需要获取的id段，然后再关联：</p>
<p>索引</p>
<p>KEY <code>idx_a_b_c</code> (<code>a</code>, <code>b</code>, <code>c</code>)</p>
<div><pre><code><span>select</span> <span>*</span> <span>from</span> _t <span>where</span> a <span>=</span> <span>1</span> <span>and</span> b <span>=</span> <span>2</span> <span>order</span> <span>by</span> c <span>desc</span> <span>limit</span> <span>10000</span><span>,</span> <span>10</span><span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>对于大分页的场景，可以优先让产品优化需求，如果没有优化的，有如下两种优化方式：</p>
<ul>
<li>
<p>一种是把上一次的最后一条数据，也即上面的c 传过来，然后做“c &lt; xxx”处理，但是这种一般需要改接口协议，并不一定可行；‘</p>
</li>
<li>
<p>另一种是采用延迟关联的方式进行处理，减少SQL回表，但是要记得索引需要完全覆盖才有效果，SQL改动如下：</p>
</li>
</ul>
<div><pre><code><span>select</span> t1<span>.</span><span>*</span> <span>from</span> _t t1<span>,</span> <span>(</span><span>select</span> id <span>from</span> _t <span>where</span> a <span>=</span> <span>1</span> <span>and</span> b <span>=</span> <span>2</span> <span>order</span> <span>by</span> c <span>desc</span> <span>limit</span> <span>10000</span><span>,</span> <span>10</span><span>)</span> t2 <span>where</span> t1<span>.</span>id <span>=</span> t2<span>.</span>id<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>灌入大量数据，共500万</p>
]]></content>
    <author>
      <name>狼爷、zsj</name>
    </author>
    <category term="mysql"/>
    <contributor>
      <name>狼爷、zsj</name>
    </contributor>
    <published>2020-08-01T00:00:00.000Z</published>
    <rights>Copyright by 狼爷、zsj</rights>
  </entry>
  <entry>
    <title type="html">sql keyword</title>
    <id>http://www.zhangsj.xyz/blog/java/datasource/sql/</id>
    <link href="http://www.zhangsj.xyz/blog/java/datasource/sql/"/>
    <updated>2022-03-08T05:36:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="sql-case-语句"> SQL CASE 语句</h2>
<p>作为 if-then-else 之类逻辑的关键字。</p>
<p>SELECT CASE(&quot;栏位名”)</p>
<p>WHEN “条件 1” THEN “结果 1”</p>
<p>WHEN “条件 2” THEN “结果 2”</p>
<p>...</p>
<p>[ELSE “结果 N”]</p>
<p>END</p>
<p>FROM “表格名”</p>
<p>例：</p>
<div><pre><code><span>select</span> store_name<span>,</span> <span>(</span><span>case</span> store_name
<span>when</span> ’Los Angeles’ <span>then</span> sales<span>*</span><span>2</span>
<span>when</span> ‘San Diego’ <span>then</span> sales<span>*</span><span>1.5</span>
<span>else</span> sales <span>end</span><span>)</span> <span>as</span> “new sales”<span>,</span> <span>date</span>
<span>from</span> store_information<span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="create-index-语句-在不读取整个表的情况下-更快地查找数据"> CREATE INDEX 语句：在不读取整个表的情况下，更快地查找数据</h2>
<p>简单索引，允许使用重复的值：</p>
<p>CREATE INDEX index_name ON table_name (colunm_name);</p>
<h2 id="group-concat"> group_concat</h2>
<p>使用group_concat()和group by显示相同名字的人的id号：</p>
<p>将上面的id号从大到小排序，且用'_'作为分隔符：</p>
<p><strong>去重</strong></p>
<p>DISTINCT score</p>
<p><strong>设置分隔符</strong></p>
<p>score SEPARATOR ';'</p>
<p><strong>排序</strong></p>
<p>score ORDER BY score DESC</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="mysql"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-23T12:02:30.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">dataource</title>
    <id>http://www.zhangsj.xyz/blog/java/datasource/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</id>
    <link href="http://www.zhangsj.xyz/blog/java/datasource/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <updated>2022-03-30T16:33:06.000Z</updated>
    <content type="html"><![CDATA[<h2 id="innodb-myisam"> Innodb &amp;Myisam</h2>
<ol>
<li>myisam 是不支持支持事务；innodb支持事务。</li>
<li>myisam支持表级锁；innodb 支持行锁，粒度更小，但是在执行不能确定扫描范围的sql语句时，innodb同样会锁全表。</li>
<li>数据都是存在磁盘文件，通过磁盘IO 操作读取数据，myisam有三个文件.frm(存储表定义)   .myi（存储表索引） .myd（存储表数据） innodb磁盘上存储的是.frm(存储表定义)，.ibd(该表的索引和数据) 和 redo-log,undo-log日志文件;</li>
</ol>
<h3 id="主键索引"> 主键索引</h3>
<p>数据表的主键列使用的就是主键索引。</p>
<p>一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</p>
<p>因为InnoDB 的数据文件本身要按主键聚集，所以InnoDB 要求表必须有主键（MyISAM 可以没有），如果没有显式指定，则MySQL 系统会自动选择一个可以唯一标识数据记录的列作为主键，没有空值的唯一索引，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐式字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
<p>在 Mysql 中，InnoDB 引擎的表的 .ibd文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p>
<h4 id="innodb聚集索引"> InnoDB聚集索引</h4>
<div><p>优点</p>
<p>查询速度非常的快，因为整个 B 树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。</p>
</div>
<div><p>缺点</p>
<ol>
<li>依赖于有序的数据 ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li>
<li>更新代价大 ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改， 而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的， 所以对于主键索引来说，主键一般都是不可被修改的。</li>
</ol>
</div>
<h4 id="myisam非聚集索引"> MYISAM非聚集索引</h4>
<p>非聚集索引即索引结构和数据分开存放的索引。</p>
<p>二级索引属于非聚集索引。 MYISAM 引擎的表的.MYI 文件包含了表的索引， 该表的索引(B+树)的每个叶子非叶子节点存储索引， 叶子节点存储索引和索引对应数据的指针，指向.MYD 文件的数据。</p>
<p>非聚集索引的叶子节点并不一定存放数据的指针， 因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</p>
<p>非聚集索引的优点 更新代价比聚集索引要小 。</p>
<p>非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的 # 非聚集索引的缺点 跟聚集索引一样，非聚集索引也依赖于有序的数据 可能会二次查询(回表) :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。 这是 MySQL 的表的文件截图:</p>
<p>覆盖索引不会回表查询</p>
<h3 id="主键索引-辅助索引区别"> 主键索引&amp;辅助索引区别：</h3>
<ul>
<li>B+Tree的叶子节点存放的是主键字段值就属于主键索引；</li>
<li>如果存放的是非主键值 就属于辅助索引（二级索引）；</li>
</ul>
<h2 id="innodb索引"> Innodb索引</h2>
<p>InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。</p>
<h3 id="myisam索引"> myisam索引</h3>
<p>索引由B+树构成，执行查询操作的时候会先搜索B+树，如果找到对应叶子结点，根据叶子节点的值（地址），拿出整行数据。</p>
<p>辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="mysql"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2020-08-01T00:00:00.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">单一职责原则：</title>
    <id>http://www.zhangsj.xyz/blog/java/design-patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</id>
    <link href="http://www.zhangsj.xyz/blog/java/design-patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <updated>2022-04-11T06:31:58.000Z</updated>
    <content type="html"><![CDATA[<h2 id="单一职责原则"> 单一职责原则：</h2>
<p>一个类只负责一项职责</p>
<h2 id="里氏替换原则"> 里氏替换原则</h2>
<p>所有引用基类的地方必须都能透明地使用其子类的对象。</p>
<h2 id="依赖倒置原则"> 依赖倒置原则</h2>
<p>定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</p>
<h2 id="开闭原则"> 开闭原则</h2>
<p>定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-04-11T06:31:58.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">interview technique</title>
    <id>http://www.zhangsj.xyz/blog/java/interview/</id>
    <link href="http://www.zhangsj.xyz/blog/java/interview/"/>
    <updated>2022-04-04T03:09:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="interview"> interview</h2>
<ol>
<li>
<p>自动说出自己匹配该职位的要点，比如项目时长够，所用技术匹配，别等提问者提问。</p>
</li>
<li>
<p>面试前不仅要准备八股文，更要多准备亮点，面试中尽可能地通过抛出亮点来引导提问者提问，尽量压缩提问者的提问空间。</p>
</li>
<li>
<p>语气神态不亢不卑，甚至故意示弱，比如某些问题想下再回答，或故意抛出些小问题，等提问者提问后再澄清。总之别让提问者感觉你事先准备过。</p>
</li>
<li>
<p>抛出诱饵问题后，别立即展开，等提问者提问再展开，这点很重要。如果直接展开，就相当于自说自话。</p>
</li>
</ol>
<p>下面就按面试流程逐渐展开。首先是自我介绍和项目介绍阶段。</p>
<p>1 抛出自己和这个职位的匹配度。</p>
<p>比如可以说，我叫张士敬，(省略自我介绍性文字)，</p>
<p>我之前在 java 方面有3年左右开发经验，有 mysql,oracle 等项目经验，有 nginx，kafka,dubbo分布式 等的使用经验。总之先亮出你和职位介绍的匹配度，职位要求上有的技术，如果你有，直接说。</p>
<p>2 介绍项目时，别过多介绍需求，大致介绍你做的模块，介绍项目流程和使用的管理方式，尤其要说明项目管理和发布用到的组件和技术。</p>
<p>比如你可以说，</p>
<p>这个项目里，我做了 手工报销相关的模块 和 针对医照人员手工报销的模块，项目规模是80人，做了多久7个月。这个项目是用敏捷开发的管理方式。这个项目，我们用 ，用 m aven + gitlab 来管理项目，等等。</p>
<p>3 抛出亮点，但别展开。下面列些哪怕是初级开发也能抛出的亮点。</p>
<p>这个项目里，我解决过了 oom 问题，有过用 redis 缓存的经验，解决过 redis 内存溢出问题，解决过 dubbo 超时而导致的问题。</p>
<p>在项目开发过程中，我还专研过 ArrayList 和 HashMap 的底层源码，还看过 Spring Boot 相关注解的源码。</p>
<p>大家可以对比下，大多数候选人面试 java，在项目介绍阶段，是大谈特谈项目需求和功能，这就相当于把提问的控制权交给提问者。但相反，你不仅列出了你和该职位的匹配度，还用项目管理方式证明了你项目的真实性。更重要的是，你还抛出了诸多分布式和解决过的实际问题作为亮点。</p>
<p>这样一来，不少提问者，尤其是资历比较浅的提问者，往往就可能在听到你的说辞后顺带一问，比如顺口问，你们项目是怎么用 Redis 的，你是怎么解决 OOM 问题的，这样就相当于进入到你事先准备好的范围。</p>
<p>但是请注意，你在介绍项目时，可以抛出亮点，比如说解决过 oom 问题，但绝不能展开说怎么解决。原因很简单，你还在介绍项目，如果展开，就相当于条理不清晰。不过你提到的点，如果提问者感兴趣，自然会继续提问，你都不用着急。</p>
<p>介绍好项目经验后，一般提问者会看着你简历，针对你简历上提到的，以及你刚说的点发问。刚也说了，你完全可以在面试前准备好技术和亮点说辞，这样的话你可以大概率把提问者的问题引导带到你准备的范围。</p>
<p>其实很多亮点，比如 OOM 调优，缓存性能优化，或者多线程使用要点等，java 八股文里都有，甚至你都不用自己多准备。但是，在这环节你回答提问者技术提问时，要注意两个要点</p>
<p>第一，主动结合项目需求，说些使用要点证明这个技术你在项目里用过。</p>
<p>第二，在回答好当前提问后多说一句，继续引导提问者提问。</p>
<p>接上文，比如提问者问你，你项目里是怎么用 redis 的？你可以通过如下层次来说。</p>
<p>1 说需求，应为我们项目经常会查询会员，为了提升性能，所以把会员信息放入缓存。</p>
<p>2 说实现，比如在 redis 缓存会员信息时，键是什么？值是什么，缓存时用到 Jedis 的什么方法。</p>
<p>3 如果有，说遇到并解决过的问题。比如可以说，在这个过程中，我还解决过 Redis 穿透问题。同样抛出点，别展开，原因刚才也说了。</p>
<p>4 这点必须有，再给出引导性说辞。比如说，这个项目里，除了 redis 缓存，我们还用到了索引来提升性能(引导到索引)。或者，这个项目里，我们用的不是单机版 Redis，而是 Redis 哨兵集群(引导到集群)。</p>
<p>如果不引导，你回答好问题后，提问者大概率会自行发问，这样就有可能问到你不熟悉的点，但你再这样引导一波，后面提问者大概率会继续顺着问。</p>
<p>Redis，其他技术一样准备。你这样一说，不仅能向提问者证明这个技术你有项目经验，而且还能通过基本的用法，进一步证明你用过。同时还能通过说明你解决过的问题进一步展示技能，最后还带引导一波。</p>
<p>这样的话，提问者问的范围大概率会是你简历上提到的技术点，以及你引导的内容。只要你事先准备过相关技术的用法和解决过的问题(这些都能从 java 八股文里找到答案)。说难听点，你哪怕在之前项目里没用过，或者用得很浅，一样能给提问者留下“项目中掌握该技术”的印象，甚至还能留下“排查解决过 xx 方面实际问题”的印象。</p>
<p>结合项目问技术之后，提问者一般会从 java 核心，数据库，框架等方面提问。这方面你更可以通过背八股文来应对。这里，任何一个问题，你照样可以从“项目中的用法”、“解决过的实际问题”和“引导说辞”等方面来说。</p>
<p>比如你被问，hashcode 方法为什么要重写？你可以这样回答。</p>
<p>1 解释下原因，原因大家自行去看八股文，不展开。</p>
<p>2 说下你项目里怎么用的，无非是存放键值对，但要结合需求说。</p>
<p>3 说下你知道 hashmap 源码，但别展开，等提问者继续提问。</p>
<p>4 把后继问题引导到缓存等方面，比如可以这样说，我们项目是用 hashmap 做缓存，除此之外，我们还引入了 redis 缓存，以提升数据库访问性能，这样就引导到 redis 甚至数据库调优方面。或者说，Hashmap 是线程不安全的，所以使用起来要小心，这样就引导到了线程方面。</p>
<p>到这里为止，基本上提问者的问题就问完了，如果采用上文给出的方法来准备并实践面试，你会比其他只会背答案的候选人强在哪里呢？</p>
<p>1 人家大概率只会说理论，你能结合项目证明你用过。</p>
<p>2 由于事先准备过，所以能讲述源码、解决过的问题等亮点说辞。</p>
<p>3 由于准备过引导话术，所以虽然可能无法做到百分之一百，但能把很多提问者的问题引导到你准备好的范围。</p>
<p>上文给出的是准备面试和实践面试的方法，但实际操作起来，面试前需要准备的点还是比较多的。或者可以这样说，如果事先不准备，这套面试方法论可以说是无源之水。</p>
<p>本来要想如何在面试前准备背题、如何准备 java 亮点乃至面试控场和引导技巧的，但来了其他事情，本文就先更新到这里。有机会再继续说下高效准备 Java 面试以及在面试中引导提问者提问的技巧。</p>
<p>1 通过自我介绍和介绍项目，全面抛出自己和该职位的匹配度，同时全面抛出自己的技术列表。</p>
<p>2 在项目介绍中，有效地证明自己的商业项目经验，同时可以通过抛出亮点作为诱饵，最大程度地引导提问者后继提问。</p>
<p>但是，提问者问好这些问题后，如果你不加以引导，提问者依然可能自由发问，从而问到你不熟悉的技术点。这里就将着重讲下“引导”相关的技巧。</p>
<p>先讲下 Java 核心方面的事先准备和引导相关技巧。在 java 核心方面，哪怕初级开发多少也能准备集合、线程和异常处理等方面的说辞。</p>
<p>集合方面，你可以准备下 HashMap 的底层代码，尤其是和 hashcode 的源码，同时也可以准备下 ArrayList 和快速失效(fast fail)的底层代码，随后可以再进一步看下 ConcurrentHashMap 的读写并发管理部分的代码，因为其中包含 volatile，散列表数据结构和线程并发部分的技能，而且 jdk1.7 和 1.8 ConcurrentHashMap 的底层代码实现起来还不同，而且 ConcurrentHashMap 源码网上都有，还不难，所以你尤其可以通过 ConcurrentHashMap 来展示实力。</p>
<p>面试的时候，提问者大概率会问到 ArrayList 等基本集合的问题，比如如何遍历，有什么优势等等。问到了，你回答好本身问题后，再多说句，在项目里，我遇到过 ArrayList 快速失效问题，对此我还专研过底层源码，然后坐等提问者提问，提问者一旦问了，你甚至可以边写源码边解释，这样如果你说你才 1 年经验，面试估计也不信。</p>
<p>集合相关的，HashMap 也是一个必考点，姑且我不管提问者怎么提问，回答好以后，你再多说下，我知道为什么要重写 hashcode 方法，因为我看过 HashMap 底层源码，然后再说下。甚至你说好 HashMap 底层源码后，还可以继续提下，HashMap 是线程不安全的，而 ConcurrentHashMap 是线程安全，因为我见过它的源码，然后展开。</p>
<p>甚至可以这样说，当你按上述方式准备并引导后，虽然你只展示了集合方面的技能，但 Java 核心方面，提问者就不问别的问题了。</p>
<p>在线程方面，准备下锁，volatile，线程池和 ThreadLocal 的说辞，</p>
<p><a href="">参考 threadlocal.md</a></p>
<p>具体通过 ConcurrentHashMap 了解下锁(1.7)版本和 synchronized+volatile(1.8 版本)的用法</p>
<p>以及 ThreadLocal 里可能引发内存泄漏的问题，这些点网上都有，本文就不展开了，其实也未必多，能讲清楚就行了。</p>
<p>这方面怎么引导？被问及 volatile，回答好以后多提一句，ConcurrentHashMap 底层源码有这个，然后可以引导到 ConcurrentHashMap 底层源码。任何线程并发问题，用类似多说一句的方式，引导到 volatile，甚至是 ConcurrentHashMap 底层源码。任何并发问题，可以引导到线程池，线程池里有个参数是描述等待队列，如果设置成无界的有可能出现 OOM(不知道的自己查)，也就是说，面试中回答好并发后，通过引导，可以引到线程池话题，再可以找机会说出，自己解决过因线程池等待队列设置不当而导致的 OOM 问题。</p>
<p>或者你可以从 ThreadLocal，引出底层的 Weak 引用话题，再引出 JVM 结构以及 OOM 调优方面的话题。这块不知道也自己去查，不说白不说。</p>
<p>异常方面，准备下你在项目里的异常处理方法实践说辞，比如尽量缩小 try...catch 的范围，finally 从句里放释放资源的代码，catch 里应尽量处理异常，先用 IOException 等专业异常处理，再用 Exception 兜底，以及尽量缩小异常的影响范围，别让程序一遇异常就崩。面试时如果你说出上述异常处理的最佳实践要点，虽然价值不大，好歹也算项目开发经验，也就是说，任何异常方面的问题，你都可以通过上文提到的“多说一句”的方式，引导到“异常实践”上。</p>
<p>Java 核心方面，其实还有很多可以挖掘的点，比如 String, final 关键字等，而且对初级开发也适用。只要大家第一准备些(未必很深的)源码和解决(oom)问题的说辞，再按上文给出的方法找个相关问题点。只要提问者一旦问及，你回答好后再多说句，同时抛出事先准备好的亮点说辞。</p>
<p>其实 Java 核心方面，虚拟机和内存调优绝对是个值钱的亮点。如何在面试前准备，面试时如何引导以及如何展示，我有专门的文章来介绍。不再重复介绍如何引出该话题，而是讲下在引入虚拟机调优话题后，如何全面展示相关技能的说法。</p>
<p><a href="">参考 jvm 调优.md</a></p>
<p>再说下，数据库调优方面的说辞该如何准备？以及对应的引导话术。</p>
<p>1 熟悉索引，包括索引结构，复合索引和回表等技能，最好是结合源码。</p>
<p>2 单机版调优技能怎么说？通过看执行计划，调优 SQL 语句，具体是在项目中，会在 linux 上设置，如果有超过 10 秒的 SQL 就打印出来，然后通过执行计划看耗时点，比如大多是走全表扫描，或者有了索引没用到，或者子 sql 运行了多次，再往深讲就是 Oracle 里连接方式不对。你通过执行计划看到问题所在后，就对应修改，比如建复合索引，或者通过 with 语句把子查询提取出来。</p>
<p>3 可以再进一步讲些 MyCAT 分库分表和 redis 方面的调优能力。这方面可以准备的项目说辞是：比如业务请求里，会经常用公司 ID 向风控模块看风险情况，那么就可以用 ID 做键，风控字段做值，另外再把 null 放到键里，以放缓存击穿。另外对于一个千万级别的大表，你可以用 ID 作为分表字段，分 10 个表，根据最后一位的值定位到具体的表。同时排查所有的 SQL 语句，把一些可能全表关联的 SQL 语句，比如带 group by 和多表关联，或者用 Java 业务写，或者优化。</p>
<p>4 同时准备些数据库调优方面解决过的问题，比如索引对应的字段重复率太高，所以索引没用到，解决方法是建复合索引，或 redis 缓存信息没设超时时间，导致内存爆掉，解决方法是设下。这种问题网上一大堆，你适当准备下。</p>
<p>准备好以后，可以采用对应的引导方式。</p>
<p>1 被问及任何数据库问题，比如 sql，jdbc，回答好了再多说下，除了直接实现数据库方面的需求外，我还有数据库性能调优方面的经验。展开时，你是说到单机版调优还是分布式组件调优，看你能力。</p>
<p>2 在介绍项目时，同时说下，在这个项目里，我做过数据库性能调优方面的事情。被继续问及后再展开。</p>
<p>3 被问到索引相关问题后，回答好以后再多说句，除了索引，我还用过其他调优技术，然后展开。</p>
<p>4 随便找个机会，比如谈到索引，或者干脆在介绍项目时，多说一句，我解决过线上的数据库性能过慢的问题，然后展开。</p>
<p>5 当你回答好 redis 问题后，可以再“顺口”说句，在我们项目里，除了 redis 外，还用过 dubbo 组件，结果过因 dubbo 超时时间过长而导致的问题。然后提问者自然就会问到这块了，你同样可以准备些 dubbo 底层细节(乃至其他分布式组件方面)的问题，这方面也很多资料。</p>
<p>分布式组件方面，网上资料更是铺天盖地，这里就仅仅给出初级开发也能准备的点。</p>
<p>1 Redis，Dubbo，kafka 等组件的超时问题，以及对应的 OOM 问题。</p>
<p>2 Netty 堆外内存导致的 OOM。</p>
<p>3 Netty 半包粘包。Netty 整合线程池，因线程池等待队列设置不当而导致的 oom。</p>
<p>4 kafka 重发和堆积消息过多的问题。</p>
<p>上述问题不难，我让我的初级开发学生也这样准备的，同时还能结合源码准备，源码虽然难，但可以死记硬背。</p>
<p>准备到上述点以后，引导到话术就更多了。比如被问及数据库性能调优问题时，引导到同为高并发解决方案的 redis 和 mycat，被问题内存相关问题时，说自己解决过 netty，kafka 等方面的内存问题等等，这类文字我都不想再多说了，只要有关联，就可以引导。做项目无非是应对高并发，解决数据库和内存等性能问题，这类引导话术准备起来简直可以说一找一大堆。</p>
<p>大家可以发现，上文给出的点包含了 java 核心，数据库调优和分布式组件调优等诸多要点，而且哪怕初级开发也能在短时间内准备。准备的时候时候，大家可以按照上文的提示，自己举一反三，另外多找些源码和其他值钱问题，网上这种问题太多。</p>
<p>准备好诸多值钱技术点后，第一需要把这些点融入项目，比如我做订单模块时，用 ArrayList 存订单对象，遍历时遇到快速失效问题。其他点也照此，一一找个可以融入项目的点。结合项目说绝对要比单纯说技术好，不仅可信，而且能证明在项目里用过，第二再多准备些引导话术，别直接抛出，如果没机会抛出千万别自说自话地抛出。</p>
<p>准备引导话术的套路是，回答到现有问题后，再多说一句，比方说，除此之外，我还解决过其他同类 xxx 问题，看过相关的 xxx 底层源码。或者说，在解决该性能调优问题时，我还额外用到了 xxx 组件。或者说，在使用这个 xxx 技术时，我还遇到 xxx(比如 oom 或超时等)问题。</p>
<p>给出了“为每个技术找个项目落脚点”的背法，能好些，至少能得到“不仅会技术，而且在项目里用过”的评语。</p>
<h2 id="谈谈你的优缺点"> 谈谈你的优缺点</h2>
<p>缺点：</p>
<ol>
<li>每个离职原因都说一下；山西年轻嘛希望更好的发展，</li>
<li>缺乏项目的完整性，大的甲方公司完整的跟踪整个业务，了解行业；之前是乙方公司，自身发展受限制，技术的提高帮助越来越小；达到瓶颈，更先进的技术栈；</li>
</ol>
<p>之前的项目没有接触过这个技术；</p>
<p>@小刘</p>
<p>1.个人情况方面（个人规划，稳定性判断，婚育情况，父母身体，有无小孩，房产购买，离职原因）
2.工作规划
（1）项目展开，个人参与度，所扮角色，项目在公司所占比重，对项目了解程度
（2）产品展开，产品上线情况，对标产品情况，优劣势分析，对产品发展看法
3.个人认知：未来发展是管理层还是深耕架构技术，自己最近遇到最大的困难，解决方法，感悟。自己认为最大的缺点是什么</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-01-01T00:00:00.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">jvm-architecture</title>
    <id>http://www.zhangsj.xyz/blog/java/jvm/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</id>
    <link href="http://www.zhangsj.xyz/blog/java/jvm/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <updated>2022-04-11T06:31:58.000Z</updated>
    <content type="html"><![CDATA[<h2 id="jvm内存结构"> JVM内存结构</h2>
<div><p>相关信息</p>
<p>Java Virtual Machine ，Java 程序的运行环境(Java 二进制字节码的运行环境)。</p>
</div>
<ul>
<li>一次编译，处处执行</li>
<li>自动的内存管理，垃圾回收机制</li>
<li>数组下标越界检查</li>
</ul>
<p>3）比较</p>
<p>JVM、JRE、JDK 的关系如下图所示</p>
<p>操作系统(Windows+Linux)</p>
<i>Not supported content</i><p>Jvm</p>
<p>~jre(jvm+基本类库)</p>
<p>~jdk(jvm+基本类库+编译工具)</p>
<p>~开发 javaSE 程序(JDK+IDE 工具)</p>
<p>~开发 JavaEE 程序(JDK+应用服务器+IDE 工具)</p>
<p>2、学习 JVM 有什么用？</p>
<p>面试必备</p>
<p>中高级程序员必备</p>
<p>想走的长远，就需要懂原理，比如：自动装箱、自动拆箱是怎么实现的，反射是怎么实现的，垃圾回收机制是怎么回事等待，JVM 是必须掌握的。</p>
<p>3、常见的 JVM</p>
<p><a href="./img/1-1.png"></a></p>
<p>4、学习路线</p>
<p><a href="./img/1-2.png"></a></p>
<p>ClassLoader：Java 代码编译成二进制后，会经过类加载器，这样才能加载到 JVM 中运行。</p>
<p>Method Area：类是放在方法区中</p>
<p>Heap：类的实例对象。</p>
<p>当类调用方法时，会用到 JVM Stack、PC Register、本地方法栈。</p>
<p>方法执行时的每行代码是有执行引擎中的解释器逐行执行，方法中的热点代码频繁调用的方法，由 JIT 编译器优化后执行，GC 会对堆中不用的对象进行回收。需要和操作系统打交道就需要使用到本地方法接口。</p>
<h2 id="二、内存结构"> 二、内存结构</h2>
<h3 id="_1、程序计数器"> 1、程序计数器</h3>
<p>1）定义</p>
<p>Program Counter Register 程序计数器(寄存器)</p>
<p>作用：是记录下一条 jvm 指令的执行地址行号。</p>
<p>特点：</p>
<p>是线程私有的</p>
<p>不会存在内存溢出</p>
<p>2）作用</p>
<div><pre><code>0: getstatic #20 // PrintStream out = System.out;
3: astore_1 // --
4: aload_1 // out.println(1);
5: iconst_1 // --
6: invokevirtual #26 // --
9: aload_1 // out.println(2);
10: iconst_2 // --
11: invokevirtual #26 // --
14: aload_1 // out.println(3);
15: iconst_3 // --
16: invokevirtual #26 // --
19: aload_1 // out.println(4);
20: iconst_4 // --
21: invokevirtual #26 // --
24: aload_1 // out.println(5);
25: iconst_5 // --
26: invokevirtual #26 // --
29: return
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>解释器会解释指令为机器码交给 cpu 执行，程序计数器会记录下一条指令的地址行号，这样下一次解释器会从程序计数器拿到指令然后进行解释执行。</p>
<p>多线程的环境下，如果两个线程发生了上下文切换，那么程序计数器会记录线程下一行指令的地址行号，以便于接着往下执行。</p>
<h3 id="_2、虚拟机栈"> 2、虚拟机栈</h3>
<p>1）定义</p>
<p>每个线程运行需要的内存空间，称为虚拟机栈 每个栈由多个栈帧(Frame)组成，对应着每次调用方法时所占用的内存 每个线程只能有一个活动栈帧，对应着当前正在执行的方法</p>
<p>问题辨析：</p>
<p>1、垃圾回收是否涉及栈内存？</p>
<p>不会。栈内存是方法调用产生的，方法调用结束后会弹出栈。</p>
<p>2、栈内存分配越大越好吗？</p>
<p>不是。因为物理内存是一定的，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</p>
<p>3、方法内的局部变量是否线程安全</p>
<p>如果方法内部的变量没有逃离方法的作用访问，它是线程安全的</p>
<p>如果是局部变量引用了对象，并逃离了方法的访问，那就要考虑线程安全问题。</p>
<p>2）栈内存溢出</p>
<p>栈帧过大、过多、或者第三方类库操作，都有可能造成栈内存溢出 java.lang.stackOverflowError ，使用 -Xss256k 指定栈内存大小！</p>
<p>3）线程运行诊断</p>
<p>案例一：cpu 占用过多</p>
<p>解决方法：Linux 环境下运行某些程序的时候，可能导致 CPU 的占用过高，这时需要定位占用 CPU 过高的线程</p>
<p>Top 命令，查看是哪个进程占用 CPU 过高</p>
<p><code>ps H -eo pid, tid（线程id）</code>, %cpu | grep</p>
<p>刚才通过 top 查到的进程号 通过 ps 命令进一步查看是哪个线程占用 CPU 过高</p>
<h3 id="_3、本地方法栈"> 3、本地方法栈</h3>
<p>一些带有<code>native</code>关键字的方法就是需要<code>JAVA</code>去调用本地的C或者C++方法，因为<code>JAVA</code>有时候没法直接和操作系统底层交互，所以需要用到本地方法栈，服务于带 native 关键字(unsafe)的方法</p>
<h3 id="_4、堆"> 4、堆</h3>
<p>1）定义</p>
<p><code>Heap</code> 堆</p>
<p>通过 <code>new</code> 关键字创建的对象都会被放在堆内存</p>
<p>特点</p>
<p>它是线程共享，堆内存中的对象都需要考虑线程安全问题</p>
<p>有垃圾回收机制</p>
<p>2）堆内存溢出</p>
<p>Java.lang.OutofMemoryError ：java heap space. 堆内存溢出 可以使用 -Xmx8m 来指定堆内存大小。</p>
<p>3）堆内存诊断</p>
<p>Jps 工具</p>
<p>查看当前系统中有哪些 java 进程</p>
<p>Jmap 工具</p>
<p>查看堆内存占用情况 <code>jmap -heap</code> 进程 ID</p>
<p>Jconsole 工具</p>
<p>图形界面的，多功能的监测工具，可以连续监测</p>
<p>Jvisualvm 工具</p>
<h3 id="_5、方法区"> 5、方法区</h3>
<h4 id="_1-定义"> 1）定义</h4>
<p>Java 虚拟机有一个在所有 Java 虚拟机线程之间共享的方法区域。方法区域类似于用于传统语言的编译代码的存储区域，或者类似于操作系统进程中的“文本”段。</p>
<p>它存储每个类的结构，例如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括特殊方法，用于类和实例初始化以及接口初始化方法区域是在虚拟机启动时创建的。</p>
<p>尽管方法区域在逻辑上是堆的一部分，但简单的实现可能不会选择垃圾收集或压缩它。</p>
<p>此规范不强制指定方法区的位置或用于管理已编译代码的策略。</p>
<p>方法区域可以具有固定的大小，或者可以根据计算的需要进行扩展，并且如果不需要更大的方法区域，则可以收缩。方法区域的内存不需要是连续的！</p>
<h4 id="_2-组成"> 2）组成</h4>
<p>Hotspot 虚拟机 jdk1.6 1.7 1.8 内存结构图</p>
<p><img src="./img/1-3.png" alt="" loading="lazy"></p>
<p><img src="./img/1-4.png" alt="" loading="lazy"></p>
<h4 id="_3-方法区内存溢出"> 3）方法区内存溢出</h4>
<p>1.8 之前会导致永久代内存溢出</p>
<p>使用 -XX:MaxPermSize=8m 指定永久代内存大小</p>
<p>1.8 之后会导致元空间内存溢出</p>
<p>使用 -XX:MaxMetaspaceSize=8m 指定元空间大小</p>
<h4 id="_4-运行时常量池"> 4）运行时常量池</h4>
<p>二进制字节码包含(类的基本信息，常量池，类方法定义，包含了虚拟机的指令)</p>
<p>首先看看常量池是什么，编译如下代码：</p>
<div><pre><code><span>public</span> <span>class</span> <span>T</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Hello World!"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>然后使用 javap -v Test.class 命令反编译查看结果。</p>
<p>每条指令都会对应常量池表中一个地址，常量池表中的地址可能对应着一个类名、方法名、参数类型等信息。</p>
<p><strong>常量池：</strong></p>
<p>就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息</p>
<p><strong>运行时常量池：</strong></p>
<p>常量池是 *.class 文件中的，当该类被加载以后，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</p>
<p>每条指令都会对应常量池表中一个地址，常量池表中的地址可能对应着一个类名、方法名、参数类型等信息。</p>
<p>5）<code>StringTable</code></p>
<p>常量池中的字符串仅是符号，只有在被用到时才会转化为对象</p>
<p>利用串池的机制，来避免重复创建字符串对象</p>
<p>字符串变量拼接的原理是 StringBuilder</p>
<p>字符串常量拼接的原理是编译器优化</p>
<p>可以使用 intern 方法，主动将串池中还没有的字符串对象放入串池中</p>
<ul>
<li>如果串池中没有该字符串对象，则放入成功</li>
<li>如果有该字符串对象，则放入失败，无论放入是否成功，都会返回串池中的字符串对象</li>
</ul>
<p>注意：此时如果调用 intern 方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p>
<p>例 1：</p>
<div><pre><code><span>public</span> <span>class</span> <span>T</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// "a" "b" 被放入串池中，str 则存在于堆内存之中</span>
        <span>String</span> str <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"a"</span><span>)</span> <span>+</span> <span>new</span> <span>String</span><span>(</span><span>"b"</span><span>)</span><span>;</span>
        <span>// 调用 str 的 intern 方法，这时串池中没有 "ab" ，则会将该字符串对象放入到串池中，此时堆内存与串池中的 "ab" 是同一个对象</span>
        <span>String</span> st2 <span>=</span> str<span>.</span><span>intern</span><span>(</span><span>)</span><span>;</span>
        <span>// 给 str3 赋值，因为此时串池中已有 "ab" ，则直接将串池中的内容返回</span>
        <span>String</span> str3 <span>=</span> <span>"ab"</span><span>;</span>
        <span>// 因为堆内存与串池中的 "ab" 是同一个对象，所以以下两条语句打印的都为 true</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str <span>==</span> st2<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str <span>==</span> str3<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>例 2：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 此处创建字符串对象 "ab" ，因为串池中还没有 "ab" ，所以将其放入串池中</span>
        <span>String</span> str3 <span>=</span> <span>"ab"</span><span>;</span>
        <span>// "a" "b" 被放入串池中，str 则存在于堆内存之中</span>
        <span>String</span> str <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"a"</span><span>)</span> <span>+</span> <span>new</span> <span>String</span><span>(</span><span>"b"</span><span>)</span><span>;</span>
        <span>// 此时因为在创建 str3 时，"ab" 已存在与串池中，所以放入失败，但是会返回串池中的 "ab"</span>
        <span>String</span> str2 <span>=</span> str<span>.</span><span>intern</span><span>(</span><span>)</span><span>;</span>
        <span>// false</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str <span>==</span> str2<span>)</span><span>;</span>
        <span>// false</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str <span>==</span> str3<span>)</span><span>;</span>
        <span>// true</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str2 <span>==</span> str3<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>6）StringTable 的位置</p>
<p>Jdk1.6 StringTable 位置是在永久代中，1.8 StringTable 位置是在堆中。</p>
<p>7）StringTable 垃圾回收</p>
<p>-Xmx10m 指定堆内存大小</p>
<p>-XX:+PrintStringTableStatistics 打印字符串常量池信息</p>
<p>-XX:+PrintGCDetails</p>
<p>-verbose:gc 打印 gc 的次数，耗费时间等信息</p>
<p>8）StringTable 性能调优</p>
<ul>
<li>因为 StringTable 是由 HashTable 实现的，所以可以适当增加 HashTable 桶的个数，来减少字符串放入串池所需要的时间</li>
</ul>
<p>-XX:StringTableSize=桶个数(最少设置为 1009 以上)</p>
<p>考虑是否需要将字符串对象入池</p>
<p>可以通过 intern 方法减少重复入池</p>
<h3 id="_6、直接内存"> 6、直接内存</h3>
<p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致频繁地使用，而且也可能导致OutOfMemoryError异常出现，常见于NIO操作时，用于数据缓冲区</p>
<p>在JDK1.4中新加入NIO（New Input、output）</p>
<p>分配回收成本较高，但读写性能高</p>
<p>不受 JVM 内存回收管理</p>
<p>文件读写流程：</p>
<p><img src="./img/1-5.png" alt="" loading="lazy"></p>
<p>因为 java 不能直接操作文件管理，需要切换到内核态，使用本地方法进行操作，然后读取磁盘文件，会在系统内存中创建一个缓冲区，将数据读到系统缓冲区， 然后在将系统缓冲区数据，复制到 java 堆内存中。缺点是数据存储了两份，在系统内存中有一份，java 堆中有一份，造成了不必要的复制。</p>
<p>使用了 DirectBuffer 文件读取流程</p>
<p><img src="./img/1-6.png" alt="" loading="lazy"></p>
<p>直接内存是操作系统和 Java 代码都可以访问的一块区域，无需将代码从系统内存复制到 Java 堆内存，从而提高了效率。</p>
<h4 id="_3-直接内存回收原理"> 3）直接内存回收原理</h4>
<div><pre><code><span>public</span> <span>class</span> <span>Code_06_DirectMemoryTest</span> <span>{</span>

    <span>public</span> <span>static</span> <span>int</span> _1GB <span>=</span> <span>1024</span> <span>*</span> <span>1024</span> <span>*</span> <span>1024</span><span>;</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>IOException</span><span>,</span> <span>NoSuchFieldException</span><span>,</span> <span>IllegalAccessException</span> <span>{</span>
<span>//        method();</span>
        <span>method1</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>// 演示 直接内存 是被 unsafe 创建与回收</span>
    <span>private</span> <span>static</span> <span>void</span> <span>method1</span><span>(</span><span>)</span> <span>throws</span> <span>IOException</span><span>,</span> <span>NoSuchFieldException</span><span>,</span> <span>IllegalAccessException</span> <span>{</span>
        <span>Field</span> field <span>=</span> <span>Unsafe</span><span>.</span><span>class</span><span>.</span><span>getDeclaredField</span><span>(</span><span>"theUnsafe"</span><span>)</span><span>;</span>
        field<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>
        <span>Unsafe</span> unsafe <span>=</span> <span>(</span><span>Unsafe</span><span>)</span> field<span>.</span><span>get</span><span>(</span><span>Unsafe</span><span>.</span><span>class</span><span>)</span><span>;</span>

        <span>long</span> base <span>=</span> unsafe<span>.</span><span>allocateMemory</span><span>(</span>_1GB<span>)</span><span>;</span>
        unsafe<span>.</span><span>setMemory</span><span>(</span>base<span>,</span> _1GB<span>,</span> <span>(</span><span>byte</span><span>)</span> <span>0</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>in<span>.</span><span>read</span><span>(</span><span>)</span><span>;</span>

        unsafe<span>.</span><span>freeMemory</span><span>(</span>base<span>)</span><span>;</span>
        <span>System</span><span>.</span>in<span>.</span><span>read</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>// 演示 直接内存被 释放</span>
    <span>private</span> <span>static</span> <span>void</span> <span>method</span><span>(</span><span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>
        <span>ByteBuffer</span> byteBuffer <span>=</span> <span>ByteBuffer</span><span>.</span><span>allocateDirect</span><span>(</span>_1GB<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"分配完毕"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>in<span>.</span><span>read</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"开始释放"</span><span>)</span><span>;</span>
        byteBuffer <span>=</span> <span>null</span><span>;</span>
        <span>System</span><span>.</span><span>gc</span><span>(</span><span>)</span><span>;</span> <span>// 手动 gc</span>
        <span>System</span><span>.</span>in<span>.</span><span>read</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><p>直接内存的回收不是通过 JVM 的垃圾回收来释放的，而是通过 unsafe.freeMemory 来手动释放。</p>
<p>第一步：<code>allocateDirect</code>的实现</p>
<div><pre><code><span>public</span> <span>static</span> <span>ByteBuffer</span> <span>allocateDirect</span><span>(</span><span>int</span> capacity<span>)</span><span>{</span>
        <span>return</span> <span>new</span> <span>DirectByteBuffer</span><span>(</span>capacity<span>)</span><span>;</span>
        <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>底层是创建了一个<code>DirectByteBuffer</code>对象。</p>
<p>第二步：DirectByteBuffer类</p>
<div><pre><code><span>DirectByteBuffer</span><span>(</span><span>int</span> cap<span>)</span><span>{</span>   <span>// package-private</span>

        <span>super</span><span>(</span><span>-</span><span>1</span><span>,</span><span>0</span><span>,</span>cap<span>,</span>cap<span>)</span><span>;</span>
        <span>boolean</span> pa<span>=</span>VM<span>.</span><span>isDirectMemoryPageAligned</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> ps<span>=</span><span>Bits</span><span>.</span><span>pageSize</span><span>(</span><span>)</span><span>;</span>
        <span>long</span> size<span>=</span><span>Math</span><span>.</span><span>max</span><span>(</span><span>1L</span><span>,</span><span>(</span><span>long</span><span>)</span>cap<span>+</span><span>(</span>pa<span>?</span>ps<span>:</span><span>0</span><span>)</span><span>)</span><span>;</span>
        <span>Bits</span><span>.</span><span>reserveMemory</span><span>(</span>size<span>,</span>cap<span>)</span><span>;</span>

        <span>long</span> base<span>=</span><span>0</span><span>;</span>
        <span>try</span><span>{</span>
        base<span>=</span>unsafe<span>.</span><span>allocateMemory</span><span>(</span>size<span>)</span><span>;</span> <span>// 申请内存</span>
        <span>}</span><span>catch</span><span>(</span><span>OutOfMemoryError</span> x<span>)</span><span>{</span>
        <span>Bits</span><span>.</span><span>unreserveMemory</span><span>(</span>size<span>,</span>cap<span>)</span><span>;</span>
        <span>throw</span> x<span>;</span>
        <span>}</span>
        unsafe<span>.</span><span>setMemory</span><span>(</span>base<span>,</span>size<span>,</span><span>(</span><span>byte</span><span>)</span><span>0</span><span>)</span><span>;</span>
        <span>if</span><span>(</span>pa<span>&amp;&amp;</span><span>(</span>base<span>%</span>ps<span>!=</span><span>0</span><span>)</span><span>)</span><span>{</span>
        <span>// Round up to page boundary</span>
        address<span>=</span>base<span>+</span>ps<span>-</span><span>(</span>base<span>&amp;</span><span>(</span>ps<span>-</span><span>1</span><span>)</span><span>)</span><span>;</span>
        <span>}</span><span>else</span><span>{</span>
        address<span>=</span>base<span>;</span>
        <span>}</span>
        cleaner<span>=</span><span>Cleaner</span><span>.</span><span>create</span><span>(</span><span>this</span><span>,</span><span>new</span> <span>Deallocator</span><span>(</span>base<span>,</span>size<span>,</span>cap<span>)</span><span>)</span><span>;</span> <span>// 通过虚引用，来实现直接内存的释放，this为虚引用的实际对象, 第二个参数是一个回调，实现了 runnable 接口，run 方法中通过 unsafe 释放内存。</span>
        att<span>=</span><span>null</span><span>;</span>
        <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>社区报备 这里调用了一个 Cleaner 的 create 方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象(这里是 DirectByteBuffer )被回收以后，就会调用 Cleaner 的 clean 方法，来清除直接内存中占用的内存。</p>
<div><pre><code><span>class</span> <span>A</span> <span>{</span>
    <span>public</span> <span>void</span> <span>clean</span><span>(</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>remove</span><span>(</span><span>this</span><span>)</span><span>)</span> <span>{</span>
            <span>try</span> <span>{</span>
                <span>// 都用函数的 run 方法, 释放内存</span>
                <span>this</span><span>.</span>thunk<span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>
            <span>}</span> <span>catch</span> <span>(</span><span>final</span> <span>Throwable</span> var2<span>)</span> <span>{</span>
                <span>AccessController</span><span>.</span><span>doPrivileged</span><span>(</span><span>new</span> <span>PrivilegedAction</span><span><span>&lt;</span><span>Void</span><span>></span></span><span>(</span><span>)</span> <span>{</span>
                    <span>public</span> <span>Void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
                        <span>if</span> <span>(</span><span>System</span><span>.</span>err <span>!=</span> <span>null</span><span>)</span> <span>{</span>
                            <span>(</span><span>new</span> <span>Error</span><span>(</span><span>"Cleaner terminated abnormally"</span><span>,</span> var2<span>)</span><span>)</span><span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
                        <span>}</span>
                        <span>System</span><span>.</span><span>exit</span><span>(</span><span>1</span><span>)</span><span>;</span>
                        <span>return</span> <span>null</span><span>;</span>
                    <span>}</span>
                <span>}</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>可以看到关键的一行代码， this.thunk.run()，thunk 是 Runnable 对象。Run 方法就是回调 Deallocator 中的 run 方法，</p>
<div><pre><code> <span>public</span> <span>class</span> <span>T</span> <span>{</span>
    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>address <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>// Paranoia</span>
            <span>return</span><span>;</span>
        <span>}</span>
        <span>// 释放内存</span>
        unsafe<span>.</span><span>freeMemory</span><span>(</span>address<span>)</span><span>;</span>
        address <span>=</span> <span>0</span><span>;</span>
        <span>Bits</span><span>.</span><span>unreserveMemory</span><span>(</span>size<span>,</span> capacity<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><p>总结直接内存的回收机制</p>
<p>使用了 Unsafe 类来完成直接内存的分配回收，回收需要主动调用 freeMemory 方法 ByteBuffer 的实现内部使用了 Cleaner(虚引用)来检测 ByteBuffer 。一旦 ByteBuffer 被垃圾回收，那么会由 ReferenceHandler(守护线程) 来调用 Cleaner 的 clean 方法调用 freeMemory 来释放内存</p>
</div>
<div><pre><code><span>public</span> <span>class</span> <span>T</span> <span>{</span>
    <span>/**
     * -XX:+DisableExplicitGC 显示的
     */</span>
    <span>private</span> <span>static</span> <span>void</span> <span>method</span><span>(</span><span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>
        <span>ByteBuffer</span> byteBuffer <span>=</span> <span>ByteBuffer</span><span>.</span><span>allocateDirect</span><span>(</span>_1GB<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"分配完毕"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>in<span>.</span><span>read</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"开始释放"</span><span>)</span><span>;</span>
        byteBuffer <span>=</span> <span>null</span><span>;</span>
        <span>System</span><span>.</span><span>gc</span><span>(</span><span>)</span><span>;</span> <span>// 手动 gc 失效</span>
        <span>System</span><span>.</span>in<span>.</span><span>read</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>一般用 jvm 调优时，会加上下面的参数：</p>
<div><pre><code>-XX:+DisableExplicitGC  // 静止显示的 GC
</code></pre>
<div><span>1</span><br></div></div><p>意思就是禁止我们手动的 GC，比如手动 System.gc() 无效，它是一种 full gc，会回收新生代、老年代，会造成程序执行的时间比较长。所以我们就通过 unsafe 对象调用 freeMemory 的方式释放内存。</p>
<p><a href="https://blog.csdn.net/weixin_50280576/article/details/113742011" target="_blank" rel="noopener noreferrer">csdn</a></p>
<p><a href="https://www.bilibili.com/video/BV1yE411Z7AP?from=search&amp;seid=14402867104835325411&amp;spm_id_from=333.337.0.0" target="_blank" rel="noopener noreferrer">bilibili</a></p>
<h2 id="jvm堆内存详解"> JVM堆内存详解</h2>
<p>在jvm的堆内存中有三个区域：</p>
<ol>
<li>年轻代：用于存放新产生的对象。</li>
<li>老年代：用于存放被长期引用的对象。</li>
<li>持久代：用于存放Class，method 元信息（1 .8之后改为元空间）。</li>
</ol>
<h3 id="年轻代"> 年轻代</h3>
<p>年轻代中包含两个区：Eden 和survivor，并且用于存储新产生的对象，其中有两个survivor区</p>
<h3 id="老年代"> 老年代</h3>
<p>年轻代在垃圾回收多次都没有被GC回收的时候就会被放到老年代，以及一些大的对象（比如缓存，这里的缓存是弱引用），这些大对象可以不进入年轻代就直接进入老年代</p>
<h3 id="持久代"> 持久代</h3>
<p>持久代用来存储class，method元信息，大小配置和项目规模，类和方法的数量有关。</p>
<h3 id="元空间"> 元空间</h3>
<p>JDK1.8之后，取消perm永久代，转而用元空间代替</p>
<p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。</p>
<p>不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。并且可以动态扩容。那么使用元空间会有哪些问题呢？同学们可以思考下。</p>
<h3 id="为什么分代"> 为什么分代？</h3>
<p>因为不同对象的生命周期是不一样的。80%-98%的对象都是“朝生夕死”，生命周期很短，大部分新对象都在年轻代，可以很高效地进行回收，不用遍历所有对象。而老年代对象生命周期一般很长，每次可能只回收一小部分内存，回收效率很低。</p>
<p>年轻代和老年代的内存回收算法完全不同，因为年轻代存活的对象很少，标记清楚再压缩的效率很低，所以采用复制算法将存活对象移到survivor区，更高效。而老年代则相反，存活对象的变动很少，所以采用标记清除压缩算法更合适。</p>
<h2 id="内存分配策略"> 内存分配策略</h2>
<h3 id="优先在eden区分配"> 优先在Eden区分配</h3>
<p>在大多数情况下, 对象在新生代Eden区中分配, 当Eden区没有足够空间分配时, VM发起一次Minor GC, 将Eden区和其中一块Survivor区内尚存活的对象放入另一块Survivor区域, 如果在Minor GC期间发现新生代存活对象无法放入空闲的Survivor区, 则会通过空间分配担保机制使对象提前进入老年代(空间分配担保见下).</p>
<h3 id="大对象直接进入老年代"> 大对象直接进入老年代</h3>
<p><code>Serial</code>和<code>ParNew</code>两款收集器提供了<code>-XX:PretenureSizeThreshold</code>的参数, 令大于该值的大对象直接在老年代分配, 这样做的目的是避免在Eden区和Survivor区之间产生大量的内存复制(大对象一般指 需要大量连续内存的Java对象, 如很长的字符串和数组), 因此大对象容易导致还有不少空闲内存就提前触发GC以获取足够的连续空间</p>
<h3 id="长期存活对象进入老年区"> 长期存活对象进入老年区</h3>
<p>如果对象在<code>Eden</code>出生并经过第一次 <code>Minor GC</code> 后仍然存活，并且能被<code>Survivor</code>容纳的话，将被移动到<code>Survivor</code>空间中，并将对象年龄设为1，对象在Survivor区中每熬过一次 Minor GC，年龄就增加1，当它的年龄增加到一定程度(默认为15)_时，就会被晋升到老年代中。</p>
<h3 id="对象年龄动态判定"> 对象年龄动态判定</h3>
<p>如果在 <code>Survivor</code>空间中相同年龄所有对象大小的综合大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代</p>
<h3 id="空间分配担保"> 空间分配担保</h3>
<p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看<code>HandlePromotionFailure</code>设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的，如果担保失败则会进行一次Full GC；如果小于，或者<code>HandlePromotionFailure</code>
设置不允许冒险，那这时也要改为进行一次Full GC。</p>
<p>HotSpot默认是开启空间分配担保的。</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="jvm"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-03-17T02:28:44.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">jvm-gc</title>
    <id>http://www.zhangsj.xyz/blog/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</id>
    <link href="http://www.zhangsj.xyz/blog/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <updated>2022-04-11T06:31:58.000Z</updated>
    <content type="html"><![CDATA[<p>::: 关于Java垃圾回收的简介</p>
<p>（1）Java内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程尔灭；栈中的栈帧随着方法的进入和退出而有条不紊的执行着出栈和入栈操作。</p>
<p>（2）每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存和回收都具确定性，</p>
<p>如果垃圾不被回收，内存迟早会被消耗空，因为我们在不断的分配内存空间而不进行回收，除非内存无限大，我们可以任性的分配儿不回收。在这几个区域内不需要过多考虑回收的问题，因为方法结束或线程结束时，内存自然就跟随着回收了。</p>
<p>（3）而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。</p>
<p>:::</p>
<h2 id="gc执行的机制"> GC执行的机制</h2>
<h3 id="minor-gc-young-gc"> Minor GC(young GC)</h3>
<p>一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Minor GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。</p>
<p>这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。</p>
<p>因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。</p>
<h3 id="full-gc"> Full GC</h3>
<p>对整个堆进行整理，包括 <code>Young</code>、<code>Tenured</code> 和 <code>Perm</code>。Full GC 因为需要对整个堆进行回收，所以比Minor GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：</p>
<ol>
<li>年老代（Tenured）被写满</li>
<li>持久代（Perm）被写满</li>
<li>System.gc()被显示调用</li>
<li>上一次GC之后Heap的各域分配策略动态变化</li>
</ol>
<h2 id="判断哪些对象可以回收"> 判断哪些对象可以回收</h2>
<p>所谓“要回收的垃圾”无非就是那些不可能再被任何途径使用的对象。那么如何找到这些对象？</p>
<h3 id="引用计数法"> 引用计数法</h3>
<p>当一个对象被引用时，就当引用对象的值加一，当值为 0 时，就表示该对象不被引用，可以被垃圾收集器回收。</p>
<p>这个引用计数法听起来不错，但是有一个弊端，循环引用时，两个对象的计数都为 1，导致两个对象都无法被释放。</p>
<h3 id="可达性分析算法"> 可达性分析算法</h3>
<p>这个算法的基本思想是通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链(即 GC Roots 到对象不可达)时，则证明此对象是不可用的。</p>
<p>那么问题又来了，如何选取 GCRoots 对象呢？在 Java 语言中，可以作为 GCRoots 的对象包括下面几种：</p>
<p>虚拟机栈(栈帧中的本地变量表)中引用的对象。
方法区中类静态属性引用的对象
方法区中常量引用的对象
本地方法栈中 JNI(即一般说的 Native 方法)引用的对象</p>
<div><pre><code><span>class</span> <span>T</span><span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>
        <span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        list<span>.</span><span>add</span><span>(</span><span>"a"</span><span>)</span><span>;</span>
        list<span>.</span><span>add</span><span>(</span><span>"b"</span><span>)</span><span>;</span>
        list<span>.</span><span>add</span><span>(</span><span>1</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>1</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>in<span>.</span><span>read</span><span>(</span><span>)</span><span>;</span>
        list <span>=</span> <span>null</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>2</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>in<span>.</span><span>read</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"end"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>对于以上代码，可以使用如下命令将堆内存信息转储成一个文件，然后使用 idea Memory Analyzer 工具进行分析。</p>
<p>使用步骤：</p>
<ol>
<li>使用 jps 命令，查看程序的进程
使用 jmap -dump:format=b,live,file=1.bin 16104 命令转储文件</li>
</ol>
<ul>
<li><code>dump</code>：转储文件</li>
<li><code>format</code> =b：二进制文件</li>
<li><code>file</code>：文件名</li>
<li><code>16104</code>：进程的 ID</li>
</ul>
<ol start="3">
<li>打开 Eclipse Memory Analyzer 对 1.bin 文件进行分析。</li>
</ol>
<p>分析的 gc root，找到了 ArrayList 对象，然后将 list 置为 null，再次转储，那么 list 对象就会被回收。</p>
<h3 id="四种引用"> 四种引用</h3>
<ol>
<li>强引用:
只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</li>
<li>软引用(SoftReference):
仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用对象
可以配合引用队列来释放软引用自身</li>
<li>弱引用(WeakReference):
仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象,可以配合引用队列来释放弱引用自身</li>
<li>虚引用(PhantomReference):
必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，
由 Reference Handler 线程调用虚引用相关方法释放直接内存</li>
<li>终结器引用(FinalReference)
无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队(被引用对象暂时没有被回收)，再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize 方法，第二次 GC 时才能回收被引用对象。</li>
</ol>
<h2 id="垃圾回收算法"> 垃圾回收算法</h2>
<h3 id="标记清除算法-引用计数算法"> 标记清除算法（引用计数算法）</h3>
<p>它很难解决对象之间的相互循环引用的问题。</p>
<p>例如：</p>
<p>对象objA和ObjB都有字段instance，赋值令</p>
<p>标记-清除算法分为两个阶段：标记阶段和清除阶段。</p>
<p>标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。</p>
<p><a href="./img/2-1.png"></a></p>
<p>这种回收算法会产生大量不连续的内存碎片，当要频繁分配一个大对象时，jvm在新生代中找不到足够大的连续的内存块，会导致jvm频繁进行内存回收(目前有机制，对大对象，直接分配到老年代中)</p>
<p>优点</p>
<p>利用率百分之百</p>
<p>缺点</p>
<p>标记和清除的效率都不高（比对复制算法）</p>
<p>会产生大量的不连续的内存碎片</p>
<h3 id="复制算法"> 复制算法</h3>
<p>复制算法将可用内存按容量划分为两个大小相等的块，每次只使用其中的一块。</p>
<p>当这一块的内存用完了，就将还存活着的对象复制到另外一块内存中，然后把这块内存一次清理掉。这样做的效率比较高，也避免了内存碎片。但是这样内存的可使用空间减半，内存利用率低。内存空间的浪费</p>
<p><a href="./img/2-2.png"></a></p>
<p>这种算法虽然实现简单，运行高效且不容易产生内存碎片，但是却对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。很显然，Copying 算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，那么 Copying 算法的效率将会大大降低。</p>
<h3 id="标记-整理算法-压缩法"> 标记-整理算法(压缩法)</h3>
<p>为了解决 Copying 算法的缺陷，充分利用内存空间，提出了 Mark-Compact 算法。该算法标记阶段和 Mark-Sweep 一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。具体过程如下图所示：</p>
<p><a href="./img/2-3.png"></a></p>
<h3 id="分代收集算法"> 分代收集算法</h3>
<p>当前商业虚拟机都采用这种算法。首先根据对象存活周期的不同将内存分为几块即新生代、老年代，然后根据不同年代的特点，采用不同的收集算法。</p>
<p>新生代: 每次垃圾收集都能发现大批对象已死, 只有少量存活。因此选用复制算法, 只需要付出少量存活对象的复制成本就可以完成。但是实际中并不是按照 1：1 的比例来划分新生代的空间的，一般来说是将新生代划分为一块较大的 <code>Eden</code> 空间和两块较小的 <code>Survivor</code> 空间，每次使用 <code>Eden</code> 空间和其中的一块 <code>Survivor</code> 空间，当进行回收时，将 <code>Eden</code> 和 <code>Survivor</code> 中还存活的对象复制到另一块 <code>Survivor</code> 空间中，然后清理掉 <code>Eden</code> 和刚才使用过的 <code>Survivor</code> 空间。</p>
<p>老年代: 是每次垃圾收集时只有少量对象需要被回收，一般使用的是标记-整理算法(压缩法)。</p>
<h2 id="典型的垃圾收集器"> 典型的垃圾收集器</h2>
<h2 id="serial-收集器"> Serial 收集器</h2>
<p>Serial 收集器是最基本的、发展历史最悠久的收集器</p>
<p>特点：单线程、简单高效（与其他收集器的单线程相比），采用复制算法。对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）！</p>
<h3 id="parnew-收集器"> ParNew 收集器</h3>
<p>ParNew 收集器其实就是 Serial 收集器的多线程版本</p>
<p>特点：多线程、ParNew 收集器默认开启的收集线程数与CPU的数量相同，在 CPU 非常多的环境中，可以使用 -XX:ParallelGCThreads 参数来限制垃圾收集的线程数。和 Serial 收集器一样存在 Stop The World 问题</p>
<h3 id="cms-收集器"> CMS 收集器</h3>
<p><code>Concurrent Mark Sweep</code>，一种以获取最短回收停顿时间为目标的<strong>老年代收集器</strong></p>
<p>特点：基于标记-清除算法实现。并发收集、低停顿，但是会产生内存碎片</p>
<p>应用场景：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。</p>
<p>如 web 程序、b/s 服务</p>
<p>CMS 收集器的运行过程分为下列4步：</p>
<ul>
<li>初始标记：标记 GC Roots 能直接到的对象。速度很快但是仍存在 Stop The World 问题。</li>
<li>并发标记：进行 GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行。</li>
<li>重新标记：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在 Stop The World 问题</li>
<li>并发清除：对标记的对象进行清除回收，清除的过程中，可能任然会有新的垃圾产生，这些垃圾就叫浮动垃圾，如果当用户需要存入一个很大的对象时，新生代放不下去，老年代由于浮动垃圾过多，就会退化为 serial Old 收集器，将老年代垃圾进行标记-整理，当然这也是很耗费时间的！</li>
</ul>
<p>CMS 收集器的内存回收过程是与用户线程一起并发执行的，可以搭配 ParNew 收集器（多线程，新生代，复制算法）与 Serial Old 收集器（单线程，老年代，标记-整理算法）使用。</p>
<h2 id="g1-收集器-待续。。。"> G1 收集器（待续。。。）</h2>
<p>适用场景：</p>
<ul>
<li>同时注重吞吐量和低延迟（响应时间）</li>
<li>超大堆内存（内存大的），会将堆内存划分为多个大小相等的区域，区域可能是Eden，也有可能是Survivor，也有可能是Old，另外Region中还有一类特殊的Humongous区域，专门用来存储大对象。</li>
<li>整体上是标记-整理算法，两个区域之间是复制算法</li>
</ul>
<p>G1的运行过程与CMS大体一致，分为以下四个步骤：</p>
<ul>
<li>初始标记(Initial Marking)：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</li>
<li>并发标记( Concurrent Marking)：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫
描完成以后，并发时有引用变动的对象会产生漏标问题，G1中会使用SATB(snapshot-at-the-beginning)算法来解决，后面会详细介绍。</li>
<li>最终标记(Final Marking)：对用户线程做一个短暂的暂停，用于处理并发标记阶段仍遗留下来的最后那少量的SATB记录(漏标对象)。</li>
<li>筛选回收(Live Data Counting and Evacuation)：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多个收集器线程并行完成的。</li>
</ul>
<p>TAMS是什么？</p>
<p>要达到GC与用户线程并发运行，必须要解决回收过程中新对象的分配，所以G1为每一个Region区域设计了两个名为TAMS（Top at Mark Start）的指针，从Region区域划出一部分空间用于记录并发回收过程中的新对象。这样的对象认为它们是存活的，不纳入垃圾回收范围。</p>
<div><pre><code>-XX:+UseG1GC
-XX:G1HeapRegionSize<span>=</span>size
-XX:MaxGCPauseMillis<span>=</span>time
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>Young Collection：对新生代垃圾收集</p>
<p>Young Collection + Concurrent Mark：如果老年代内存到达一定的阈值了，新生代垃圾收集同时会执行一些并发的标记。</p>
<p>Mixed Collection：会对新生代 + 老年代 + 幸存区等进行混合收集，然后收集结束，会重新进入新生代收集。</p>
<p>Young Collection</p>
<p>新生代存在 STW：</p>
<p>分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间！</p>
<p>E：eden，S：幸存区，O：老年代</p>
<p>新生代收集会产生 STW ！</p>
<p><a href="./img/20210210122339138.gif"></a></p>
<p>Young Collection + CM</p>
<p>在 Young GC 时会进行 GC Root 的初始化标记</p>
<p>老年代占用堆空间比例达到阈值时，进行并发标记（不会STW），由下面的 JVM 参数决定 -XX:InitiatingHeapOccupancyPercent=percent （默认45%）</p>
<p><a href="./img/20210210122601873.png"></a></p>
<p>Mixed Collection</p>
<p>会对 E S O 进行全面的回收</p>
<p>最终标记会 STW</p>
<p>拷贝存活会 STW</p>
<p>-XX:MaxGCPauseMills=xxms 用于指定最长的停顿时间！</p>
<p>问：为什么有的老年代被拷贝了，有的没拷贝？</p>
<p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会回收最有价值的老年代（回收后，能够得到更多内存）</p>
<p><a href="./img/20210210144216170.png"></a></p>
<p>Full GC</p>
<p>G1 在老年代内存不足时（老年代所占内存超过阈值）</p>
<p>如果垃圾产生速度慢于垃圾回收速度，不会触发 Full GC，还是并发地进行清理</p>
<p>如果垃圾产生速度快于垃圾回收速度，便会触发 Full GC，然后退化成 serial Old 收集器串行的收集，就会导致停顿的时候长。</p>
<h2 id="tiaoyou新生代"> tiaoyou新生代</h2>
<p>新生代的特点</p>
<p>所有的 new 操作分配内存都是非常廉价的</p>
<p>TLAB thread-lcoal allocation buffer</p>
<p>死亡对象回收零代价</p>
<p>大部分对象用过即死（朝生夕死）</p>
<p>Minor GC 所用时间远小于 Full GC</p>
<p>新生代内存越大越好么？ 不是</p>
<p>新生代内存太小：频繁触发 Minor GC ，会 STW ，会使得吞吐量下降</p>
<p>新生代内存太大：老年代内存占比有所降低，会更频繁地触发 Full GC。而且触发 Minor GC 时，清理新生代所花费的时间会更长</p>
<p>新生代内存设置为内容纳[并发量*(请求-响应)]的数据为宜</p>
<p>幸存区需要能够保存 当前活跃对象+需要晋升的对象</p>
<p>晋升阈值配置得当，让长时间存活的对象尽快晋升</p>
<div><pre><code>-XX:MaxTenuringThreshold<span>=</span>threshold
-XX:+PrintTenuringDistrubution
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="tiaoyou老年代"> tiaoyou老年代</h2>
<p>以 CMS 为例：CMS 的老年代内存越大越好</p>
<p>先尝试不做调优，如果没有 Full G，否者先尝试调优新生代。</p>
<p>观察发现 Full GC 时老年代内存占用，将老年代内存预设调大 1/4 ~ 1/3</p>
<p><code>-XX:CMSInitiatingOccupancyFraction=percent</code></p>
<p><a href="https://blog.csdn.net/weixin_50280576/article/details/113775575" target="_blank" rel="noopener noreferrer">csdn</a></p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="jvm"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2021-02-01T00:00:00.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">jvm mulu</title>
    <id>http://www.zhangsj.xyz/blog/java/jvm/</id>
    <link href="http://www.zhangsj.xyz/blog/java/jvm/"/>
    <updated>2022-03-17T02:28:44.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li><a href="./JVM内存结构.html">内存结构</a></li>
<li><a href="./JVM垃圾回收.html">垃圾回收</a></li>
<li><a href="./JVM类加载与字节码技术&amp;内存模型.html">类加载与字节码技术&amp;内存模式</a></li>
<li><a href="./jvm调优.html">jvm调优</a></li>
</ul>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="mulu"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-25T04:26:56.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">jvmclassload</title>
    <id>http://www.zhangsj.xyz/blog/java/jvm/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF&amp;%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <link href="http://www.zhangsj.xyz/blog/java/jvm/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF&amp;%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <updated>2022-03-17T02:28:44.000Z</updated>
    <content type="html"><![CDATA[<h2 id="class-load"> class load</h2>
<p>类加载与字节码技术</p>
<p><img src="./img/3-1.png" alt="" loading="lazy"></p>
<p>1、类文件结构</p>
<p>通过 javac 类名.java 编译 java 文件后，会生成一个 .class 的文件！</p>
<div><pre><code>0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09
0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07
0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29
0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e
0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63
0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01
0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63
0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f
0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16
0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72
0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13
0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69
0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61
0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46
0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64
0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e
0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64
0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74
0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c
0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61
0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61
0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f
0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72
0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76
0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d
0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a
0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b
0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01
0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01
0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00
0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00
0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00
0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00
0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a
0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b
0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00
0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00
0001120 00 00 02 00 14

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><p>据 JVM 规范，类文件结构如下：</p>
<div><pre><code>u4       magic
u2             minor_version;
u2             major_version;
u2             constant_pool_count;
cp_info        constant_pool[constant_pool_count-1];
u2             access_flags;
u2             this_class;
u2             super_class;
u2             interfaces_count;
u2             interfaces[interfaces_count];
u2             fields_count;
field_info     fields[fields_count];
u2             methods_count;
method_info    methods[methods_count];
u2             attributes_count;
attribute_info attributes[attributes_count];
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>1）魔数</p>
<p>U4 magic
对应字节码文件的 0~3 个字节
0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09
ca fe ba be ：意思是 .class 文件，不同的东西有不同的魔数，比如 jpg、PNG 图片等！</p>
<p>2）版本</p>
<p>U2 minor_version;
u2 major_version;
0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09
00 00 00 34：34H(16 进制) = 52(10 进制)，代表 JDK8</p>
<p>3）常量池
…</p>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.5" target="_blank" rel="noopener noreferrer">参考文档</a></p>
<h2 id="_2、字节码指令"> 2、字节码指令</h2>
<p>可参考：</p>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5" target="_blank" rel="noopener noreferrer">字节码指令</a></p>
<h3 id="_1-javap-工具"> 1）javap 工具</h3>
<p>Java 中提供了 javap 工具来反编译 class 文件</p>
<h3 id="_2-图解方法执行流程"> 2）图解方法执行流程</h3>
<p>Todo zsj</p>
<p>代码</p>
<div><pre><code><span>public</span> <span>class</span> <span>Demo3_1</span> <span>{</span>
 <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
  <span>int</span> a <span>=</span> <span>10</span><span>;</span>
  <span>int</span> b <span>=</span> <span>Short</span><span>.</span>MAX_VALUE <span>+</span> <span>1</span><span>;</span>
  <span>int</span> c <span>=</span> a <span>+</span> b<span>;</span>
  <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>c<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>常量池载入运行时常量池</p>
<p>常量池也属于方法区，只不过这里单独提出来了</p>
<p><img src="./img/3-2.png" alt="" loading="lazy"></p>
<p>方法字节码载入方法区</p>
<p>(stack=2，locals=4) 对应操作数栈有 2 个空间(每个空间 4 个字节)，局部变量表中有 4 个槽位。</p>
<p><img src="./img/3-3.png" alt="" loading="lazy"></p>
<p>执行引擎开始执行字节码</p>
<p>Bipush 10</p>
<ul>
<li>将一个 byte 压入操作数栈(其长度会补齐 4 个字节)，类似的指令还有
<ul>
<li>sipush 将一个 short 压入操作数栈(其长度会补齐 4 个字节)</li>
<li>ldc 将一个 int 压入操作数栈</li>
<li>ldc2_w 将一个 long 压入操作数栈（<strong>分两次压入</strong>，因为 long 是 8 个字节）</li>
<li>这里小的数字都是和字节码指令存在一起，<strong>超过 short 范围的数字存入了常量池</strong></li>
</ul>
</li>
</ul>
<p>Istore 1</p>
<p>将操作数栈栈顶元素弹出，放入局部变量表的 slot 1 中</p>
<p>对应代码中的 a = 10</p>
<p>3）通过字节码指令分析问题</p>
<p>代码</p>
<p><a href="https://blog.csdn.net/weixin_50280576/article/details/113784268" target="_blank" rel="noopener noreferrer">csdn</a></p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="jvm"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-03-17T02:28:44.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">jvm-tiaoyou</title>
    <id>http://www.zhangsj.xyz/blog/java/jvm/jvm%E8%B0%83%E4%BC%98/</id>
    <link href="http://www.zhangsj.xyz/blog/java/jvm/jvm%E8%B0%83%E4%BC%98/"/>
    <updated>2022-02-28T02:20:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="jvm调优"> jvm调优</h2>
<p>虚拟机和内存调优技能</p>
<p>第一步，发现系统很卡，或者日志里频繁出现 OOM 异常。</p>
<p>第二步，用 dump 文件看 OOM 时的内存镜像，看的工具可以是 JMAT。这两个步骤是通用的。</p>
<p>生成dump文件 <code>jmap -dump:live,format=b,file=xxxx.bin 进程ID</code></p>
<p>第三，通过 dump 文件，jvisualvm 启动可视化工具，再结合日志上下文，</p>
<p>定位 OOM 的原因，比较简单的原因是 Redis 缓存超时时间过长，或者是 ThreadLocal 里的对象用好没 remove(这块还涉及到弱引用，大家可以自己去查，本文不展开)，或者创建线程池时，等待队列设置成了无界，或者你在 mybatis 里，where 条件都是带 if 的，即如果传入 ID 和 name 再拼装 where ID = xxx 之类的语句，在一种场景里，都没传条件，所以 where 后面不带条件，把数据库里记录全捞出来了，导致 OOM。</p>
<p>第四是解决，发现问题后，对症下药解决就很容易，比如降低 Redis 超时时间，或者修改好对应的代码。</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="jvm"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-23T04:24:33.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">前言</title>
    <id>http://www.zhangsj.xyz/blog/java/jvm/%E5%88%9D%E6%8E%A2Java%E6%BA%90%E7%A0%81%E4%B9%8BLinkedList/</id>
    <link href="http://www.zhangsj.xyz/blog/java/jvm/%E5%88%9D%E6%8E%A2Java%E6%BA%90%E7%A0%81%E4%B9%8BLinkedList/"/>
    <updated>2022-04-04T03:09:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言"> 前言</h2>
<p>上篇文章我们分析了常见的ArrayList源码，它的内部是由一个数组来实现的。那么今天，我们来分析另一个常见的类LinkedList。本文分析都来自Java8。(ps:这段话写自写完本文记录后添加。个人感想为已经写成了介绍链表)</p>
<p>一、类说明</p>
<p>首先我们来看一下这个类。</p>
<div><pre><code><span>public</span> <span>class</span> <span>LinkedLiist</span>

</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="总结"> 总结</h2>
<p>首先linkedlist
内部是由双向链表来实现的。我们存储的每一个数据都会被封装到一个数据节点之中。包括指向前节点的指针，数据，指向后节点的指针；依靠这些数据结点实现双向链表。</p>
<p>既然是链表，那么优点就是插入，修改，删除数据效率比数组高很多。因为在插入或者实时某个数据时，只需对要删除节点，前节点，后节点进行操作，无需像数组一样将后续数据全部前移或者后移。但是由此也看出缺点，因为链表并不是连续的空间存储，也没有什么下标进行记录位置，因此要寻找某个数据时只能进行遍历，而不像数组一样可以随机查找。如果在实际开发中，我们需要对某个list进行频繁的插入、删除，而且数据量有特别大的时候。可以考虑使用linkedlist。</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-04-04T03:09:33.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">Shallow&amp;Deep copy</title>
    <id>http://www.zhangsj.xyz/blog/java/jvm/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <link href="http://www.zhangsj.xyz/blog/java/jvm/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <updated>2022-03-24T01:58:17.000Z</updated>
    <content type="html"><![CDATA[<h2 id="基本类型和引用类型"> 基本类型和引用类型</h2>
<h3 id="在java中数据类型可以分为两大类-基本类型和引用类型。"> 在Java中数据类型可以分为两大类：基本类型和引用类型。</h3>
<p>基本类型也称为值类型，分别是字符型char，布尔型boolean以及数值型 byte、short、int、long、float、double。</p>
<p>引用类型则包括类、接口、数组、枚举等。</p>
<h3 id="内存空间分为堆和栈"> 内存空间分为堆和栈</h3>
<p>基本类型直接在栈中存储数值，而引用类型是将引用放在栈中，实际存储的值是放在堆中，通过栈中的引用指向堆中存放的数据。</p>
<p>开发过程中，有时会遇到把现有的一个对象的所有成员属性拷贝给另一个对象的需求。</p>
<h2 id="创建对象的5种方式"> 创建对象的5种方式</h2>
<p>①、通过 new 关键字</p>
<p>这是最常用的一种方式，通过 new 关键字调用类的有参或无参构造方法来创建对象。比如 Object obj = new Object();</p>
<p>②、通过 Class 类的 newInstance() 方法</p>
<p>这种默认是调用类的无参构造方法创建对象。</p>
<p>比如 <code>Person p2 = (Person) Class.forName(&quot;com.ys.test.Person&quot;).newInstance();</code></p>
<p>③、通过 Constructor 类的 newInstance 方法</p>
<p>这和第二种方法类时，都是通过反射来实现。通过 java.lang.relect.Constructor 类的 newInstance() 方法指定某个构造器来创建对象。</p>
<p><code>Person p3 = (Person) Person.class.getConstructors()[0].newInstance();</code></p>
<p>实际上第二种方法利用 Class 的 <code>newInstance()</code>方法创建对象，其内部调用还是 Constructor 的 newInstance() 方法。</p>
<p>④、利用 Clone 方法</p>
<p><code>Clone</code> 是 <code>Object</code> 类中的一个方法，通过 对象<code>A.clone()</code>方法会创建一个内容和对象 A 一模一样的对象 B，clone 克隆，顾名思义就是创建一个一模一样的对象出来。</p>
<p><code>Person p4 = (Person) p3.clone();</code></p>
<p>⑤、反序列化</p>
<p>序列化是把堆内存中的 Java 对象数据，通过某种方式把对象存储到磁盘文件中或者传递给其他网络节点（在网络上传输）。而反序列化则是把磁盘文件中的对象数据或者把网络节点上的对象数据，恢复成Java对象模型的过程。</p>
<h2 id="clone-方法"> Clone 方法</h2>
<p>本篇博客我们讲解的是 Java 的深拷贝和浅拷贝，其实现方式正是通过调用 Object 类的 clone() 方法来完成。在 Object.class 类中，源码为：</p>
<p><code>protected native Object clone() throws CloneNotSupportedException;</code></p>
<p>ative 修饰的方法就是告诉操作系统，这个方法我不实现了，让操作系统去实现。具体怎么实现我们不需要了解，只需要知道 clone方法的作用就是复制对象，产生一个新的对象。</p>
<h2 id="深拷贝"> 深拷贝</h2>
<p>深拷贝：创建一个新对象，然后将当前对象的非静态字段复制到该新对象，无论该字段是值类型的还是引用类型，都复制独立的一份。</p>
<p>当你修改其中一个对象的任何内容时，都不会影响另一个对象的内容。</p>
<p>①、让每个引用类型属性内部都重写clone() 方法</p>
<p>既然引用类型不能实现深拷贝，那么我们将每个引用类型都拆分为基本类型，分别进行浅拷贝。比如上面的例子，Person 类有一个引用类型 Address(其实String 也是引用类型，但是String类型有点特殊，后面会详细讲解)，我们在 Address 类内部也重写 clone 方法。如下：</p>
<p>测试还是和上面一样，我们会发现更改了p2对象的Address属性，p1 对象的 Address 属性并没有变化。</p>
<p>但是这种做法有个弊端，这里我们 Person 类只有一个 Address 引用类型，而 Address 类没有，所以我们只用重写 Address 类的clone 方法，但是如果 Address 类也存在一个引用类型，那么我们也要重写其clone 方法，这样下去，有多少个引用类型，我们就要重写多少次，如果存在很多引用类型，那么代码量显然会很大，所以这种方法不太合适。</p>
<p>②、利用序列化</p>
<p>序列化是将对象写到流中便于传输，而反序列化则是把对象从流中读取出来。这里写到流中的对象则是原始对象的一个拷贝，因为原始对象还存在 JVM 中，所以我们可以利用对象的序列化产生克隆对象，然后通过反序列化获取这个对象。</p>
<p>注意每个需要序列化的类都要实现 Serializable 接口，如果有某个属性不需要序列化，可以将其声明为 transient，即将其排除在克隆属性之外。</p>
<p>因为序列化产生的是两个完全独立的对象，所有无论嵌套多少个引用类型，序列化都是能实现深拷贝的。</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="jvm"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-03-17T12:34:10.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">双亲委派模型</title>
    <id>http://www.zhangsj.xyz/blog/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E3%80%81%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E3%80%81%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81%E7%B1%BB%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E5%88%B0JVM%E4%B8%AD%E7%9A%84/</id>
    <link href="http://www.zhangsj.xyz/blog/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E3%80%81%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E3%80%81%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81%E7%B1%BB%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E5%88%B0JVM%E4%B8%AD%E7%9A%84/"/>
    <updated>2022-04-11T06:31:58.000Z</updated>
    <content type="html"><![CDATA[<h2 id="双亲委派模型"> 双亲委派模型</h2>
<p>避免用户自己编写的类动态替换JAVA的一些核心类，比如String。同时也避免了类的重复加载，因为JVM中区分不同类，不仅仅根据类名，相同的class文件被不同ClassLoader加载就是不同的两个类。</p>
<p>双亲委派模型的好处：</p>
<p>主要是为了安全性，便面用户自己编写的类动态替换JAVA的一些核心类，比如String。</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-04-11T06:31:58.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">mq</title>
    <id>http://www.zhangsj.xyz/blog/java/message-queue/</id>
    <link href="http://www.zhangsj.xyz/blog/java/message-queue/"/>
    <updated>2022-03-24T04:39:03.000Z</updated>
    <content type="html"><![CDATA[<p>消息队列目录</p>
<ul>
<li><a href="./kafka.html">Kafka背景及架构介绍</a></li>
<li><a href="./rabbit.html">rabbit</a></li>
<li><a href="./为什么一定要用消息中间件？.html">为什么一定要用消息中间件？</a></li>
</ul>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="mulu"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-25T04:26:56.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">kafka</title>
    <id>http://www.zhangsj.xyz/blog/java/message-queue/kafka/</id>
    <link href="http://www.zhangsj.xyz/blog/java/message-queue/kafka/"/>
    <updated>2022-03-24T04:39:03.000Z</updated>
    <content type="html"><![CDATA[<h2 id="kafka"> kafka</h2>
<h2 id="特点"> 特点</h2>
<ul>
<li>高吞吐量、低延迟：消息中间件每秒可以处理几十万条消息，它的延迟最低只有几毫秒</li>
<li>可扩展性：kafka 集群支持热扩展</li>
<li>持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</li>
<li>容错性：允许集群中节点失败(若副本数量为 n,则允许 n-1 个节点失败)</li>
<li>高并发：支持数千个客户端同时读写</li>
<li>支持Kafka Server间的消息分区，及分布式消费，同时保证每个Partition内的消息顺序传输；</li>
</ul>
<p>数据稳定性一般，而且无法保证消息有序性</p>
<p>每个 topic 可以分多个 partition, consumer group 对 partition 进行 consume 操作。</p>
<h2 id="常用mq对比"> 常用MQ对比</h2>
<p>RabbitMQ：RabbitMQ是使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正因如此，它非常重量级，更适合于企业级的开发。同时实现了Broker构架，这意味着消息在发送给客户端时先在中心队列排队。对路由，负载均衡或者数据持久化都有很好的支持。</p>
<p>Redis：Redis是一个基于Key-Value对的NoSQL数据库，开发维护很活跃。虽然它是一个Key-Value数据库存储系统，但它本身支持MQ功能，所以完全可以当做一个轻量级的队列服务来使用。对于RabbitMQ和Redis的入队和出队操作，各执行100万次，每10万次记录一次执行时间。测试数据分为128Bytes、512Bytes、1K和10K四个不同大小的数据。实验表明：入队时，当数据比较小时Redis的性能要高于RabbitMQ，而如果数据大小超过了10K，Redis则慢的无法忍受；出队时，无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于Redis。</p>
<p>ZeroMQ：ZeroMQ号称最快的消息队列系统，尤其针对大吞吐量的需求场景。ZMQ能够实现RabbitMQ不擅长的高级/复杂的队列，但是开发人员需要自己组合多种技术框架，技术上的复杂度是对这MQ能够应用成功的挑战。ZeroMQ具有一个独特的非中间件的模式，你不需要安装和运行一个消息服务器或中间件，因为你的应用程序将扮演这个服务器角色。你只需要简单的引用ZeroMQ程序库，可以使用NuGet安装，然后你就可以愉快的在应用程序之间发送消息了。但是ZeroMQ仅提供非持久性的队列，也就是说如果宕机，数据将会丢失。其中，Twitter的Storm 0.9.0以前的版本中默认使用ZeroMQ作为数据流的传输（Storm从0.9版本开始同时支持ZeroMQ和Netty作为传输模块）。</p>
<p>ActiveMQ：ActiveMQ是Apache下的一个子项目。 类似于ZeroMQ，它能够以代理人和点对点的技术实现队列。同时类似于RabbitMQ，它少量代码就可以高效地实现高级应用场景。</p>
<p>Kafka/Jafka：Kafka是Apache下的一个子项目，是一个高性能跨语言分布式发布/订阅消息队列系统，而Jafka是在Kafka之上孵化而来的，即Kafka的一个升级版。具有以下特性：快速持久化，可以在O(1)的系统开销下进行消息持久化；高吞吐，在一台普通的服务器上既可以达到10W/s的吞吐速率；完全的分布式系统，Broker、Producer、Consumer都原生自动支持分布式，自动实现负载均衡；支持Hadoop数据并行加载，对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka通过Hadoop的并行加载机制统一了在线和离线的消息处理。Apache Kafka相对于ActiveMQ是一个非常轻量级的消息系统，除了性能非常好之外，还是一个工作良好的分布式系统。</p>
<h2 id="使用场景"> 使用场景</h2>
<ul>
<li>消息系统：解耦和生产者和消费者、缓存消息等。</li>
<li>日志收集：一个公司可以用 Kafka 可以收集各种服务的 log，通过 kafka 以统一接口服务的方式开放给各种 consumer，例如 hadoop、HBase、Solr 等。</li>
<li>流式处理：比如 spark streaming 和 Flink</li>
</ul>
<h2 id="概念"> 概念</h2>
<ul>
<li>Broker：Kafka集群包含一个或多个服务器，这种服务器被称为broker；</li>
<li>Producer：消息生产者，就是向 kafka broker 发消息的客户端。</li>
<li>Consumer：消息消费者，向Kafka broker读取消息的客户端；</li>
<li>Topic： 每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）；</li>
<li>Partition：Parition是物理上的概念，每个Topic包含一个或多个Partition.；</li>
<li>Producer：负责发布消息到Kafka broker；</li>
<li>Consumer：消息消费者，向Kafka broker读取消息的客户端；</li>
<li>Consumer Group：每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。</li>
</ul>
<p>为了实现扩展性，一个非常大的 topic 可以分布到多个 broker 上，每个 partition 是一个有序的队列。Partition 中的每条消息都会被分配一个有序的 id(offset)。将消息发给 consumer，kafka 只保证按一个 partition 中的消息的顺序，不保证一个 topic 的整体(多个 partition 间)的顺序。</p>
<p>kafka 的存储文件都是按照 offset.kafka 来命名，用 offset 做名字的好处是方便查找。例如你想找位于 2049 的位置，只要找到 2048.kafka 的文件即可。当然 the first offset 就是 00000000000.kafka。</p>
<h2 id="生产者发送重复解决方案"> 生产者发送重复解决方案</h2>
<p>1、启动 kafka 的幂等性</p>
<p>要启动 kafka 的幂等性，无需修改代码，默认为关闭，需要修改配置文件:enable.idempotence=true 同时要求 ack=all 且 retries&gt;1。</p>
<p>幂等原理：</p>
<p>每个 producer 有一个 producer id，服务端会通过这个 ID 关联记录每个 producer 的状态，每个 producer 的每条消息会带上一个递增的 sequence，服务端会记录每个 producer 对应的当前最大 sequence，producerId + sequence ，如果新的消息带上的 sequence 不大于当前的最大 sequence 就拒绝这条消息，如果消息落盘会同时更新最大 sequence，这个时候重发的消息会被服务端拒掉从而避免消息重复。该配置同样应用于 kafka 事务中。</p>
<p>2、ack=0，不重试。</p>
<p>可能会丢消息，适用于吞吐量指标重要性高于数据丢失，例如：日志收集。</p>
<h2 id="生产者和-broke-阶段消息丢失场景"> 生产者和 broke 阶段消息丢失场景</h2>
<p>1、ack=0，不重试</p>
<p>Producer 发送消息完，不管结果了，如果发送失败也就丢失了。</p>
<p>2、ack=1，leader crash</p>
<p>Producer 发送消息完，只等待 lead 写入成功就返回了，leader crash 了，这时 follower 没来及同步，消息丢失。</p>
<p>3、unclean.leader.election.enable 配置 true</p>
<p>允许选举 ISR 以外的副本作为 leader,会导致数据丢失，默认为 false。Producer 发送异步消息完，只等待 lead 写入成功就返回了，leader crash 了，这时 ISR 中没有 follower，leader 从 OSR 中选举，因为 OSR 中本来落后于 Leader 造成消息丢失。</p>
<h2 id="kafka消息堆积"> kafka消息堆积</h2>
<p>提高消费者处理速度</p>
<p>增加更多消费者</p>
<p>增加队列消息存储上限</p>
<p>注：Kafka 什么时候进行提交消费进度以及心跳保活的方式很关键</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="mq"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-01-30T09:23:34.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">rocketMQ</title>
    <id>http://www.zhangsj.xyz/blog/java/message-queue/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%98%AF%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84/</id>
    <link href="http://www.zhangsj.xyz/blog/java/message-queue/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%98%AF%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84/"/>
    <updated>2022-04-11T06:31:58.000Z</updated>
    <content type="html"><![CDATA[<h2 id="rocketmq"> rocketMQ</h2>
<p>consumer</p>
<p>需要部署多个节点，以保证</p>
<ul>
<li>Zookeeper部署2N+1节点，形成ZOOKEEPER集群，保证高可用。</li>
<li>kafka Broker部署集群。
<ul>
<li>每个TOPIC的PARTITION，基于【副本机制】，在Broker集群中复制，形成REPICA副本，保证消息存储的可靠性。每个REPILICA副本，都会选择出一个LEADER分区，提供给客户端进行读写。</li>
</ul>
</li>
<li></li>
</ul>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-04-11T06:31:58.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">kafka</title>
    <id>http://www.zhangsj.xyz/blog/java/message-queue/kafka%E8%A1%A5%E5%85%85/</id>
    <link href="http://www.zhangsj.xyz/blog/java/message-queue/kafka%E8%A1%A5%E5%85%85/"/>
    <updated>2022-04-11T06:31:58.000Z</updated>
    <content type="html"><![CDATA[<h2 id="kafka"> kafka</h2>
<p>Kafka 是一个分布式流式处理平台。</p>
<p>流平台具有三个关键功能：</p>
<ol>
<li>消息队列：发布和订阅消息流，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。</li>
<li>容错的持久方式存储记录消息流： Kafka 会把消息持久化到磁盘，有效避免了消息丢失的风险。</li>
<li>流式处理平台: 在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。</li>
</ol>
<p>Kafka 主要有两大应用场景：</p>
<ol>
<li>消息队列 ：建立实时流数据管道，以可靠地在系统或应用程序之间获取数据。</li>
<li>数据处理： 构建实时的流数据处理程序来转换或处理数据流。</li>
</ol>
<h3 id="和其他消息队列相比-kafka-的优势在哪里"> 和其他消息队列相比,Kafka 的优势在哪里？</h3>
<p>Kafka 相比其他消息队列主要的优势如下：</p>
<ol>
<li>极致的性能 ：设计中大量使用了批量处理和异步的思想，最高可以每秒处理千万级别的消息。</li>
<li>生态系统兼容性好 ：Kafka 与周边生态系统的兼容性是最好的，在大数据和流计算领域。</li>
</ol>
<h3 id="队列模型了解吗-kafka-的消息模型知道吗"> 队列模型了解吗？Kafka 的消息模型知道吗？</h3>
<p>使用队列(Queue)作为消息通信载体，满足生产者与消费者模式，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。 比如：我们生产者发送 100 条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半(也就是你一个我一个的消费。)</p>
<p>队列模型存在的问题：</p>
<p>假如我们存在这样一种情况：我们需要将生产者产生的消息分发给多个消费者，并且每个消费者都能接收到完整的消息内容。</p>
<p>这种情况，队列模型就不好解决了。很多比较杠精的人就说：我们可以为每个消费者创建一个单独的队列，让生产者发送多份。这是一种非常愚蠢的做法，浪费资源不说，还违背了使用消息队列的目的。</p>
<h4 id="发布-订阅模型-kafka-消息模型"> 发布-订阅模型:Kafka 消息模型</h4>
<p>发布-订阅模型主要是为了解决队列模型存在的问题。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/发布订阅模型.png" alt="发布订阅模型" loading="lazy"></p>
<p>发布订阅模型(Pub-Sub) 使用主题(Topic) 作为消息通信载体，类似于广播模式；发布者发布一条消息，该消息通过主题传递给所有的订阅者，在一条消息广播之后才订阅的用户则是收不到该条消息的。</p>
<p>在发布 - 订阅模型中，如果只有一个订阅者，那它和队列模型就基本是一样的了。所以说，发布 - 订阅模型在功能层面上是可以兼容队列模型的。</p>
<p>Kafka 采用的就是发布 - 订阅模型。</p>
<blockquote>
<p>RocketMQ 的消息模型和 Kafka 基本是完全一样的。唯一的区别是 Kafka 中没有队列这个概念，与之对应的是 Partition(分区)。</p>
</blockquote>
<h3 id="基本概念"> 基本概念</h3>
<p>Kafka 将生产者发布的消息发送到 Topic(主题) 中，需要这些消息的消费者可以订阅这些 Topic(主题)，如下图所示：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/KafkaTopicPartitioning.png" alt="Kafka Topic Partition" loading="lazy"></p>
<h2 id="二、kafka基本架构"> 二、Kafka基本架构</h2>
<p>Producer(生产者) 产生消息的一方。</p>
<p>Consumer(消费者) 消费消息的一方。</p>
<p>Broker(代理)</p>
<p>可以看作是一个独立的 Kafka 实例。多个 Kafka Broker 组成一个 Kafka Cluster。</p>
<p>同时，你一定也注意到每个 Broker 中又包含了 Topic 以及 Partition 这两个重要的概念：</p>
<ul>
<li>主题（Topic）： Producer将消息发送到特定的主题，Consumer通过订阅特定的Topic（主题）来消费消息。</li>
<li>分区（Partition）: <code>Partition</code>属于<code>Topic</code>的一部分。一个Topic可以有多个Partition ，并且同一 Topic 下的 Partition 可以分布在不同的 Broker 上，这也就表明一个 Topic 可以横跨多个 Broker 。这正如我上面所画的图一样。</li>
<li></li>
</ul>
<blockquote>
<p>划重点：Kafka 中的 Partition(分区) 实际上可以对应成为消息队列中的队列。这样是不是更好理解一点？</p>
</blockquote>
<h3 id="kafka-的多副本机制"> Kafka 的多副本机制</h3>
<p>还有一点我觉得比较重要的是 Kafka 为分区(Partition)引入了多副本(Replica)机制。分区(Partition)中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。</p>
<blockquote>
<p>生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。当 leader 副本发生故障时会从 follower 中选举出一个 leader,但是 follower 中如果有和 leader 同步程度达不到要求的参加不了 leader 的竞选。</p>
</blockquote>
<h4 id="好处"> 好处</h4>
<p>Kafka 的多分区(Partition)以及多副本(Replica)机制有什么好处呢？</p>
<ol>
<li>Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力(负载均衡)。</li>
<li>Partition 可以指定对应的 Replica 数, 这也极大地提高了消息存储的安全性, 提高了容灾能力，不过也相应的增加了所需要的存储空间。</li>
</ol>
<h3 id="zookeeper-在-kafka-中的作用"> Zookeeper 在 Kafka 中的作用</h3>
<p>下图就是我的本地 Zookeeper ，它成功和我本地的 Kafka 关联上(以下文件夹结构借助 idea 插件 Zookeeper tool 实现)。</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/zookeeper-kafka.jpg" style="zoom:50%;" />
<p>ZooKeeper 主要为 Kafka 提供元数据的管理的功能。</p>
<p>从图中我们可以看出，Zookeeper 主要为 Kafka 做了下面这些事情：</p>
<ol>
<li>Broker 注册 ：</li>
</ol>
<p>在 Zookeeper 上会有一个专门用来进行 Broker 服务器列表记录的节点。每个 Broker 在启动时，都会到 Zookeeper 上进行注册，即到 <code>/brokers/ids</code> 下创建属于自己的节点。每个 Broker 就会将自己的 IP 地址和端口等信息记录到该节点中去</p>
<ol start="2">
<li>Topic 注册 ：</li>
</ol>
<p>在 Kafka 中，同一个 Topic 的消息会被分成多个分区并将其分布在多个 Broker 上，这些分区信息及与 Broker 的对应关系也都是由 Zookeeper 在维护。比如我创建了一个名字为 my-topic 的主题并且它有两个分区，对应到 zookeeper 中会创建这些文件夹：<code>/brokers/topics/my-topic/Partitions/0</code>、<code>/brokers/topics/my-topic/Partitions/1</code></p>
<ol start="3">
<li>负载均衡 ：</li>
</ol>
<p>上面也说过了 Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力。 对于同一个 Topic 的不同 Partition，Kafka 会尽力将这些 Partition 分布到不同的 Broker 服务器上。当生产者产生消息后也会尽量投递到不同 Broker 的 Partition 里面。当 Consumer 消费的时候，Zookeeper 可以根据当前的 Partition 数量以及 Consumer 数量来实现动态负载均衡。</p>
<h3 id="kafka-如何保证消息的消费顺序"> Kafka 如何保证消息的消费顺序？</h3>
<p>我们在使用消息队列的过程中经常有业务场景需要严格保证消息的消费顺序，比如我们同时发了 2 个消息，这 2 个消息对应的操作分别对应的数据库操作是：</p>
<ol>
<li>更改用户会员等级。</li>
<li>根据会员等级计算订单价格。</li>
</ol>
<p>假如这两条消息的消费顺序不一样造成的最终结果就会截然不同。</p>
<p>我们知道 Kafka 中 Partition(分区)是真正保存消息的地方，我们发送的消息都被放在了这里。而我们的 Partition(分区) 又存在于 Topic(主题) 这个概念中，并且我们可以给特定 Topic 指定多个 Partition。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/KafkaTopicPartionsLayout.png" alt="" loading="lazy"></p>
<p>每次添加消息到 Partition(分区) 的时候都会采用尾加法，如上图所示。 Kafka 只能为我们保证 Partition(分区) 中的消息有序。</p>
<blockquote>
<p>消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量(offset)。Kafka 通过偏移量(offset)来保证消息在分区内的顺序性。</p>
</blockquote>
<p>所以，我们就有一种很简单的保证消息消费顺序的方法：</p>
<p>1 个 Topic 只对应一个 Partition。</p>
<p>这样当然可以解决问题，但是破坏了 Kafka 的设计初衷。</p>
<p>Kafka 中发送 1 条消息的时候，可以指定 topic, partition, key, data(数据) 4 个参数。如果你发送消息的时候指定了 Partition 的话，所有消息都会被发送到指定的 Partition。并且，同一个 key 的消息可以保证只发送到同一个 partition，这个我们可以采用表/对象的 ID 来作为 key 。</p>
<div><p>总结</p>
<p>对于如何保证 Kafka 中消息消费的顺序，有了下面两种方法：</p>
<ol>
<li>
<p>1 个 Topic 只对应一个 Partition。</p>
</li>
<li>
<p>(推荐)发送消息的时候指定 key/Partition。</p>
</li>
</ol>
</div>
<p>当然不仅仅只有上面两种方法，上面两种方法是我觉得比较好理解的，</p>
<h3 id="kafka-如何保证消息不丢失"> Kafka 如何保证消息不丢失</h3>
<h4 id="生产者丢失消息的情况"> 生产者丢失消息的情况</h4>
<p>生产者(Producer) 调用<code>send</code>方法发送消息之后，消息可能因为网络问题并没有发送过去。</p>
<p>所以，我们不能默认在调用<code>send</code>方法发送消息之后消息发送成功了。为了确定消息是发送成功，我们要判断消息发送的结果。但是要注意的是 Kafka 生产者(Producer) 使用 <code>send</code> 方法发送消息实际上是异步的操作，我们可以通过 <code>get()</code>方法获取调用结果，但是这样也让它变为了同步操作，示例代码如下：</p>
<div><pre><code><span>SendResult</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> sendResult <span>=</span> kafkaTemplate<span>.</span><span>send</span><span>(</span>topic<span>,</span> o<span>)</span><span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
<span>if</span> <span>(</span>sendResult<span>.</span><span>getRecordMetadata</span><span>(</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
  logger<span>.</span><span>info</span><span>(</span><span>"生产者成功发送消息到"</span> <span>+</span> sendResult<span>.</span><span>getProducerRecord</span><span>(</span><span>)</span><span>.</span><span>topic</span><span>(</span><span>)</span> <span>+</span> <span>"-> "</span> <span>+</span> sendRe
              sult<span>.</span><span>getProducerRecord</span><span>(</span><span>)</span><span>.</span><span>value</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>但是一般不推荐这么做！可以采用为其添加回调函数的形式，示例代码如下：</p>
<div><pre><code><span>class</span> <span>T</span><span>{</span>
        <span>private</span> <span>void</span> <span>m</span><span>(</span><span>)</span><span>{</span>
            <span>ListenableFuture</span><span><span>&lt;</span><span>SendResult</span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span><span>></span></span> future <span>=</span> kafkaTemplate<span>.</span><span>send</span><span>(</span>topic<span>,</span> o<span>)</span><span>;</span>
                    future<span>.</span><span>addCallback</span><span>(</span>result <span>-></span> logger<span>.</span><span>info</span><span>(</span><span>"生产者成功发送消息到topic:{} partition:{}的消息"</span><span>,</span> result<span>.</span><span>getRecordMetadata</span><span>(</span><span>)</span><span>.</span><span>topic</span><span>(</span><span>)</span><span>,</span> result<span>.</span><span>getRecordMetadata</span><span>(</span><span>)</span><span>.</span><span>partition</span><span>(</span><span>)</span><span>)</span><span>,</span>
                    ex <span>-></span> logger<span>.</span><span>error</span><span>(</span><span>"生产者发送消失败，原因：{}"</span><span>,</span> ex<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>如果消息发送失败的话，我们检查失败的原因之后重新发送即可！</p>
<p>另外这里推荐为 Producer 的<code>retries</code>(重试次数)设置一个比较合理的值，一般是 3 ，</p>
<p>但是为了保证消息不丢失的话一般会设置比较大一点。</p>
<p>设置完成之后，当出现网络问题之后能够自动重试消息发送，避免消息丢失。另外，建议还要设置重试间隔，因为间隔太小的话重试的效果就不明显了，网络波动一次你 3 次一下子就重试完了</p>
<h4 id="消费者丢失消息的情况"> 消费者丢失消息的情况</h4>
<p>我们知道消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量(offset)。</p>
<p>偏移量(offset)表示 Consumer 当前消费到的 Partition(分区)的所在的位置。Kafka 通过偏移量（offset)可以保证消息在分区内的顺序性。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/kafka-offset.jpg" alt="kafka offset" loading="lazy"></p>
<p>当消费者拉取到了分区的某个消息之后，消费者会自动提交了 offset。自动提交的话会有一个问题，试想一下，当消费者刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了。</p>
<p>解决办法也比较粗暴，我们手动关闭自动提交 offset，每次在真正消费完消息之后再自己手动提交 offset 。 但是，细心的朋友一定会发现，这样会带来消息被重新消费的问题。比如你刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。</p>
<h4 id="kafka-弄丢了消息"> Kafka 弄丢了消息</h4>
<p>我们知道 Kafka 为分区(Partition)引入了多副本(Replica)机制。</p>
<p>分区(Partition)中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。</p>
<p>我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。</p>
<p>生产者和消费者只与 leader 副本交互。</p>
<p>你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。</p>
<p>试想一种情况：假如 leader 副本所在的 broker 突然挂掉，那么就要从 follower 副本重新选出一个 leader ，但是 leader 的数据还有一些没有被 follower 副本的同步的话，就会造成消息丢失。</p>
<p>设置 <code>acks = all</code></p>
<p>解决办法就是我们设置 acks = all。</p>
<p>acks 是 Kafka 生产者(Producer) 很重要的一个参数。</p>
<p>acks 的默认值即为 1，代表我们的消息被 leader 副本接收之后就算被成功发送。当我们配置 acks = all 代表则所有副本都要接收到该消息之后该消息才算真正成功被发送。</p>
<p>设置 replication.factor &gt;= 3</p>
<p>为了保证 leader 副本能有 follower 副本能同步消息，我们一般会为 topic 设置 replication.factor &gt;= 3。这样就可以保证每个 分区(partition) 至少有 3 个副本。虽然造成了数据冗余，但是带来了数据的安全性。</p>
<p>设置 min.insync.replicas &gt; 1</p>
<p>一般情况下我们还需要设置 min.insync.replicas&gt; 1 ，这样配置代表消息至少要被写入到 2 个副本才算是被成功发送。Min.insync.replicas 的默认值为 1 ，在实际生产中应尽量避免默认值 1。</p>
<p>但是，为了保证整个 Kafka 服务的高可用性，你需要确保 replication.factor &gt; min.insync.replicas 。为什么呢？设想一下假如两者相等的话，只要是有一个副本挂掉，整个分区就无法正常工作了。这明显违反高可用性！一般推荐设置成 replication.factor = min.insync.replicas + 1。</p>
<p>设置 unclean.leader.election.enable = false</p>
<blockquote>
<p>Kafka 0.11.0.0 版本开始 unclean.leader.election.enable 参数的默认值由原来的 true 改为 false</p>
</blockquote>
<p>我们最开始也说了我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。多个 follower 副本之间的消息同步情况不一样，当我们配置了 unclean.leader.election.enable = false 的话，当 leader 副本发生故障时就不会从 follower 副本中和 leader 同步程度达不到要求的副本中选择出 leader ，这样降低了消息丢失的可能性。</p>
<h3 id="kafka-如何保证消息不重复消费"> Kafka 如何保证消息不重复消费</h3>
<p>kafka 出现消息重复消费的原因：</p>
<ul>
<li>服务端侧已经消费的数据没有成功提交 offset(根本原因)。</li>
<li>Kafka 侧 由于服务端处理业务时间长或者网络链接等等原因让 Kafka 认为服务假死，触发了分区 rebalance。</li>
</ul>
<p>解决方案：</p>
<ul>
<li>消费消息服务做幂等校验，比如 Redis 的 set、MySQL 的主键等天然的幂等功能。这种方法最有效。</li>
<li>将 <code>enable.auto.commit</code> 参数设置为 false，关闭自动提交，开发者在代码中手动提交 offset。那么这里会有个问题：什么时候提交 offset 合适？
<ul>
<li>处理完消息再提交：依旧有消息重复消费的风险，和自动提交一样</li>
<li>拉取到消息即提交：会有消息丢失的风险。允许消息延时的场景，一般会采用这种方式。然后，通过定时任务在业务不繁忙(比如凌晨)的时候做数据兜底。</li>
</ul>
</li>
</ul>
<h3 id="reference"> Reference</h3>
<ul>
<li>Kafka 官方文档： <a href="https://kafka.apache.org/documentation/" target="_blank" rel="noopener noreferrer">https://kafka.apache.org/documentation/</a></li>
<li>极客时间—《Kafka 核心技术与实战》第 11 节：无消息丢失配置怎么实现？</li>
</ul>
<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486269&amp;idx=2&amp;sn=ec00417ad641dd8c3d145d74cafa09ce&amp;chksm=cea244f6f9d5cde0c8eb233fcc4cf82e11acd06446719a7af55230649863a3ddd95f78d111de&amp;token=1633957262&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">Kafka 系列第三篇！10 分钟学会如何在 Spring Boot 程序中使用 Kafka 作为消息队列?</a></p>
<h2 id="三、基本原理"> 三、基本原理</h2>
<p>我们将消息的发布者称作producer，将消息的订阅表述为consumer，将中间的存储阵列称作broker，这样就可以大致描绘出一个场面：</p>
<p>生产者将数据生产出来，交给broker进行存储，，消费者需要消费数据了，就从broker中区拿出数据来，然后完成一系列对数据的处理操作。</p>
<p>咋一看范爷太简单了，不是说了它是分布式吗？难道把producer、broker、和consumer放在三台不同的机器上就算是分布式了吗？</p>
<p>多个broker协同合作，producer和consumer部署在各个分布式消息发布订阅系统就完成了。</p>
<p>图上有个细节需要注意，producer到broker的过程是push，也就是有数据就推送到borker，而consumer到borker的过程就是pull，是通过consumer主动去拉数据的，而不是broker把数据主动发送到consumer端的。</p>
<h2 id="_4、zookeeper在kafka的作用"> 4、Zookeeper在kafka的作用：</h2>
<p>上述，提到了Zookeeper，那么Zookeeper在kafka的作用是什么？</p>
<p>（1）、无论是kafka集群，还是producer和consumer都依赖于zookeeper来保证系统可用性集群保存一些Meta信息。</p>
<p>（2）、kafka使用zookeeper作为其分布式协调框架，很好地将消息生产、存储、消费的过程结合在一起。</p>
<p>(3)、同时借助Z</p>
<h2 id="执行流程"> 执行流程：</h2>
<p>我们看上面的图：我们把broker的数量减少，另有一台。现在假设我们安装上图进行部署:</p>
<h2 id="特性"> 特性：</h2>
<p>高吞吐量、低延迟：</p>
<p>可扩展性：</p>
<p>持久性：</p>
<p>容错性：</p>
<p>高并发：</p>
<p>支持实时在线处理和离线处理：可以用时storm这种实时流处理系统对消息进行实时处理，同时还可以使用Hadoop这种批处理系统进行离线处理；</p>
<h2 id="使用场景"> 使用场景：</h2>
<p>日志收集：</p>
<p>消息系统：</p>
<p>用户活动跟踪：</p>
<p>运营指标：</p>
<p>流式处理：</p>
<p>事件源：</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="mq"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-23T04:30:59.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">RabbitMQ</title>
    <id>http://www.zhangsj.xyz/blog/java/message-queue/rabbit/</id>
    <link href="http://www.zhangsj.xyz/blog/java/message-queue/rabbit/"/>
    <updated>2022-03-24T05:27:46.000Z</updated>
    <content type="html"><![CDATA[<h2 id="rabbitmq"> RabbitMQ</h2>
<h3 id="如何避免消息堆积"> 如何避免消息堆积？</h3>
<p>消息堆积问题产生的原因往往是因为消息发送的速度超过了消费者消息处理的速度。</p>
<h3 id="解决方案"> 解决方案</h3>
<p>无外乎以下三点：</p>
<ul>
<li>提高消费者处理速度</li>
<li>增加更多消费者</li>
<li>增加队列消息存储上限</li>
</ul>
<p><strong>1、提高消费者处理速度</strong></p>
<p>消费者处理速度是由业务代码决定的，所以我们能做的事情包括：</p>
<ul>
<li>尽可能优化业务代码，提高业务性能</li>
<li>接收到消息后，开启线程池，并发处理多个消息</li>
</ul>
<p>优点：成本低，改改代码即可</p>
<p>缺点：开启线程池会带来额外的性能开销，对于高频、低时延的任务不合适。推荐任务执行周期较长的业务。</p>
<p><strong>2、增加更多消费者</strong></p>
<p>一个队列绑定多个消费者，共同争抢任务，自然可以提供消息处理的速度。</p>
<p>优点：能用钱解决的问题都不是问题。实现简单粗暴</p>
<p>缺点：问题是没有钱。成本太高</p>
<p><strong>3、增加队列消息存储上限</strong></p>
<p>在 RabbitMQ 的 1.8 版本后，加入了新的队列模式：Lazy Queue</p>
<p>这种队列不会将消息保存在内存中，而是在收到消息后直接写入磁盘中，理论上没有存储上限。可以解决消息堆积问题。</p>
<p>优点：磁盘存储更安全；存储无上限；避免内存存储带来问题，性能更稳定；</p>
<p>缺点：磁盘存储受到 IO 性能的限制，消息时效性不如内存模式，但影响不大。</p>
<h2 id="rabbitmq-如何保证消息的有序性"> RabbitMQ 如何保证消息的有序性？</h2>
<h3 id="概念"> 概念</h3>
<p>其实 RabbitMQ 是队列存储，天然具备先进先出的特点，只要消息的发送是有序的，那么理论上接收也是有序的。不过当一个队列绑定了多个消费者时，可能出现消息轮询投递给消费者的情况，而消费者的处理顺序就无法保证了。</p>
<h3 id="解决方案-2"> 解决方案</h3>
<p>因此，要保证消息的有序性，需要做的下面几点：</p>
<ul>
<li>保证消息发送的有序性</li>
<li>保证一组有序的消息都发送到同一个队列</li>
<li>保证一个队列只包含一个消费者</li>
</ul>
<h2 id="如何防止-mq-消息被重复消费"> 如何防止 MQ 消息被重复消费？</h2>
<h3 id="概念-2"> 概念</h3>
<p>消息重复消费的原因多种多样，不可避免。所以只能从消费者端入手，只要能保证消息处理的幂等性就可以确保消息不被重复消费。</p>
<h3 id="解决方案-3"> 解决方案</h3>
<p>而幂等性的保证又有很多方案：</p>
<ul>
<li>给每一条消息都添加一个唯一 id，在本地记录消息表及消息状态，处理消息时基于数据库表的 ID 唯一性做判断</li>
<li>同样是记录消息表，利用消息状态字段实现基于乐观锁的判断，保证幂等</li>
<li>基于业务本身的幂等性。比如根据 ID 的删除、查询业务天生幂等；新增、修改等业务可以考虑基于数据库 ID 唯一性、或者乐观锁机制确保幂等。本质与消息表方案类似。</li>
</ul>
<h2 id="如何保证-rabbitmq-的高可用"> 如何保证 RabbitMQ 的高可用？</h2>
<h3 id="概念-3"> 概念</h3>
<p>要实现 RabbitMQ 的高可用无外乎下面两点：</p>
<h3 id="解决方案-4"> 解决方案</h3>
<ul>
<li>做好交换机、队列、消息的持久化</li>
<li>搭建 RabbitMQ 的镜像集群，做好主从备份。当然也可以使用仲裁队列代替镜像集群。</li>
</ul>
<h2 id="使用-mq-可以解决那些问题"> 使用 MQ 可以解决那些问题？</h2>
<p>RabbitMQ 能解决的问题很多，例如：</p>
<ul>
<li>解耦合：将几个业务关联的微服务调用修改为基于 MQ 的异步通知，可以解除微服务之间的业务耦合。同时还提高了业务性能。</li>
<li>流量削峰：将突发的业务请求放入 MQ 中，作为缓冲区。后端的业务根据自己的处理能力从 MQ 中获取消息，逐个处理任务。流量曲线变的平滑很多</li>
<li>延迟队列：基于 RabbitMQ 的死信队列或者 DelayExchange 插件，可以实现消息发送后，延迟接收的效果。</li>
</ul>
<p>业务模块中使用的 RabbitMQ</p>
<p>kafka 是以吞吐量高而闻名，不过其数据稳定性一般，而且无法<code>保证消息有序性</code>。我们公司的日志收集也有使用，</p>
<p>阿里巴巴的 RocketMQ 基于 Kafka 的原理，弥补了 Kafka 的缺点，继承了其高吞吐的优势，其客户端目前以 Java 为主。</p>
<p>RabbitMQ 基于面向并发的语言 Erlang 开发，吞吐量不如 Kafka，消息可靠性较好，并且消息延迟极低，集群搭建比较方便。</p>
<p>支持多种协议，并且有各种语言的客户端，比较灵活。</p>
<p>Spring 对 RabbitMQ 的支持也比较好，使用起来比较方便</p>
<p>综合考虑并发需求以及稳定性需求，RabbitMQ 和 kafka</p>
<h2 id="rabbitmq-如何确保消息的不丢失"> RabbitMQ 如何确保消息的不丢失</h2>
<p>RabbitMQ 针对消息传递过程中可能发生问题的各个地方，给出了针对性的解决方案：</p>
<h3 id="生产者发送消息时可能因为网络问题导致消息没有到达交换机"> 生产者发送消息时可能因为网络问题导致消息没有到达交换机</h3>
<p>RabbitMQ 提供了 publisher confirm 机制</p>
<p>生产者发送消息后，可以编写 ConfirmCallback 函数</p>
<p>消息成功到达交换机后，RabbitMQ 会调用 ConfirmCallback 通知消息的发送者，返回 ACK</p>
<p>消息如果未到达交换机，RabbitMQ 也会调用 ConfirmCallback 通知消息的发送者，返回 NACK</p>
<p>消息超时未发送成功也会抛出异常</p>
<p>消息到达交换机后，如果未能到达队列，也会导致消息丢失：</p>
<p>RabbitMQ 提供了 publisher return 机制</p>
<p>生产者可以定义 ReturnCallback 函数</p>
<p>消息到达交换机，未到达队列，RabbitMQ 会调用 ReturnCallback 通知发送者，告知失败原因</p>
<h3 id="消息到达队列后-mq-宕机也可能导致丢失消息"> 消息到达队列后，MQ 宕机也可能导致丢失消息</h3>
<p>RabbitMQ 提供了持久化功能，集群的主从备份功能</p>
<p>消息持久化，RabbitMQ 会将交换机、队列、消息持久化到磁盘，宕机重启可以恢复消息</p>
<p>镜像集群，仲裁队列，都可以提供主从备份功能，主节点宕机，从节点会自动切换为主，数据依然在</p>
<blockquote>
<p>仲裁队列概念()</p>
<p>开启第一个应用是消息发布者，第二个应用是消息的订阅者，第三个应用将在时间到时关闭 RabbitMQ 节点，模拟故障宕机。</p>
<p>开启消息发布，会看到发布者正在发布，订阅者正在订阅。消息从仲裁队列按顺序到达。然后关闭 RabbitMQ 三个节点中一个，但是处理过程中没有暂停，并且 Spring Boot 应用程序保持按顺序发送和接收数据。仲裁队列有了新的领导者，并且三个集群成员中只有两个处于联机状态。</p>
<p>再次启动已停止的节点，发现它迅速重新加入群集并再次开始参与仲裁队列。</p>
</blockquote>
<h3 id="消息投递给消费者后-如果消费者处理不当-也可能导致消息丢失"> 消息投递给消费者后，如果消费者处理不当，也可能导致消息丢失</h3>
<p>SpringAMQP 基于 RabbitMQ 提供了消费者确认机制、消费者重试机制，消费者失败处理策略：</p>
<p>1、消费者的确认机制：</p>
<p>消费者处理消息成功，未出现异常时，Spring 返回 ACK 给 RabbitMQ，消息才被移除</p>
<p>消费者处理消息失败，抛出异常，宕机，Spring 返回 NACK 或者不返回结果，消息不被异常</p>
<p>2、消费者重试机制：</p>
<p>默认情况下，消费者处理失败时，消息会再次回到 MQ 队列，然后投递给其它消费者。Spring 提供的消费者重试机制，则是在处理失败后不返回 NACK，而是直接在消费者本地重试。多次重试都失败后，则按照消费者失败处理策略来处理消息。避免了消息频繁入队带来的额外压力。</p>
<p>3、消费者失败策略：</p>
<p>当消费者多次本地重试失败时，消息默认会丢弃。</p>
<p>Spring 提供了 Republish 策略，在多次重试都失败，耗尽重试次数后，将消息重新投递给指定的异常交换机，并且会携带上异常栈信息，帮助定位问题。</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="mq"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-02T03:31:07.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">java</title>
    <id>http://www.zhangsj.xyz/blog/java/</id>
    <link href="http://www.zhangsj.xyz/blog/java/"/>
    <updated>2022-04-12T10:55:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="java目录"> java目录</h2>
<ul>
<li><a href="./docs/algo/">算法</a></li>
<li><a href="./concurrent/">并发</a></li>
<li><a href="./datasource/">数据库</a></li>
<li><a href="./jvm/">虚拟机</a></li>
<li><a href="./message-queue/">消息队列</a></li>
<li><a href="./redis/">缓存</a></li>
<li><a href="./spring/">spring 框架</a></li>
<li><a href="./soa/">微服务、springCloud、Dubbo、前后端分离</a></li>
</ul>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="mulu"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-24T06:03:53.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">redis-content</title>
    <id>http://www.zhangsj.xyz/blog/java/redis/</id>
    <link href="http://www.zhangsj.xyz/blog/java/redis/"/>
    <updated>2022-03-28T06:04:45.000Z</updated>
    <content type="html"><![CDATA[<h2 id="目录"> 目录</h2>
<ul>
<li><a href="./redis.html">redis 知识点梳理1</a></li>
<li><a href="./interview.html">redis 知识点梳理2</a></li>
<li><a href="./redis高可用架构分析和搭建.html">redis高可用架构分析和搭建</a></li>
</ul>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="mulu"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-25T04:26:56.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">redis-lock</title>
    <id>http://www.zhangsj.xyz/blog/java/redis/redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <link href="http://www.zhangsj.xyz/blog/java/redis/redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <updated>2022-03-04T10:32:59.000Z</updated>
    <content type="html"><![CDATA[<h3 id="分布式锁"> 分布式锁</h3>
<p>Redis 中的乐观锁机制，可以帮助我们实现分布式锁的效果，用于解决分布式系统下的多线程安全问题</p>
<CodeGroup>
<CodeGroupItem title="基于Redis的分布式锁">
<div><pre><code><span>public</span> <span>void</span> <span>UserRegWithLock</span><span>(</span><span>UserRegDto</span> dto<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
    <span>//精心设计并构造SETNX中的key, 一定要跟实际的业务或共享资源挂钩</span>
    <span>final</span> <span>String</span> key <span>=</span> dto<span>.</span><span>getUserName</span><span>(</span><span>)</span> <span>+</span> <span>"-lock"</span><span>;</span>
    <span>//设计key对应的value应该具有随机性</span>
    <span>final</span> <span>String</span> value <span>=</span> <span>System</span><span>.</span><span>nanoTime</span><span>(</span><span>)</span> <span>+</span> <span>""</span> <span>+</span> UUID<span>.</span><span>randomUUID</span><span>(</span><span>)</span><span>;</span>
    <span>//调用SETNX操作获取锁, 如果返回true, 代表获取锁成功</span>
    <span>boolean</span> res <span>=</span> redisUtils<span>.</span><span>setIfAbsent</span><span>(</span>key<span>,</span> value<span>)</span><span>;</span>
    <span>if</span> <span>(</span>res<span>)</span> <span>{</span>
        <span>//为了防止出现死锁, 加上EXPIRE操作, 即key的过期时间, 在这里设置为20s, 实际开发是情况而定</span>
        redisUtils<span>.</span><span>expire</span><span>(</span>key<span>,</span> <span>20L</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>)</span><span>;</span>
        <span>try</span> <span>{</span>
            <span>UserReg</span> userReg <span>=</span> userRegMapper<span>.</span><span>selectByUserName</span><span>(</span>dto<span>.</span><span>getUserName</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>if</span> <span>(</span>userReg <span>==</span> <span>null</span><span>)</span> <span>{</span>
                log<span>.</span><span>info</span><span>(</span><span>"---加分布式锁---, 当前用户名为:{}"</span><span>,</span> dto<span>.</span><span>getUserName</span><span>(</span><span>)</span><span>)</span><span>;</span>
                <span>UserReg</span> entity <span>=</span> <span>new</span> <span>UserReg</span><span>(</span><span>)</span><span>;</span>
                <span>BeanUtils</span><span>.</span><span>copyProperties</span><span>(</span>dto<span>,</span> entity<span>)</span><span>;</span>
                entity<span>.</span><span>setCreateTime</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>;</span>
                userRegMapper<span>.</span><span>insertSelective</span><span>(</span>entity<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>
            <span>throw</span> e<span>;</span>
        <span>}</span> <span>finally</span> <span>{</span>
            <span>//不管发生任何状况, 都需要在redis加锁成功并访问操作完成共享资源后释放资源</span>
            <span>if</span> <span>(</span>value<span>.</span><span>equals</span><span>(</span>redisUtils<span>.</span><span>get</span><span>(</span>key<span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>
                redisUtils<span>.</span><span>del</span><span>(</span>key<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="不带锁">
<div><pre><code><span>/**
 * 处理用户提交注册
 *
 * @param dto UserRegDto(用户名, 密码)
 * @throws Exception 账户已注册
 */</span>
<span>public</span> <span>void</span> <span>userRegNoLock</span><span>(</span><span>UserRegDto</span> dto<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
    <span>UserReg</span> userReg <span>=</span> userRegMapper<span>.</span><span>selectByUserName</span><span>(</span>dto<span>.</span><span>getUserName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>userReg <span>==</span> <span>null</span><span>)</span> <span>{</span>
        log<span>.</span><span>info</span><span>(</span><span>"---不加分布式锁---, 当前用户名为:{}"</span><span>,</span> dto<span>.</span><span>getUserName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>UserReg</span> entity <span>=</span> <span>new</span> <span>UserReg</span><span>(</span><span>)</span><span>;</span>
        <span>BeanUtils</span><span>.</span><span>copyProperties</span><span>(</span>dto<span>,</span> entity<span>)</span><span>;</span>
        entity<span>.</span><span>setCreateTime</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>;</span>
        userRegMapper<span>.</span><span>insertSelective</span><span>(</span>entity<span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>Exception</span><span>(</span><span>"用户信息已经存在"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div></CodeGroupItem>
</CodeGroup>
<h3 id="redisson"> Redisson</h3>
<h4 id="典型应用场景之高性能点赞"> 典型应用场景之高性能点赞</h4>
<p>一般情况下, 一个完整的点赞业务模块包含两大核心操作: 点赞和取消点赞.</p>
<p>用户点赞文章</p>
<ol>
<li>校验文章，用户等基本信息</li>
<li>校验通过，查询当前用户-当前文章的点赞记录</li>
<li>插入当前用户-当前文档的点赞记录 返回相应结果被</li>
</ol>
<p>先查询当前用户是否已经点赞过了, 如果已经点赞过了, 就直接返回点赞成功; 如果没有点赞过, 当用户点赞时系统后端会记录一条该文章的点赞记录至数据库中, 并设置该记录当前的状态为1, 表示当前用户已点赞该文章.</p>
<CodeGroup>
<CodeGroupItem title="分布式锁">
<div><pre><code> <span>public</span> <span>void</span> <span>addPraiseLock</span><span>(</span><span>PraiseDto</span> dto<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
    <span>//定义用于获取分布式锁的Redis的key</span>
    <span>final</span> <span>String</span> lockName <span>=</span> keyAddBlogLock <span>+</span> dto<span>.</span><span>getBlogId</span><span>(</span><span>)</span> <span>+</span> <span>"-"</span> <span>+</span> dto<span>.</span><span>getUserId</span><span>(</span><span>)</span><span>;</span>
    <span>//获取一次性锁对象</span>
    <span>RLock</span> lock <span>=</span> redissonClient<span>.</span><span>getLock</span><span>(</span>lockName<span>)</span><span>;</span>
    <span>//上锁并在10秒钟自动释放,可用于避免Redis节点宕机时出现死锁</span>
    lock<span>.</span><span>lock</span><span>(</span><span>10L</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>)</span><span>;</span>

    <span>try</span> <span>{</span>
        <span>Praise</span> praise <span>=</span> praiseMapper<span>.</span><span>selectByBlogUserId</span><span>(</span>dto<span>.</span><span>getBlogId</span><span>(</span><span>)</span><span>,</span> dto<span>.</span><span>getUserId</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>praise <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>//如果没有点赞记录, 则创建点赞实体信息</span>
            <span>Praise</span> p <span>=</span> <span>new</span> <span>Praise</span><span>(</span><span>)</span><span>;</span>
            <span>BeanUtils</span><span>.</span><span>copyProperties</span><span>(</span>dto<span>,</span> p<span>)</span><span>;</span>
            <span>Date</span> date <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>;</span>
            p<span>.</span><span>setPraiseTime</span><span>(</span>date<span>)</span><span>;</span>
            p<span>.</span><span>setStatus</span><span>(</span><span>1</span><span>)</span><span>;</span>
            p<span>.</span><span>setCreateTime</span><span>(</span>date<span>)</span><span>;</span>
            p<span>.</span><span>setUpdateTime</span><span>(</span>date<span>)</span><span>;</span>
            <span>//插入点赞记录</span>
            <span>int</span> total <span>=</span> praiseMapper<span>.</span><span>insertSelective</span><span>(</span>p<span>)</span><span>;</span>
            <span>if</span><span>(</span>total <span>></span> <span>0</span><span>)</span> <span>{</span>
                <span>//如果插入成功, 则输出打印相应的信息, 并将用户点赞记录添加至缓存中</span>
                log<span>.</span><span>info</span><span>(</span><span>"--点赞博客,-{}-加分布式锁-插入点赞记录成功---"</span><span>,</span>dto<span>.</span><span>getBlogId</span><span>(</span><span>)</span><span>)</span><span>;</span>
                redisPraise<span>.</span><span>cachePraiseBlog</span><span>(</span>dto<span>.</span><span>getBlogId</span><span>(</span><span>)</span><span>,</span> dto<span>.</span><span>getUserId</span><span>(</span><span>)</span><span>,</span> <span>1</span><span>)</span><span>;</span>
                <span>this</span><span>.</span><span>cachePraiseTotal</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>
        log<span>.</span><span>error</span><span>(</span><span>"--点赞博客,-{}-分布式锁-发生未知异常--"</span><span>,</span>dto<span>.</span><span>getBlogId</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>throw</span> e<span>;</span>
    <span>}</span> <span>finally</span> <span>{</span>
        <span>if</span> <span>(</span>lock<span>.</span><span>isLocked</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>lock<span>.</span><span>isHeldByCurrentThread</span><span>(</span><span>)</span><span>)</span> <span>{</span>
                lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="无分布式锁">
<div><pre><code> <span>@Transactional</span><span>(</span>rollbackFor <span>=</span> <span>Exception</span><span>.</span><span>class</span><span>)</span>
<span>public</span> <span>void</span> <span>addPraise</span><span>(</span><span>PraiseDto</span> dto<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
    <span>Praise</span> praise <span>=</span> praiseMapper<span>.</span><span>selectByBlogUserId</span><span>(</span>dto<span>.</span><span>getBlogId</span><span>(</span><span>)</span><span>,</span> dto<span>.</span><span>getUserId</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>praise <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>//如果没有点赞记录, 则创建点赞实体信息</span>
        <span>Praise</span> p <span>=</span> <span>new</span> <span>Praise</span><span>(</span><span>)</span><span>;</span>
        <span>BeanUtils</span><span>.</span><span>copyProperties</span><span>(</span>dto<span>,</span> p<span>)</span><span>;</span>
        <span>Date</span> date <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>;</span>
        p<span>.</span><span>setPraiseTime</span><span>(</span>date<span>)</span><span>;</span>
        p<span>.</span><span>setStatus</span><span>(</span><span>1</span><span>)</span><span>;</span>
        p<span>.</span><span>setCreateTime</span><span>(</span>date<span>)</span><span>;</span>
        p<span>.</span><span>setUpdateTime</span><span>(</span>date<span>)</span><span>;</span>
        <span>//插入点赞记录</span>
        <span>int</span> total <span>=</span> praiseMapper<span>.</span><span>insertSelective</span><span>(</span>p<span>)</span><span>;</span>
        <span>if</span><span>(</span>total <span>></span> <span>0</span><span>)</span> <span>{</span>
            <span>//如果插入成功, 则输出打印相应的信息, 并将用户点赞记录添加至缓存中</span>
            log<span>.</span><span>info</span><span>(</span><span>"--点赞博客,-{}-无锁-插入点赞记录成功---"</span><span>,</span>dto<span>.</span><span>getBlogId</span><span>(</span><span>)</span><span>)</span><span>;</span>
            redisPraise<span>.</span><span>cachePraiseBlog</span><span>(</span>dto<span>.</span><span>getBlogId</span><span>(</span><span>)</span><span>,</span> dto<span>.</span><span>getUserId</span><span>(</span><span>)</span><span>,</span> <span>1</span><span>)</span><span>;</span>
            <span>this</span><span>.</span><span>cachePraiseTotal</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div></CodeGroupItem>
</CodeGroup>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="redis"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-03-04T10:32:59.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">redis-shuli</title>
    <id>http://www.zhangsj.xyz/blog/java/redis/interview/</id>
    <link href="http://www.zhangsj.xyz/blog/java/redis/interview/"/>
    <updated>2022-04-12T10:55:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="为什么说redis是单线程的"> 为什么说REDIS是单线程的？?</h2>
<p>近乎所有与Java相关的面试都会问到缓存的问题，基础一点的会问到什么是“二八定律”、什么是”热数据和冷数据“，复杂一点的会问到缓存雪崩、缓存穿透，缓存预热，缓存更新、缓存降级等问题，这些看似不常见的概念，都会与我们的缓存服务器相关，一般常见的缓存服务器有Redis，Memcached等，而笔者目前最常用的也只有Redis这一种。</p>
<p>数据库、缓存和消息中间件。</p>
<p>它支持多种类型的数据结构，如字符串（Strings），散列（Hash)、列表、集合、有序集合与范围查找，位图，地图空间索引半径查询。</p>
<p>内置了复制，LUA脚本，LRU驱动事件，事务（不同级别的磁盘持久化，并通过REDIS哨兵和自动分区提供高可用性。</p>
<h1 id="redis"> Redis</h1>
<p>缓存主要用来存放那些读写比很高、很少变化的数据。
没有热点的访问。 缓存使用的内存资源非常宝贵，只能将最新访问的数据缓存起来，而把历史数据清理出缓存。即缓存资源应该留给 20%的热点数据。
数据不一致与脏读。 一般会对缓存设置失效时间，超过失效时间，就要从数据库重新加载。因此应用要忍受一定时间的数据不一致。另一种策略是数据更新时立即更新缓存，不过这也会带来更多的系统开销和事务一致性的问题。
缓存可用性。 业务发展到一定阶段时，缓存会承担大部分数据访问的压力，数据库已经习惯了有缓存的日子，所以当缓存服务器崩溃时，数据库会因为完全不能承受如此大的压力而宕机，进而导致整个网站不可用。这种情况被称作缓存雪崩，发生这种故障，甚至不能简单地重启缓存服务器和数据库服务器来恢复网站访问。 解决方式：1、缓存热备(当某台服务器宕机时，将缓存访问切换到热备服务器上。)；2、缓存服务器集群。</p>
<h2 id="缓存预热。"> 缓存预热。</h2>
<p>系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<p>解决思路：</p>
<ol>
<li>直接写个缓存刷新页面，上线时手工操作下；</li>
<li>数据量不大，可以在项目启动的时候自动进行加载；</li>
<li>定时刷新缓存。</li>
</ol>
<p>缓存中存放的是热点数据，热点数据是缓存系统用 LRU 对不断访问的数据筛选出来的，这个过程需要较长的时间。新启动的缓存系统没有任何数据，此时系统的性能和数据库负载都不太好。因此可以选择在启动缓存是就把热点数据预加载好。</p>
<p>LRU 是 Least Recently Used 的缩写，即最近最少使用</p>
<h2 id="缓存穿透。"> 缓存穿透。</h2>
<p>因为不恰当的业务或恶意攻击，持续高并发地访问某一个不存在的数据，如果缓存不保存该数据，就会有大量的请求压力落在数据库上。简单的解决方式是把请求的不存在的数据也放进缓存，其 value 是 null。</p>
<h2 id="缓存降级"> 缓存降级</h2>
<p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p>降级的目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p>
<p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案；</p>
<ol>
<li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li>
<li>警告：有些服务在一段时间内成功率有波动（如在95~100%）之间），可以自动降级或人工降级，并发送告警；</li>
<li>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阈值，此时可以根据情况自动降级或者人工降级。</li>
<li>严重错误：比如因为特殊原因数据操作了，此时需要紧急人工降级。</li>
</ol>
<ul>
<li>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memecache 把数据全部存在内存之中。</li>
<li>集群模式：memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的.</li>
</ul>
<h2 id="redis到底有多快"> REDIS到底有多快？</h2>
<p>REDIS采用的是基于NCP的采用的是单进程单线程模型的KV数据库，由C语言编写，官方提供的数据是可以达到100000+的QPS（每秒查询次数）。这个数据不必担进行多线程的同样基于内存的KV数据库差！</p>
<p>多路IO服用模型，非阻塞IO。</p>
<p>使用底层模型不同，它们之间底层实现方式以及客户端之间通信的应用协议不一样，</p>
<ul>
<li>Redis 使用单线程：Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</li>
</ul>
<p><img src="./assets/1574821356723.png" alt="1574821356723" loading="lazy"></p>
<ol>
<li>完全基于内存</li>
<li>数据结构简单，对数据操作也简单</li>
<li>使用多路 I/O 复用模型，充分利用 CPU 资源</li>
</ol>
<ul>
<li>代码更清晰，处理逻辑更简单</li>
<li>不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为锁而导致的性能消耗</li>
<li>不存在多进程或者多线程导致的 CPU 切换，充分利用 CPU 资源</li>
</ul>
<h3 id="redis-16-个常见使用场景"> Redis 16 个常见使用场景</h3>
<p>1、缓存
2、数据共享分布式
3、分布式锁
4、全局ID
5、计数器
6、限流
7、位统计
8、购物车
9、用户消息时间线timeline
10、消息队列
11、抽奖
12、点赞、签到、打卡
13、商品标签
14、商品筛选
15、用户关注、推荐模型
16、排行榜</p>
<h2 id="redis-的集群方式"> Redis 的集群方式</h2>
<p>Redis 集群可以分为<strong>主从集群</strong>和<strong>分片集群</strong>两类。</p>
<p><strong>主从集群</strong></p>
<p>一般一主多从，主库用来写数据，从库用来读数据。结合哨兵，可以再主库宕机时从新选主，<strong>目的是保证 Redis 的高可用</strong>。</p>
<p><strong>分片集群</strong></p>
<p>是数据分片，我们会让多个 Redis 节点组成集群，并将 16383 个插槽分到不同的节点上。存储数据时利用对 key 做 hash 运算，得到插槽值后存储到对应的节点即可。因为存储数据面向的是插槽而非节点本身，因此可以做到集群动态伸缩。<strong>目的是让 Redis 能存储更多数据。</strong></p>
<p>1）主从集群</p>
<p>主从集群，也是读写分离集群。一般都是一主多从方式。</p>
<p>Redis 的复制(replication)功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器(master)，而通过复制创建出来的服务器复制品则为从服务器(slave)。</p>
<p>只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步 给从服务器，从而一直保证主从服务器的数据相同。</p>
<ul>
<li>写数据时只能通过主节点完成</li>
<li>读数据可以从任何节点完成</li>
<li>如果配置了<code>哨兵节点</code>，当 master 宕机时，哨兵会从 salve 节点选出一个新的主。</li>
</ul>
<p>主从集群分两种：</p>
<p><img src="./assets/1574821993599.png" alt="1574821993599" loading="lazy"> <img src="./assets/1574822026037.png" alt="1574822026037" loading="lazy"></p>
<p>带有哨兵的集群：</p>
<p><img src="./assets/1574822077190.png" alt="1574822077190" loading="lazy"></p>
<p>2）分片集群</p>
<p>主从集群中，每个节点都要保存所有信息，容易形成木桶效应。并且当数据量较大时，单个机器无法满足需求。此时我们就要使用分片集群了。</p>
<p><img src="./assets/1574822184467.png" alt="1574822184467" loading="lazy"></p>
<p>集群特征：</p>
<ul>
<li>
<p>每个节点都保存不同数据</p>
</li>
<li>
<p>所有的 redis 节点彼此互联(PING-PONG 机制),内部使用二进制协议优化传输速度和带宽.</p>
</li>
<li>
<p>节点的 fail 是通过集群中超过半数的节点检测失效时才生效.</p>
</li>
<li>
<p>客户端与 redis 节点直连,不需要中间 proxy 层连接集群中任何一个可用节点都可以访问到数据</p>
</li>
<li>
<p>redis-cluster 把所有的物理节点映射到[0-16383]slot(插槽)上，实现动态伸缩</p>
</li>
</ul>
<p>为了保证 Redis 中每个节点的高可用，我们还可以给每个节点创建 replication(slave 节点)，如图：</p>
<p><img src="./assets/1574822584357.png" alt="1574822584357" loading="lazy"></p>
<p>出现故障时，主从可以及时切换：</p>
<p><img src="./assets/1574822602109.png" alt="1574822602109" loading="lazy"></p>
<h2 id="redis-的常用数据类型"> Redis 的常用数据类型</h2>
<p>支持多种类型的数据结构，主要区别是 value 存储的数据格式不同：</p>
<ul>
<li>string：最基本的数据类型，二进制安全的字符串，最大 512M。</li>
<li>list：按照添加顺序保持顺序的字符串列表。</li>
<li>set：无序的字符串集合，不存在重复的元素。</li>
<li>sorted set：已排序的字符串集合。</li>
<li>hash：key-value 对格式</li>
</ul>
<h2 id="redis-事务机制"> Redis 事务机制</h2>
<p>Redis 事务功能是通过 MULTI、EXEC、DISCARD 和 WATCH 四个原语实现的。</p>
<p>Redis 会将一个事务中的所有命令序列化，然后按顺序执行。但是 Redis 事务不支持回滚操作，命令运行出错后，正确的命令会继续执行。</p>
<ul>
<li><code>MULTI</code>: 用于开启一个事务，它总是返回 OK。 MULTI 执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个<strong>待执行命令队列</strong>中</li>
<li><code>EXEC</code>：按顺序执行命令队列内的所有命令。返回所有命令的返回值。事务执行过程中，Redis 不会执行其它事务的命令。</li>
<li><code>DISCARD</code>：清空命令队列，并放弃执行事务， 并且客户端会从事务状态中退出</li>
<li><code>WATCH</code>：Redis 的乐观锁机制，利用 compare-and-set(CAS)原理，可以监控一个或多个键，一旦其中有一个键被修改，之后的事务就不会执行</li>
</ul>
<p>使用事务时可能会遇上以下两种错误：</p>
<ul>
<li>执行 EXEC 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误(参数数量错误，参数名错误，等等)，或者其他更严重的错误，比如内存不足（如果服务器使用 <code>maxmemory</code> 设置了最大内存限制的话）。
<ul>
<li>Redis 2.6.5 开始，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务。</li>
</ul>
</li>
<li>命令可能在 EXEC 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。
<ul>
<li>即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行，不会回滚。</li>
</ul>
</li>
</ul>
<h3 id="redis-不支持回滚"> Redis 不支持回滚</h3>
<p>优点：</p>
<ul>
<li>Redis 命令只会因为错误的语法而失败(并且这些问题不能在入队时发现)，或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由<strong>编程错误</strong>造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li>
<li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li>
</ul>
<p>鉴于没有任何机制能避免程序员自己造成的错误， 并且这类错误通常不会在生产环境中出现， 所以 Redis 选择了更简单、更快速的无回滚方式来处理事务。</p>
<h2 id="redis-事务"> Redis 事务</h2>
<p>其实是把一系列 Redis 命令放入队列，然后批量执行，执行过程中不会有其它事务来打断。不过与关系型数据库的事务不同，Redis 事务不支持回滚操作，事务中某个命令执行失败，其它命令依然会执行。</p>
<p>为了弥补不能回滚的问题，Redis 会在事务入队时就检查命令，如果命令异常则会放弃整个事务。</p>
<p>因此，只要程序员编程是正确的，理论上说 Redis 会正确执行所有事务，无需回滚。</p>
<h2 id="事务执行一半的时候-redis-宕机怎么办"> 事务执行一半的时候 Redis 宕机怎么办？</h2>
<p>Redis 有持久化机制，因为可靠性问题，我们一般使用 AOF 持久化。</p>
<p>事务的所有命令也会写入 AOF 文件，但是如果在执行 EXEC 命令之前，Redis 已经宕机，则 AOF 文件中事务不完整。使用 <code>redis-check-aof</code> 程序可以移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。</p>
<h2 id="redis-的-key-过期策略"> Redis 的 Key 过期策略</h2>
<h4 id="为什么需要内存回收"> 为什么需要内存回收？</h4>
<ul>
<li>1、在 Redis 中，set 指令可以指定 key 的过期时间，当过期时间到达以后，key 就失效了；</li>
<li>2、Redis 是基于内存操作的，所有的数据都是保存在内存中，一台机器的内存是有限且很宝贵的。</li>
</ul>
<p>基于以上两点，为了保证 Redis 能继续提供可靠的服务，Redis 需要一种机制清理掉不常用的、无效的、多余的数据，失效后的数据需要及时清理，这就需要内存回收了。</p>
<p>Redis 的内存回收主要分为过期删除策略和内存淘汰策略两部分。</p>
<h4 id="过期删除策略"> 过期删除策略</h4>
<p>删除达到过期时间的 key。</p>
<ul>
<li>1）定时删除</li>
</ul>
<p>对于每一个设置了过期时间的 key 都会创建一个定时器，一旦到达过期时间就立即删除。该策略可以立即清除过期的数据，对内存较友好，但是缺点是占用了大量的 CPU 资源去处理过期的数据，会影响 Redis 的吞吐量和响应时间。</p>
<ul>
<li>2）惰性删除</li>
</ul>
<p>当访问一个 key 时，才判断该 key 是否过期，过期则删除。该策略能最大限度地节省 CPU 资源，但是对内存却十分不友好。有一种极端的情况是可能出现大量的过期 key 没有被再次访问，因此不会被清除，导致占用了大量的内存。</p>
<blockquote>
<p>在计算机科学中，懒惰删除(英文：lazy deletion)指的是从一个散列表(也称哈希表)中删除元素的一种方法。在这个方法中，删除仅仅是指标记一个元素被删除，而不是整个清除它。被删除的位点在插入时被当作空元素，在搜索之时被当作已占据。</p>
</blockquote>
<ul>
<li>3）定期删除</li>
</ul>
<p>每隔一段时间，扫描 Redis 中过期 key 字典，并清除部分过期的 key。该策略是前两者的一个折中方案，还可以通过调整定时扫描的时间间隔和每次扫描的限定耗时，在不同情况下使得 CPU 和内存资源达到最优的平衡效果。</p>
<p>在 Redis 中，<code>同时使用了定期删除和惰性删除</code>。不过 Redis 定期删除采用的是随机抽取的方式删除部分 Key，因此不能保证过期 key 100%的删除。</p>
<p>Redis 结合了定期删除和惰性删除，基本上能很好的处理过期数据的清理，但是实际上还是有点问题的，如果过期 key 较多，定期删除漏掉了一部分，而且也没有及时去查，即没有走惰性删除，那么就会有大量的过期 key 堆积在内存中，导致 redis 内存耗尽，当内存耗尽之后，有新的 key 到来会发生什么事呢？是直接抛弃还是其他措施呢？有什么办法可以接受更多的 key？</p>
<h4 id="内存淘汰策略"> 内存淘汰策略</h4>
<p>Redis 的内存淘汰策略，是指内存达到 maxmemory 极限时，使用某种算法来决定清理掉哪些数据，以保证新数据的存入。</p>
<p>Redis 的内存淘汰机制包括：</p>
<ul>
<li>
<p>noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错。</p>
</li>
<li>
<p>allkeys-lru：当内存不足以容纳新写入数据时，在键空间（<code>server.db[i].dict</code>）中，移除最近最少使用的 key(这个是最常用的)。</p>
</li>
<li>
<p>allkeys-random：当内存不足以容纳新写入数据时，在键空间（<code>server.db[i].dict</code>）中，随机移除某个 key。</p>
</li>
<li>
<p>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间（<code>server.db[i].expires</code>）中，移除最近最少使用的 key。</p>
</li>
<li>
<p>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间（<code>server.db[i].expires</code>）中，随机移除某个 key。</p>
</li>
<li>
<p>volatile -ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间（<code>server.db[i].expires</code>）中，有更早过期时间的 key 优先移除。</p>
<p>4.0 新增 lfu</p>
</li>
</ul>
<p>Allkey-lfu 针对所有的 key 删除最近最不常使用
volatile-lfu 针对设置过期时间的 key 删除最近最不常使用</p>
<h3 id="maxmemory-policy-可以配置要使用哪一个淘汰机制"> maxmemory-policy 可以配置要使用哪一个淘汰机制</h3>
<p>什么时候会进行淘汰？</p>
<p>Redis 会在每一次处理命令的时候(processCommand 函数调用 freeMemoryIfNeeded)判断当前 redis 是否达到了内存的最大限制，如果达到限制，则使用对应的算法去处理需要删除的 key。</p>
<p>在淘汰 key 时，Redis 默认最常用的是 LRU 算法(Latest Recently Used)。Redis 通过在每一个 redisObject 保存 lru 属性来保存 key 最近的访问时间，在实现 LRU 算法时直接读取 key 的 lru 属性。</p>
<p>具体实现时，Redis 遍历每一个 db，从每一个 db 中随机抽取一批样本 key，默认是 3 个 key，再从这 3 个 key 中，删除最近最少使用的 key。</p>
<h3 id="redis-过期策略"> Redis 过期策略</h3>
<p>包含定期删除和惰性删除两部分。定期删除是在 Redis 内部有一个定时任务，会定期删除一些过期的 key。惰性删除是当用户查询某个 Key 时，会检查这个 Key 是否已经过期，如果没过期则返回用户，如果过期则删除。</p>
<p>但是这两个策略都无法保证过期 key 一定删除，漏网之鱼越来越多，还可能导致内存溢出。当发生内存不足问题时，Redis 还会做内存回收。内存回收采用 LRU 策略，就是最近最少使用。其原理就是记录每个 Key 的最近使用时间，内存回收时，随机抽取一些 Key，比较其使用时间，把最老的几个删除。</p>
<p>Redis 的逻辑是：最近使用过的，很可能再次被使用</p>
<h2 id="redis-在项目使用"> Redis 在项目使用</h2>
<h3 id="共享-session"> 共享 session</h3>
<p>在分布式系统下，服务会部署在不同的 tomcat，因此多个 tomcat 的 session 无法共享，以前存储在 session 中的数据无法实现共享，可以用 redis 代替 session，解决分布式系统间数据共享问题。</p>
<h3 id="数据缓存"> 数据缓存</h3>
<p>Redis 采用内存存储，读写效率较高。我们可以把数据库的访问频率高的热点数据存储到 redis 中，这样用户请求时优先从 redis 中读取，减少数据库压力，提高并发能力。</p>
<h3 id="异步队列"> 异步队列</h3>
<p>Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis 能作为一个很好的消息队列平台来使用。而且 Redis 中还有 pub/sub 这样的专用结构，用于 1 对 N 的消息通信模式。</p>
<h2 id="redis-的缓存击穿、缓存雪崩、缓存穿透"> Redis 的缓存击穿、缓存雪崩、缓存穿透</h2>
<h3 id="缓存穿透"> 缓存穿透</h3>
<blockquote>
<p>什么是缓存穿透
正常情况下，我们去查询数据都是存在。那么请求去查询一条压根儿数据库中根本就不存在的数据，也就是缓存和数据库都查询不到这条数据，但是请求每次都会打到数据库上面去。这种查询不存在数据的现象我们称为<strong>缓存穿透</strong>。</p>
<p>穿透带来的问题</p>
<p>如果有黑客会对你的系统进行攻击，拿一个不存在的 id 去查询数据，会产生大量的请求到数据库去查询。可能会导致你的数据库由于压力过大而宕掉。</p>
</blockquote>
<h4 id="解决办法"> 解决办法</h4>
<p>缓存空值：之所以会发生穿透，就是因为缓存中没有存储这些空数据的 key。从而导致每次查询都到数据库去了。那么我们就可以为这些 key 对应的值设置为 null 丢到缓存里面去。后面再出现查询这个 key 的请求的时候，直接返回 null 。这样，就不用在到数据库中去走一圈了，但是别忘了设置过期时间。</p>
<p>BloomFilter(布隆过滤)：将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被 这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。在缓存之前在加一层 BloomFilter ，在查询的时候先去 BloomFilter 去查询 key 是否存在，如果不存在就直接返回，存在再走查缓存 -&gt; 查 DB。</p>
<p>缓存穿透有两种解决方案：</p>
<p>其一、是把不存在的 key 设置 null 值到缓存中。</p>
<p>其二、使用布隆过滤器，将所有可能存在的数据哈希到一个足够大的BITMAP中，一个一定不存在的数据会被这个BITMAP拦截掉，从而避免了对底层存储系统的查询压力。</p>
<p>如果一个查询返回的数据为空（不管使数据存在，还是系统故障），我们仍然把这个空结果进行缓存，但他的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放在缓存，这样第二次缓存中获取就会有值了，而不会继续访问数据库。</p>
<p>设置 null 值可能被恶意针对，攻击者使用大量不存在的不重复 key ，那么方案一就会缓存大量不存在 key 数据。此时我们还可以对 Key 规定格式模板，然后对不存在的 key 做<strong>正则规范</strong>匹配，如果完全不符合就不用存 null 值到 redis，而是直接返回错误。</p>
<h3 id="缓存击穿"> 缓存击穿</h3>
<p>概念：key 可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。</p>
<p>这个时候，需要考虑一个问题：缓存被“击穿”的问题。当这个 key 在失效的瞬间，redis 查询失败，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p>
<p>解决方案：</p>
<p>使用互斥锁(mutex key)：就是在缓存失效的时候(判断拿出来的值为空)，不是立即去 load db，而是先使用 Redis 的 SETNX 去 set 一个互斥 key，当操作返回成功时，再进行 load db 的操作并回设缓存；否则，就重试整个 get 缓存的方法。SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现互斥的效果。</p>
<p>软过期：也就是逻辑过期，不使用 redis 提供的过期时间，而是业务层在数据中存储过期时间信息。查询时由业务程序判断是否过期，如果数据即将过期时，将缓存的时效延长，程序可以派遣一个线程去数据库中获取最新的数据，其他线程这时看到延长了的过期时间，就会继续使用旧数据，等派遣的线程获取最新数据后再更新缓存。</p>
<p>推荐使用互斥锁，因为软过期会有业务逻辑侵入和额外的判断。</p>
<p>缓存击穿主要担心的是某个 Key 过期，更新缓存时引起对数据库的突发高并发访问。</p>
<p>因此我们可以在更新缓存时采用互斥锁控制，只允许一个线程去更新缓存，其它线程等待并重新读取缓存。例如 Redis 的 setnx 命令就能实现互斥效果。</p>
<h3 id="缓存雪崩"> 缓存雪崩</h3>
<p>概念：是指在某一个时间段，缓存集中过期失效。对这批数据的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰（波动）。</p>
<p>解决方案：</p>
<ul>
<li>数据分类分批处理：采取不同分类数据，缓存不同周期</li>
<li>相同分类数据：采用固定时长加随机数方式设置缓存</li>
<li>热点数据缓存时间长一些，冷门数据缓存时间短一些</li>
<li>避免 redis 节点宕机引起雪崩，搭建主从集群，保证高可用</li>
</ul>
<div><p>总结</p>
<p>解决缓存雪崩问题的关键是让缓存 Key 的过期时间分散。因此我们可以把数据按照业务分类，然后设置不同过期时间。相同业务类型的 key，设置固定时长加随机数。尽可能保证每个 Key 的过期时间都不相同。</p>
</div>
<p>另外，Redis 宕机也可能导致缓存雪崩，因此我们还要搭建 Redis 主从集群及哨兵监控，保证 Redis 的高可用。</p>
<h2 id="数据库与缓存数据一致性"> 数据库与缓存数据一致性</h2>
<p>实现方案：</p>
<ul>
<li>本地缓存同步：当前微服务的数据库数据与缓存数据同步，可以直接在数据库修改时加入对 Redis 的修改逻辑，保证一致。</li>
<li>跨服务缓存同步：服务 A 调用了服务 B，并对查询结果缓存。服务 B 数据库修改，可以通过 MQ 通知服务 A，服务 A 修改 Redis 缓存数据</li>
<li>通用方案：使用 Canal 框架，伪装成 MySQL 的 salve 节点，监听 MySQL 的 binLog 变化，然后修改 Redis 缓存数据</li>
</ul>
<h2 id="redis-存储对象信息是用-hash-还是-string"> Redis 存储对象信息是用 Hash 还是 String</h2>
<p>Redis 内部使用一个 RedisObject 对象来表示所有的 key 和 value，RedisObject 中的 type，则是代表一个 value 对象具体是何种数据类型，它包含字符串（String）、链表（List）、哈希结构（Hash）、集合（Set）、有序集合（Sorted set）。</p>
<p>日常工作中我们存储对象信息的时候，一般有两种做法，一种是用 Hash 存储，另一种是 String 存储。但好像并没有所谓的最佳实践，那么实际上到底用什么数据结构存储更好呢？</p>
<p>首先简单回顾下，Redis 的 Hash 和 String 结构。</p>
<p>String
String 数据结构是简单的 key-value 类型，value 其实不仅是 String，也可以是数字。Redis 中的 String 可以表示很多语义：</p>
<p>字符串（bits）</p>
<p>整数</p>
<p>浮点数</p>
<p>这三种类型，Redis 会根据具体的场景完成自动转换，并且根据需要选取底层的承载方式。String 在Redis 内部存储默认就是一个字符串，被 RedisObject 所引用，当遇到 incr、decr 等操作时会转成数值型进行计算，此时 RedisObject 的 encoding 字段为int。</p>
<p>在存储过程中，我们可以将用户信息使用 Json 序列化成字符串，然后将序列化后的字符串存入 Redis 进行缓存。</p>
<p>由于 Redis 的字符串是动态字符串，可以修改，内部结构类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。如上图所示，内部为当前字符串实际分配的空间 capacity，一般高于实际字符串长度 len。</p>
<p>假设我们要存储的结构是：</p>
<div><pre><code><span>{</span>
  <span>"name"</span><span>:</span> <span>"xiaowang"</span><span>,</span>
  <span>"age"</span><span>:</span> <span>"35"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果此时将此用户信息的 name 改为“xiaoli”，再存到 Redis 中，Redis 是不需要重新分配空间的。而且我们在读取和存储数据的时候只需要对做 Json 序列化与反序列化，比较方便。</p>
<p>Hash
Hash 在很多编程语言中都有着很广泛的应用，而在 Redis 中也是如此。在 Redis 中，Hash 常常用来缓存一些对象信息，如用户信息、商品信息、配置信息等，因此也被称为字典（dictionary），Redis 的字典使用 Hash table 作为底层实现， 一个 Hash table 里面可以有多个哈希表节点，而每个哈希表节点保存了字典中的一个键值对。实际上，Redis 数据库底层也是采用 Hash table 来存储键值对的。</p>
<p>Redis 的 Hash 相当于 Java 的 HashMap，内部结构实现与 HashMap 一致，即数组+链表结构。只是 reHash 方式不一样。</p>
<p>前面说到 String 适合存储用户信息，而 Hash 结构也可以存储用户信息，不过是对每个字段单独存储，因此可以在查询时获取部分字段的信息，节省网络流量。不过 Redis 的 Hash 的值只能是字符串，存储上面的那个例子还好，如果存储的用户信息变为：</p>
<div><pre><code><span>{</span>
  <span>"name"</span><span>:</span> <span>"xiaowang"</span><span>,</span>
  <span>"age"</span><span>:</span> <span>25</span><span>,</span>
  <span>"clothes"</span><span>:</span> <span>{</span>
    <span>"shirt"</span><span>:</span> <span>"gray"</span><span>,</span>
    <span>"pants"</span><span>:</span> <span>"read"</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>那么该如何存储&quot;clothes&quot;属性又变成了该用 String 还是 Hash 的问题。</p>
<p>适合用 String 存储的情况：</p>
<ul>
<li>每次需要访问大量的字段</li>
<li>存储的结构具有多层嵌套的时候</li>
</ul>
<p>适合用 Hash 存储的情况：</p>
<ul>
<li>在大多数情况中只需要访问少量字段</li>
<li>自己始终知道哪些字段可用，防止使用 <code>mget</code> 时获取不到想要的数据</li>
</ul>
<div><p>总结</p>
<p>介绍了Redis 存储对象信息是用 Hash 还是 String，建议是大部分情况下使用 String 存储就好，毕竟在存储具有多层嵌套的对象时方便很多，占用的空间也比 Hash 小。当我们需要存储一个特别大的对象时，而且在大多数情况中只需要访问该对象少量的字段时，可以考虑使用 Hash。</p>
</div>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="redis"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-02T03:44:34.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">redis</title>
    <id>http://www.zhangsj.xyz/blog/java/redis/redis/</id>
    <link href="http://www.zhangsj.xyz/blog/java/redis/redis/"/>
    <updated>2022-03-03T08:03:14.000Z</updated>
    <content type="html"><![CDATA[<h1 id="redis"> redis</h1>
<h2 id="tiaoyou"> tiaoyou</h2>
<p>比如业务请求里，会经常用公司 ID 向风控模块看风险情况，那么就可以用 ID 做键，风控字段做值，另外再把 null 放到键里，以放缓存击穿。</p>
<h2 id="跳表"> 跳表</h2>
<p>我们保存了热点数据到缓存，缓存层 redis 和 存储层 mysql 的数据存在时间窗口的不一致性，redis 跟更新策略有关</p>
<p>会使代码维护成本增加，新增数据，要同时处理缓存和数据库的逻辑，增大开发成本</p>
<p>搭建缓存集群，无形中增加运维成本</p>
<p>跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。</p>
<h3 id="跳表的原理"> 跳表的原理</h3>
<p>跳表就是一种可以进行二分查找的有序链表。跳表的数据结构模型如图 1:</p>
<p><img src="./img/1-1.png" alt="" loading="lazy"></p>
<p>可以看到，跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。</p>
<p>首先在最高级索引上查找最后一个小于当前查找元素的位置，然后再跳到次高级索引继续查找，直到跳到最底层为止，这时候以及十分接近要查找的元素的位置了(如果查找元素存在的话)。</p>
<p>由于根据索引可以一次跳过多个元素，所以跳查找的查找速度也就变快了。</p>
<h2 id="redis-持久化"> Redis 持久化</h2>
<h3 id="rdb"> RDB</h3>
<p>默认情况下，Redis 使用的是 RDB 持久化。</p>
<p>RDB 持久化可以使用 <code>save</code> 或 <code>bgsave</code>，为了不阻塞主进程业务，一般都使用 bgsave，流程</p>
<ul>
<li>Save 命令执行一个同步保存操作，将当前 Redis 实例的所有数据快照(snapshot)以 RDB 文件的形式保存到硬盘。</li>
<li>BGSAVE 命令执行之后立即返回 OK ，然后 Redis fork 出一个新子进程，原来的 Redis 进程(父进程)继续处理客户端请求，而子进程则负责将数据保存到磁盘，然后退出。由子进程将内存中的所有数据写入到一个临时的 RDB 文件中。 完成写入操作之后，旧的 RDB 文件会被新的 RDB 文件替换掉。</li>
</ul>
<h4 id="rdb-持久化相关配置"> RDB 持久化相关配置</h4>
<ul>
<li><code>save 60 10000</code>：如果在 60 秒内有 10000 个 key 发生改变，那就执行 RDB 持久化。</li>
<li><code>stop-writes-on-bgsave-error yes</code>：如果 Redis 执行 RDB 持久化失败(常见于操作系统内存不足)，那么 Redis 将不再接受 client 写入数据的请求。</li>
<li><code>rdbcompression yes</code>：当生成 RDB 文件时，同时进行压缩。</li>
<li><code>dbfilename dump.rdb</code>：将 RDB 文件命名为 dump.rdb。</li>
<li><code>dir /var/lib/redis</code>：将 RDB 文件保存在<code>/var/lib/redis</code>目录下。</li>
</ul>
<p>当然在实践中，我们通常会将<code>stop-writes-on-bgsave-error</code>设置为<code>false</code>，同时让监控系统在 Redis 执行 RDB 持久化失败时发送告警，以便人工介入解决，而不是粗暴地拒绝 client 的写入请求。</p>
<h4 id="rdb-持久化优点"> RDB 持久化优点</h4>
<ul>
<li>RDB 持久化文件小，Redis 数据恢复时速度快</li>
<li>子进程不影响父进程，父进程可以持续处理客户端命令</li>
<li>子进程 fork 时采用 copy-on-write 方式，大多数情况下，没有太多的内存消耗，效率比较好。</li>
</ul>
<h4 id="rdb-持久化缺点"> RDB 持久化缺点</h4>
<ul>
<li>子进程 fork 时采用 copy-on-write 方式，如果 Redis 此时写操作较多，可能导致额外的内存占用，甚至内存溢出</li>
<li>RDB 文件压缩会减小文件体积，但通过时会对 CPU 有额外的消耗</li>
<li>如果业务场景很看重数据的持久性 (durability)，那么不应该采用 RDB 持久化。譬如说，如果 Redis 每 5 分钟执行一次 RDB 持久化，要是 Redis 意外奔溃了，那么最多会丢失 5 分钟的数据。</li>
</ul>
<h3 id="aof-持久化"> AOF 持久化</h3>
<p><strong>AOF 持久化相关的配置</strong></p>
<p>可以使用<code>appendonly yes</code>配置项来开启 AOF 持久化。Redis 执行 AOF 持久化时，会将接收到的写命令追加到 AOF 文件的末尾，因此 Redis 只要对 AOF 文件中的命令进行回放，就可以将数据库还原到原先的状态。
　　与 RDB 持久化相比，AOF 持久化的一个明显优势就是，它可以提高数据的持久性 (durability)。因为在 AOF 模式下，Redis 每次接收到 client 的写命令，就会将命令<code>write()</code>到 AOF 文件末尾。
　　然而，在 Linux 中，将数据<code>write()</code>到文件后，数据并不会立即刷新到磁盘，而会先暂存在 OS 的文件系统缓冲区。在合适的时机，OS 才会将缓冲区的数据刷新到磁盘（如果需要将文件内容刷新到磁盘，可以调用<code>fsync()</code>或<code>fdatasync()</code>）。
　　通过<code>appendfsync</code>配置项，可以控制 Redis 将命令同步到磁盘的频率：</p>
<ul>
<li><code>always</code>：每次 Redis 将命令<code>write()</code>到 AOF 文件时，都会调用<code>fsync()</code>，将命令刷新到磁盘。这可以保证最好的数据持久性，但却会给系统带来极大的开销。</li>
<li><code>no</code>：Redis 只将命令<code>write()</code>到 AOF 文件。这会让 OS 决定何时将命令刷新到磁盘。</li>
<li><code>everysec</code>：除了将命令<code>write()</code>到 AOF 文件，Redis 还会每秒执行一次<code>fsync()</code>。在实践中，推荐使用这种设置，一定程度上可以保证数据持久性，又不会明显降低 Redis 性能。</li>
</ul>
<h4 id="aof-持久化缺点"> AOF 持久化缺点</h4>
<ul>
<li>文件体积大</li>
<li>文件大导致服务数据恢复时效率较低</li>
</ul>
<p>Redis 会不断将接收到的写命令追加到 AOF 文件中，导致 AOF 文件越来越大。过大的 AOF 文件会消耗磁盘空间，并且导致 Redis 重启时更加缓慢。为了解决这个问题，在适当情况下，Redis 会对 AOF 文件进行重写，去除文件中冗余的命令，以减小 AOF 文件的体积。在重写 AOF 文件期间， Redis 会启动一个子进程，由子进程负责对 AOF 文件进行重写。
　　可以通过下面两个配置项，控制 Redis 重写 AOF 文件的频率：</p>
<ul>
<li><code>auto-aof-rewrite-min-size 64mb</code></li>
<li><code>auto-aof-rewrite-percentage 100</code></li>
</ul>
<p>上面两个配置的作用：当 AOF 文件的体积大于 64MB，并且 AOF 文件的体积比上一次重写之后的体积大了至少一倍，那么 Redis 就会执行 AOF 重写。</p>
<h4 id="aof-持久化优点"> AOF 持久化优点</h4>
<ul>
<li>持久化频率高，数据可靠性高</li>
<li>没有额外的内存或 CPU 消耗</li>
</ul>
<p>RDB 持久化文件体积较小，但是保存数据的频率一般较低，可靠性差，容易丢失数据。另外 RDB 写数据时会采用 Fork 函数拷贝主进程，可能有额外的内存消耗，文件压缩也会有额外的 CPU 消耗。</p>
<p>aof 持久化可以做到每秒钟持久化一次，可靠性高。但是持久化文件体积较大，导致数据恢复时读取文件时间较长，效率略低</p>
<div><p>注：数据恢复流程说明</p>
<p>（1）AOF持久化开启且存在AOF文件时，优先加载AOF文件。</p>
<p>（2）AOF关闭或者AOF文件不存在时，加载RDB文件。</p>
<p>（3）加载AOF/RDB文件成功后，Redis启动成功。</p>
<p>（4）AOF/RDB文件存在错误时，Redis启动失败并打印错误信息。</p>
</div>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="redis"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-01-30T09:23:34.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">redislock</title>
    <id>http://www.zhangsj.xyz/blog/java/redis/%E5%BE%85%E8%A1%A5%E5%85%85%E5%86%85%E5%AE%B9/</id>
    <link href="http://www.zhangsj.xyz/blog/java/redis/%E5%BE%85%E8%A1%A5%E5%85%85%E5%86%85%E5%AE%B9/"/>
    <updated>2022-02-25T04:39:47.000Z</updated>
    <content type="html"><![CDATA[<h3 id="redis-分布式锁依赖于-redis-如果-redis-宕机则锁失效。如何解决"> redis 分布式锁依赖于 redis，如果 redis 宕机则锁失效。如何解决？</h3>
<p>可以做搭建主从集群，做数据备份。</p>
<p>但如果搭建主从集群做数据备份时，进程 A 获取锁，master 还没有把数据备份到 slave，master 宕机，slave 升级为 master，此时原来锁失效，其它进程也可以获取锁，出现安全问题。如何解决？</p>
<p>关于这个问题，Redis 官网给出了解决方案，使用 RedLock 思路可以解决：</p>
<p>在 Redis 的分布式环境中，我们假设有 N 个 Redis master。</p>
<p>这些节点完全互相独立，不存在主从复制或者其他集群协调机制。</p>
<p>之前我们已经描述了在 Redis 单实例下怎么安全地获取和释放锁。</p>
<p>我们确保将在每（N)个实例上使用此方法获取和释放锁。</p>
<p>在这个样例中，我们假设有 5 个 Redis master 节点，这是一个比较合理的设置，所以我们需要在 5 台机器上面或者 5 台虚拟机上面运行这些实例，</p>
<p>这样保证他们不会同时都宕掉。</p>
<p>为了取到锁，客户端应该执行以下操作:</p>
<p>1、获取当前 Unix 时间，以毫秒为单位。</p>
<p>2、依次尝试从 N 个实例，使用相同的 key 和随机值获取锁。在步骤 2，当向 Redis 设置锁时,客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为 10 秒，则超时时间应该在 5-50 毫秒之间。这样可以避免服务器端 Redis 已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个 Redis 实例。</p>
<p>3、客户端使用当前时间减去开始获取锁时间(步骤 1 记录的时间)就得到获取锁使用的时间。当且仅当从大多数(这里是 3 个节点)的 Redis 节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。</p>
<p>5、如果取到了锁，key 的真正有效时间等于有效时间减去获取锁所使用的时间(步骤 3 计算的结果)。
6、如果因为某些原因，获取锁失败（<em>没有</em>在至少 N/2+1 个 Redis 实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的 Redis 实例上进行解锁(即便某些 Redis 实例根本就没有加锁成功)。</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="redis"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-23T03:54:08.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">redis high availability</title>
    <id>http://www.zhangsj.xyz/blog/java/redis/redis%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90%E5%92%8C%E6%90%AD%E5%BB%BA/</id>
    <link href="http://www.zhangsj.xyz/blog/java/redis/redis%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90%E5%92%8C%E6%90%AD%E5%BB%BA/"/>
    <updated>2022-03-28T06:04:45.000Z</updated>
    <content type="html"><![CDATA[<h2 id="高可用redis服务架构分析与搭建"> 高可用Redis服务架构分析与搭建！</h2>
<p>基于内存的Redis应该是目前各种Web开发业务中最为常用的Key-Value数据库了，我们经常在业务中用其存储用户登陆态（Session存储），加速一些热数据的查询（相比较MySQL而言，速度有数量级的提升），做简单的消息队列（LPUSH和BRPOP）、订阅发布（PUB/SUB）系统等等。规模比较大的互联网公司，一般都会有专门的团队，将Redis存储以基础服务的形式提供给各个业务调用。</p>
<p>不过任何一个基础服务的提供方，都会被调用方问起的一个问题是：你的服务是否具有高可用性？最好不要因为你的服务经常出问题，导致我这边的业务跟着遭殃。最近我所在的项目中也自己搭了一套小型的“高可用”Redis服务，在此做一下自己的总结和思考。</p>
<p>首先我们要定义一下对于Redis服务来说怎样才算是高可用，即在各种出现异常的情况下，依然可以正常提供服务。或者宽松一些，出现异常的情况下，只经过很短暂的时间即可恢复正常服务。</p>
<p>所谓异常，应该至少包含了以下几种可能性：</p>
<p>【异常1】某个节点服务器的某个进程突然down掉（例如某开发手残，把一台服务器的redis-server进程kill了）；</p>
<p>【异常2】某台节点服务器down掉，相当于这个节点上所有进程都停了（例如某运维手残，把一个服务器的电源拔了；例如一些老旧机器出现硬件故障）；</p>
<p>【异常3】任意两个节点服务器之间的通信中断了（例如某临时工手残，把用于两个机房通信的光缆挖断了）；</p>
<p>其实以上任意一种异常都是小概率事件，而做到高可用性的基本指导思想就是：多个小概率事件同时发生的概率可以忽略不计。只要我们设计的系统可以容忍短时间内的单点故障，即可实现高可用性。</p>
<p>对于搭建高可用Redis服务，网上已有了很多方案，例如Keepalived，Codis，Twemproxy，Redis Sentinel。其中Codis和Twemproxy主要是用于大规模的Redis集群中，也是在Redis官方发布Redis Sentinel之前twitter和豌豆荚提供的开源解决方案。我的业务中数据量并不大，所以搞集群服务反而是浪费机器了。最终在Keepalived和Redis Sentinel之间做了个选择，选择了官方的解决方案Redis Sentinel。</p>
<p>Redis Sentinel可以理解为一个监控Redis Server服务是否正常的进程，并且一旦检测到不正常，可以自动地将备份（slave）Redis Server启用，使得外部用户对Redis服务内部出现的异常无感知。我们按照由简至繁的步骤，搭建一个最小型的高可用的Redis服务。</p>
<p>方案1：单机版Redis Server，无Sentinel</p>
<p><img src="./img/单机版redis-server，无Sentinel.png" alt="" loading="lazy"></p>
<p>一般情况下，我们搭的个人网站，或者平时做开发时，会起一个单实例的Redis Server。调用方直接连接Redis服务即可，甚至Client和Redis本身就处于同一台服务器上。这种搭配仅适合个人学习娱乐，毕竟这种配置总会有单点故障的问题无法解决。一旦Redis服务进程挂了，或者服务器1停机了，那么服务就不可用了。并且如果没有配置Redis数据持久化的话，Redis内部已经存储的数据也会丢失。</p>
<p>方案2：主从同步Redis Server，单实例Sentinel</p>
<p><img src="./img/主从同步redis-server，单实例Sentinel.png" alt="" loading="lazy"></p>
<p>为了实现高可用，解决方案1中所述的单点故障问题，我们必须增加一个备份服务，即在两台服务器上分别各启动一个Redis Server进程，一般情况下由master提供服务，slave只负责同步和备份。与此同时，在额外启动一个Sentinel进程，监控两个Redis Server实例的可用性，以便在master挂掉的时候，及时把slave提升到master的角色继续提供服务，这样就实现了Redis Server的高可用。这基于一个高可用服务设计的依据，即单点故障本身就是个小概率事件，而多个单点同时故障（即master和slave同时挂掉），可以认为是（基本）不可能发生的事件。</p>
<p>对于Redis服务的调用方来说，现在要连接的是Redis Sentinel服务，而不是Redis Server了。常见的调用过程是，client先连接Redis Sentinel并询问目前Redis Server中哪个服务是master，哪些是slave，然后再去连接相应的Redis Server进行操作。当然目前的第三方库一般都已经实现了这一调用过程，不再需要我们手动去实现（例如Nodejs的ioredis，PHP的predis，Golang的go-redis/redis，JAVA的jedis等）。</p>
<p>然而，我们实现了Redis Server服务的主从切换之后，又引入了一个新的问题，即Redis Sentinel本身也是个单点服务，一旦Sentinel进程挂了，那么客户端就没办法链接Sentinel了。所以说，方案2的配置并无法实现高可用性。</p>
<p>方案3：主从同步Redis Server，双实例Sentinel</p>
<p><img src="./img/主从同步redis-server，双实例Sentinel.png" alt="" loading="lazy"></p>
<p>为了解决方案2的问题，我们把Redis Sentinel进程也额外启动一份，两个Sentinel进程同时为客户端提供服务发现的功能。对于客户端来说，它可以连接任何一个Redis Sentinel服务，来获取当前Redis Server实例的基本信息。通常情况下，我们会在Client端配置多个Redis Sentinel的链接地址，Client一旦发现某个地址连接不上，会去试图连接其他的Sentinel实例，这当然也不需要我们手动实现，各个开发语言中比较热门的redis连接库都帮我们实现了这个功能。我们预期是：即使其中一个Redis Sentinel挂掉了，还有另外一个Sentinel可以提供服务。</p>
<p>然而，愿景是美好的，现实却是很残酷的。如此架构下，依然无法实现Redis服务的高可用。方案3示意图中，红线部分是两台服务器之间的通信，而我们所设想的异常场景（【异常2】）是，某台服务器整体down机，不妨假设服务器1停机，此时，只剩下服务器2上面的Redis Sentinel和slave Redis Server进程。这时，Sentinel其实是不会将仅剩的slave切换成master继续服务的，也就导致Redis服务不可用，因为Redis的设定是只有当超过50%的Sentinel进程可以连通并投票选取新的master时，才会真正发生主从切换。本例中两个Sentinel只有一个可以连通，等于50%并不在可以主从切换的场景中。</p>
<p>你可能会问，为什么Redis要有这个50%的设定？假设我们允许小于等于50%的Sentinel连通的场景下也可以进行主从切换。试想一下【异常3】，即服务器1和服务器2之间的网络中断，但是服务器本身是可以运行的。如下图所示：</p>
<p><img src="./img/主从同步redis-server，双实例Sentinel（2）.png" alt="" loading="lazy"></p>
<p>实际上对于服务器2来说，服务器1直接down掉和服务器1网络连不通是一样的效果，反正都是突然就无法进行任何通信了。假设网络中断时我们允许服务器2的Sentinel把slave切换为master，结果就是你现在拥有了两个可以对外提供服务的Redis Server。Client做任何的增删改操作，有可能落在服务器1的Redis上，也有可能落在服务器2的Redis上（取决于Client到底连通的是哪个Sentinel），造成数据混乱。即使后面服务器1和服务器2之间的网络又恢复了，那我们也无法把数据统一了（两份不一样的数据，到底该信任谁呢？），数据一致性完全被破坏。</p>
<h2 id="方案4-主从同步redis-server-三实例sentinel"> 方案4：主从同步Redis Server，三实例Sentinel</h2>
<p><img src="./img/主从同步redis-server，三实例Sentinel.png" alt="" loading="lazy"></p>
<p>鉴于方案3并没有办法做到高可用，我们最终的版本就是上图所示的方案4了。实际上这就是我们最终搭建的架构。我们引入了服务器3，并且在3上面又搭建起一个Redis Sentinel进程，现在由三个Sentinel进程来管理两个Redis Server实例。这种场景下，不管是单一进程故障、还是单个机器故障、还是某两个机器网络通信故障，都可以继续对外提供Redis服务。</p>
<p>实际上，如果你的机器比较空闲，当然也可以把服务器3上面也开启一个Redis Server，形成1 master + 2 slave的架构，每个数据都有两个备份，可用性会提升一些。当然也并不是slave越多越好，毕竟主从同步也是需要时间成本的。</p>
<p>在方案4中，一旦服务器1和其他服务器的通信完全中断，那么服务器2和3会将slave切换为master。对于客户端来说，在这么一瞬间会有2个master提供服务，并且一旦网络恢复了，那么所有在中断期间落在服务器1上的新数据都会丢失。如果想要部分解决这个问题，可以配置Redis Server进程，让其在检测到自己网络有问题的时候，立即停止服务，避免在网络故障期间还有新数据进来（可以参考Redis的min-slaves-to-write和min-slaves-max-lag这两个配置项）。</p>
<p>至此，我们就用3台机器搭建了一个高可用的Redis服务。其实网上还有更加节省机器的办法，就是把一个Sentinel进程放在Client机器上，而不是服务提供方的机器上。只不过在公司里面，一般服务的提供方和调用方并不来自同一个团队。两个团队共同操作同一个机器，很容易因为沟通问题导致一些误操作，所以出于这种人为因素的考虑，我们还是采用了方案4的架构。并且由于服务器3上面只跑了一个Sentinel进程，对服务器资源消耗并不多，还可以用服务器3来跑一些其他的服务。</p>
<p>易用性：像使用单机版Redis一样使用Redis Sentinel</p>
<p>作为服务的提供方，我们总是会讲到用户体验问题。在上述方案当中始终有一个让Client端用的不是那么舒服的地方。对于单机版Redis，Client端直接连接Redis Server，我们只需要给一个ip和port，Client就可以使用我们的服务了。而改造成Sentinel模式之后，Client不得不采用一些支持Sentinel模式的外部依赖包，并且还要修改自己的Redis连接配置，这对于“矫情”的用户来讲显然是不能接收的。有没有办法还是像在使用单机版的Redis那样，只给Client一个固定的ip和port就可以提供服务呢？</p>
<p><img src="./img/易用性：像使用单机版Redis一样使用Redis Sentinel.png" alt="" loading="lazy"></p>
<p>答案当然是肯定的。这可能就要引入虚拟IP（Virtual IP，VIP），如上图所示。我们可以把虚拟IP指向Redis Server master所在的服务器，在发生Redis主从切换的时候，会触发一个回调脚本，回调脚本中将VIP切换至slave所在的服务器。这样对于Client端来说，他仿佛在使用的依然是一个单机版的高可用Redis服务。</p>
<h2 id="结语"> 结语</h2>
<p>搭建任何一个服务，做到“能用”其实是非常简单的，就像我们运行一个单机版的Redis。不过一旦要做到“高可用”，事情就会变得复杂起来。业务中使用了额外的两台服务器，3个Sentinel进程+1个Slave进程，只是为了保证在那小概率的事故中依然做到服务可用。在实际业务中我们还启用了supervisor做进程监控，一旦进程意外退出，会自动尝试重新启动。</p>
]]></content>
    <author>
      <name>HorstXu</name>
    </author>
    <category term="redis"/>
    <contributor>
      <name>HorstXu</name>
    </contributor>
    <published>2022-03-28T06:04:45.000Z</published>
    <rights>Copyright by HorstXu</rights>
  </entry>
  <entry>
    <title type="html">dubbo interview</title>
    <id>http://www.zhangsj.xyz/blog/java/soa/Dubbo%E9%9D%A2%E8%AF%9518%E9%97%AE%EF%BC%81%E8%BF%99%E4%BA%9B%E4%BD%A0%E9%83%BD%E4%BC%9A%E5%90%97%EF%BC%9F/</id>
    <link href="http://www.zhangsj.xyz/blog/java/soa/Dubbo%E9%9D%A2%E8%AF%9518%E9%97%AE%EF%BC%81%E8%BF%99%E4%BA%9B%E4%BD%A0%E9%83%BD%E4%BC%9A%E5%90%97%EF%BC%9F/"/>
    <updated>2022-04-08T00:53:08.000Z</updated>
    <content type="html"><![CDATA[<h2 id="dubbo是什么"> dubbo是什么</h2>
<p>dubbo是一个分布式框架，远程服务调用的分布式框架，其核心部分包含：</p>
<ul>
<li>集群容错：提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</li>
<li>远程通讯：提供对多种基于长连接的NIO 框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。</li>
<li>自动发现：基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</li>
</ul>
<h2 id="dubbo能做什么"> dubbo能做什么</h2>
<p>透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</p>
<h2 id="_1、默认使用的是什么通信框架-还有别的选择吗"> 1、默认使用的是什么通信框架，还有别的选择吗?</h2>
<p>答：默认也推荐使用<code>netty</code> 框架，还有 <code>mina</code>。</p>
<h2 id="_2、服务调用是阻塞的吗"> 2、服务调用是阻塞的吗？</h2>
<p>答：默认是阻塞的，可以异步调用，没有返回值的可以这么做。</p>
<h2 id="_3、一般使用什么注册中心-还有别的选择吗"> 3、一般使用什么注册中心？还有别的选择吗？</h2>
<p>答：推荐使用 <code>zookeeper</code> 注册中心，还有 <code>Multicast</code> 注册中心, <code>Redis</code> 注册中心, <code>Simple</code> 注册中心.</p>
<p><code>ZooKeeper</code>的节点是通过像树一样的结构来进行维护的，并且每一个节点通过路径来标示以及访问。除此之外，每一个节点还拥有自身的一些信息，包括：数据、数据长度、创建时间、修改时间等等。</p>
<h2 id="_4、默认使用什么序列化框架-你知道的还有哪些"> 4、默认使用什么序列化框架，你知道的还有哪些？</h2>
<p>答：默认使用 Hessian 序列化，还有 Duddo 、FastJson、Java 自带序列化。 <code>hessian</code>是一个采用二进制格式传输的服务框架，相对传统 soap web service，更轻量，更快速。</p>
<p>Hessian原理与协议简析：</p>
<p>http的协议约定了数据传输的方式，<code>hessian</code>也无法改变太多：</p>
<ol>
<li>
<p>hessian中client与server的交互，基于<code>http-post</code>方式。</p>
</li>
<li>
<p>hessian将辅助信息，封装在<code>http header</code>中，比如“<code>授权token</code>”等，我们可以基于<code>http-header</code>来封装关于“安全校验”，“meta数据”等。hessian提供了简单的”校验”机制。</p>
</li>
<li>
<p>对于<code>hessian</code>的交互核心数据，比如“调用的方法”和参数列表信息，将通过post请求的body体直接发送，格式为字节流。</p>
</li>
<li>
<p>对于<code>hessian</code>的server端响应数据，将在<code>response</code>中通过字节流的方式直接输出。</p>
</li>
</ol>
<p>hessian 的协议本身并不复杂，在此不再赘言；所谓协议(<code>protocol</code>)就是约束数据的格式，client按照协议将请求信息序列化成字节序列发送给server端，server端根据协议，将数据反序列化成“对象”，然后执行指定的方法，并将方法的返回值再次按照协议序列化成字节流，响应给client，client按照协议将字节流反序列化成”对象”。</p>
<h2 id="_5、服务提供者能实现失效踢出是什么原理"> 5、服务提供者能实现失效踢出是什么原理？</h2>
<p>答：服务失效踢出基于 <code>zookeeper</code> 的临时节点原理。</p>
<h2 id="_6、服务上线怎么不影响旧版本"> 6、服务上线怎么不影响旧版本？</h2>
<p>答：采用多版本开发，不影响旧版本。在配置中添加<code>version</code>来作为版本区分</p>
<h2 id="_7、如何解决服务调用链过长的问题"> 7、如何解决服务调用链过长的问题？</h2>
<p>答：可以结合 <code>zipkin</code> 实现分布式服务追踪。</p>
<h2 id="_8、说说核心的配置有哪些"> 8、说说核心的配置有哪些？</h2>
<p>核心配置有：</p>
<ol>
<li>dubbo:service/ 服务提供者暴露服务配置。
对应的配置类：<code>org.apache.dubbo.config.ServiceConfig</code></li>
<li>dubbo:reference/ 服务消费者引用服务配置。
对应的配置类： <code>org.apache.dubbo.config.ReferenceConfig</code></li>
<li>dubbo:protocol/ 服务提供者协议配置。
对应的配置类： <code>org.apache.dubbo.config.ProtocolConfig</code>。同时，如果需要支持多协议，可以声明多个 <a href="dubbo:protocol">dubbo:protocol</a> 标签，并在 <a href="dubbo:service">dubbo:service</a> 中通过 protocol 属性指定使用的协议。</li>
<li>dubbo:registry/ 注册中心配置。
对应的配置类： <code>org.apache.dubbo.config.RegistryConfig</code>。同时如果有多个不同的注册中心，可以声明多个 <code>&lt;dubbo:registry&gt;</code> 标签，并在 <code>&lt;dubbo:service&gt;</code> 或 <code>&lt;dubbo:reference&gt;</code> 的 registry 属性指定使用的注册中心。</li>
<li>dubbo:application/ 应用信息配置。</li>
<li>dubbo:provider/ 服务提供者缺省值配置。同时该标签为 <a href="dubbo:service">dubbo:service</a> 和 <a href="dubbo:protocol">dubbo:protocol</a> 标签的缺省值设置。</li>
<li>dubbo:consumer/ 服务消费者缺省值配置。同时该标签为 <a href="dubbo:reference">dubbo:reference</a> 标签的缺省值设置。</li>
<li>dubbo:method/ 方法级配置。同时该标签为 <a href="dubbo:service">dubbo:service</a> 或 <a href="dubbo:reference">dubbo:reference</a> 的子标签，用于控制到方法级。</li>
</ol>
<p>protocol	英[ˈprəʊtəkɒl] 美[ˈproʊtəkɑːl]</p>
<h2 id="_9、dubbo-支持哪些协议-每种协议的应用场景-优缺点"> 9、Dubbo 支持哪些协议，每种协议的应用场景，优缺点？</h2>
<ul>
<li>dubbo：单一长连接和 NIO 异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议 TCP，异步，Hessian 序列化；</li>
<li>rmi：采用 JDK 标准的 rmi 协议实现，传输参数和返回参数对象需要实现 <code>Serializable</code> 接口，使用 java 标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议 TCP。 多个短连接，TCP 协议传输，同步传输，适用常规的远程服务调用和 rmi 互操作。在依赖低版本的 Common-Collections 包，java 序列化存在安全漏洞； <code>webservice</code>:基于 WebService 的远程调用协议，集成 CXF 实现，提供和原生 WebService 的互操作。多个短连接，基于 HTTP 传输，同步传输，适用系统集成和跨语言调用；</li>
<li>http： 基于 Http 表单提交的远程调用协议，使用 Spring 的 HttpInvoke 实现。多个短连接，传输协议 HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器 JS 调用；</li>
<li>hessian： 集成 Hessian 服务，基于 HTTP 通讯，采用 Servlet 暴露服务，Dubbo 内嵌 Jetty 作为服务器时默认实现，提供与 Hession 服务互操作。多个短连接，同步 HTTP 传输，Hessian 序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件；</li>
<li>memcache： 基于 memcached 实现的 RPC 协议</li>
<li>redis： 基于 redis 实现的 RPC 协议</li>
</ul>
<p>dubbo 推荐用什么协议？ 默认使用 dubbo 协议。</p>
<h2 id="_11、同一个服务多个注册的情况下可以直连某一个服务吗"> 11、同一个服务多个注册的情况下可以直连某一个服务吗？</h2>
<p>答：可以直连，修改配置即可，也可以通过 <code>telnet</code> 直接某个服务。</p>
<h2 id="_11、dubbo-在安全机制方面如何解决的"> 11、dubbo 在安全机制方面如何解决的？</h2>
<p>dubbo 通过 token 令牌防止用户绕过注册中心直连，然后在注册中心管理授权，dubbo 提供了黑白名单，控制服务所允许的调用方。</p>
<h2 id="_12、集群容错怎么做"> 12、集群容错怎么做？</h2>
<p>答：读操作建议使用 <code>Failover</code> 失败自动切换，默认重试两次其他服务器。写操作建议使用 <code>Failfast</code> 快速失败，发一次调用失败就立即报错。</p>
<h2 id="_13、在使用过程中都遇到了些什么问题-如何解决的"> 13、在使用过程中都遇到了些什么问题？ 如何解决的？</h2>
<ol>
<li>
<p>同时配置了 XML 和 properties 文件，则 properties 中的配置无效 只有 XML 没有配置时，properties 才生效。</p>
</li>
<li>
<p>dubbo 缺省会在启动时检查依赖是否可用，不可用就抛出异常，阻止 spring 初始化完成，check 属性默认为 true。
测试时有些服务不关心或者出现了循环依赖，将 check 设置为 false</p>
</li>
<li>
<p>为了方便开发测试，线下有一个所有服务可用的注册中心，这时，如果有一个正在开发中的服务提供者注册，可能会影响消费者不能正常运行。
解决：让服务提供者开发方，只订阅服务，而不注册正在开发的服务，通过直连测试正在开发的服务。设置 dubbo:registry 标签的 register 属性为 false。</p>
</li>
<li>
<p>spring 2.x 初始化死锁问题。 在 spring 解析到 dubbo:service 时，就已经向外暴露了服务，而 spring 还在接着初始化其他 bean，如果这时有请求进来，并且服务的实现类里有调用 <code>applicationContext.getBean()</code> 的用法。getBean 线程和 spring 初始化线程的锁的顺序不一样，导致了线程死锁，不能提供服务，启动不了。</p>
</li>
</ol>
<p>解决：不要在服务的实现类中使用 applicationContext.getBean(); 如果不想依赖配置顺序，可以将 dubbo:provider 的 deplay 属性设置为 - 1，使 dubbo 在容器初始化完成后再暴露服务。</p>
<ol start="5">
<li>服务注册不上 检查 <code>dubbo</code> 的 jar 包有没有在 <code>classpath</code> 中，以及有没有重复的 jar 包</li>
</ol>
<p>检查暴露服务的 <code>spring</code> 配置有没有加载</p>
<p>在服务提供者机器上测试与注册中心的网络是否通</p>
<ol start="6">
<li>出现 RpcException: No provider available for remote service 异常
表示没有可用的服务提供者，</li>
</ol>
<p>a. 检查连接的注册中心是否正确</p>
<p>b. 到注册中心查看相应的服务提供者是否存在</p>
<p>c. 检查服务提供者是否正常运行</p>
<ol start="7">
<li>出现” 消息发送失败” 异常</li>
</ol>
<p>通常是接口方法的传入传出参数未实现 Serializable 接口。</p>
<h2 id="_14、dubbo-和-dubbox-之间的区别"> 14、dubbo 和 dubbox 之间的区别？</h2>
<p>答：dubbox 是当当网基于 dubbo 上做了一些扩展，如加了服务可 restful 调用，更新了开源组件等。</p>
<h2 id="_15、你还了解别的分布式框架吗"> 15、你还了解别的分布式框架吗？</h2>
<p>答：别的还有 spring 的 spring cloud，facebook 的 <code>thrift</code>，twitter 的 <code>finagle</code> 等。</p>
<h2 id="_17、dubbo-集群的负载均衡有哪些策略"> 17、Dubbo 集群的负载均衡有哪些策略</h2>
<ul>
<li>Dubbo 提供了常见的集群策略实现，并预扩展点予以自行实现。</li>
<li>Random LoadBalance : 随机选取提供者策略，有利于动态调整提供者权重。截面碰撞率高，调用次数越多，分布越均匀；</li>
<li>RoundRobin LoadBalance : 轮循选取提供者策略，平均分布，但是存在请求累积的问题；</li>
<li>LeastActive LoadBalance : 最少活跃调用策略，解决慢提供者接收更少的请求；</li>
<li>ConstantHash LoadBalance : 一致性 Hash 策略，使相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者，避免引起提供者的剧烈变动；</li>
</ul>
<h2 id="_18、服务调用超时问题怎么解决"> 18、服务调用超时问题怎么解决</h2>
<p>dubbo在调用服务不成功时，默认是会重试两次的。这样在服务端的处理时间超过了设定的超时时间时，就会有重复请求，比如在发邮件时，可能就会发出多份重复邮件，执行注册请求时，就会插入多条重复的注册数据，那么怎么解决超时问题呢？如下</p>
<p>对于核心的服务中心，去除dubbo超时重试机制，并重新评估设置超时时间。 业务处理代码必须放在服务端，客户端只做参数验证和服务调用，不涉及业务流程处理 全局配置实例</p>
<div><pre><code><span><span><span>&lt;</span><span>dubbo:</span>provider</span> <span>delay</span><span><span>=</span><span>"</span>1<span>"</span></span> <span>timeout</span><span><span>=</span><span>"</span>6000<span>"</span></span> <span>retries</span><span><span>=</span><span>"</span>0<span>"</span></span><span>/></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>当然Dubbo的重试机制其实是非常好的QOS保证，它的路由机制，是会帮你把超时的请求路由到其他机器上，而不是本机尝试，所以 dubbo的重试机器也能一定程度的保证服务的质量。但是请一定要综合线上的访问情况，给出综合的评估。</p>
<p>![原文链接：](https://deanwang1943.github.io/bugs/2018/10/05/面试/饿了么/dubbo 面试题/)</p>
]]></content>
    <author>
      <name>Dean Wang</name>
    </author>
    <category term="soa"/>
    <contributor>
      <name>Dean Wang</name>
    </contributor>
    <published>2022-03-24T01:58:17.000Z</published>
    <rights>Copyright by Dean Wang</rights>
  </entry>
  <entry>
    <title type="html">ZooKeeper</title>
    <id>http://www.zhangsj.xyz/blog/java/soa/Zookeeper/</id>
    <link href="http://www.zhangsj.xyz/blog/java/soa/Zookeeper/"/>
    <updated>2022-02-28T02:20:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="概念"> 概念</h2>
<p>ZooKeeper 是一个开放源码的分布式协调服务，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p>
<p>分布式应用程序可以基于Zookeeper实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等功能。</p>
<p>Zookeeper保证了如下分布式一致性特性：</p>
<p>顺序一致性
原子性
单一视图
可靠性
实时性（最终一致性）</p>
<p>客户端的读请求可以被集群中的任意一台机器处理，如果读请求在节点上注册了监听器，这个监听器也是由所连接的zookeeper机器来处理。对于写请求，这些请求会同时发给其他zookeeper机器并且达成一致后，请求才会返回成功。因此，随着zookeeper的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。</p>
<p>有序性是zookeeper中非常重要的一个特性，所有的更新都是全局有序的，每个更新都有一个唯一的时间戳，这个时间戳称为zxid（Zookeeper Transaction Id）。而读请求只会相对于更新有序，也就是读请求的返回结果中会带有这个zookeeper最新的zxid。</p>
<h2 id="zookeeper提供了什么"> ZooKeeper提供了什么</h2>
<h3 id="文件系统"> 文件系统</h3>
<p>Zookeeper提供一个多层级的节点命名空间（节点称为znode）。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。</p>
<p>Zookeeper为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得Zookeeper不能用于存放大量的数据，每个节点的存放数据上限为1M。</p>
<h3 id="zab协议"> ZAB协议</h3>
<p>ZAB协议是为分布式协调服务Zookeeper专门设计的一种支持崩溃恢复的原子广播协议。</p>
<p>ZAB协议包括两种基本的模式：崩溃恢复和消息广播。</p>
<p>当整个zookeeper集群刚刚启动或者Leader服务器宕机、重启或者网络故障导致不存在过半的服务器与Leader服务器保持正常通信时，所有进程（服务器）进入崩溃恢复模式，首先选举产生新的Leader服务器，然后集群中Follower服务器开始与新的Leader服务器进行数据同步，当集群中超过半数机器与该Leader服务器完成数据同步之后，退出恢复模式进入消息广播模式，Leader服务器开始接收客户端的事务请求生成事物提案来进行事务请求处理。</p>
<h2 id="znode"> Znode</h2>
<ul>
<li>
<p>PERSISTENT-持久节点
除非手动删除，否则节点一直存在于Zookeeper上</p>
</li>
<li>
<p>EPHEMERAL-临时节点
临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与zookeeper连接断开不一定会话失效），那么这个客户端创建的所有临时节点都会被移除。</p>
</li>
<li>
<p>PERSISTENT_SEQUENTIAL-持久顺序节点
基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。</p>
</li>
<li>
<p>EPHEMERAL_SEQUENTIAL-临时顺序节点
基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。</p>
</li>
</ul>
<h2 id="leader-选举"> Leader 选举</h2>
<p>Leader选举是保证分布式数据一致性的关键所在。当Zookeeper集群中的一台服务器出现以下两种情况之一时，需要进入Leader选举。</p>
<p>(1) 服务器初始化启动。
(2) 服务器运行期间无法和Leader保持连接。</p>
<ol>
<li>服务器启动时期的Leader选举</li>
</ol>
<p>若进行Leader选举，则至少需要两台机器，这里选取3台机器组成的服务器集群为例。在集群初始化阶段，当有一台服务器Server1启动时，其单独无法进行和完成Leader选举，当第二台服务器Server2启动时，此时两台机器可以相互通信，每台机器都试图找到Leader，于是进入Leader选举过程。选举过程如下</p>
<p>(1) 每个Server发出一个投票。由于是初始情况，Server1和Server2都会将自己作为Leader服务器来进行投票，每次投票会包含所推举的服务器的myid和ZXID，使用(myid, ZXID)来表示，此时Server1的投票为(1, 0)，Server2的投票为(2, 0)，然后各自将这个投票发给集群中其他机器。</p>
<p>(2) 接受来自各个服务器的投票。集群的每个服务器收到投票后，首先判断该投票的有效性，如检查是否是本轮投票、是否来自LOOKING状态的服务器。</p>
<p>(3) 处理投票。针对每一个投票，服务器都需要将别人的投票和自己的投票进行PK，PK规则如下</p>
<p>· 优先检查ZXID。ZXID比较大的服务器优先作为Leader。
· 如果ZXID相同，那么就比较myid。myid较大的服务器作为Leader服务器。</p>
<p>对于Server1而言，它的投票是(1, 0)，接收Server2的投票为(2, 0)，首先会比较两者的ZXID，均为0，再比较myid，此时Server2的myid最大，于是更新自己的投票为(2, 0)，然后重新投票，对于Server2而言，其无须更新自己的投票，只是再次向集群中所有机器发出上一次投票信息即可。</p>
<p>(4) 统计投票。每次投票后，服务器都会统计投票信息，判断是否已经有过半机器接受到相同的投票信息，对于Server1、Server2而言，都统计出集群中已经有两台机器接受了(2, 0)的投票信息，、
此时便认为已经选出了Leader。</p>
<p>(5) 改变服务器状态。一旦确定了Leader，每个服务器就会更新自己的状态，如果是Follower，那么就变更为FOLLOWING，如果是Leader，就变更为LEADING。</p>
]]></content>
    <author>
      <name>lanqiu5ge</name>
    </author>
    <category term="soa"/>
    <contributor>
      <name>lanqiu5ge</name>
    </contributor>
    <published>2018-08-02T00:00:00.000Z</published>
    <rights>Copyright by lanqiu5ge</rights>
  </entry>
  <entry>
    <title type="html">Netty&amp;NIO</title>
    <id>http://www.zhangsj.xyz/blog/java/soa/nio/</id>
    <link href="http://www.zhangsj.xyz/blog/java/soa/nio/"/>
    <updated>2022-02-25T04:39:47.000Z</updated>
    <content type="html"><![CDATA[<h2 id="netty-nio"> Netty&amp;NIO</h2>
<p>Netty 是一个异步的、基于事件驱动的网络应用框架，它可以用来开发高性能服务端和客户端。</p>
<h3 id="问题"> 问题</h3>
<p>以前编写网络调用程序的时候，我们都会在客户端创建一个 Socket，通过这个 Socket 连接到服务端。</p>
<p>服务端根据这个 Socket 创建一个 Thread，用来发出请求。客户端在发起调用以后，需要等待服务端处理完成，才能继续后面的操作。这样线程会出现等待的状态。</p>
<p>如果客户端请求数越多，服务端创建的处理线程也会越多，JVM 如此多的线程并不是一件容易的事。</p>
<h2 id="nio"> NIO</h2>
<p>为了解决上述的问题，推出了 NIO 的概念，也就是(Non-blocking I/O)。其中，Selector 机制就是 NIO 的核心。</p>
<p>当每次客户端请求时，会创建一个 Socket Channel，并将其注册到 Selector 上(多路复用器)。</p>
<p>然后，Selector 关注服务端 IO 读写事件，此时客户端并不用等待 IO 事件完成，可以继续做接下来的工作。</p>
<p>一旦，服务端完成了 IO 读写操作，Selector 会接到通知，同时告诉客户端 IO 操作已经完成。</p>
<p>接到通知的客户端，就可以通过 SocketChannel 获取需要的数据了。</p>
<p>上面描述的过程有点异步的意思，不过，Selector 实现的并不是真正意义上的异步操作。</p>
<p>因为 Selector 需要通过线程阻塞的方式监听 IO 事件变更，只是这种方式没有让客户端等待，是 Selector 在等待 IO 返回，并且通知客户端去获取数据。真正“异步 IO”(AIO)这里不展开介绍，有兴趣可以自行查找。</p>
<p>说好了 NIO 再来谈谈 Netty，Netty 作为 NIO 的实现，它适用于服务器/客户端通讯的场景，以及针对于 TCP 协议下的高并发应用。</p>
<p>对于开发者来说，它具有以下特点：</p>
<p>对 NIO 进行封装，开发者不需要关注 NIO 的底层原理，只需要调用 Netty 组件就能够完成工作。</p>
<p>对网络调用透明，从 Socket 建立 TCP 连接到网络异常的处理都做了包装。</p>
<p>对数据处理灵活， Netty 支持多种序列化框架，通过“ChannelHandler”机制，可以自定义“编/解码器”。</p>
<p>对性能调优友好，Netty 提供了线程池模式以及 Buffer 的重用机制(对象池化)，不需要构建复杂的多线程模型和操作队列。</p>
<h2 id="从一个简单的例子开始"> 从一个简单的例子开始</h2>
<p>开篇讲到了，为了满足高并发下网络请求，引入了 NIO 的概念。Netty 是针对 NIO 的实现，在 NIO 封装，网络调用，数据处理以及性能优化等方面都有不俗的表现。</p>
<p>学习架构最容易的方式就是从实例入手，从客户端访问服务端的代码来看看 Netty 是如何运作的。再一次介绍代码中调用的组件以及组件的工作原理。</p>
<p>假设有一个客户端去调用一个服务端，假设服务端叫做 EchoServer，客户端叫做 EchoClient，用 Netty 架构实现代码如下。</p>
<p>服务端代码</p>
<p>构建服务器端，假设服务器接受客户端传来的信息，然后在控制台打印。首先，生成 EchoServer，在构造函数中传入需要监听的端口号。</p>
<p>接下来就是服务的启动方法：</p>
<p>Server 的启动方法涉及到了一些组件的调用，例如 EventLoopGroup，Channel。这些会在后面详细讲解。</p>
<p>这里有个大致的印象就好：</p>
<p>创建 EventLoopGroup。</p>
<p>创建 ServerBootstrap。</p>
<p>指定所使用的 NIO 传输 Channel。</p>
<p>使用指定的端口设置套接字地址。</p>
<p>添加一个 ServerHandler 到 Channel 的 ChannelPipeline。</p>
<p>异步地绑定服务器；调用 sync() 方法阻塞等待直到绑定完成。</p>
<p>获取 Channel 的 CloseFuture，并且阻塞当前线程直到它完成。</p>
<p>关闭 EventLoopGroup，释放所有的资源。</p>
<p>NettyServer 启动以后会监听某个端口的请求，当接受到了请求就需要处理了。在 Netty 中客户端请求服务端，被称为“入站”操作。</p>
<p>可以通过 ChannelInboundHandlerAdapter 实现，具体内容如下：</p>
<p>从上面的代码可以看出，服务端处理的代码包含了三个方法。这三个方法都是根据事件触发的。</p>
<p>他们分别是：</p>
<p>当接收到消息时的操作，channelRead。</p>
<p>消息读取完成时的方法，channelReadComplete。</p>
<p>出现异常时的方法，exceptionCaught。</p>
<p>客户端代码</p>
<p>客户端和服务端的代码基本相似，在初始化时需要输入服务端的 IP 和 Port。</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-23T12:02:30.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">dubbo</title>
    <id>http://www.zhangsj.xyz/blog/java/soa/dubbo/</id>
    <link href="http://www.zhangsj.xyz/blog/java/soa/dubbo/"/>
    <updated>2022-03-17T12:34:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="dubbo"> Dubbo</h2>
<h2 id="协议"> 协议</h2>
<p>Dubbo: 单一长连接和 NIO 异步通讯，适合大并发小数据量的服务调用， 以及消费者远大于提供者。传输协议 <code>TCP</code>，异步，<code>Hessian</code> 序列化;</p>
<p>Rmi: 采用 JDK 标准的 rmi 协议实现，传输参数和返回参数对象需要实现 Serializable 接口，使用 java 标准序列化机制，使用阻塞式短连接，传输数 据包大小混合，消费者和提供者个数差不多，可传文件，传输协议 TCP。 多个短连接，TCP 协议传输，同步传输，适用常规的远程服务调用和 rmi 互 操作。在依赖低版本的 Common-Collections 包，java 序列化存在安全漏 洞;</p>
<p>Webservice: 基于 WebService 的远程调用协议，集成 CXF 实现，提供和 原生 WebService 的互操作。多个短连接，基于 HTTP 传输，同步传输，适 用系统集成和跨语言调用;</p>
<p>Http: 基于 Http 表单提交的远程调用协议，使用 Spring 的 HttpInvoke 实 现。多个短连接，传输协议 HTTP，传入参数大小混合，提供者个数多于消 费者，需要给应用程序和浏览器 JS 调用;</p>
<p>Hessian:集成 Hessian 服务，基于 HTTP 通讯，采用 Servlet 暴露服务， Dubbo 内嵌 Jetty 作为服务器时默认实现，提供与 Hession 服务互操作。多 个短连接，同步 HTTP 传输，Hessian 序列化，传入参数较大，提供者大于 消费者，提供者压力较大，可传文件;</p>
<p>Memcache: 基于 memcached 实现的 RPC 协议</p>
<p>Redis: 基于 redis 实现的 RPC 协议</p>
<h2 id="dubbo-超时时间"> Dubbo 超时时间</h2>
<p>Dubbo 超时时间设置有两种方式:</p>
<p>服务提供者端设置超时时间，在 Dubbo 的用户文档中，推荐如果能在服务 端多配置就尽量多配置，因为服务提供者比消费者更清楚自己提供的服务特 性。</p>
<p>服务消费者端设置超时时间，如果在消费者端设置了超时时间，以消费者端为主，即优先级更高。因为服务调用方设置超时时间控制性更灵活。如果消费方超时，服务端线程不会定制，会产生警告。</p>
<h2 id="注册中心"> 注册中心</h2>
<p>Zookeeper 注册中心:</p>
<p>基于分布式协调系统 Zookeeper 实现，采用 Zookeeper 的 watch 机制实现数据变更;</p>
<h2 id="dubbo-和-spring-cloud"> Dubbo 和 Spring Cloud</h2>
<p>Dubbo 是 SOA 时代的产物，它的关注点主要在于服务的调用，流 量分发、流量监控和熔断。而 Spring Cloud 诞生于微服务架构时 代，考虑的是微服务治理的方方面面，另外由于依托了 Spirng、 Spirng Boot 的优势之上，两个框架在开始目标就不一致，Dubbo 定位服务治理、</p>
<p>Spirng Cloud 是一个生态。</p>
<p>最大的区别:Dubbo 底层是使用 <code>Netty</code> 这样的 <code>NIO</code> 框架，是基于 TCP 协议传输的，配合以 Hession 序列化完成 RPC 通信。</p>
<h2 id="负载均衡策略"> 负载均衡策略</h2>
<p>Dubbo提供了4中负载均衡策略</p>
<h3 id="_1-random-loadbalance-随机均衡算法"> ① Random LoadBalance（随机均衡算法）</h3>
<p>随机，按权重设置随机概率。</p>
<p>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</p>
<h3 id="_2-roundrobin-loadbalance-权重轮询均衡算法"> ② RoundRobin LoadBalance（权重轮询均衡算法）</h3>
<p>轮询，按公约后的权重设置轮询比率。</p>
<p>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调用第二台时就卡在那里，久而久之，所有请求都卡在第二台机器上。</p>
<p>Round Robin轮询算法，是按照公约后的权重设置轮询比率，即权重轮询算法（Weighted Round-Robin），它是基于轮询算法改进而来的</p>
<p>轮询调度算法的原理是：每一次把来自用户的请求轮流分配给内部中的服务器。如从1开始，一直到N（其中N是内部服务器的总个数），然后重新开始循环。</p>
<p>该算法的优点：</p>
<p>简洁，无需记录当前所有连接的状态，所以它是一种无状态调度。</p>
<p>缺点：</p>
<p>轮询调度算法假设所有服务器的处理性能都相同，不关心每台服务器的当前连接数和相应速度。当请求服务间隔时间变化比较大时，轮询调度算法容易导致服务器间的负载不平衡。</p>
<h3 id="_3-leastaction-loadbalance-最少活跃调用数均衡算法"> ③ LeastAction LoadBalance（最少活跃调用数均衡算法）</h3>
<p>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。</p>
<p>使慢的提供者收到更少请求，因为越慢的提供者的调用前后技术差会越大。</p>
<h3 id="_4-consistenthash-loadbalance-一致性hash均衡算法"> ④ ConsistentHash LoadBalance（一致性Hash均衡算法）</h3>
<p>一致性hash，相同参数的请求总是发送到同一提供者</p>
<p>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其他提供者，不会引起剧烈变动弄。</p>
<p>一致性hash算法可以解决服务提供者的增加、移除及挂掉时的情况，能尽可能小的改变已存在key的映射关系，尽可能的满足单调性的要求。</p>
<p>一致性hash通过构建虚拟节点，能尽可能避免分配失衡，具有很好的平衡性。</p>
<p>以下示例假设对象（Object）就相当于Client发的请求，cache相当于服务提供者。</p>
<p>环形hash空间</p>
<p>考虑通常的hash算法都是将value映射到一个32位的key值，也即是0~2<sup>32-1次方的数值空间。可以将这个空间想象成一个首（0）尾(2</sup>32-1)相接的圆环，如：</p>
<div><p>总结</p>
<p>一致性hash，相同参数的请求总是发送到同一提供者</p>
<p>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其他提供者，不会引起剧烈变动弄。</p>
<p>一致性hash算法可以解决服务提供者的增加、移除及挂掉时的情况，能尽可能小的改变已存在key的映射关系，尽可能的满足单调性的要求。</p>
<p>一致性hash通过构建虚拟节点，能尽可能避免分配失衡，具有很好的平衡性。</p>
<p>以下示例假设对象（Object）就相当于Client发的请求，cache相当于服务提供者。</p>
<p>环形hash空间</p>
<p>考虑通常的hash算法都是将value映射到一个32位的key值，也即是0~2<sup>32-1次方的数值空间。可以将这个空间想象成一个首（0）尾(2</sup>32-1)相接的圆环，如：</p>
</div>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="soa"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-23T04:24:33.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">spring cloud</title>
    <id>http://www.zhangsj.xyz/blog/java/soa/spring-cloud/</id>
    <link href="http://www.zhangsj.xyz/blog/java/soa/spring-cloud/"/>
    <updated>2022-04-12T10:55:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="什么是微服务-spring-cloud"> 什么是微服务？spring cloud</h2>
<p>spring cloud是一系列框架的有序集合，它利用了spring boot的开发便利性简化了分布式系统的开发，比如服务发现、服务网关、服务路由、链路追踪等。spring cloud并不重复造轮子，而是将市面上开发的比较好的模块集成进去，进行封装，从而减少了各模块的开发成本。换句话说：spring cloud提供了构建分布式系统所需的“全家桶”。</p>
<h3 id="springcloud现状"> SpringCloud现状</h3>
<ol>
<li>中文文档较少，出现问题网上没有太多的解决方案，</li>
<li>国内创业型公司技术老大的多是阿里系员工，而阿里系多采用DUBBO来构建微服务架构。</li>
<li>大型公司基本都有自己的分布式解决方案，而中小型公司的架构很多用不上为服务，所以没有采用SpringCloud的必要性。</li>
</ol>
<p>但是，微服务架构是一个趋势，而SpringCloud是为服务解决方案的佼佼者。</p>
<p>##　微服务优缺点</p>
<ul>
<li>单一职责原则；</li>
<li>每个服务足够内聚，足够小，代码容易理解，这样能聚焦一个指定的业务功能或业务需求；</li>
<li>开发简单，开发效率高，一个服务可能就是专一的只干一件事；</li>
<li>微服务能够被小团队单独开发，这个团队只需2-5个开发人员组成；</li>
<li>微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的；</li>
<li>微服务能使用不同的语言开发；</li>
<li>易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如jenkins，Hudson，bamboo；</li>
</ul>
<h3 id="springcloud优缺点"> SpringCloud优缺点</h3>
<p>优点：</p>
<ol>
<li>集大成者，SpringCloud包含了微服务架构的方方面面。</li>
<li>约定优于配置，基于注解，没有配置文件。</li>
<li>轻量级组件，SpringCloud对各个组件进行了大量的封装，从而简化了开发。</li>
<li>开发灵活，SpringCloud的组件都是解耦的，开发人员可以灵活按需选择组件。</li>
</ol>
<p>缺点：</p>
<ol>
<li>项目结构复杂，每一个组件或者每一个微服务都需要创建一个项目。</li>
<li>部署门槛高，项目部署需要配合DOCKER等容器技术进行集群部署，而是想要深入了解DOCKER，学习成本高。</li>
</ol>
<h2 id="springcloud项目搭建"> SpringCloud项目搭建</h2>
<p>使用Maven项目进行构建：</p>
<p>父项目，GAV填写，根据自己的习惯进行填写，然后点击NEXT.</p>
<p>配置pom.xml文件。</p>
<p>父工程是不写业务的，其中我们可以将SRC文件夹删除，将一些没用的文件进行设置不显示或者删除，我们此时父工程就搭建完成了，就是这么简单。</p>
<p>接下来，我们就可以进行继续搭建其他的微服务工程了。我们首先搭建一个专门放我们是提累的服务，来让其他服务调用。</p>
<p>选中我们的父工程点击NEW，再点击MOUDULE：</p>
<p>这里是跟建父工程一样。</p>
<p>填写我们的MOUDULE的项目名称。</p>
<p>注意这一步，我们项目名的-省略，因为实际项目中有更多的工程，我们为了方便看得更清楚，需要加-来进行分割！</p>
<p>我们的第一个微服务工程就建立完成了，接下来就是配置啦，我们首先配置POM文件，我们引入了HUTOOL这个JAR包，它是一个JAVA基础工具类，对文件、流、加密解密、转码、正则、线程、xml等jdk方法进行封装，组成各种UTIL工具类，同时提供以下组件：</p>
<ul>
<li>布隆过滤器</li>
<li>缓存</li>
<li>克隆接口</li>
<li>类型转换</li>
<li>日期处理</li>
<li>数据库ORM</li>
<li>基于DFA有限自动机的多个关键字查找</li>
<li>HTTP客户端</li>
<li>IO和文件</li>
<li>有用的一些数据结构</li>
<li>日志</li>
<li>反射代理类的简化（AOP切面实现）</li>
</ul>
<p>它提倡单一的应用程序垂直地划分为一组小的服务，每个服务都是独立在自己的进程内，服务之间相互协调。</p>
<p>互相配置，为用户提供最终价值，服务之间采用轻量级的通信机制（HTTP）互相沟通，每个服务都围绕着具体的业务进行构建，并且能够独立的部署到生产环境中，</p>
<p>另外，应尽 量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应该根据业务上下文，选择合适的语言，工具(Maven)对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来编写服务，也可以使用不同的数据存储。</p>
<h2 id="微服务之间是如何独立通讯的"> 微服务之间是如何独立通讯的？</h2>
<p>同步（REST HTTP协议，RPC TCP 协议）</p>
<p>同步（REST HTTP协议，RPC TCP 协议）</p>
<p>异步（消息中间件，例如 Kafka、ActiveMQ、RabbitMQ、RocketMQ）</p>
<p>REST HTTP 协议（编写restful风格接口，调用接口）（springcloud使用REST通信）</p>
<p>RPC TCP 协议（客户端代理序列化方法和参数传入服务器，服务器代理解码方法和参数并执行方法，将结果再序列化传回去，客户端代理再解码结果得到结果）</p>
<p>springboot 可以springCloud</p>
<h2 id="springcloud-常见组件"> SpringCloud 常见组件</h2>
<p>•注册中心组件：Eureka、Nacos 等</p>
<p>•负载均衡组件：Ribbon</p>
<p>•远程调用组件：OpenFeign</p>
<p>•网关组件：Zuul、Gateway</p>
<p>•服务保护组件：Hystrix、Sentinel</p>
<p>•服务配置管理组件：SpringCloudConfig、Nacos</p>
<h2 id="nacos-的-服务注册表结构是怎样的"> Nacos 的 服务注册表结构是怎样的？</h2>
<p>问题: 考察对 Nacos 数据分级结构的了解，以及 Nacos 源码的掌握情况</p>
<p>Nacos 采用了数据的分级存储模型，最外层是 Namespace，用来隔离环境。然后是 Group，用来对服务分组。接下来就是服务(Service)了，一个服务包含多个实例，但是可能处于不同机房，因此 Service 下有多个集群(Cluster)，Cluster 下是不同的实例(Instance)。</p>
<p>对应到 Java 代码中，Nacos 采用了一个多层的 Map 来表示。结构为 Map&lt;String, Map&lt;String, Service&gt;&gt;，其中最外层 Map 的 key 就是 namespaceId，值是一个 Map。内层 Map 的 key 是 group 拼接 serviceName，值是 Service 对象。Service 对象内部又是一个 Map，key 是集群名称，值是 Cluster 对象。而 Cluster 对象内部维护了 Instance 的集合。</p>
<p>如图：</p>
<p><img src="./assets/image-20210925215305446.png" alt="image-20210925215305446" loading="lazy"></p>
<h2 id="nacos-如何支撑阿里内部数十万服务注册压力"> Nacos 如何支撑阿里内部数十万服务注册压力？</h2>
<p>Nacos 内部接收到注册的请求时，不会立即写数据，而是将服务注册的任务放入一个阻塞队列就立即响应给客户端。</p>
<p>然后利用线程池读取阻塞队列中的任务，异步来完成实例更新，从而提高并发写能力。</p>
<h2 id="nacos-如何避免并发读写冲突问题"> Nacos 如何避免并发读写冲突问题？</h2>
<p>问题: 考察对 Nacos 源码的掌握情况</p>
<p>Nacos 在更新实例列表时，会采用 CopyOnWrite 技术，首先将旧的实例列表拷贝一份，然后更新拷贝的实例列表，再用更新后的实例列表来覆盖旧的实例列表。</p>
<p>这样在更新的过程中，就不会对读实例列表的请求产生影响，也不会出现脏读问题了。</p>
<h2 id="nacos-与-eureka"> Nacos 与 Eureka</h2>
<p>Nacos 与 Eureka 有相同点，也有不同之处，可以从以下几点来描述：</p>
<ul>
<li><strong>接口方式</strong>：Nacos 与 Eureka 都对外暴露了 Rest 风格的 API 接口，用来实现服务注册、发现等功能</li>
<li><strong>实例类型</strong>：Nacos 的实例有永久和临时实例之分；而 Eureka 只支持临时实例</li>
<li><strong>健康检测</strong>：Nacos 对临时实例采用心跳模式检测，对永久实例采用主动请求来检测；Eureka 只支持心跳模式</li>
<li><strong>服务发现</strong>：Nacos 支持定时拉取和订阅推送两种模式；Eureka 只支持定时拉取模式</li>
</ul>
<h2 id="sentinel-的限流与-gateway-的限流有什么差别"> Sentinel 的限流与 Gateway 的限流有什么差别？</h2>
<p>限流算法常见的有三种实现：</p>
<p>滑动时间窗口、令牌桶算法、漏桶算法。</p>
<p>Gateway 则采用了基于 Redis 实现的令牌桶算法。</p>
<p>而 Sentinel 内部却比较复杂：</p>
<ul>
<li>默认限流模式是基于滑动时间窗口算法</li>
<li>排队等待的限流模式则基于漏桶算法</li>
<li>而热点参数限流则是基于令牌桶算法</li>
</ul>
<h2 id="sentinel-的线程隔离与-hystix-的线程隔离"> Sentinel 的线程隔离与 Hystix 的线程隔离</h2>
<p>线程隔离方案的掌握</p>
<p>Hystix 默认是基于线程池实现的线程隔离，每一个被隔离的业务都要创建一个独立的线程池，线程过多会带来额外的 CPU 开销，性能一般，但是隔离性更强。</p>
<p>Sentinel 是基于 信号量 实现的线程隔离，不用创建线程池，性能较好，但是隔离性一般。</p>
<h2 id="服务熔断-服务降级"> 服务熔断，服务降级</h2>
<p>服务熔断（提供者）</p>
<p>Hystrix解决服务雪崩的方案（服务熔断）：</p>
<p>在不可用的服务中服务端给调用方返回备用响应，就可以继续运行调用之后的服务，就可以避免长时间的等待或抛出无法解决的异常，无法释放调用线程，导致服务雪崩</p>
<p>服务降级（消费者）：</p>
<p>当某个时间段访问压力大，需要停掉不重要的某些功能（例如：广告。。），释放占用资源以保证主要核心重要业务能够顺利完成，而消费者调用这些不重要功能时，客户端会返回备用响应</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="soa"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-04-12T10:55:02.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">fubushi mulu</title>
    <id>http://www.zhangsj.xyz/blog/java/soa/</id>
    <link href="http://www.zhangsj.xyz/blog/java/soa/"/>
    <updated>2022-03-24T03:51:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="分布式目录"> 分布式目录</h2>
<ul>
<li><a href="./Zookeeper.html">Zookeepre</a></li>
<li><a href="./nio.html">nio</a></li>
<li><a href="./gateway.html">gateway</a></li>
<li><a href="./dubbo.html">dubbo</a></li>
<li><a href="./分布式事务.html">分布式事务</a></li>
<li><a href="./分布式id.html">分布式id</a></li>
<li><a href="./Dubbo面试18问！这些你都会吗？.html">Dubbo面试18问！这些你都会吗？</a></li>
<li><a href="./spring cloud.html">springCloud</a></li>
<li><a href="./一步步带你了解前后端分离利器之JWT.html">一步步带你了解前后端分离利器之JWT</a></li>
</ul>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="mulu"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-26T14:37:30.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">fubushi id</title>
    <id>http://www.zhangsj.xyz/blog/java/soa/%E5%88%86%E5%B8%83%E5%BC%8Fid/</id>
    <link href="http://www.zhangsj.xyz/blog/java/soa/%E5%88%86%E5%B8%83%E5%BC%8Fid/"/>
    <updated>2022-04-11T06:31:58.000Z</updated>
    <content type="html"><![CDATA[<h2 id="分布式-id"> 分布式 id</h2>
<div><p>Snowflake**</p>
<p>Snowflake 是 Twitter 开源的分布式 ID 生成算法，目的是在分布式系统中生成全局唯一且趋势递增的 long(64bit) 的id数值。
其特性是各节点无需协调、按时间大致有序、且整个集群各节点单不重复。
该数值的默认组成如下(符号位之外的三部分允许个性化调整)：
1bit: 符号位，始终是 0(为了保证主键是正数)。
41bit: 毫秒数(可用 69 年)；
10bit: 节点ID(5bit数据中心 + 5bit节点ID，支持 32 * 32 = 1024 个节点)
12bit: 流水号(每个节点每毫秒内支持 4096 个 ID，相当于 409万的 QPS)
整个64位数值最大值为2的63次方-1，正好等于Long.MAX_VALUE（9223372036854775807）</p>
</div>
<p>一、UUID</p>
<p>UUID是通过唯一识别码，可以生成一个长度32位的全局唯一识别码。
String uuid = UUID.randomUUID().toString()；
缺点：UUID虽然能保证全局唯一，但是占用32位有些太长，而且是无序的，入库时性能较差。(由于关系型数据库索引大多都是B+ tree结构，每个索引节点都存储着若干个id，如果无序的插入会导致一些中间节点分裂，造成很多节点不饱和，大大降低了数据库插入性能)</p>
<p>二、数据库自增主键</p>
<p>分布式系统中用DB proxy请求不同的分库，每个分库设置不同的初始值，步长和分库数量相等：</p>
<p>缺点：id的生成严重依赖数据库，不但影响性能，而且一旦数据库宕机，服务将变得不可用。</p>
<h3 id="snowflake算法"> SnowFlake算法</h3>
<p>雪花算法支持毫秒级的百万id生成操作。</p>
<p>定义一个初始时间戳startTimestamp(14位)，比如 1483200000000L(2017-01-01)，接着获取相应的机房和机器id码(10位)，我目前做的项目就是12位的机器id码+10位的sequence序列号</p>
<p>1、同步锁保证线程安全，step1中，我们先比较当前时间戳与上次缓存毫秒时间，如果小于缓存时间(两种原因，一是毫秒级sequence达到了上限，二是时间回调)，则使用上次缓存毫秒时间戳进行缓存计数器计数操作</p>
<p>2、step2中，我们判断当前时间戳与上次缓存时间是否相等，若相等则进行缓存计数器sequence+1操作，当sequence达到最大值2的10次方1024时，重置为0，且当前时间戳+1；若不等，即当前时间戳大于缓存时间戳，那么sequence从0开始新的计数</p>
<p>3、step3中将当前时间戳的值缓存到lastTimestamp，进行二进制的位运算获得64位全局唯一的分布式id并转成十进制。</p>
<p>41位时间戳：(timestamp - startTimestamp) &lt;&lt; TIMESTAMP_OFFSET，左移22位，相当于2的22次方，右边补0 10位机器码：machineId &lt;&lt; MACHINE_OFFSET，左移12位，相当于2的12次方，右边补0 最后将41位时间戳二进制值、10位机器码二进制值与sequence二进制值进行或运算(相当于右边补0的位置进行相应的合并计算)</p>
<p>优点：ID呈趋势递增，后续插入索引树的时候性能较好。</p>
<p>缺点：</p>
<p>依赖于系统时钟的一致性。</p>
<p>我这边写法仅仅解决了机器系统时钟短时间内的回拨，如果某台机器的系统时钟回拨+服务器重启，缓存时间丢失，那么就有可能造成ID冲突，或者ID乱序。</p>
<ol>
<li>生成ID时不依赖于DB，完全在内存生成，高性能高可用。</li>
</ol>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="fubushi"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-28T02:20:38.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">JWT</title>
    <id>http://www.zhangsj.xyz/blog/java/soa/%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%88%A9%E5%99%A8%E4%B9%8BJWT/</id>
    <link href="http://www.zhangsj.xyz/blog/java/soa/%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%88%A9%E5%99%A8%E4%B9%8BJWT/"/>
    <updated>2022-04-08T00:53:08.000Z</updated>
    <content type="html"><![CDATA[<h1 id="一步步带你了解前后端分离利器之jwt"> 一步步带你了解前后端分离利器之JWT</h1>
<h2 id="一、http的无状态性"> 一、HTTP的无状态性</h2>
<p>HTTP 是无状态协议，它不对之前发送过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。假设要求登录认证的 Web 页面本身无法进行状态的管理（不记录已登录的状态），那么每次跳转新页面不是要再次登录，就是要在每次请求报文中附加参数来管理登录状态。</p>
<p>不可否认，无状态协议当然也有它的优点。由于不必保存状态，自然可减少服务器的CPU及内存资源的消耗。从另一侧面来说，也正是因为 <code>HTTP</code> 协议本身是非常简单的，所以才会被应用在各种场景里。</p>
<h2 id="二、cookie-技术的引入"> 二、Cookie 技术的引入</h2>
<p>如果让服务器管理全部客户端状态则会成为负担，保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入了 Cookie 技术。Cookie 技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。</p>
<p>Cookie 会根据从服务器端发送的响应报文内的一个叫做<code>Set-Cookie</code> 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。</p>
<p>1、没有 Cookie 信息状态下的请求（来源《图解HTTP》）</p>
<p>客户端 保存 Cookie</p>
<p>请求 -&gt; ①保存请求</p>
<p>响应 &lt;- ②在响应中添加Cookie后返回</p>
<p>服务器 生成Cookie记住是向谁发送到</p>
<p>2、第 2 次以后（存有 Cookie 信息状态） 的请求（来源《图解HTTP》）</p>
<p>Client</p>
<p>request -&gt; ③请求中添加Cookie后send</p>
<p>response &lt;-</p>
<p>server ④检查Cookie （是刚才生成的Cookie）</p>
<p>3、详细介绍Cookie 传输过程</p>
<p>server发现client发送过来的Cookie后，回去check 是从哪一个client发来的request，然后对比server上的记录，最后得到之前的状态信息。</p>
<h2 id="三、基于表单的认证"> 三、基于表单的认证</h2>
<p>目前用户的认证多半是基于表单的认证，基于表单的认证一般会使用 Cookie 来管理Session（Session会话，Session代表着服务器和客户端一次会话的过程，直到Session失效（服务端关闭）或者客户端关闭时结束）。基于表单认证本身是通过服务器端的 Web应用，将客户端发送过来的用户ID和密码与之前登录过的信息做匹配来进行认证的。</p>
<p>但鉴于 HTTP 是无状态协议，之前已认证成功的用户状态无法通过协议层面保存下来。即无法实现状态管理，因此即使当该用户下一次继续访问，也无法区分它与其他的用户。于是我们会使用Cookie来管理Session，以弥补HTTP协议中不存在状态管理功能。</p>
<h2 id="四、session存储位置以及集群情况下的问题"> 四、Session存储位置以及集群情况下的问题</h2>
<p>Session 是存储在Web服务器（例如：Tomcat）中的，并针对每个客户端（客户），通过SessionID来区别不同用户的。Session是以Cookie技术或URL重写实现，默认以Cookie技术实现，服务端会给这次会话创造一个JSESSIONID的Cookie值。</p>
<p>但是一个显著的问题就是，在集群模式下如果通过Nginx负载均衡的时候，如果有一个用户登录的时候请求被分配到服务器A上，登录成功后设置的Session就会存放在服务器A上了，但是在服务器B上却没有该用户的Session数据，当用户再次发起一个请求的时候，此时请求如果被分配到服务器B上，则就不会查询到该用户的登录状态，就会出现登录失败的情况！</p>
<p>一种可以想到的方式就是将多个Web服务器上存储的Session统一存储到某一存储介质中，保证进集群中的每一台机器都可以看到所有相同Session数据，这里的同步体现在所有的Session存储在同一的存储介质里边。</p>
<p>幸运的是我们常用的Tomcat容器已经为我们提供了一个接口，可以让我们实现将Session存储到除当前服务器之外的其他存储介质上，例如Redis等。</p>
<p>了解Spring Session的小伙伴可能都会知道<code>Spring Session</code>的本质就是通过实现Tomcat提供的该接口将Session存储到Redis中，以此来实现Session的统一存储管理，对Spring Session有兴趣的小伙伴可以参考往期的文章：</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247483665&amp;idx=1&amp;sn=126be172d9804cdcf75a17b50dcd48fa&amp;chksm=e9c5f8a0deb271b62898af1266da1bde81aed33b231b7c79216dd550d467401728bb6726f5bd&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">使用Redis存储Nginx+Tomcat负载均衡集群的Session</a></p>
<h2 id="五、小结与需求痛点"> 五、小结与需求痛点</h2>
<p>Session和Cookie的目的相同，都是为了克服HTTP协议无状态的缺陷，但完成的方法不同。Session通过Cookie，在客户端保存SessionID，而将用户的其他会话消息保存在服务端的Session对象中，与此相对的，Cookie需要将所有信息都保存在客户端。因此Cookie存在着一定的安全隐患，例如本地Cookie中保存的用户名密码被破译，或Cookie被其他网站收集，例如：</p>
<ol>
<li>
<p>appA主动设置域B cookie，让域B cookie获取；</p>
</li>
<li>
<p>XSS，在appA上通过JavaScript获取document.cookie，并传递给自己的appB。</p>
</li>
</ol>
<p>上述过程我们简单的描述了Session的演进过程还有使用同步的方式解决Session在集群的时候出现的问题，但是我们意识到了使用Spring Session的方式来实现Session的同步是一件相对比较麻烦的事情，我们虽然使用Redis来进行同步，但是Redis并不是100%可靠的，我们需要对Redis搭建集群、进行主从同步复制、进行持久化等，显然这是一件很复杂的事情，因此有没有一种小而轻便的方式来实现我们的这种<strong>认证需求</strong>！那就是JWT了！</p>
<p>除了上述我们遇到的问题之外，在目前前后端分离的大环境下经常会遇到需要根据用户来分配权限和显示相对应信息的问题，虽然传统的Cookie和Session机制可以解决这个问题，但就通用性而言，JWT（JSON Web Token）相对来说更好。</p>
<p>看到这里很多小伙伴都已经按捺不住了！那JWT到底是什么呢？</p>
<p>##六、JWT是什么</p>
<p>Json web token (JWT)，是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519)。该标准被设计为紧凑且安全的，一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息。当然该标准也可直接被用于认证，也可被加密。</p>
<p><strong>JWT的几个特点：</strong></p>
<p>1、由于它们的尺寸较小，JWT可以通过URL，POST参数或HTTP头部发送。 另外，尺寸越小意味着传输速度越快。</p>
<p>2、有效载荷包含有关用户的所有必需信息，避免了多次查询数据库的需要。</p>
<p><strong>JWT的使用场景：</strong></p>
<p>1.验证 这是使用JWT 最常见的情况。 一旦用户登录，每个后续请求将包括JWT。它将允许用户访问该令牌允许的路由，服务和资源。 单点登录是当今广泛使用JWT的一项功能，因为它的开销很小，而且能够轻松地跨不同域使用。
2.信息交换 JWT 是在各方之间安全传输信息的好方法， 因为JWT可以被签名（例如使用公钥/私钥对进行签名）。所以你可以确定发件人是他们说的那个人。 此外，由于使用头部（header）和有效载荷（payload）计算签名，因此您还可以验证内容是否未被篡改。</p>
<p>##七、JWT的结构说明</p>
<p>JWT包含三个由点（.）分隔的部分，它们是：</p>
<ul>
<li>头部（header）</li>
<li>有效负载（payload）</li>
<li>签名（signature）</li>
</ul>
<p>因此，JWT通常看起来如下所示:</p>
<p>xxxxx.yyyyy.zzzzz</p>
<p>1、头部（header）</p>
<p>头部（header）通常由两部分组成：令牌的类型（即JWT）和正在使用的散列算法（如HMAC SHA256或RSA）。如下所示：</p>
<div><pre><code><span>{</span>
  <span>"alg"</span><span>:</span> <span>"HS256"</span><span>,</span>
  <span>"typ"</span><span>:</span> <span>"JWT"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>然后，将这个JSON用Base64编码，形成JWT的第一部分。</p>
<p>2、有效负载（payload）</p>
<p>令牌的第二部分是包含声明的有效载荷。 声明是关于实体（通常是用户）和附加元数据的声明。 有三种类型的声明：</p>
<p>标准中注册的声明；</p>
<p>公开声明；</p>
<p>私人声明；</p>
<p>（1）标准中注册的声明：这是一组预先定义的声明，这些声明不是强制性的，但建议提供一套有用的，可互操作的声明。 如下：</p>
<div><pre><code>iss: jwt签发者

sub: jwt所面向的用户

aud: 接收jwt的一方

exp: jwt的过期时间，这个过期时间必须要大于签发时间

nbf: 定义在什么时间之前，该jwt都是不可用的.

iat: jwt的签发时间

jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>注意：声明名称只有三个字符长，因为JWT是紧凑的。</p>
<p>（2）公开声明：这些可以由使用JWT的人员随意定义。 但为避免冲突，应在IANA JSON Web令牌注册表中定义它们，或者将其定义为包含防冲突命名空间的URI。</p>
<p>（3）私人声明：这是为了共享使用它们的当事方之间共享信息而创建的声明，既不是登记声明，也不是公开声明。</p>
<p>示例如下：</p>
<div><pre><code><span>{</span>
 <span>"sub"</span><span>:</span> <span>"1234567890"</span><span>,</span>
 <span>"name"</span><span>:</span> <span>"john"</span><span>,</span>
<span>"admin"</span><span>:</span> <span>true</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>然后将有效载荷进行Base64编码，以形成JSON Web令牌的第二部分。</p>
<p>3、签名（signature）</p>
<p>要创建签名部分，您必须采用头部（header），有效载荷（payload），密钥（secret），以及头部中指定的算法。例如，如果你想使用HMACSHA256算法，签名将按以下方式创建：</p>
<div><pre><code>HMACSHA256<span>{</span>
base64UrlEncoded(header)+<span>"."</span>+base64UrlEncoded(payload)<span>,</span>
secret
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>签名通常用于验证JWT的发件人是谁，并JWT在传送的过程中不被篡改。</p>
<p>注意：上图红框中的secret是保存在服务器端的，JWT的签发生成也是在服务器端的，secret就是用来进行JWT的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret，那就意味着客户端是可以自我签发jwt了。</p>
<p>4、案例演示</p>
<p>显示了一个登录请求成功之后服务端返回的Token，它由编码头部（header）、编码有效载荷（payload）和签名（signature）通过（.）拼接而成：</p>
<p>如果需要，你可以使用jwt.io的Debugger工具，来编码、验证和生成JWT。操作界面如下：</p>
<h2 id="八、jwt的工作原理"> 八、JWT的工作原理</h2>
<p>在身份验证中，当用户使用他们的凭证（如用户名、密码）成功登录时，后台服务器将返回一个token，前端接收到这个token将其保存在本地（通常在本地存储中，也可以使用Cookie，但不是传统方法中创建会话，服务器并返回一个cookie）。下次用户想要访问受保护的路由或资源时，就将本地保存的token放在头部Header中发送到后台服务器。服务器接收到请求，检查头部中token的存在，如果存在就允许访问受保护的路由或资源，否则就不允许。如下所示：</p>
<p>一般默认的Value是以“<code>Bearer</code> ”开始，注意这里的<code>Bearer</code>之后有一个空格，以便后端进行分割。</p>
<p>这是一种无状态身份验证机制，因为用户状态永远不会保存在服务器内存中。由于JWT是独立的，所有必要的信息都在那里，所以减少了多次查询数据库的需求。</p>
<h2 id="九、总结"> 九、总结</h2>
<p>1、优点</p>
<ul>
<li>（1）因为Json的通用性，所以JWT 是可以进行跨语言支持的，像Java、JavaScript、NodeJS、PHP等很多语言都可以使用。</li>
<li>（2）因为有了payload部分，所以JWT 可以在自身存储一些其他业务逻辑所必要的非敏感信息。</li>
<li>（3）便于传输，JWT 的构成非常简单，字节占用很小，所以它是非常便于传输的。</li>
<li>（4）它不需要在服务端保存会话信息, 所以它易于应用的扩展</li>
</ul>
<p>2、安全相关</p>
<ul>
<li>（1）不应该在JWT的payload 部分存放敏感信息，因为该部分是客户端可解密的部分。</li>
<li>（2）保护好secret私钥，该私钥非常重要。</li>
<li>（3）如果可以，请使用HTTPS 协议，不！是务必使用HTTPS!</li>
</ul>
]]></content>
    <author>
      <name>徐刘根</name>
    </author>
    <contributor>
      <name>徐刘根</name>
    </contributor>
    <published>2022-03-24T03:51:02.000Z</published>
    <rights>Copyright by 徐刘根</rights>
  </entry>
  <entry>
    <title type="html">fubuhi transaction</title>
    <id>http://www.zhangsj.xyz/blog/java/soa/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</id>
    <link href="http://www.zhangsj.xyz/blog/java/soa/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <updated>2022-04-11T06:31:58.000Z</updated>
    <content type="html"><![CDATA[<p>解决跨库操作的数据一致性问题：</p>
<p>在分布式或者微服务架构中，每个服务都有自己的数据源，使用不同事务管理器，如果A服务去调用B服务，B服务执行失败了，A服务的事务和B服务的事务都会回滚，这时候是不存在事务问题的，但是如果A服务B服务执行成功之后出现异常，A服务的事原子性务会回滚，但是B服务的事务不会回滚，此时就存在分布式事务问题。</p>
<h2 id="使用场景"> 使用场景：</h2>
<ul>
<li>转账：包含转出和转入操作</li>
<li>网购：包含下单、扣减库存、支付操</li>
</ul>
<h3 id="事务的4个特性acid"> 事务的4个特性ACID</h3>
<p>原子性（Atomicity）：操作这些指令时，要么全部执行成功，要么全部不执行。只要其中一个指令执行失败，所有的指令都执行失败，数据进行回滚，回到执行指令前的数据状态。</p>
<p>一致性（Consistency）<i>Not supported content</i>：事务的执行使数据从一个状态转换为另一个状态，数据库的完整性约束没有被破坏。</p>
<blockquote>
<p>拿转账来说，假设用户A和用户B 两者的钱加起来一共是2000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是2000，这就是事务的一致性。</p>
</blockquote>
<p>隔离性（Isolation）<i>Not supported content</i>：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>
<blockquote>
<p>即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p>
</blockquote>
<p>持久性（Durability）：当事务正确完成后，它对于数据的改变是永久性的。不会轻易丢失</p>
<div><pre><code><span>begin</span> <span>transaction</span>； 
<span>// 本地数据库操作：张三减少金额 </span>
<span>// 本地数据库操作：李四增加金额 </span>
<span>commit</span> transation<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>随着互联网的快速发展，软件系统由原来的单体应用转变为分布式应用，下图描述了单体应用向微服务的演变：分布式系统会把一个应用系统拆分为可独立部署的多个服务，因此需要服务与服务之间远程协作才能完成事务操 作，这种分布式系统环境下由不同的服务之间通过网络远程协作完成事务称之为分布式事务，例如用户注册送积分 事务、创建订单减库存事务，银行转账事务等都是分布式事务。</p>
<p>典型的场景就是微服务架构 微服务之间通过远程调用完成事务操作。 比如：订单微服务和库存微服务，下单的 同时订单微服务请求库存微服务减库存。 简言之：跨JVM进程产生分布式事务。</p>
<div><pre><code><span>begin</span> <span>transaction</span>；
<span>//1.本地数据库操作：张三减少金额</span>
<span>//2.远程调用：让李四增加金额 </span>
<span>commit</span> transation<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="cap定理"> CAP定理</h3>
<p>CAP原则指的是在一个分布式系统中，不可能同时满足以下三点。</p>
<p>一致性（Consistency）<i>Not supported content</i></p>
<p>指强一致性，在写操作完成后开始的任何读操作都必须返回该值，或者后续写操作的结果。</p>
<p>可用性（Availability）<i>Not supported content</i>：</p>
<p>可用性是指，每次向未崩溃的节点发送请求，总能保证收到响应数据（允许不是最新数据）</p>
<p>分区容忍性（Partition tolerance）<i>Not supported content</i>：分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务,，也就是说，服务器A和B发送给对方的任何消息都是可以放弃的，也就是说A和B可能因为各种意外情况，导致无法成功进行同步，分布式系统要能容忍这种情况。除非整个网络环境都发生了故障。</p>
<ol>
<li>使用MQ</li>
<li>使用Seata</li>
</ol>
<p>CP  满足原子和分区容错，也就是说，要放弃可用。当系统被分区，为了保证原子性，必须放弃可用性，让服务停用。
AP 满足可用性和分区容错，当出现分区，同时为了保证可用性，必须让节点继续对外服务，这样必然导致失去原子性。</p>
<h3 id="一致性"> 一致性 <i>Not supported content</i></h3>
<p>一致性可以分为强一致性与弱一致性。所谓强一致性，即复制是同步的，弱一致性，即复制是异步的。</p>
<p>ap 不是完全放弃数据一致性，而是牺牲强一致性换取弱一致性。</p>
<h2 id="seata"> seata</h2>
<ul>
<li>TC (Transaction Coordinator) - 事务协调者
维护全局和分支事务的状态，驱动全局事务提交或回滚；</li>
<li>TM (Transaction Manager) - 事务管理器
定义全局事务的范围：开始全局事务、提交或回滚全局事务；</li>
<li>RM (Resource Manager) - 资源管理器
管理分支事务处理的资源，与TC交互以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚；</li>
</ul>
<p>Seata是阿里巴巴退出的一款用来解决分布式事务问题的框架，他经过天猫双十一的考验，很有可能成为解决分布式事务问题的主流框架</p>
<p>4、Seata分布式事务框架实现原理？</p>
<p>Seata有三个组成部分：事务协调器TC：协调者、事务管理器TM：发起方、资源管理器RM：参与方</p>
<ol>
<li>发起方会向协调者申请一个全局事务id ，并保存到ThreadLocal中（为什么要保存到ThreadLocal中？弱引用，线程之间不会发生数据冲突）</li>
<li>Seata 数据源代理发起方和参与方的数据源，将前置镜像和后置镜像写入到undo_log表中，方便后期回滚使用</li>
<li>发起方获取全局事务id，通过改写Feign客户端请求头传入全局事务id。</li>
<li>参与方从请求头中获取全局事务id保存到ThreadLocal中，并把该分支注册到SeataServer中。</li>
<li>如果没有出现异常，发起方会通知协调者，协调者通知所有分支，通过全局事务id和本地事务id删除undo_log数据，如果出现异常，通过undo_log逆向生成sql语句并执行，然后删除undo_log语句。如果处理业务逻辑代码超时，也会回滚</li>
</ol>
<h2 id="at事务模式"> AT事务模式</h2>
<p>分布式事务工作机制</p>
<p>前提： 基于支持本地 ACID 事务的关系型数据库；（mysql、oracle）</p>
<p>Java 应用，通过JDBC访问数据库；</p>
<p>整体机制就是两阶段提交协议的演变：</p>
<p>一阶段： “业务数据“和“回滚日志记录“在同一个本地事务中提交，释放本地锁和连接资源；</p>
<p>二阶段： 如果没有异常异步化提交，非常快速地完成； 如果有异常回滚通过一阶段的回滚日志进行反向补偿；</p>
<p>具体举例说明整个AT分支的工作过程：</p>
<h2 id="saga事务模式"> saga事务模式</h2>
<p>又称为Long-running-transaction(长事务)，核心思想是把一个长事务分为多个本地事务来完成，由一个<code>Process Manager</code> 统一协调。如果成功，则继续往下执行，如果失败，则调用补偿操作。</p>
<p>每个业务都至少需要实现正向、反向两个接口。</p>
<p>我们看如下一个业务场景。在购买旅游套餐业务操作涉及到三个操作，他们分别是预定车辆，预定宾馆，预定机票，他们分别属于三个不同的远程接口。可能从我们程序的角度来说他们不属于一个事务，但是从业务角度来说是属于同一个事务的。</p>
<p><img src="./assets/20220413/分布式事务-1649804696250.png" alt="saga案例" loading="lazy"></p>
<p>他们的执行顺序如上图所示，所以当发生失败时，会依次进行取消的补偿操作。</p>
<p>因为长事务被拆分了很多个业务流，所以 Saga 事务模型最重要的一个部件就是流程管理器(Process Manager)。</p>
<p>在执行到第3步时，发生了失败，回退的过程也比较复杂，特别是子业务比较多的场景。</p>
<p>如何实现数据的一致性呢？如下罗列了一些方案。</p>
<ol>
<li>如果失败，可以发生消息到MQ，消费者根据状态，去重试，或者执行回退操作。同时，也可以进一步检查数据的一致性。</li>
<li>建立一个定时任务去检查数据的完整性，如果第3步失败了，定时任务会检测到并修复数据。</li>
<li>本地操作日志或DB日志。</li>
</ol>
<h2 id="tcc事务模型"> TCC事务模型</h2>
<p>TCC(Try Confirm Cancel)事务模型的思想和2PC提交有点类似。下图是TCC和2PC(XA)的对比。</p>
<p><img src="./assets/20220413/分布式事务-1649805216922.png" alt="TCC实物模型的思想和2PC提交比较" loading="lazy"></p>
<ol>
<li>在阶段一：XA模型中，各个RM准备提交各自的事务分支，事实上就是准备提交资源的更新操作（insert、delete、update等），而在TCC中，是主业务活动请求(try)各个从业务服务检查和预留资源。</li>
<li>阶段二：2PC（XA）根据第一阶段每个RM是否都prepare成功，判断是要提交还是回滚。如果都prepare成功，那么就commit每个事务分支，反之则rollback每个事务分支。</li>
<li>TCC中，如果在第一阶段所有业务资源都预留成功，那么confirm各个从业务服务，否则取消(cancel)所有从业务服务的资源预留请求。</li>
</ol>
<p>TCC两阶段提交与2PC/XA两阶段提交的区别是：</p>
<ul>
<li>2PC是资源层面的分布式事务，强一致性，在两阶段提交的整个过程中，一直会持有资源的锁。</li>
<li>TCC是业务层面的分布式事务，最终一致性，不会一直持有资源的锁。</li>
</ul>
<p>是目前最火的一种柔性事务方案，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作</p>
<p>所谓的 TCC 编程模式，也是两阶段提交的一个变种，不同的是 TCC 为在业务层编写代码实现的两阶段提交。</p>
<h3 id="注意事项"> 注意事项：</h3>
<p>最常见的主要是这三种异常，分别是空回滚、幂等、悬挂。</p>
<p>1、允许空回滚：</p>
<p>事务协调器在调用TCC服务的一阶段TRY操作时，可能会出现因为丢包而导致的网络超时，此时事务协调器会触发二阶段回滚，调用TCC服务的CANCEL操作；</p>
<p>TCC服务在未收到TRY请求的情况下受到CANCEL请求，这种场景被称为空回滚；TCC服务在实现时应当允许空回滚的执行。</p>
<p>那怎么解决空回滚呢？前面提到，Cancel 要识别出空回滚，直接返回成功。那关键就是要识别出这个空回滚。**思路很简单就是需要知道一阶段是否执行，如果执行了，那就是正常回滚；**如果没执行，那就是空回滚。因此，需要一张额外的事务控制表，其中有分布式事务 ID 和分支事务 ID，第一阶段 Try 方法里会插入一条记录，表示一阶段执行了。Cancel 接口里读取该记录，如果该记录存在，则正常回滚；如果该记录不存在，则是空回滚。</p>
<p>3、防悬挂控制</p>
<p>事务协调器在调用TCC服务的一阶段TRY操作时，可能会出现网络拥堵而导致的超时，此时事务协调器会触发二阶段回滚，调用TCC服务的CANCEL操作；在此之后，拥堵在网络上的一阶段TRY数据包被TCC服务收到，出现了二阶段CanCEL请求比一阶段TRY请求先执行的情况。</p>
<p>用户在实现TCC服务时，应该允许空回滚，但是要拒绝执行空回滚之后到来的一阶段TRY请求；</p>
<p>大家是否想到了刚才解决空回滚和幂等时用到的事务控制表，可以在二阶段执行时插入一条事务控制记录，状态为已回滚，这样当一阶段执行时，先读取该记录，如果记录存在，就认为二阶段已经执行；否则二阶段没执行。</p>
<p>4、幂等控制</p>
<p>无论是网络数据包重传，还是异常事务的补偿执行；用户在实现TCC，需要考虑幂等控制，即TRY、CONFIRM、CANCEL执行一次和执行多次的业务结果是一样的；</p>
<p>接下来是幂等。幂等就是对于同一个分布式事务的同一个分支事务，重复去调用该分支事务的第二阶段接口，因此，要求 TCC 的二阶段 Confirm 和 Cancel 接口保证幂等，不会重复使用或者释放资源。如果幂等控制没有做好，很有可能导致资损等严重问题。</p>
<p>什么样的情形会造成重复提交或回滚？从图中可以看到，提交或回滚是一次 TC 到参与者的网络调用。因此，网络故障、参与者宕机等都有可能造成参与者 TCC 资源实际执行了二阶段防范，但是 TC 没有收到返回结果的情况，这时，TC 就会重复调用，直至调用成功，整个分布式事务结束。</p>
<p>TCC 分别指 Try、Confirm、Cancel ，一个业务操作要对应的写这三个方法。</p>
<p>第一阶段</p>
<p>Try（尝试）：</p>
<p>完成所有业务检查(一致性)
预留必须业务资源(准隔离性)</p>
<p>第二阶段</p>
<p>本阶段根据第一阶段的结果，决定是执行confirm还是cancel</p>
<p>Confirm（确认）：</p>
<ul>
<li>执行真正的业务执行业务</li>
<li>不做任何业务检查</li>
<li>只使用Try阶段预留的业务资源</li>
<li>释放Try阶段预留的业务资源</li>
</ul>
<p>Cancle（取消）</p>
<ul>
<li>释放Try阶段预留的业务资源</li>
</ul>
<p>以下单扣库存为例，</p>
<ul>
<li>Try 阶段去占库存（资源的检测与预留）；</li>
<li>Confirm 阶段则实际扣库存（执行的业务操作提交）；</li>
<li>如果库存扣减失败 Cancel 阶段进行回滚，释放库存（预留资源释放）；</li>
</ul>
<h3 id="一个完整的tcc事务参与方包括三部分"> 一个完整的TCC事务参与方包括三部分：</h3>
<ul>
<li>发起方</li>
<li>参与方：服务必须实现Try、Confirm 和Cancel三个接口，供发起方服务调用，由于Confirm和Cancel操作可能被重复调用，故要求Confirm和Cancel两个接口必须是幂等的。</li>
<li>tc：记录维护TCC全局事务的事务状态和每个从业务服务的子事务状态，并在业务活动提交时确认所有的TCC型操作的confirm操作，在业务活动取消时调用所有TCC型操作的cancel操作。</li>
</ul>
<p>并发控制 ➢允许空回滚 ➢防悬挂控制 ➢幂等控制</p>
<p>TCC 不存在资源阻塞的问题，因为每个方法都直接进行事务的提交，一旦出现异常通过则 Cancel 来进行回滚补偿，这也就是常说的补偿性事务。</p>
<p>原本一个方法，现在却需要三个方法来支持，可以看到 TCC 对业务的侵入性很强，而且这种模式并不能很好地被复用，会导致开发量激增。还要考虑到网络波动等原因，</p>
<p>为保证请求一定送达都会有重试机制，所以考虑到接口的幂等性。</p>
<h3 id="tcc-案例"> tcc 案例</h3>
<p>账务拆分的业务场景如下，分别位于三个不同分库的帐户A、B、C，A和B一起向C转帐共80元：</p>
<p>1、Try：尝试执行业务。</p>
<p>完成所有业务检查(一致性)：检查A、B、C的帐户状态是否正常，帐户A的余额是否不少于30元，帐户B的余额是否不少于50元。</p>
<p>预留必须业务资源(准隔离性)：帐户A的冻结金额增加30元，帐户B的冻结金额增加50元，这样就保证不会出现其他并发进程扣减了这两个帐户的余额而导致在后续的真正转帐操作过程中，帐户A和B的可用余额不够的情况。</p>
<p>2、Confirm：确认执行业务。</p>
<p>真正执行业务：如果Try阶段帐户A、B、C状态正常，且帐户A、B余额够用，则执行帐户A给账户C转账30元、帐户B给账户C转账50元的转帐操作。</p>
<p>不做任何业务检查：这时已经不需要做业务检查，Try阶段已经完成了业务检查。</p>
<p>只使用Try阶段预留的业务资源：只需要使用Try阶段帐户A和帐户B冻结的金额即可。</p>
<p>3、Cancel：取消执行业务</p>
<p>释放Try阶段预留的业务资源：如果Try阶段部分成功，比如帐户A的余额够用，且冻结相应金额成功，帐户B的余额不够而冻结失败，则需要对帐户A做Cancel操作，将帐户A被冻结的金额解冻掉。</p>
<p><a href="https://gitee.com/SHIJINGSPACE/seata-tcc-main" target="_blank" rel="noopener noreferrer">实例代码</a></p>
<h3 id="一个稳定的、高可用的、扩展性强的tcc事务管理器-seata"> 一个稳定的、高可用的、扩展性强的TCC事务管理器（seata）</h3>
<h3 id="tcc事务的优点和限制"> TCC事务的优点和限制</h3>
<p>解决了跨应用业务操作的原子性问题，在诸如组合支付、账务拆分场景非常实用。</p>
<p>TCC实际上把数据库层的二阶段提交上提到了应用层来实现，对于数据库来说是一阶段提交，规避了数据库层的2PC性能低下问题。</p>
<p>TCC事务的缺点，主要就一个：</p>
<p>TCC的Try、Confirm和Cancel操作功能需业务提供，开发成本高。</p>
<p>当然，对TCC事务的这个缺点是否是缺点，是一个见仁见智的事情。</p>
<h2 id="基于消息的分布式事务"> 基于消息的分布式事务</h2>
<p>基于消息的分布式事务与上面的方案很不同，适合执行周期长且实时性要求不高的场景。</p>
<p>基于消息的分布式事务是指当发起方执行完本地事务后并发出一条消息，参与方一定能够接收消息并处理事务成功，此方案强调的是只要消息发给参与方最终事务要达到一致。</p>
<p>一般使用消息中间件完成。</p>
<p>事务发起方（消息生产方）将消息发给消息中间件，事务参与方从消息中间件接收消息，事务发起方和消息中间件之间，事务参与方（消息消费方）和消息中间件之间都是通过网络通信。</p>
<p>发起方将消息发给消息中间件，参与方从消息中间件接收消息，发起方和消息中间件之间，参与方和消息中间件之间都是通过网络通信。</p>
<p>本地事务与消息发送的原子性问题</p>
<ul>
<li>保证数据库操作与发送消息的一致性，不会出现只有一个成功，另一个不成功的情况</li>
<li>事务参与方接收消息的可靠性</li>
<li>事务参与方必须能够从消息队列接收到消息，如果接收消息失败可以重复接收消息</li>
<li>消息重复消费的问题</li>
</ul>
<p>由于网络的存在，若某一个消费节点超时但是消费成功，此时消息中间件会重复投递此消息，就导致了消息的重复消费</p>
<p>RocketMQ 事务消息设计则主要是为了解决发起方的消息发送与本地事务执行的原子性问题，</p>
<p>RocketMQ 的设计中 broker 与提供者的双向通信能力，使得 broker 天生可以作为一个事务协调者存在；而 RocketMQ 本身提供的存储机制为事务消息提供了持久化能力；</p>
<p>RocketMQ 的高可用机制以及可靠消息设计则为事务消息在系统发生异常时依然能够保证达成事务的最终一致性。</p>
<p>发起方发消息到mq，mq 将消息状态标记为prepared，这条消息消费者无法消费到。</p>
<p>mq接受到发起方发送的消息回应发送成功</p>
<p>发起方执行本地业务代码； 本地事务执行成功，向mq发送commit消息，mq 接受到commit 消息把状态置为可消费，此时消费者（参与方）正常消费消息 参与方本地事务执行失败，向mq发送rollback 消息，mq接收到rollback 消息删除消息 参与方消费消息成功向mq回应ack 确认消费消息成功，否则重复接收，这里ack默认自动回应。 如果参与者执行本地事务时，宕机或超时，mq 会不停询问同组的其他消费者来获取事务执行状态。mq 会根据会回查结构来确定是否投递消息；</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="分布式"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2021-10-21T00:00:00.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">为什么分布式要有分布式锁！</title>
    <id>http://www.zhangsj.xyz/blog/java/soa/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <link href="http://www.zhangsj.xyz/blog/java/soa/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <updated>2022-04-11T06:31:58.000Z</updated>
    <content type="html"><![CDATA[<h1 id="为什么分布式要有分布式锁"> 为什么分布式要有分布式锁！</h1>
<p>目前网上大部分的基于ZOOKEEPER，和REDIS的分布式锁的文章都不够全面。要么就是特意避开集群的情况，要么就是考虑不全，堵着看着还是一脸迷茫。坦白说，这种老题材，很难写出新创意，博主内心战战兢兢，如履薄冰，文中有什么不严谨之处，欢迎批评。</p>
<p>博主的这篇文章，不上代码，只讲分析。</p>
<p>1、在REDIS方面，有开源REDISSION的JAR包供你使用。
2、在ZOOKEEPER方面，有开源的CURATOR的JAR包供你使用。</p>
<p>因为已经有开源JAR供你使用，没有必要去自己封装一个，大家出门百度一个API即可，不需要再罗列一堆实现代码。</p>
<p>需要说明的是，Google有一个名为CHUBBY的粗粒度分布式锁的服务，然而，Google chubb并不是开源的，我们只能通过其论文和其他相关的文档中了解具体的细节。值得庆幸的是，YAHOO！借鉴CHUBBY的设计思想开发了ZOOKEEPER，并将其开源，因此本文不讨论CHUBBY。至于TAIR，是阿里开源的一个分布式KV存储方案。我们在工作中基本上REDIS是用的比较多，讨论TAIR所实现的分布式锁，不具有代表性。</p>
<p>因此，主要分析的还是REDIS和ZOOKEEPER所实现的分布式锁。</p>
<p>文档的目录结构如下：</p>
<p>1、为什么使用分布式锁
2、单机情形比较。
3、集群情形比较；
4、锁的其它特性比较；</p>
<p>为什么使用分布式锁？</p>
<p>使用分布式锁的目的，无外乎就是保证同一时间只有一个客户端可以对共享资源进行操作。</p>
<p>但是MARTIN指出，根据锁的用途还可以细分为以下两类：</p>
<p>1、允许多个客户端操作共享资源</p>
<p>这种情况下，对共享资源的操作一定是幂等性操作，无论你操作多少次都不会出现不同结果。在这里使用锁，无外乎就是避免重复操作共享资源从而提高效率。</p>
<p>2、 只允许一个客户端操作共享资源</p>
<p>这种情况下，对共享资源的操作一般是非幂等性操作。在这种情况下，如果出现多个客户端操作共享资源，就可能意味着数据不一致，数据丢失。</p>
<h2 id="第一回合-单机情形比较"> 第一回合，单机情形比较</h2>
<p>1、redis</p>
<p>先说加锁，根据REDIS官网文档的描述，是所有下面的命令加锁：</p>
<div><pre><code><span>set</span> resource_name my_random_value NX PX <span>30000</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>my_random_value是由客户端生成的一个随机字符串，相当于客户端持有锁的标志</li>
<li>NX表示只有当resource_name对应的KEY值不存在的时候才能SET成功，相当于只有第一个请求的客户端才能获得锁</li>
<li>PX 30000表示这个锁有一个三十秒的自动过期时间。</li>
</ul>
<p>至于解锁，为了防止客户端A获得的锁被客户端B释放，采用下面的LUA脚本来释放锁</p>
<div><pre><code><span>if</span> redis<span>.</span><span>call</span><span>(</span><span>"get"</span><span>,</span>KEY<span>[</span><span>1</span><span>]</span> <span>==</span> ARGV<span>[</span><span>1</span><span>]</span> then
        <span>return</span> redis<span>.</span><span>call</span><span>(</span><span>"del"</span><span>,</span>KEYS<span>[</span><span>1</span><span>]</span><span>)</span>
    <span>)</span>
<span>else</span>
    <span>return</span> <span>0</span>
end
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>在执行这段LUA脚本的时候，KEYS[1]的值为resource_name，ARGV[1]的值为my_random_value。原理就是先获取所对应的VALUE值，保证和客户端穿进去的my_random_value值相等，这样就能避免自己的所被其他人释放。另外，采取LUA脚本操作保证了原子性。</p>
<p>过期时间如果设置。如果客户端在操作共享资源的过程中，因为长期阻塞的原因，导致锁过期，那么接下来访问共享资源就不安全。</p>
<p>可是，有的人会说</p>
<blockquote>
<p>那可以在客户端操作完共享资源后，判断锁是否依然归该客户端所有，如果依然归客户端所有，则提交资源，释放锁。若不归客户端所有，则不提交资源。</p>
</blockquote>
<p>这么做，只能降低多个客户端操作共享资源发生的概率，并不能解决问题</p>
<h2 id="第二回合-集群情形比较"> 第二回合，集群情形比较：</h2>
<p>我们在生产中，一般都是用集群情形，所以第一回合讨论的单机情形。算是给大家热热身。</p>
<p>1、Redis</p>
<p>为了Redis的高可用，一般都会给REDIS的节点挂一个SLAVE，然后采用哨兵模式进行主备切换。但由于REDIS的主从复制是异步的，这可能会出现在数据同步过程中，master宕机，slave来不及同步数据就被选为MASTER，从而数据丢失。具体流程如下所示：</p>
<ol>
<li>客户端A从MASTER获取了锁。</li>
<li>MASTER宕机了，存储锁的KEY还没有来得及同步到SLAVE上。</li>
<li>SLAVE升级为MASTER。</li>
<li>客户端B从新的MASTER获取到了对应的同一个资源的锁</li>
</ol>
<p>为了应对这个情形，REDIS的作者antirez提出了REDLOCK算法，步骤如下：</p>
<p>假设我们有N个MASTER节点</p>
<ol>
<li>获取当前时间（单位是毫秒）。</li>
<li>轮流用相同的KEY和随机值在N个节点上清求索，在这一步里，客户端在每个master上请求锁时，会有一个和总得锁释放时间相比小得多的超时时间。比如如果锁自动释放时间是十秒钟，那每个节点所请求的超时时间可能是5~50毫秒的范围，这个可以防止一个客户端在某个宕掉的MASTER节点上阻塞过长时间，如果一个MASTER节点不可用了，我们应该尽快尝试下一个MASTER节点。</li>
<li>客户端计算第二步中获取锁所花的时间，只有当客户端在大多数MASTER节点上成功获取了锁（在这里是三个），而且总共消耗的时间不超过锁释放时间，这个锁就认为是获取成功了。</li>
</ol>
<h2 id="redis-实现分布式锁"> Redis 实现分布式锁</h2>
<p>分布式锁要满足的条件：</p>
<ul>
<li>多进程互斥：同一时刻，只有一个进程可以获取锁</li>
<li>保证锁可以释放：任务结束或出现异常，锁一定要释放，避免死锁</li>
<li>阻塞锁(可选)：获取锁失败时可否重试</li>
<li>重入锁(可选)：获取锁的代码递归调用时，依然可以获取锁</li>
</ul>
<h3 id="最基本的分布式锁"> 最基本的分布式锁</h3>
<p>利用 Redis 的 setnx 命令，这个命令的特征时如果多次执行，只有第一次执行会成功，可以实现<code>互斥</code>的效果。为了保证服务宕机时也可以释放锁，同时需要利用 expire 命令给锁设置一个有效期</p>
<div><pre><code>setnx lock thread-01 # 尝试获取锁
expire lock 10 # 设置有效期
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="释放锁的时候-保证持有锁的线程释放锁"> 释放锁的时候，保证持有锁的线程释放锁</h3>
<p>在锁中存储当前进程和线程标识，释放锁时对锁的标识判断，如果是自己的则删除，不是则放弃操作。</p>
<p>但是这两步操作要保证原子性，需要通过 Lua 脚本来实现。</p>
<div><pre><code>if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then
    redis.call(&quot;del&quot;,KEYS[1])
end
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="可重入分布式锁"> 可重入分布式锁</h3>
<p>如果有重入的需求，则除了在锁中记录进程标识，还要记录重试次数，流程如下：</p>
<p>下面我们假设锁的 key 为“<code>lock</code>”，hashKey 是当前线程的 id：“<code>threadId</code>”，锁自动释放时间假设为 20</p>
<p>获取锁的步骤：</p>
<ul>
<li>1、判断 lock 是否存在 <code>EXISTS lock</code>
<ul>
<li>存在，说明有人获取锁了，下面判断是不是自己的锁</li>
<li>判断当前线程 ID 作为 hashKey 是否存在：<code>HEXISTS lock threadId</code></li>
<li>不存在，说明锁已经有了，且不是自己获取的，锁获取失败，end</li>
<li>存在，说明是自己获取的锁，重入次数+1：<code>HINCRBY lock threadId 1</code>，去到步骤 3</li>
</ul>
</li>
<li>2、不存在，说明可以获取锁，<code>HSET key threadId 1</code></li>
<li>3、设置锁自动释放时间，<code>EXPIRE lock 20</code></li>
</ul>
<p>释放锁的步骤：</p>
<ul>
<li>1、判断当前线程 ID 作为 hashKey 是否存在：<code>HEXISTS lock threadId</code>
<ul>
<li>不存在，说明锁已经失效，不用管了</li>
<li>存在，说明锁还在，重入次数减 1：<code>HINCRBY lock threadId -1</code>，获取新的重入次数</li>
</ul>
</li>
<li>2、判断重入次数是否为 0：
<ul>
<li>为 0，说明锁全部释放，删除 key：<code>DEL lock</code></li>
<li>大于 0，说明锁还在使用，重置有效时间：<code>EXPIRE lock 20</code></li>
</ul>
</li>
</ul>
<p>对应的 Lua 脚本如下：</p>
<p>首先是获取锁：</p>
<div><pre><code><span>local</span> key <span>=</span> KEYS<span>[</span><span>1</span><span>]</span><span>;</span> <span>-- 锁的key</span>
<span>local</span> threadId <span>=</span> ARGV<span>[</span><span>1</span><span>]</span><span>;</span> <span>-- 线程唯一标识</span>
<span>local</span> releaseTime <span>=</span> ARGV<span>[</span><span>2</span><span>]</span><span>;</span> <span>-- 锁的自动释放时间</span>

<span>if</span><span>(</span>redis<span>.</span><span>call</span><span>(</span><span>'exists'</span><span>,</span> key<span>)</span> <span>==</span> <span>0</span><span>)</span> <span>then</span> <span>-- 判断是否存在</span>
 redis<span>.</span><span>call</span><span>(</span><span>'hset'</span><span>,</span> key<span>,</span> threadId<span>,</span> <span>'1'</span><span>)</span><span>;</span> <span>-- 不存在, 获取锁</span>
 redis<span>.</span><span>call</span><span>(</span><span>'expire'</span><span>,</span> key<span>,</span> releaseTime<span>)</span><span>;</span> <span>-- 设置有效期</span>
 <span>return</span> <span>1</span><span>;</span> <span>-- 返回结果</span>
<span>end</span><span>;</span>

<span>if</span><span>(</span>redis<span>.</span><span>call</span><span>(</span><span>'hexists'</span><span>,</span> key<span>,</span> threadId<span>)</span> <span>==</span> <span>1</span><span>)</span> <span>then</span> <span>-- 锁已经存在，判断threadId是否是自己</span>
 redis<span>.</span><span>call</span><span>(</span><span>'hincrby'</span><span>,</span> key<span>,</span> threadId<span>,</span> <span>'1'</span><span>)</span><span>;</span> <span>-- 不存在, 获取锁，重入次数+1</span>
 redis<span>.</span><span>call</span><span>(</span><span>'expire'</span><span>,</span> key<span>,</span> releaseTime<span>)</span><span>;</span> <span>-- 设置有效期</span>
 <span>return</span> <span>1</span><span>;</span> <span>-- 返回结果</span>
<span>end</span><span>;</span>
<span>return</span> <span>0</span><span>;</span> <span>-- 代码走到这里,说明获取锁的不是自己，获取锁失败</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>然后是释放锁：</p>
<div><pre><code><span>local</span> key <span>=</span> KEYS<span>[</span><span>1</span><span>]</span><span>;</span> <span>-- 锁的key</span>
<span>local</span> threadId <span>=</span> ARGV<span>[</span><span>1</span><span>]</span><span>;</span> <span>-- 线程唯一标识</span>
<span>local</span> releaseTime <span>=</span> ARGV<span>[</span><span>2</span><span>]</span><span>;</span> <span>-- 锁的自动释放时间</span>

<span>if</span> <span>(</span>redis<span>.</span><span>call</span><span>(</span><span>'HEXISTS'</span><span>,</span> key<span>,</span> threadId<span>)</span> <span>==</span> <span>0</span><span>)</span> <span>then</span> <span>-- 判断当前锁是否还是被自己持有</span>
    <span>return</span> <span>nil</span><span>;</span> <span>-- 如果已经不是自己，则直接返回</span>
<span>end</span><span>;</span>
<span>local</span> count <span>=</span> redis<span>.</span><span>call</span><span>(</span><span>'HINCRBY'</span><span>,</span> key<span>,</span> threadId<span>,</span> <span>-</span><span>1</span><span>)</span><span>;</span> <span>-- 是自己的锁，则重入次数-1</span>

<span>if</span> <span>(</span>count <span>></span> <span>0</span><span>)</span> <span>then</span> <span>-- 判断是否重入次数是否已经为0</span>
    redis<span>.</span><span>call</span><span>(</span><span>'EXPIRE'</span><span>,</span> key<span>,</span> releaseTime<span>)</span><span>;</span> <span>-- 大于0说明不能释放锁，重置有效期然后返回</span>
    <span>return</span> <span>nil</span><span>;</span>
<span>else</span>
    redis<span>.</span><span>call</span><span>(</span><span>'DEL'</span><span>,</span> key<span>)</span><span>;</span> <span>-- 等于0说明可以释放锁，直接删除</span>
    <span>return</span> <span>nil</span><span>;</span>
<span>end</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div>]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-04-11T06:31:58.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">spring mulu</title>
    <id>http://www.zhangsj.xyz/blog/java/spring/</id>
    <link href="http://www.zhangsj.xyz/blog/java/spring/"/>
    <updated>2022-02-26T14:37:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="java目录"> java目录</h2>
<ul>
<li><a href="spring">三级缓存</a></li>
<li><a href="springboot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B">自动装配</a></li>
<li><a href="spring%E4%BA%8B%E5%8A%A1">事务</a></li>
</ul>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="mulu"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-26T14:37:30.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">3jicache&amp;mvc</title>
    <id>http://www.zhangsj.xyz/blog/java/spring/spring/</id>
    <link href="http://www.zhangsj.xyz/blog/java/spring/spring/"/>
    <updated>2022-02-28T02:15:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="spring-mvc-工作原理"> spring mvc 工作原理</h2>
<p>其中核心类是 <code>DispatcherServlet</code>，它是一个 Servlet，顶层是实现的Servlet接口。</p>
<p>客户端发送请求-&gt;
前端控制器 <code>DispatcherServlet</code> 接受客户端请求 -&gt;
找到处理器映射 <code>HandlerMapping</code> 解析请求对应的 Handler-&gt;
<code>HandlerAdapter</code> 会根据 Handler 来调用真正的处理器开处理请求，并处理相应的业务逻辑 -&gt;
处理器返回一个模型视图 ModelAndView -&gt;
视图解析器进行解析 -&gt;
返回一个视图对象（jsp、freemarker、pdf...）-&gt;
前端控制器 DispatcherServlet 渲染数据（Moder）-&gt;
将得到视图对象返回给用户</p>
<h2 id="三级缓存"> 三级缓存</h2>
<p>Spring在启动过程中，使用到了三个map，称为三级缓存。</p>
<div><pre><code><span>public</span> <span>class</span> <span>DefaultSingletonBeanRegistry</span> <span>extends</span> <span>SimpleAliasRegistry</span> <span>implements</span> <span>SingletonBeanRegistry</span> <span>{</span>

	<span>/** Cache of singleton objects: bean name --> bean instance */</span>
	<span>private</span> <span>final</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> singletonObjects <span>=</span> <span>new</span> <span>ConcurrentHashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>256</span><span>)</span><span>;</span>

	<span>/** Cache of singleton factories: bean name --> ObjectFactory */</span>
	<span>private</span> <span>final</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>ObjectFactory</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> singletonFactories <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>16</span><span>)</span><span>;</span>

	<span>/** Cache of early singleton objects: bean name --> bean instance */</span>
	<span>private</span> <span>final</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> earlySingletonObjects <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>16</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>Spring启动过程大致如下：</p>
<ol>
<li>创建beanFactory，加载配置文件</li>
<li>解析配置文件转化beanDefination，获取到bean的所有属性、依赖及初始化用到的各类处理器等</li>
<li>刷新beanFactory容器，初始化所有单例bean</li>
<li>注册所有的单例bean并返回可用的容器，一般为扩展的applicationContext</li>
</ol>
<h3 id="一级缓存"> 一级缓存</h3>
<p>在第三步中，所有单例的bean初始化完成后会存放在一个Map(singletonObjects)中，beanName为key，单例bean为value。</p>
<p>第三步单例bean的初始化过程大致如下：</p>
<ol start="0">
<li>标记bean为创建中</li>
<li>new出bean对象</li>
<li>如果支持循环依赖则生成三级缓存，可以提前暴露bean</li>
<li>填充bean属性，解决属性依赖</li>
<li>初始化bean，处理Aware接口并执行各类bean后处理器，执行初始化方法，如果需要生成aop代理对象</li>
<li>如果存在循环依赖，解决之 – 这里有点问题，这一步是如果之前解决了aop循环依赖，则缓存中放置了提前生成的代理对象，然后使用原始bean继续执行初始化，所以需要再返回最终bean前，把原始bean置换为代理对象返回。</li>
<li>此时bean已经可以被使用，进行bean注册(标记)并注册销毁方法。</li>
<li>将bean放入容器中(一级缓存)，移除创建中标记及二三级缓存(后面再具体分析)</li>
</ol>
<h3 id="循环依赖及三级缓存"> 循环依赖及三级缓存</h3>
<p>根据以上步骤可以看出bean初始化是一个相当复杂的过程，假如初始化A bean时，发现A bean依赖B bean,即A初始化执行到了第3步填充属性，需要注入B bean，此时B还没有初始化，则需要暂停A，先去初始化B，那么此时new出来的A对象放哪里，直接放在容器Map里显然不合适，半残品怎么能用，所以需要提供一个可以标记创建中bean(A)的Map，可以提前暴露正在创建的bean供其他bean依赖，而如果初始化A所依赖的bean B时，发现B也需要注入一个A的依赖(即发生循环依赖)，则B可以从创建中的beanMap中直接获取A对象（创建中）注入A，然后完成B的初始化，返回给正在注入属性的A，最终A也完成初始化，皆大欢喜。</p>
<p>如果配置不允许循环依赖，则上述缓存就用不到了，A 依赖B，就是创建B，B依赖C就去创建C，创建完了逐级返回就行，所以，一级缓存之后的其他缓存(二三级缓存)就是为了解决循环依赖！而配置支持循环依赖后，就一定要解决循环依赖吗？肯定不是！循环依赖在实际应用中也有，但不会太多，简单的应用场景是： controller注入service，service注入mapper，只有复杂的业务，可能service互相引用，有可能出现循环依赖，所以为了出现循环依赖才去解决，不出现就不解决，虽然支持循环依赖，但是只有在出现循环依赖时才真正暴露早期对象，否则只暴露个获取bean的方法，并没有真正暴露bean，因为这个方法不会被执行到，这块的实现就是三级缓存（singletonFactories），只缓存了一个单例bean工厂。</p>
<p>这个bean工厂不仅可以暴露早期bean还可以暴露代理bean，如果存在aop代理，则依赖的应该是代理对象，而不是原始的bean。而暴露原始bean是在单例bean初始化的第2步，填充属性第3步，生成代理对象第4步，这就矛盾了，A依赖到B并去解决B依赖时，要去初始化B，然后B又回来依赖A，而此时A还没有执行代理的过程，所以，需要在填充属性前就生成A的代理并暴露出去，第2步时机就刚刚好。</p>
<p>三级缓存的bean工厂getObject方式，实际执行的是getEarlyBeanReference，如果对象需要被代理(存在beanPostProcessors -&gt; SmartInstantiationAwareBeanPostProcessor)，则提前生成代理对象。</p>
<h3 id="二级缓存"> 二级缓存</h3>
<p>三级缓存已经解决所有问题了，二级缓存用来做什么呢？为什么三级缓存不直接叫做二级缓存?这个应该是在缓存使用时决定的：</p>
<p>三级缓存中提到出现循环依赖才去解决，也就是说出现循环依赖时，才会执行工厂的getObject生成(获取)早期依赖，这个时候就需要给它挪个窝了，因为真正暴露的不是工厂，而是对象，所以需要使用一个新的缓存保存暴露的早期对象(earlySingletonObjects)，同时移除提前暴露的工厂，也不需要在多重循环依赖时每次去执行getObject(虽然个人觉得不会出问题，因为代理对象不会重复生成，详细可以了解下代理里面的逻辑，如wrapIfNecessary)。</p>
<div><p>总结</p>
<p>经过分析可以看到：</p>
<ol>
<li>不支持循环依赖情况下，只有一级缓存生效，二三级缓存用不到</li>
<li>二三级缓存就是为了解决循环依赖，且之所以是二三级缓存而不是二级缓存，主要是可以解决循环依赖对象需要提前被aop代理，以及如果没有循环依赖，早期的bean也不会真正暴露，不用提前执行代理过程，也不用重复执行代理过程。</li>
</ol>
</div>
<h2 id="自动装配"> 自动装配</h2>
<h3 id="spring中bean注入的三种形式"> spring中bean注入的三种形式</h3>
<ol>
<li>setter注入</li>
<li>构造器注入</li>
<li>属性注入</li>
</ol>
<h3 id="spring的两种配置方式"> Spring的两种配置方式</h3>
<ol>
<li>基于XML的配置</li>
<li>基于JavaConfig类的配置方式</li>
</ol>
<h3 id="springbootconfiguration注解"> @SpringBootConfiguration注解</h3>
<p>复合注解,主要的有以下三个：</p>
<ul>
<li>@SpringBootConfiguration</li>
<li>@EnableAutoConfiguration</li>
<li>@ComponentScan</li>
</ul>
<p><strong>@SpringBootConfiguration</strong></p>
<p>这个注解之后会发现，原来该注解是@Configuration，一个JavaConfig配置类</p>
<p><strong>@ComponentScan</strong></p>
<p>组件扫描，这个扫描的范围是：SpringBoot主启动类的同级路径及子路径</p>
<p><strong>@EnableAutoConfiguration</strong></p>
<p>进入注解，发现@Import({AutoConfigurationImportSelector.class}) 导入了 AutoConfigurationImportSelector 这个类的bean定义，</p>
<p>返回的是要加载的Config配置文件的全包名</p>
<p>META-INF/spring.factories</p>
<p>spring boot自动装配的依赖jar包：</p>
<p>注解默认加载124个配置类</p>
<p>帮我们加载了各种已经写好的Config类文件，实现了这些JavaConfig配置文件的重复利用和组件化</p>
<div><p>总结</p>
<p>SpringBoot自动装配的本质就是通过Spring去读取META-INF/spring.factories中保存的配置类文件然后加载bean定义的过程。</p>
<p>如果是标了@Configuration注解，就是批量加载了里面的bean定义</p>
<p>如何实现”自动“：通过配置文件获取对应的批量配置类，然后通过配置类批量加载bean定义，只要有写好的配置文件spring.factories就实现了自动。</p>
</div>
<div><pre><code><span>@Target</span><span>(</span><span>{</span><span>ElementType</span><span>.</span>TYPE<span>}</span><span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>@Documented</span>
<span>@Inherited</span>
<span>@AutoConfigurationPackage</span>
<span>@Import</span><span>(</span><span>{</span><span>AutoConfigurationImportSelector</span><span>.</span><span>class</span><span>}</span><span>)</span>
<span>public</span> <span>@interface</span> <span>EnableAutoConfiguration</span> <span>{</span>
    <span>String</span> ENABLED_OVERRIDE_PROPERTY <span>=</span> <span>"spring.boot.enableautoconfiguration"</span><span>;</span>

    <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span><span>]</span> <span>exclude</span><span>(</span><span>)</span> <span>default</span> <span>{</span><span>}</span><span>;</span>

    <span>String</span><span>[</span><span>]</span> <span>excludeName</span><span>(</span><span>)</span> <span>default</span> <span>{</span><span>}</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>Spring Boot 在启动的时候从类路径下的 META-INF/spring.factories 保存配置类的路径</p>
<p>中获取 EnableAutoConfiguration 指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作。以前我们需要自己配置的东西，自动配置类都帮我们完成了。</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="spring"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-01-30T09:23:34.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">RequestBody&amp;ResponseBody</title>
    <id>http://www.zhangsj.xyz/blog/java/spring/@RequestBody%E5%92%8C&amp;ResponseBody/</id>
    <link href="http://www.zhangsj.xyz/blog/java/spring/@RequestBody%E5%92%8C&amp;ResponseBody/"/>
    <updated>2022-03-01T05:15:03.000Z</updated>
    <content type="html"><![CDATA[<h2 id="content-type"> Content-Type</h2>
<h3 id="application-x-www-form-urlencoded"> application/x-www-form-urlencoded</h3>
<p>application/x-www-form-urlencoded主要用于表单形式的POST请求中，如普通的表单提交，或者js发包，默认都是通过这种方式，可以使用Postman来发一个这种类型请求：</p>
<p>用get提交，和post提交是一样的，数据格式都是这样，get和post的区别是，get显示地址栏中，post提交是不显示的，相对于get来说，post这种提交方式更加安全</p>
<h3 id="multipart-form-data"> multipart/form-data</h3>
<p>multipart/form-data是使用POST请求上传文件，如果上传照片，文件等，由于很多情况下都会有批量上传，为了区分不同的数据，multipart/form-data的类型有boundary参数进行分割，对上传文件请求抓包，request头部信息如下：</p>
<p>此时的数据格式是json格式：</p>
<p>a=123&amp;b=123&amp;c=123</p>
<p>用get提交，和post提交是一样的，数据格式都是这样，get和post的区别是，get显示地址栏中，post提交是不显示的，相对于get来说，post这种提交方式更加安全</p>
<p>如果说是 a=123&amp;b=123&amp;c=123这种格式的话。，spring会自动的去转成对象的格式</p>
<h3 id="application-json"> application/json</h3>
<p>application/json是POST请求以JSON的格式向服务请求发起请求或者请求返回JSON格式的响应内容，服务端接受到数据后对JSON进行解析拿到所需要的参数，同样适用Postman模拟一个请求：</p>
<p>此时的数据格式是json格式：</p>
<p>{“a”，“b”，“c”，“d”}。</p>
<p>那么这种格式的话，Spring就无法自动转化为对象，那么如何解决呢？ 就会自动将json数据转化为对象（实体类）</p>
<h2 id="requestbody"> @RequestBody</h2>
<p>@RequestBody的作用是将前端传来的json格式的数据转为自己定义好的javabean对象</p>
<p>@RequestBody要写在方法的参数前</p>
<p>如图以微信小程序为例，前端向后端传入如下json格式的</p>
<p>传入数据的属性名称要和后端javabean中定义的一致</p>
<h2 id="responsebody"> @ResponseBody</h2>
<p>@ResponseBody的作用是将后端以return返回的javabean类型数据转为json格式数据输出到HTTP响应中</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="spring"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2019-06-23T00:00:00.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">autowire</title>
    <id>http://www.zhangsj.xyz/blog/java/spring/springboot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</id>
    <link href="http://www.zhangsj.xyz/blog/java/spring/springboot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <updated>2022-02-26T14:37:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="boot-flow"> boot flow</h2>
<h2 id="自动装配流程"> 自动装配流程</h2>
<p>里面有一个 main 方法运行了一个 run()方法，在 run 方法中必须要传入一个被@SpringBootApplication 注解的类。</p>
<p>@SpringBootApplication
SpringBoot 应用标注在某个类上说明这个类是 SpringBoot 的主配置类，SpringBoot 就会运行这个类的 main 方法来启动 SpringBoot 项目。</p>
<p>那@SpringBootApplication 注解到底是什么呢，点进去看看：</p>
<p>发现@@SpringBootApplication 是一个组合注解。</p>
<h2 id="springbootconfiguration"> @SpringBootConfiguration</h2>
<p>先看看@SpringBootConfiguration 注解：</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="spring"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2021-10-21T00:00:00.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">spring中常用的设计模式达到九种，我们举例说明。</title>
    <id>http://www.zhangsj.xyz/blog/java/spring/%E6%9D%A5%E7%BB%99%E6%88%91%E8%AF%B4%E4%B8%80%E4%B8%8B%20Spring%20%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <link href="http://www.zhangsj.xyz/blog/java/spring/%E6%9D%A5%E7%BB%99%E6%88%91%E8%AF%B4%E4%B8%80%E4%B8%8B%20Spring%20%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <updated>2022-04-08T00:53:08.000Z</updated>
    <content type="html"><![CDATA[<h2 id="spring中常用的设计模式达到九种-我们举例说明。"> spring中常用的设计模式达到九种，我们举例说明。</h2>
<h3 id="_1、简单工厂模式"> 1、简单工厂模式</h3>
<p>又叫做静态工厂方法（StaticFactory Method）模式，但不属于23种GOF设计模式之一。</p>
<p>GoF（Gang of Four），中文名——四人组。 《Design Patterns: Elements of Reusable Object-Oriented Software》（即后述《设计模式》一书）</p>
<p>简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。</p>
<p>spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。如下配置，就是在 HelloItxx 类中创建一个 itxxBean。</p>
<div><pre><code><span><span><span>&lt;</span>beans</span><span>></span></span>
  <span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>"</span>singletonBean<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>com.itxxz.HelloItxxz<span>"</span></span><span>></span></span>
     <span><span><span>&lt;</span>constructor-arg</span><span>></span></span>
       <span><span><span>&lt;</span>value</span><span>></span></span>Hello ! 这是singletonBean!<span><span><span>&lt;</span>value</span><span>></span></span>
     <span><span><span>&lt;/</span>constructor-arg</span><span>></span></span>
 &lt;/ bean>
 <span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>"</span>itxxzBean<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>com.itxxz.HelloItxxz<span>"</span></span>  <span>singleton</span><span><span>=</span><span>"</span>false<span>"</span></span><span>></span></span>
   <span><span><span>&lt;</span>constructor-arg</span><span>></span></span>
       <span><span><span>&lt;</span>value</span><span>></span></span>Hello! 这是itxxzBean! value>
   <span><span><span>&lt;/</span>constructor-arg</span><span>></span></span>
 <span><span><span>&lt;/</span>bean</span><span>></span></span>
<span><span><span>&lt;/</span>beans</span><span>></span></span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="_2、工厂方法模式"> 2、工厂方法模式</h3>
<p>通常由应用程序直接使用new创建新的对象，，为了将对象的创建和使用相分离，采用工厂模式,即应用程序将对象的创建及初始化职责交给工厂对象。</p>
<p>一般情况下,应用程序有自己的工厂对象来创建bean.如果将应用程序自己的工厂对象交给Spring管理,那么Spring管理的就不是普通的bean,而是工厂Bean。</p>
<p>就以工厂方法中的静态方法为例讲解一下：</p>
<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Random</span><span>;</span>
<span>public</span> <span>class</span> <span>StaticFactoryBean</span> <span>{</span>
 <span>public</span> <span>static</span> <span>Integer</span> <span>createRandom</span><span>(</span><span>)</span> <span>{</span>
      <span>return</span> <span>new</span> <span>Integer</span><span>(</span><span>new</span> <span>Random</span><span>(</span><span>)</span><span>.</span><span>nextInt</span><span>(</span><span>)</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>建一个config.xm配置文件，将其纳入Spring容器来管理,需要通过factory-method指定静态方法名称：</p>
<div><pre><code><span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>"</span>random<span>"</span></span>
<span>class</span><span><span>=</span><span>"</span>example.chapter3.StaticFactoryBean<span>"</span></span> <span>factory-method</span><span><span>=</span><span>"</span>createRandom<span>"</span></span>
<span>scope</span><span><span>=</span><span>"</span>prototype<span>"</span></span>
<span>/></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>测试：</p>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>//调用getBean()时,返回随机数.如果没有指定factory-method,会返回StaticFactoryBean的实例,即返回工厂Bean的实例      </span>
    <span>XmlBeanFactory</span> factory <span>=</span> <span>new</span> <span>XmlBeanFactory</span><span>(</span><span>new</span> <span>ClassPathResource</span><span>(</span><span>"config.xml"</span><span>)</span><span>)</span><span>;</span>      
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"我是IT学习者创建的实例:"</span><span>+</span>factory<span>.</span><span>getBean</span><span>(</span><span>"random"</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="_3、单例模式"> 3、单例模式</h3>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p>spring中的单例模式完成了后半句话，即提供了全局的访问点<code>BeanFactory</code>。但没有从构造器级别去控制单例，这是因为spring管理的是是任意的java对象。</p>
<p>核心提示点：Spring下默认的bean均为singleton，可以通过singleton=“true|false” 或者 scope=&quot;?&quot;来指定。</p>
<h3 id="_4、适配器模式"> 4、适配器模式</h3>
<p>在Spring的Aop（Aspect Oriented Program）中，使用的<code>Advice</code>（通知）来增强被代理类的功能。Spring 实现这一AOP功能的原理就使用代理模式（1、JDK动态代理。2、CGLib字节码生成技术代理。）对类进行方法级别的切面增强，即，生成被代理类的代理类， 并在代理类的方法前，设置拦截器，通过执行拦截器中的内容增强了代理方法的功能，实现的面向切面编程。</p>
<p><code>Adapter</code>类接口：<code>Target</code></p>
<div><pre><code><span>public</span> <span>interface</span> <span>AdvisorAdapter</span> <span>{</span>

    <span>boolean</span> <span>supportsAdvice</span><span>(</span><span>Advice</span> advice<span>)</span><span>;</span>

    <span>MethodInterceptor</span> <span>getInterceptor</span><span>(</span><span>Advisor</span> advisor<span>)</span><span>;</span>

<span>}</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><code>MethodBeforeAdviceAdapter</code>类，Adapter</p>
<div><pre><code><span>class</span> <span>MethodBeforeAdviceAdapter</span> <span>implements</span> <span>AdvisorAdapter</span><span>,</span> <span>Serializable</span> <span>{</span>

     <span>public</span> <span>boolean</span> <span>supportsAdvice</span><span>(</span><span>Advice</span> advice<span>)</span> <span>{</span>
           <span>return</span> <span>(</span>advice <span>instanceof</span> <span>MethodBeforeAdvice</span><span>)</span><span>;</span>
     <span>}</span>

     <span>public</span> <span>MethodInterceptor</span> <span>getInterceptor</span><span>(</span><span>Advisor</span> advisor<span>)</span> <span>{</span>
        <span>MethodBeforeAdvice</span> advice <span>=</span> <span>(</span><span>MethodBeforeAdvice</span><span>)</span> advisor<span>.</span><span>getAdvice</span><span>(</span><span>)</span><span>;</span>
        <span>return</span> <span>new</span> <span>MethodBeforeAdviceInterceptor</span><span>(</span>advice<span>)</span><span>;</span>
     <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="_5、包装器模式"> 5、包装器模式</h3>
<p>在我们的项目中遇到这样一个问题：我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。我们以往在spring和hibernate框架中总是配置一个数据源，因而<code>sessionFactory</code>的<code>dataSource</code>属性总是指向这个数据源并且恒定不变，所有DAO在使用<code>sessionFactory</code>的时候都是通过这个数据源访问数据库。</p>
<p>但是现在，由于项目的需要，我们的DAO在访问<code>sessionFactory</code>的时候都不得不在多个数据源中不断切换，问题就出现了：如何让<code>sessionFactory</code>在执行数据持久化的时候，根据客户的需求能够动态切换不同的数据源？我们能不能在spring的框架下通过少量修改得到解决？是否有什么设计模式可以利用呢？</p>
<p>首先想到在spring的<code>applicationContext</code>中配置所有的<code>dataSource</code>。这些dataSource可能是各种不同类型的，比如不同的数据库：Oracle、SQL Server、MySQL等，也可能是不同的数据源：比如<code>apache</code> 提供的<code>org.apache.commons.dbcp.BasicDataSource</code>、<code>spring</code>提供的<code>org.springframework.jndi.JndiObjectFactoryBean</code>等。然后<code>sessionFactory</code>根据客户的每次请求，将<code>dataSource</code>属性设置成不同的数据源，以到达切换数据源的目的。</p>
<p>spring中用到的包装器模式在类名上有两种表现：一种是类名中含有<code>Wrapper</code>，另一种是类名中含有Decorator。基本上都是动态地给一个对象添加一些额外的职责。</p>
<p>decorator	英[ˈdekəreɪtə(r)] 美[ˈdekəreɪtər] n.	室内装修设计师; (房屋的)油漆匠，裱糊匠;</p>
<h3 id="_6、代理模式"> 6、代理模式</h3>
<p>为其他对象提供一种代理以控制对这个对象的访问。  从结构上来看和<code>Decorator</code>模式类似，但<code>Proxy</code>是控制，更像是一种对功能的限制，而Decorator是增加职责。</p>
<p>spring的<code>Proxy</code>模式在aop中有体现，比如JdkDynamicAopProxy和Cglib2AopProxy。</p>
<p>proxy	英[ˈprɒksi] 美[ˈprɑːksi] n.	代理; 代理人; 代表; 代理权; 代表权; 受托人; (测算用的)代替物; 指标;</p>
<h3 id="_7、观察者模式"> 7、观察者模式</h3>
<p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<p>spring中<code>Observer</code>模式常用的地方是<code>listener</code>的实现。如<code>ApplicationListener</code>。</p>
<p>observer	英[əbˈzɜːvə(r)] 美[əbˈzɜːrvər] n.	观察者; 观察员; 观察家; 观测者; 目击者; 旁听者; 评论员;</p>
<h3 id="_8、策略模式"> 8、策略模式</h3>
<p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</p>
<p>spring中在实例化对象的时候用到Strategy模式</p>
<p>在<code>SimpleInstantiationStrategy</code>中有如下代码说明了策略模式的使用情况：</p>
<p>strategy	英[ˈstrætədʒi] 美[ˈstrætədʒi] n.	策略; 计策; 行动计划; 策划; 规划; 部署; 统筹安排; 战略; 战略部署;</p>
<h3 id="_9、模板方法模式"> 9、模板方法模式</h3>
<p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。<code>Template Method</code>使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p><code>Template Method</code>模式一般是需要继承的。这里想要探讨另一种对<code>Template Method</code>的理解。spring中的<code>JdbcTemplate</code>，在用这个类时并不想去继承这个类，因为这个类的方法太多，但是我们还是想用到<code>JdbcTemplate</code>已有的稳定的、公用的数据库连接，那么我们怎么办呢？我们可以把变化的东西抽出来作为一个参数传入<code>JdbcTemplate</code>的方法中。但是变化的东西是一段代码，而且这段代码会用到<code>JdbcTemplate</code>中的变量。怎么办？那我们就用回调对象吧。</p>
<p>在这个回调对象中定义一个操纵<code>JdbcTemplate</code>中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到JdbcTemplate，从而完成了调用。这可能是<code>Template Method</code>不需要继承的另一种实现方式。</p>
<p>一个具体的例子： JdbcTemplate中的<code>execute</code>方法</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-04-08T00:53:08.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">transaction</title>
    <id>http://www.zhangsj.xyz/blog/java/spring/spring%E4%BA%8B%E5%8A%A1/</id>
    <link href="http://www.zhangsj.xyz/blog/java/spring/spring%E4%BA%8B%E5%8A%A1/"/>
    <updated>2022-02-26T14:37:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="spring-事务"> spring 事务</h2>
<p>Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring 是无法提供事务功能的。对于纯 JDBC 操作数据库，想要用到事务，可以按照以下步骤进行：</p>
<h3 id="事务传播行为"> 事务传播行为</h3>
<p>spring特有的事务传播行为，spring支持7种事务传播行为，确定客户端和被调用端的事务边界 （说得通俗一点就是多个具有事务控制的service的相互调用时所形成的复杂的事务边界控制）下图所示为7钟事务传播机制</p>
<ol>
<li>获取连接 Connection con = DriverManager.getConnection()</li>
<li>开启事务 con.setAutoCommit(true/false);</li>
<li>执行 CRUD</li>
<li>提交事务/回滚事务 con.commit() / con.rollback();</li>
<li>关闭连接 conn.close();</li>
</ol>
<p>使用 Spring 的事务管理功能后，我们可以不再写步骤 2 和 4 的代码，而是由 Spirng 自动完成。那么 Spring 是如何在我们书写的 CRUD 之前和之后开启事务和关闭事务的呢？解决这个问题，也就可以从整体上理解 Spring 的事务管理实现原理了。</p>
<p>注解方式开启事务的步骤：</p>
<p>1、配置文件开启注解驱动，在相关的类和方法上通过注解@Transactional 标识。
2、spring 在启动的时候会去解析生成相关的 bean，这时候会查看拥有相关注解的类和方法，并且为这些类和方法生成代理，并根据@Transaction 的相关参数进行相关配置注入，这样就在代理中为我们把相关的事务处理掉了(开启正常提交事务，异常回滚事务)。
3、真正的数据库层的事务提交和回滚是通过 binlog 或者 redo log 实现的。</p>
<h2 id="spring-的事务机制"> Spring 的事务机制</h2>
<p>而 Spring 的事务机制是用统一的机制来处理不同数据访问技术的事务处理。</p>
<p>Spring 的事务机制提供了一个 <code>PlatformTransactionManager</code> 接口，不同的数据访问技术的事务使用不同的接口实现，</p>
<h3 id="aop-代理的两种实现"> AOP 代理的两种实现</h3>
<p>Jdk 是代理接口，私有方法必然不会存在在接口里，所以就不会被拦截到；</p>
<p>Cglib 是子类，private 的方法照样不会出现在子类里，也不能被拦截。</p>
<h2 id="spring-事务的传播属性"> Spring 事务的传播属性</h2>
<p>所谓 spring 事务的传播属性，就是定义在存在多个事务同时存在的时候，spring 应该如何处理这些事务的行为。这些属性在 TransactionDefinition 中定义，具体常量的解释见下表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">传播行为</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PROPAGATION_REQUIRED（XML文件中为REQUIRED)</td>
<td>表示当前方法必须在一个具有事务的上下文中运行，如有客户端有事务在进行，那么被调用端将在该事务中运行，否则的话重新开启一个事务。（如果被调用端发生异常，那么调用端和被调用端事务都将回滚）</td>
</tr>
<tr>
<td style="text-align:center">PROPAGATION_SUPPORTS(XML文件中为SUPPORTS）</td>
<td>表示当前方法不必需要具有一个事务上下文，但是如果有一个事务的话，它也可以在这个事务中运行</td>
</tr>
<tr>
<td style="text-align:center">PROPAGATION_MANDATORY(XML文件中为MANDATORY）</td>
<td>表示当前方法必须在一个事务中运行，如果没有事务，将抛出异常</td>
</tr>
<tr>
<td style="text-align:center">PROPAGATION_NESTED(XML文件中为NESTED)</td>
<td>表示如果当前方法正有一个事务在运行中，则该方法应该运行在一个嵌套事务中，被嵌套的事务可以独立于被封装的事务中进行提交或者回滚。如果封装事务存在，并且外层事务抛出异常回滚，那么内层事务必须回滚，反之，内层事务并不影响外层事务。如果封装事务不存在，则同PROPAGATION_REQUIRED的一样</td>
</tr>
<tr>
<td style="text-align:center">PROPAGATION_NEVER（XML文件中为NEVER)</td>
<td>表示当方法务不应该在一个事务中运行，如果存在一个事务，则抛出异常</td>
</tr>
<tr>
<td style="text-align:center">PROPAGATION_REQUIRES_NEW(XML文件中为REQUIRES_NEW）</td>
<td>表示当前方法必须运行在它自己的事务中。一个新的事务将启动，而且如果有一个现有的事务在运行的话，则这个方法将在运行期被挂起，直到新的事务提交或者回滚才恢复执行。</td>
</tr>
<tr>
<td style="text-align:center">PROPAGATION_NOT_SUPPORTED（XML文件中为NOT_SUPPORTED）</td>
<td>表示该方法不应该在一个事务中运行。如果有一个事务正在运行，他将在运行期被挂起，直到这个事务提交或者回滚才恢复执行</td>
</tr>
</tbody>
</table>
<p>所有的数据访问技术都有事务处理机制，这些技术提供了 API 用来开启事务、提交事务来完成数据操作，或者在发生错误的时候回滚数据。</p>
<h3 id="spring-声明式事务"> spring 声明式事务</h3>
<p><a href="./../basic/java的异常.html">Java检查型异常和非检查型异常</a></p>
<p>Spring 声明式事务管理默认对非检查型异常和运行时异常进行事务回滚，而对检查型异常则不进行回滚操作</p>
<h3 id="java-中抛异常后如何使事务回滚"> java 中抛异常后如何使事务回滚</h3>
<p>代码中 try……catch 抛出的 Exception 异常，属于检查型异常,Spring 的框架默认是不会进行回滚的。所以必须在 service 捕获异常，然后再次手动 throw 一个非检查型异常，这样事务方才起效.</p>
<p>首先方法名前面有：<code>@Transactional</code>，下面介绍三种使事务回滚的方式</p>
<ol>
<li>手动 throw 异常，让 aop 捕获异常再去回滚，并且在 service 上层(webservice 客户端，view 层 action)要继续捕获这个异常并处理</li>
</ol>
<div><pre><code><span>Try</span><span>{</span>undefined
    …………
<span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>undefined
    …………
    <span>Throw</span> <span>new</span> <span>RuntimeException</span><span>(</span>e<span>)</span><span>;</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ol start="2">
<li>通过注解参数改变默认的回滚方式 。</li>
</ol>
<p>在<code>@Transaction</code>注解中定义了 <code>noRollbackFor</code> 和 <code>RollbackFor</code> 来指定某种异常是否回滚。</p>
<p>使用例子：</p>
<p>@Transaction(noRollbackFor=RuntimeException.class)</p>
<p>@Transaction(RollbackFor=Exception.class)</p>
<p>所以上述的问题可以直接将@Transaction</p>
<p>添加回滚参数@Transaction(RollbackFor=Exception.class) ,这样就改变了默认的事务处理方式。</p>
<ol start="3">
<li>在 service 层方法的 catch 语句中增加：TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();语句，手动回滚，这样上层就无需去处理异常(现在项目的做法)</li>
</ol>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="spring"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2021-10-20T00:00:00.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">life expierence</title>
    <id>http://www.zhangsj.xyz/blog/note/60%E6%9D%A1%E6%9C%89%E5%90%8D%E7%9A%84%E5%8E%9F%E5%88%99%E4%B8%8E%E5%AE%9A%E7%90%86/</id>
    <link href="http://www.zhangsj.xyz/blog/note/60%E6%9D%A1%E6%9C%89%E5%90%8D%E7%9A%84%E5%8E%9F%E5%88%99%E4%B8%8E%E5%AE%9A%E7%90%86/"/>
    <updated>2022-03-24T05:27:46.000Z</updated>
    <content type="html"><![CDATA[<h2 id="_60-条有名的原则与定理"> 60 条有名的原则与定理</h2>
<p>1、蓝斯登原则：在你往上爬的时候，一定要保持梯子的整洁，否则你下来时可能会滑倒。</p>
<p>提出者：美国管理学家蓝斯登。</p>
<p>点评：进退有度，才不至进退维谷；宠辱皆忘，方可以宠辱不惊。</p>
<p>2、卢维斯定理：谦虚不是把自己想得很糟，而是完全不想自己。</p>
<p>提出者：美国心理学家卢维斯</p>
<p>点评：如果把自己想得太好，就很容易将别人想得很糟。</p>
<p>3、托利得定理：测验一个人的智力是否属于上乘，只看脑子里能否同时容纳两种相反的思想，而无碍于其处世行事。</p>
<p>提出者：法国社会心理学家托利得</p>
<p>点评：思可相反，得须相成。</p>
<p>4、刺猬理论：刺猬在天冷时彼此靠拢取暖，但保持一定距离，以免互相刺伤。</p>
<p>点评：保持亲密的重要方法，乃是保持适当的距离。</p>
<p>5、鲦鱼效应：鲦鱼因个体弱小而常常群居，并以强健者为自然首领。将一只稍强的鲦鱼脑后控制行为的部分割除后，此鱼便失去自制力，行动也发生紊乱，但其他鲦鱼却仍像从前一样盲目追随。</p>
<p>提出者：德国动物学家霍斯特</p>
<p>点评：1、下属的悲剧总是领导一手造成的。2、下属觉得最没劲的事，是他们跟着一位最差劲的领导。</p>
<p>6、雷鲍夫法则：在你着手建立合作和信任时要牢记我们语言中：</p>
<p>1.最重要的八个字是：我承认我犯过错误 2.最重要的七个字是：你干了一件好事 3.最重要的六个字是：你的看法如何 4.最重要的五个字是：咱们一起干 5.最重要的四个字是：不妨试试 6.最重要的三个字是：谢谢您 7.最重要的两个字是：咱们 8.最重要的一个字是：您</p>
<p>提出者：美国管理学家雷鲍夫</p>
<p>点评：1、最重要的四个字是：不妨试试；2、最重要的一个字是：您</p>
<p>7、洛伯定理：对于一个经理人来说，最要紧的不是你在场时的情况，而是你不在场时发生了什么。</p>
<p>提出者：美国管理学家洛伯</p>
<p>点评：如果只想让下属听你的，那么当你不在身边时他们就不知道应该听谁的了。</p>
<p>8、斯坦纳定理：在哪里说得愈少，在哪里听到的就愈多。</p>
<p>提出者：美国心理学家斯坦纳</p>
<p>点评：只有很好听取别人的，才能更好说出自己的。</p>
<p>9、费斯诺定理：人两只耳朵却只有一张嘴巴，这意味着人应该多听少讲。</p>
<p>提出者：英国联合航空公司总裁兼总经理费斯诺</p>
<p>点评：说得过多了，说的就会成为做的障碍。</p>
<p>10、牢骚效应：凡是公司中有对工作发牢骚的人，那家公司或老板一定比没有这种人或有这种人而把牢骚埋在肚子里公司要成功得多。</p>
<p>提出者：美国密歇根大学社会研究院</p>
<p>点评：1、牢骚是改变不合理现状的催化剂。2、牢骚虽不总是正确的，但认真对待牢骚却总是正确的。</p>
<p>11、避雷针效应：在高大建筑物顶端安装一个金属棒，用金属线与埋在地下的一块金属板连接起来，利用金属棒的尖端放电，使云层所带的电和地上的电逐渐中和，从而保护建筑物等避免雷击。</p>
<p>点评：善疏则通，能导必安</p>
<p>12、氨基酸组合效应：组成人体蛋白的八种氨基酸，只要有一种含量不足，其他七种就无法合成蛋白质。</p>
<p>点评：当缺一不可时，一就是一切。</p>
<p>13、米格-25 效应：前苏联研制的米格-25 喷气式战斗机的许多零部件与美国的相比都落后，但因设计者考虑了整体性能，故能在升降、速度、应急反应等方面成为当时世界一流。</p>
<p>点评：所谓最佳整体，乃是个体的最佳组合。</p>
<p>14、磨合效应：新组装的机器，通过一定时期的使用，把磨擦面上的加工痕迹磨光而变得更加密合。</p>
<p>点评：要想达到完整的契合，须双方都做出必要的割舍。</p>
<p>15、波特定理：当遭受许多批评时，下级往往只记住开头的一些，其余就不听了，因为他们忙于思索论据来反驳开头的批评。</p>
<p>提出者：英国行为学家波特
点评：总盯着下属的失误，是一个领导者的最大失误。</p>
<p>16、蓝斯登定律：跟一位朋友一起工作，远较在父亲之下工作有趣得多。</p>
<p>提出者：美国管理学家蓝斯登</p>
<p>点评：可敬不可亲，终难敬；有权没有威，常失权。</p>
<p>17、吉尔伯特法则：工作危机最确凿的信号，是没有人跟你说该怎样作。</p>
<p>提出者：英国人力培训专家吉尔伯特</p>
<p>点评：真正危险的事，是没人跟你谈危险。</p>
<p>18、权威暗示效应：一化学家称，他将测验一瓶臭气的传播速度，他打开瓶盖 15 秒后，前排学生即举手，称自己闻到臭气，而后排的人则陆续举手，纷纷称自己也已闻到，其实瓶中什么也没有。</p>
<p>点评：迷信则轻信，盲目必盲从。</p>
<p>19、奥尼尔定理：所有的政治都是地方的。</p>
<p>提出者：美国前众议院院长奥尼尔</p>
<p>点评：只有能切身体会到的，群众才认为那是真实的。</p>
<p>20、定位效应：社会心理学家曾作过一个试验：在召集会议时先让人们自由选择位子，之后到室外休息片刻再进入室内入座，如此五至六次，发现大多数人都选择他们第一次坐过的位子。</p>
<p>点评：凡是自己认定的，人们大都不想轻易改变它。</p>
<p>21、艾奇布恩定理：如果你遇见员工而不认得，或忘了他的名字，那你的公司就太大了点。</p>
<p>提出者：英国史蒂芬约瑟剧院导演亚伦艾奇布恩</p>
<p>点评：摊子一旦铺得过大，你就很难把它照顾周全。</p>
<p>22、吉格勒定理：除了生命本身，没有任何才能不需要后天的锻炼。</p>
<p>提出者：美国培训专家吉格吉格勒</p>
<p>点评：水无积无辽阔，人不养不成才。</p>
<p>23、犬獒效应：当年幼的藏犬长出牙齿并能撕咬时，主人就把它们放到一个没有食物和水的封闭环境里让这些幼犬自相撕咬，最后剩下一只活着的犬，这只犬称为獒。据说十只犬才能产生一只獒。</p>
<p>点评：困境是造就强者的学校。</p>
<p>24、近因效应：最近或最后的印象对人的认知有强烈的影响。</p>
<p>提出者：美国社会心理学家洛钦斯。</p>
<p>点评：结果往往会被视为过程的总结。</p>
<p>25、洒井法则：在招工时用尽浑身解数，使出各种方法，不如使自身成为一个好公司，这样人才自然而然会汇集而来。</p>
<p>提出者：日本企业管理顾问酒井正敬。</p>
<p>点评：不能吸引人才，已有的人才也留不住。</p>
<p>26、美即好效应：对一个外表英俊漂亮的人，人们很容易误认为他或她的其他方面也很不错。</p>
<p>提出者：美国心理学家丹尼尔麦克尼尔。</p>
<p>点评：印象一旦以情绪为基础，这一印象常会偏离事实。</p>
<p>27、奥格尔维法则：如果我们每个人都雇用比我们自己都更强的人，我们就能成为巨人公司。</p>
<p>提出者：美国奥格尔维马瑟公司总裁奥格尔维。</p>
<p>点评：如果你所用的人都比你差，那么他们就只能作出比你更差的事情。</p>
<p>28、皮尔卡丹定理：用人上一加一不等于二，搞不好等于零。</p>
<p>提出者：法国著名企业家皮尔卡丹。</p>
<p>点评：组合失当，常失整体优势，安排得宜，才成最佳配置。</p>
<p>29、马蝇效应：再懒惰的马，只要身上有马蝇叮咬，它也会精神抖擞，飞快奔跑。</p>
<p>点评：有正确的刺激，才会有正确的反应。</p>
<p>30、倒 u 形假说：当一个人处于轻度兴奋时，能把工作作得最好。当一个人一点儿兴奋都没有时，也就没有作好工作的动力了；相应地，当一个人处于极度兴奋时，随之而来的压力可能会使他完不成本该完成的工作。世界网坛名将贝克尔之所以被称为常胜将军，其秘诀之一即是在比赛中自始至终防止过度兴奋，而保持半兴奋状态。所以有人亦将倒 u 形假说称为贝克尔境界。</p>
<p>提出者：英国心理学家罗伯特耶基斯和多德林。</p>
<p>点评：1、激情过热，激情就会把理智烧光。2、热情中的冷静让人清醒，冷静中的热情使人执着。</p>
<p>31、特伯论断：在数字中找不到安全。</p>
<p>提出者：美国经济学家特伯。</p>
<p>点评：数字是死的，情况是活的。</p>
<p>32、摩斯科定理：你得到的第一个回答，不一定是最好的回答。</p>
<p>提出者：美国管理学家摩斯科。</p>
<p>点评：刨根得根，问底知底。</p>
<p>33、罗杰斯论断：成功的公司不会等待外界的影响来决定自己的命运，而是始终向前看。</p>
<p>提出者：美国 IBM 公司前总裁罗杰斯。</p>
<p>点评：只想随波逐流，难有理想彼岸。</p>
<p>34、萨盖定律：戴一块手表的人知道准确的时间，戴两块手表的人便不敢确定几点了。</p>
<p>提出者：英国心理学家萨盖。</p>
<p>点评：若选错误参照，必无正确比较。</p>
<p>35、隧道视野效应：一个人若身处隧道，他看到的就只是前后非常狭窄的视野。</p>
<p>点评：1、不拓心路，难开视野。2、视野不宽，脚下的路也会愈走愈窄。</p>
<p>36、巴菲特定律：在其他人都投了资的地方去投资，你是不会发财的。</p>
<p>提出者：美国股神巴菲特。</p>
<p>点评：1、善于走自己的路，才可望走别人没走过的路。2、特色不特，优势无优。</p>
<p>37、古特雷定理：每一处出口都是另一处的入口。</p>
<p>提出者：美国管理学家古特雷。</p>
<p>点评：上一个目标是下一个目标的基础，下一个目标是上一个目标的延续。</p>
<p>38、列文定理：那些犹豫着迟迟不能作出计划的人，通常是因为对自己的能力没有把握。</p>
<p>提出者：法国管理学家列文。</p>
<p>点评：如果没有能力去筹划，就只有时间去后悔了。</p>
<p>39、弗洛斯特法则：在筑墙之前应该知道把什么圈出去，把什么圈进来。</p>
<p>提出者：美国思想家弗洛斯特。</p>
<p>点评：开始就明确了界限，最终就不会作出超越界限的事来。</p>
<p>40、波克定理：只有在争辩中，才可能诞生最好的主意和最好的决定。</p>
<p>提出者：美国庄臣公司总经理詹姆士波克。</p>
<p>点评：无磨擦便无磨合，有争论才有高论。</p>
<p>41、韦奇定理：即使你已有了主见，但如果有十个朋友看法和你相反，你就很难不动摇。</p>
<p>提出者：美国洛杉矶加州大学经济学家伊渥韦奇。</p>
<p>点评：1、未听之时不应有成见，既听之后不可无主见。2、不怕开始众说纷纭，只怕最后莫衷一是。</p>
<p>42、福克兰定律：没有必要作出决定时，就有必要不作决定。</p>
<p>提出者：法国管理学家福克兰。</p>
<p>点评：当不知如何行动时，最好的行动就是不采取任何行动。</p>
<p>43、王安论断：犹豫不决固然可以免去一些作错事的机会，但也失去了成功的机遇。</p>
<p>提出者：美籍华裔企业家王安博士。</p>
<p>点评：寡断能使好事由好变坏，果断可将危机转危为安。</p>
<p>44、格瑞斯特定理：杰出的策略必须加上杰出的执行才能奏效。</p>
<p>提出者：美国企业家格瑞斯特。</p>
<p>点评：好事干实更好，实事办好愈实。</p>
<p>45、吉德林法则：</p>
<p>把难题清清楚楚地写出来，便已经解决了一半。</p>
<p>提出者：美国通用汽车公司管理顾问查尔斯吉德林。</p>
<p>点评：杂乱无章的思维，不可能产生有条有理的行动。</p>
<p>46、沃尔森法则：把信息和情报放在第一位，金钱就会滚滚而来。</p>
<p>提出者：美国企业家沃尔森。</p>
<p>点评：你能得到多少，往往取决于你能知道多少。</p>
<p>47、塔马拉效应：塔马拉是捷克雷达专家弗佩赫发明的一种雷达，它与其他雷达的最大不同是不发射信号而只接收信号，故不会被敌方反雷达装置发现。</p>
<p>点评：善藏者人不可知，能知者人无以藏。</p>
<p>48、小池定理：越是沉醉，就越是抓住眼前的东西不放。</p>
<p>提出者：日本管理学家小池敬。</p>
<p>点评：自我陶醉不易清醒，自以为是不喜批评。</p>
<p>49、赫勒法则：</p>
<p>当人们知道自己的工作成绩有人检查的时候会加倍努力。</p>
<p>提出者：英国管理学家赫勒。</p>
<p>点评：只有在相互信任的情况下，监督才会成为动力。</p>
<p>50 横山法则：最有效并持续不断的控制不是强制，而是触发个人内在的自发控制。</p>
<p>提出者：日本社会学家横山宁夫。</p>
<p>点评：有自觉性才有积极性，无自决权便无主动权</p>
<p>51、蝴蝶效应：紊乱学研究者称，南半球某地的一只蝴蝶偶尔扇动一下翅膀所引起的微弱气流，几星期后可变成席卷北半球某地的一场龙卷风。他们将这种由一个极小起因，经过一定的时间，在其他因素的参与作用下，发展成极为巨大和复杂后果的现象称为蝴蝶效应。</p>
<p>点评：善终者慎始，谨小者慎微。</p>
<p>52、阿什法则：承认问题是解决问题的第一步。</p>
<p>提出者：美国企业家阿什。</p>
<p>点评：你愈是躲着问题，问题愈会揪住你不放。</p>
<p>53、洛克忠告：规定应该少定，一旦定下之后，便得严格遵守。</p>
<p>提出者：英国教育家洛克。</p>
<p>点评：简则易循，严则必行。</p>
<p>54、热炉法则：当人用手去碰烧热的火炉时，就会受到烫的惩罚，其有以下三个特点：即时性、预警性、平等性。</p>
<p>点评：罪与罚能相符，法与治可相期。</p>
<p>55、柯美雅定律：世上没有十全十美的东西，所以任何东西都有改革的余地。</p>
<p>提出者：美国社会心理学家柯美雅。</p>
<p>点评：不拘于常规，才能激发出创造力。</p>
<p>56、达维多夫定律：没有创新精神的人永远也只能是一个执行者。</p>
<p>提出者：前苏联心理学家达维多夫</p>
<p>点评：只有敢为人先的人，才最有资格成为真正的先驱者。</p>
<p>57、自吃幼崽效应：美国硅谷企业竞争十分激烈，以至于各公司都积极寻找自己的致命弱点，所有公司共同的生存之道是：拿出更好看产品来击败自己的原有产品。有人将这种行为戏称为自吃幼崽。</p>
<p>点评：1、自己不逼自己，别人迟早会逼你。2、敢于对过去告一个段落，才有信心掀开新的一章。</p>
<p>58、舍恩定理：新思想只有落到真正相信它，对它着迷的人手里才能开花结果。</p>
<p>提出者：美国麻省理工学院教授舍恩。</p>
<p>点评：只有信之不疑，才能持之以恒。</p>
<p>59、吉宁定理：真正的错误是害怕犯错误。</p>
<p>提出者：美国管理学家吉宁。</p>
<p>点评：不怕错误的人，错误往往也离他最远。</p>
<p>60、卡贝定理：放弃是创新的钥匙。</p>
<p>提出者：美国电话电报公司前总经理卡贝。</p>
<p>点评：在未学会放弃之前，你将很难懂得什么是争取。</p>
<p><a href="https://blog.csdn.net/poem_qianmo/article/details/30025827?spm=1001.2014.3001.5501" target="_blank" rel="noopener noreferrer">reference</a></p>
<p>用 ctrl+r 进行内容替换，使用正则表达式，用^\s*\n 替换空即可</p>
<p>\s 包括空格、制表符、换页符等空白字符的其中任意一个
\r,\n 代表回车和换行符 *表达式不出现或出现任意次，相当于{0,}，</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="expierence"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-03-24T05:27:46.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">note</title>
    <id>http://www.zhangsj.xyz/blog/note/</id>
    <link href="http://www.zhangsj.xyz/blog/note/"/>
    <updated>2022-03-24T05:27:46.000Z</updated>
    <content type="html"><![CDATA[<h2 id="note"> note</h2>
<ul>
<li><a href="./docs/note/做一个有批判性思维的程序员！.html">做一个有批判性思维的程序员</a></li>
<li><a href="./docs/note/《阿里感悟》如何在三年内成长为一名技术专家.html">如何在三年内成长为一名技术专家</a></li>
<li><a href="./docs/note/60条有名的原则与定理.html">60条有名的原则与定理</a></li>
<li><a href="./docs/note/一个NullPointerException，竟然有这么多花样！.html">一个NullPointerException，竟然有这么多花样！</a></li>
<li><a href="./docs/note/还在使用SimpleDateFormat？你的项目崩没？.html">还在使用SimpleDateFormat？你的项目崩没？</a></li>
</ul>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="note"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-03-24T05:27:46.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">《阿里感悟》如何在三年内成长为一名技术专家</title>
    <id>http://www.zhangsj.xyz/blog/note/%E3%80%8A%E9%98%BF%E9%87%8C%E6%84%9F%E6%82%9F%E3%80%8B%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%89%E5%B9%B4%E5%86%85%E6%88%90%E9%95%BF%E4%B8%BA%E4%B8%80%E5%90%8D%E6%8A%80%E6%9C%AF%E4%B8%93%E5%AE%B6/</id>
    <link href="http://www.zhangsj.xyz/blog/note/%E3%80%8A%E9%98%BF%E9%87%8C%E6%84%9F%E6%82%9F%E3%80%8B%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%89%E5%B9%B4%E5%86%85%E6%88%90%E9%95%BF%E4%B8%BA%E4%B8%80%E5%90%8D%E6%8A%80%E6%9C%AF%E4%B8%93%E5%AE%B6/"/>
    <updated>2022-03-24T05:27:46.000Z</updated>
    <content type="html"><![CDATA[<p>工作前三年是职业生涯中成长最快的几年，在这段时间里你会充满激情，做事专注，也容易养成良好的习惯。</p>
<p>在我们公司有些同学在前三年中就快速成为某一个领域的技术专家，有些同学也可能止步不前。本文和大家一起探讨下如何在三年内快速成长为一名技术专家。</p>
<p>学习方法</p>
<p>1：掌握良好的学习心态
2：掌握系统化的学习方法
3：知识如何内化成能力
4：广度和深度的选择</p>
<p>实战技巧</p>
<p>1：你需要学会的编码习惯
2：在业务团队做开发如何成长</p>
<p>掌握良好的学习心态</p>
<p>空杯心态</p>
<h2 id="二、拒绝寻求帮助"> 二、拒绝寻求帮助</h2>
<p>这一条在学习和工作场景中都很常见。我们很多人都不寻求帮助。原因很多，但我认为最主要的原因无非是自尊以及害怕让人认为自己啥也不会。我们很多人都有冒名顶替综合征，觉得自己不完全胜任自己的工作。我在公司里、在和客户打交道时、甚至在上课和辅导中都有这种感觉。我们认为寻求帮助会强化这种感觉。但事实上，它浪费了大量时间，阻碍了你的成长。</p>
<p>其他真正的开发人员们都是视频或书籍一般的资源，甚至要比这些好太多。他们可以直接回答你的问题，帮助你真正的理解它。</p>
<p>只有混蛋才会因为你问问题而批评你，这时候我会尽力避开这些人。</p>
<p>如果你想要自己找到答案，不想寻求帮助，那也没问题，给自己一个时间限制。当你的前辈就在你旁边，他可能知道或至少可以帮到你的时候，千万不要浪费几天时间来寻找答案。</p>
<h2 id="四、混乱的代码"> 四、混乱的代码</h2>
<p>这一条更多地是一种技术习惯，但也可能意味着很多事情。你应当以一种直观、高效、安全的方式写代码。这在自学的时候简直太难了，因为在相关的课程中，你学到的不是写某些代码的最佳方法，而是导师认为这么写最容易理解一些核心概念。所以，你必须进行一些额外的研究，找出清理你代码的最佳方法。</p>
<p>我绝对建议你使用“避免重复代码原则”（DRY principle，don’t repeat yourself）。如果你遇到常见的代码块，那就创建某种“类”（class）或“函数”（function）来合并这部分功能，而不是仅仅重复它。这让代码更加简洁，节省了大量代码行，并且便于他人使用。</p>
<p>你也要注意性能，比如压缩图片、缩小JavaScript和CSS。你可以使用task runner（如gulp）或其他工具自动完成压缩，面对小型任务，你甚至可以使用minifier.org等手动完成。</p>
<p>另外，不要进行不必要的API接口调用，要使你的全栈应用程序以尽可能少的请求完成你需要的全部功能。以及测试……我在这上面犯了很多错，没有做足够的测试。就我所知，单元测试有助于搭建更健全的应用程序，避免潜在问题，节约时间和开销。但我就是很讨厌它，这可能是我最坏的习惯之一，也是我成为更好的开发人员需要解决的大问题。有时候我们回了节约时间减少测试，但在现实中，这样做会降低应用程序的性能、效率和可读性，而且与一开始就采用正确的方法相比，它可能在将来引起更大的麻烦。所以请记住这一点。</p>
<h2 id="六、糟糕的办公室政治"> 六、糟糕的办公室政治</h2>
<p>这一条是给那些在公司工作的人们的。你和其他人一起工作，但这反过来又会引起冲突、分歧、争论等等。许多开发人员十分傲慢，总认为自己是正确的，即使他们知道自己犯了错，他们中的一些人也永远不会承认。我不是说这是大多数开发人员，但我认为我们至少会遇到一位这样的人。我听很多人说，他们的团队非常棒，成员之间相处得非常融洽，这很好，但不是所有团队都是这样子。</p>
<ul>
<li>很多时候你们会在想法和解决方案上发生冲突，试着表现得老练和对对方的尊重，但同时，也不要太容易就被说服，尤其是当你对自己的提案非常有信心的时候。</li>
<li>不要大喊大叫，不要骂人，千万别做这些事情，这什么用也没有。</li>
<li>如果他们开始这样对待你，你就离开，做一个更强大的人。</li>
<li>如果你不幸遇到了一个十足混蛋的团队成员，他完全不听理由，你除了想办法避开他之外，别无他法。</li>
<li>在某些情况下，你可能不得不和你们的领导交谈，不过我还是建议你先和那个人谈谈。</li>
</ul>
<h2 id="九、做一个无所不知的人"> 九、做一个无所不知的人</h2>
<p>我之前提到过，我认为一些开发人员十分傲慢的原因是，他们认为自己无所不知。他们从不听其他人的意见，他们为啥要听呢？他们知道所有的答案。如果你周围全是这样的人，那真是糟透了，这对你也没好处，因为你也会认为自己无所不知，就会不积极学习、不改善自己。我敢打赌，总有一天你会被自己犯下的错误叫醒，这源于你不听取任何人的意见，也不自己进行调研。</p>
<p>这些人大多数都是 Stack Overflow 网站（一个IT技术问答网站）的魔鬼，他们取笑新开发人员的问题，嘲笑他人的回答，一有机会就点击“反对”。我讨厌死这些人了。我认为他们中的许多人在学校里就总是被人找茬，他们利用自己的知识欺负其他可能有问题或是没有所得的开发人员，看上去像是忘掉了被欺负的感受，只想要复仇。我这个理论可能有问题，只是一家之言。</p>
<p>无论他们出于什么原因这么做，我认为如果他们思想开放、欢迎不同的想法、尊重他人，那他们就会比总是想要“正确”的人快乐多了。他们可能是团队中最聪明的人，也是最糟糕的人，因为没人愿意和他们合作，无法进行良好的沟通。对于一个想要成功的团队来说，沟通和团结是必需的，而无所不知的人会破坏这些。所以，如果你是这样的人，试着别那么自负，开放一点，尊重一点，你会走得更远。</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="note"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2017-09-16T00:00:00.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">NullPointerException</title>
    <id>http://www.zhangsj.xyz/blog/note/%E4%B8%80%E4%B8%AANullPointerException%EF%BC%8C%E7%AB%9F%E7%84%B6%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E8%8A%B1%E6%A0%B7%EF%BC%81/</id>
    <link href="http://www.zhangsj.xyz/blog/note/%E4%B8%80%E4%B8%AANullPointerException%EF%BC%8C%E7%AB%9F%E7%84%B6%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E8%8A%B1%E6%A0%B7%EF%BC%81/"/>
    <updated>2022-03-24T05:27:46.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一个-nullpointerexception-竟然有这么多花样"> 一个 NullPointerException ，竟然有这么多花样！</h2>
<p>敢问各位大佬，在使用spring 的缓存注解@Cacheable 时，缓存配置的时redis，客户端Jedis ,生产时单点，线上是否碰到过随机的空指针异常，有spring的RedisCache在get时抛出的；</p>
<p>这里就涉及到一个重要的问题，那就是提问的艺术</p>
<p>比如说：我们常见的错误提问方式是：</p>
<p>你们有没有遇到过XXX问题？【X】</p>
<p>看到这样的问题着实让人脑壳疼，其实简单的常见问题网上搜一下都有</p>
<p>复杂的问题基本和业务相关，别人碰到和你一样的问题的概率很小</p>
<p>比较正确的提问姿势应该是把问题具体描述出来</p>
<p>我做了什么事， 我期望的结果是XX，但是目前出现的结果又是XX ，异常栈信息如下XX</p>
<p>感兴趣的自然会出声，不感兴趣的那也没办法</p>
<p>等他出来，再做工作交接，但是得把现有的问题处理处理，再交接。</p>
<p>要写个交接文档，包括流程、操作表之类的，代码实现具体类、方法。</p>
<p>有还有另一种奇葩问法：</p>
<p>XX功能怎么做，如何实现？</p>
]]></content>
    <author>
      <name>Felix zyf</name>
    </author>
    <category term="note"/>
    <contributor>
      <name>Felix zyf</name>
    </contributor>
    <published>2022-03-24T05:27:46.000Z</published>
    <rights>Copyright by Felix zyf</rights>
  </entry>
  <entry>
    <title type="html">critical thinking</title>
    <id>http://www.zhangsj.xyz/blog/note/%E5%81%9A%E4%B8%80%E4%B8%AA%E6%9C%89%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98%EF%BC%81/</id>
    <link href="http://www.zhangsj.xyz/blog/note/%E5%81%9A%E4%B8%80%E4%B8%AA%E6%9C%89%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98%EF%BC%81/"/>
    <updated>2022-03-24T05:27:46.000Z</updated>
    <content type="html"><![CDATA[<h2 id="做一个有批判性思维的程序员"> 做一个有批判性思维的程序员！</h2>
<blockquote>
<blockquote>
<p>作为一名程序员，我也喜欢对自己和别人的代码进行批判，为什么要这样写，这个注解有什么用、有没有更好的实现方式等等。对自己写的每一行代码、用到的每一个工具类，都要理解，不然不知道这个工具类都做了什么，怎么敢保证用了之后不会带来Bug？</p>
</blockquote>
</blockquote>
<p>好的游戏一定要让玩家玩的很爽吗？王者荣耀和吃鸡游戏的成功，让这个问题的答案似乎毫无争议，不能带给玩家刺激的游戏就不是好游戏。</p>
<p>什么样的游戏才能吸引玩家不断的玩下去？答案就一个字，爽，用罗胖的话说就是，从前打一局CS，让你十几分钟爽一次，现在，来一盘农药，让你几分钟就爽一次。然后，吃鸡，一款让你爽的更频繁的游戏又出来了，紧接着，各个大厂的吃鸡游戏陆续上线，大家都在力争带给玩家更多的刺激，因为他们都相信，只有让玩家爽下去，他们才不会把游戏卸载掉。</p>
<p>就在游戏制造商们为生产出更加痛快的游戏杀红了眼的时候，一只青蛙，一边旅行着，一边给家里寄照片，默默的嘲笑道，“他们真俗！”。</p>
<h3 id="不会批判性思维的你-显得很傻"> 不会批判性思维的你，显得很傻</h3>
<p>有人说，整天疑神疑鬼的，过着会很累，但是，我想说，如果不学会质疑，你不仅会错过旅行的蛙，而且还会显得你很傻。</p>
<p>你看到一篇文章，《成功的人，没有哪个是不阅读的》，文章写得非常励志，让很久没有读书的你非常惭愧，心想，都怪自己太懒，要是利用业余时间多读点书，现在说不定都身家千万了，于是你转发了这篇文章，转发时还不忘附上一句：从今天起，我要坚持天天读书[奋斗脸]</p>
<p>朋友看到你的朋友圈，心想，这人真傻，这话也信，没读过书造样过得很舒服很幸福的人多得是。 于是你成了朋友眼中那个很傻的人。其实，阅读是件好事，但是转发这样的文章，就显得你很没主见，显得很low，很鸡汤，甚至有点“中老年表情包”的范。</p>
<p>缺少批判性思维给你带来的傻还不止与此，你看了上面那篇文章后开始看书、开始关注各种微信公众号，你看到一篇文章说“晚上吃姜对身体有害”，于是有一天晚上聚餐，你看到服务员上了一盘姜葱鸡，就硬是让服务员把菜退了。</p>
<p>你聚餐完回到家，刷朋友圈时发现刚刚一起吃饭的小刘，转发了一篇文章，《晚上吃姜有害健康？哈佛教授用实验告诉你真相》，文章中列举了各种真实可靠的实验数据，你顿时有点脸红了，更要命的是，你看到小刘这条朋友圈下面，一堆点赞，而且，点赞的，都是晚上一块吃饭的同事……</p>
<p>因为没有批判性思维，你把所有的书都视若珍宝，把作者说的话都当成金玉良言，还为了显摆自己看过很多书，不断地再别人面前宣扬书中的各种错误观点，一个字，傻！</p>
<p>所以，是累好还是傻好呢？我想大多数人还是宁愿累点吧。</p>
<p>批判性思维就像给大脑装上了一道防火墙，外界的输入在进入我们大脑之前，都要经过筛选，通过筛选的观点和想法，才能进入我们的大脑。</p>
<p>那么，要怎样进行批判性思维呢，最近阅读了《学会提问——批判性思维指南》，作者Marcia Brown对如何批判性思维进行了系统性的介绍。</p>
<h3 id="如何进行批判性思维"> 如何进行批判性思维</h3>
<p>要想对一个推理进行批判，首先就要找准这个推理的论题和结论，如果连对方在谈论什么话题、对方的立场是什么都不清楚，那就谈不上什么批判了。</p>
<p>确定了对方的论题和结论之后，就要找到对方的理由，也就是支撑结论的证据。</p>
<p>找到对方提供的证据之后，接下来你就可以开始对它进行全方位的批判了。</p>
<p>总结一下：</p>
<p>对方在讨论什么（论题）-&gt; 对方想说服我相信什么（结论）-&gt; 对方给出的理由是什么（证据） -&gt; 这些证据靠谱不（批判）</p>
<p>其中前面三步都很简单，这里就不细说，我们直接谈谈，如何对证据进行批判。</p>
<h3 id="哪些词语意思不明确"> 哪些词语意思不明确</h3>
<p>你以为的不一定是他以为的。</p>
<p>“某某牌贴膏，只需三片，即可见效”。</p>
<p>上面是很多药品广告的广告语，药商往往还会请上几个健康活泼的老人来念这些广告词，但是“见效”这个词是什么含义呢？是指让你再也不会疼痛呢，还是让你一个月内不再疼痛呢，还是只是短暂地缓解病情？显然，这个歧义不解决，你就无法决定是否信服。</p>
<p>类似的歧义还有很多，最常见的就是模糊不清的需求。客户要求提供一个登录界面，你以为只需要做简单的用户名密码校验就好了，结果呢，客户不单要求输错密码一次后要输入验证码，还要求输错密码五次后当天不得再次登录，甚至还要求可以通过手机和邮箱找回密码……</p>
<p>解决这类问题的办法——不断质疑：</p>
<p>“你的意思是……吗？”</p>
<p>“除了……还需要……吗？”</p>
<p>“这样子可以满足要求吗？”</p>
<p>在向客户或者SE的不断提问的过程中，需求也慢慢得到澄清，我们也慢慢看到了客户的真实“验收标准”。</p>
<p>总之，不要猜测，弄清歧义，才可以下决定。</p>
<h3 id="推理过程中有没有谬误"> 推理过程中有没有谬误</h3>
<p>总有一些推理听起来非常有说服力，但往往经不起推敲。</p>
<p>“你代码不能这样写，我们组基本上不用这种写法，而且老黄（某组内专家级人物）推荐要采用另一种写法……”</p>
<p>很多项目的新人都会遇到类似的说辞，有些人听完就点点头，把自己代码改了。</p>
<p>然而如果你是一个求知欲很强的程序员，听到类似的解释，至少会在心里回怼一句：“凭什么？？？”</p>
<p>其实只要仔细思考一下对方的说辞，就会发现对方根本不是在说服你，而是在要挟。</p>
<p>首先，“我们组基本上不用这种写法”，这是用组内的“江湖规矩”在要挟你，意思是你要入乡随俗；</p>
<p>其次，“老黄推荐要采用另一种写法”，这是用权威在要挟你，你不可以不服从权威。</p>
<p>然而，这些都不属于证据，真正的证据应该是像这样的：这样写会有什么性能问题，或者是耦合性问题，用“江湖规矩”和”权威“来试图说服别人，恰恰犯了书中提到的诉诸公众谬误和诉诸可疑权威谬误。</p>
<p>类似的推理谬误还有很多，我们不可能一一记住。只需记得，在接受对方观点之前，不妨多问一句，凭什么？？？，唤醒自己的懒人脑，进行理性的批判思考。</p>
<h3 id="证据的效力如何"> 证据的效力如何</h3>
<p>证据的来源有很多，常见的有这四种：</p>
<ul>
<li>个人经历</li>
<li>典型案例</li>
<li>专家意见</li>
<li>研究报告</li>
</ul>
<p>这些证据的可信度有多少呢？</p>
<p>1、个人经历和典型案例</p>
<p>很多人都知道个人经历不可信，可是当看到别人炒股赚的盆满钵满、别人追求自己的理想出去创业收获人生巅峰时，还是忍不住想把对方当做偶像去模仿。</p>
<p>然而，现实是，那些炒股炒的倾家荡产的、那些创业失败破产倒闭的人，你是看不到对他们的报道的。《清醒思考的艺术》的作者罗尔夫·多贝里，在书中建议读者，多去失败者的“墓地”走走，想想也是很有道理的。</p>
<p>2、专家意见和研究报告</p>
<p>既然称为专家，那么也就意味着对方经验丰富、技术高深，在大多数情况下，专家都是对的，不然也不能被人叫做专家。</p>
<p>然而，专家并不总是对的，在这个时候，你也不必对其冷嘲热讽。我们要做的是，即使是专家的意见，也要批判性对待，不断提出质疑，敢于挑战权威，即使最后证明你的质疑是错的，你的收获，也比那些把专家意见当做真理的人要多很多。</p>
<p>研究报告也是类似的，很多研究报告都出自著名的实验室，但是这并不代表他们的结论就是正确的。他们做了那些实验，不代表就可以得出那些结论，我们同样需要对他们的实验过程和推理过程进行批判性思考。</p>
<h3 id="数据有没有欺骗性"> 数据有没有欺骗性</h3>
<p>“大人总是喜欢数字”，小王子的这句话恰恰说明了人性的弱点。</p>
<p>人们往往容易被带有数字的证据说服，最常见的就是“平均数”陷阱，“XX公司员工平均年收入XXX万”，这种平均数，根本无法说明问题。九个年薪十万的员工和一个年薪千万的员工，平均下来，每人年薪超百万，但是他们十个人中却只有一个过上年薪百万的生活。在很多时候，中位数和众数，比平均数更能说明问题。</p>
<p>除此之外，数据来源也是你非常值得批判的一个角度，人们总喜欢使用不明来历的数据来证明自己的观点。</p>
<p>下次再看到金光闪闪的数据或者图表时，先想想数据从何而来，这些数据又有多大意义。</p>
<h3 id="哪些场合要使用批判性思维"> 哪些场合要使用批判性思维</h3>
<p>生活中有很多场合都需要用到批判性思维：</p>
<p>1、评价别人的观点</p>
<p>我们每天都会从各种各样的渠道获取各种新的观点，书籍、微信公众号推送、知乎、简书等等。在接纳这些新观点，或者为之付诸行动之前，应该先批判思考一下，有歧义吗？有谬误吗？凭什么这么说？？？</p>
<p>2、评价自己的想法</p>
<p>批判性思维不仅仅是对外进行批判，对自己进行批判也很重要。</p>
<p>养成记日记的习惯，在回顾自己一天做了什么的时候，顺便批判思考一下，自己今天的哪些行为做的不好。比如我某天晚上记日记的时候，发现自己写了一天代码，但是效率很低，于是第二天就给自己的屏幕录了视频，研究一下自己一天对着电脑都做了什么，看看有哪些可以提高效率的地方。</p>
<p>3、写作</p>
<p>既然对别人的文章可以进行批判，那么对自己的文章也同样可以。不妨把自己当做读者，看看自己写的文章里，有哪些没有依据的断言、有哪些词语带有歧义、有哪些论据带有谬误等等。</p>
<p>同时，对于那些技术性较强的文章，在写完文章初稿之后，不妨接着寻找更多的相关主题的文献，来证明和冲击你的观点。永远不要满足于少量文献，这也是论文通常对参考文献的数量达到一定数量的原因。</p>
<p>4、学习</p>
<p>很多人学习一项知识时，喜欢把书或者其他学习资料从头看到尾。事实上，这样做是很没效率的，因为你很难保持那么长时间的专注，尤其是在阅读一些英文的文献时，更是如此。</p>
<p>这时候就有一个好办法，你可以在粗读了文章，比如文章的标题、文章的开头结尾、段落开头结尾之后，向自己提问题，记下问题清单，然后带着问题清单去文章中找答案，这样学习起来会非常有效率。</p>
<p>我在学习Kafka的时候，就是阅读了Kafka官方文档中Introduction的章节，对着Get Started做了个Hello World，然后就给自己提了一堆问题，什么Kafka的broker.partition都是啥、Kafka的架构是怎样体现分布式和集群的、Kafka和RabbitMQ相比，有什么优势和劣势，诸如此类自己非常感兴趣、很想了解的问题，接着下一步就是把一个个问题给解决掉，在寻找答案的过程中，不知不觉就把文档翻了好几遍，而且由于我是主动学习，学习的时候十分专注，效率奇高。</p>
<p>5、批判代码</p>
<p>作为一名程序员，我也喜欢对自己和别人的代码进行批判，为什么要这样写，这个注解有什么用、有没有更好的实现方式等等。对自己写的每一行代码、用到的每一个工具类，都要理解，不然不知道这个工具类都做了什么，怎么敢保证用了之后不会带来Bug？如果实在来不及去弄清楚，我也会把问题先记下来，等后面有空闲时间了再来慢慢学习。</p>
<h3 id="哪些场合不必使用批判性思维"> 哪些场合不必使用批判性思维</h3>
<p>也不是所有场合都适合使用批判性思维的，我们也要用批判性思维去看待批判性思维。</p>
<p>比方说看电影、电视剧， 我身边很多朋友，喜欢在看到电影一些非常不可思议的巧合的时候，说一句，“怎么可能这么凑巧”，每当这时，我就在心里默默的怼一句，“你这人不适合看电影……”</p>
<p>电影、电视剧、小说等很多虚构的故事，不一定完全符合正常逻辑，但是我们看电影不就是为了放松么？只要在那一瞬间，剧情打动了你或者逗的你哈哈大笑，看电影的目的就达到了。</p>
<p>我看到的最搞笑的事是，有一次和朋友去看一部喜剧片，看的时候他笑得眼泪都出来了，然后看完电影，他却在朋友圈发了一张图片，晒了他在豆瓣上给这部电影打了两颗星的影评……</p>
<p>总之，善用批判性思维，看穿生活中的那些谬论，做一个清醒思考的程序员。</p>
]]></content>
    <author>
      <name>SexyCode</name>
    </author>
    <category term="note"/>
    <contributor>
      <name>SexyCode</name>
    </contributor>
    <published>2022-03-24T05:27:46.000Z</published>
    <rights>Copyright by SexyCode</rights>
  </entry>
  <entry>
    <title type="html">excel export</title>
    <id>http://www.zhangsj.xyz/blog/note/%E5%8D%83%E4%B8%87%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%87%BAexcel%E7%9A%84%E4%B8%80%E7%82%B9%E5%BF%83%E5%BE%97/</id>
    <link href="http://www.zhangsj.xyz/blog/note/%E5%8D%83%E4%B8%87%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%87%BAexcel%E7%9A%84%E4%B8%80%E7%82%B9%E5%BF%83%E5%BE%97/"/>
    <updated>2022-03-24T05:27:46.000Z</updated>
    <content type="html"><![CDATA[<h2 id="千万级的数据用-excel-导出"> 千万级的数据用 EXCEL 导出</h2>
<p>最近做了个项目,使用 MYSQL 数据库,要求做到千万级的数据用 EXCEL 导出,试了良久,找出了几个方法.</p>
<h2 id="问题"> 问题</h2>
<p>JAVA 实现大数据量导出操作时，如果采用 POI 直接导出，会出现内存溢出的情况。再者 EXCEL 的 SHEET 也存在行数的限制，Excel2003 版最大行数是 655536 行、Excel2007 版最大行数是 1048576 行、Excel2010 版最大行数是 1048576 行。</p>
<h2 id="解决方案"> 解决方案</h2>
<ol>
<li>先统计总的记录数，如果大于一定数目则采用压缩文件方式导出</li>
<li>采用分页方式从数据库中获取数据，并生成多个 Excel 临时文件</li>
<li>将临时文件 Excel 压缩导出</li>
<li>删除服务器上的临时文件</li>
</ol>
<p>注：
使用流式读取,耗时 3 分钟,速度还可以再优化,就是占用内存太大,1000W 数据占了 3G 运存,关键字为 <code>resultSetType=&quot;FORWARD_ONLY&quot; fetchSize=&quot;-2147483648&quot;</code></p>
<p>但是这样得话老大非找我麻烦不可.不过百万左右的数据用这个,速度是真快 3.使用两者结合,在 mybatis 里开启流式读取,并且启用分批读取
这样数据量大的时候分批读取也不会太慢,读取一批数据,处理一批数据并清空,然后读取下一段,这样耗时 10 分钟左右,256M 内存也正常运行,配合 easyexcel</p>
<h2 id=""> </h2>
<div><pre><code><span>class</span> <span>T</span><span>{</span>

 <span>@RequestMapping</span><span>(</span>value <span>=</span> <span>"/exportExcelFile"</span><span>,</span> produces <span>=</span> <span>{</span> <span>"text/plain;charset=UTF-8"</span> <span>}</span><span>)</span>
    <span>public</span> <span>void</span> <span>excelDownLoad</span><span>(</span><span>Map</span> params<span>,</span> <span>HttpServletResponse</span> response<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        <span>QueryParam</span> queryParam <span>=</span> <span>new</span> <span>QueryParam</span><span>(</span><span>)</span><span>;</span>
        <span>Long</span> allRowNumbers <span>=</span> <span>0l</span><span>;</span>
        <span>Long</span> rowMaxCount <span>=</span> <span>60000l</span><span>;</span>
        <span>// 查询记录数</span>
        allRowNumbers <span>=</span> ossFileListBiz<span>.</span><span>totalRecord</span><span>(</span>queryParam<span>.</span><span>getSqlMap</span><span>(</span><span>)</span><span>)</span><span>;</span>

        <span>// 是否大数据量（超过6W）</span>
        <span>if</span> <span>(</span>allRowNumbers <span>></span> rowMaxCount<span>)</span> <span>{</span>
            <span>List</span> list <span>=</span> <span>new</span> <span>ArrayList</span><span>(</span><span>)</span><span>;</span>
            <span>List</span> downlist <span>=</span> <span>new</span> <span>ArrayList</span><span>(</span><span>)</span><span>;</span>
            <span>// 1.设置相应头</span>
            <span>String</span> filename <span>=</span> <span>"导出TEST.zip"</span><span>;</span>
            filename <span>=</span> <span>new</span> <span>String</span><span>(</span>filename<span>.</span><span>getBytes</span><span>(</span><span>"GBK"</span><span>)</span><span>,</span> <span>"iso-8859-1"</span><span>)</span><span>;</span>
            response<span>.</span><span>reset</span><span>(</span><span>)</span><span>;</span>
            response<span>.</span><span>setContentType</span><span>(</span><span>"application/octet-stream;charset=UTF-8"</span><span>)</span><span>;</span>
            response<span>.</span><span>setHeader</span><span>(</span><span>"Content-Disposition"</span><span>,</span> <span>"attachment;filename="</span> <span>+</span> filename<span>)</span><span>;</span>
            response<span>.</span><span>addHeader</span><span>(</span><span>"pargam"</span><span>,</span> <span>"no-cache"</span><span>)</span><span>;</span>
            response<span>.</span><span>addHeader</span><span>(</span><span>"Cache-Control"</span><span>,</span> <span>"no-cache"</span><span>)</span><span>;</span>

            <span>// 2.设置批次文件名</span>
            <span>String</span> fileSuff <span>=</span> <span>""</span><span>;</span>
            <span>SimpleDateFormat</span> sdf <span>=</span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>"yyyyMMddHHmmss"</span><span>)</span><span>;</span>
            fileSuff <span>=</span> sdf<span>.</span><span>format</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>String</span> fileName <span>=</span> <span>"导出TEST"</span> <span>+</span> fileSuff<span>;</span>
            <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> fileNames <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span> <span>// 存放生成的文件名称</span>
            <span>String</span> filePath <span>=</span> <span>"D:/excel/"</span><span>;</span> <span>// 上线后切换成linux服务器地址</span>
            <span>if</span> <span>(</span><span>!</span><span>new</span> <span>File</span><span>(</span>filePath<span>)</span><span>.</span><span>exists</span><span>(</span><span>)</span><span>)</span> <span>{</span>
                <span>new</span> <span>File</span><span>(</span>filePath<span>)</span><span>.</span><span>mkdirs</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
            <span>File</span> zip <span>=</span> <span>new</span> <span>File</span><span>(</span>filePath <span>+</span> fileName <span>+</span> <span>".zip"</span><span>)</span><span>;</span> <span>// 压缩文件路径</span>

            <span>// 3.分批次生成excel</span>
            <span>Long</span> tempsize <span>=</span> <span>(</span>allRowNumbers <span>%</span> rowMaxCount<span>)</span> <span>==</span> <span>0</span> <span>?</span> allRowNumbers <span>/</span> rowMaxCount
                    <span>:</span> allRowNumbers <span>/</span> rowMaxCount <span>+</span> <span>1</span><span>;</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> tempsize<span>;</span> i<span>++</span><span>)</span> <span>{</span>
                <span>if</span> <span>(</span>i <span>==</span> <span>(</span>allRowNumbers <span>/</span> rowMaxCount<span>)</span><span>)</span> <span>{</span>
                    queryParam<span>.</span><span>setPageNow</span><span>(</span><span>(</span>i <span>+</span> <span>1</span><span>)</span><span>)</span><span>;</span>
                    queryParam<span>.</span><span>setPageSize</span><span>(</span><span>Integer</span><span>.</span><span>valueOf</span><span>(</span><span>String</span><span>.</span><span>valueOf</span><span>(</span>rowMaxCount<span>)</span><span>)</span><span>)</span><span>;</span>
                    <span>// params.put("startNum", i*rowMaxCount);</span>
                    <span>// params.put("endNum", allRowNumbers);</span>
                <span>}</span> <span>else</span> <span>{</span>
                    <span>// params.put("startNum", i*rowMaxCount);</span>
                    <span>// params.put("endNum", (i+1)*rowMaxCount);</span>
                    queryParam<span>.</span><span>setPageNow</span><span>(</span><span>(</span>i <span>+</span> <span>1</span><span>)</span><span>)</span><span>;</span>
                    queryParam<span>.</span><span>setPageSize</span><span>(</span><span>Integer</span><span>.</span><span>valueOf</span><span>(</span><span>String</span><span>.</span><span>valueOf</span><span>(</span>rowMaxCount<span>)</span><span>)</span><span>)</span><span>;</span>
                <span>}</span>
                list <span>=</span> ossFileListBiz<span>.</span><span>findList</span><span>(</span>queryParam<span>)</span><span>;</span>

                <span>// 3.2生成excel</span>
                <span>String</span> tempExcelFile <span>=</span> filePath <span>+</span> fileName <span>+</span> <span>"["</span> <span>+</span> <span>(</span>i <span>+</span> <span>1</span><span>)</span> <span>+</span> <span>"-pic].xlsx"</span><span>;</span>
                fileNames<span>.</span><span>add</span><span>(</span>tempExcelFile<span>)</span><span>;</span>
                <span>FileOutputStream</span> fos <span>=</span> <span>new</span> <span>FileOutputStream</span><span>(</span>tempExcelFile<span>)</span><span>;</span>
                <span>int</span> rowMemory <span>=</span> <span>100</span><span>;</span>
                <span>SXSSFWorkbook</span> wb <span>=</span> <span>new</span> <span>SXSSFWorkbook</span><span>(</span>rowMemory<span>)</span><span>;</span>
                <span>try</span> <span>{</span>
                    wb <span>=</span> <span>exportDataToExcelXLSX</span><span>(</span>wb<span>,</span> list<span>)</span><span>;</span>
                    wb<span>.</span><span>write</span><span>(</span>fos<span>)</span><span>;</span>
                    fos<span>.</span><span>flush</span><span>(</span><span>)</span><span>;</span>
                    fos<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
                <span>}</span> <span>catch</span> <span>(</span><span>RuntimeException</span> runMsg<span>)</span> <span>{</span>
                    <span>throw</span> <span>new</span> <span>Exception</span><span>(</span><span>"查询数据信息异常 "</span><span>)</span><span>;</span>
                <span>}</span> <span>finally</span> <span>{</span>
                    fos<span>.</span><span>flush</span><span>(</span><span>)</span><span>;</span>
                    fos<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
                    <span>// 手动清除list</span>
                    list<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>
                    downlist<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
            <span>// 4.导出zip压缩文件</span>
            <span>exportZip</span><span>(</span>response<span>,</span> fileNames<span>,</span> zip<span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"导出失败"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>/**
     * 文件压缩并导出到客户端
     *
     * @param outPut
     * @param fileNames
     * @param zip
     * @throws FileNotFoundException
     * @throws IOException
     */</span>
    <span>private</span> <span>void</span> <span>exportZip</span><span>(</span><span>HttpServletResponse</span> response<span>,</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> fileNames<span>,</span> <span>File</span> zip<span>)</span>
            <span>throws</span> <span>FileNotFoundException</span><span>,</span> <span>IOException</span> <span>{</span>
        <span>OutputStream</span> outPut <span>=</span> response<span>.</span><span>getOutputStream</span><span>(</span><span>)</span><span>;</span>

        <span>// 1.压缩文件</span>
        <span>File</span> srcFile<span>[</span><span>]</span> <span>=</span> <span>new</span> <span>File</span><span>[</span>fileNames<span>.</span><span>size</span><span>(</span><span>)</span><span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> fileNames<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            srcFile<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>File</span><span>(</span>fileNames<span>.</span><span>get</span><span>(</span>i<span>)</span><span>)</span><span>;</span>
        <span>}</span>
        <span>byte</span><span>[</span><span>]</span> byt <span>=</span> <span>new</span> <span>byte</span><span>[</span><span>1024</span><span>]</span><span>;</span>
        <span>ZipOutputStream</span> out <span>=</span> <span>new</span> <span>ZipOutputStream</span><span>(</span><span>new</span> <span>FileOutputStream</span><span>(</span>zip<span>)</span><span>)</span><span>;</span>
        <span>// out.setEncoding("UTF-8");</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> srcFile<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>FileInputStream</span> in <span>=</span> <span>new</span> <span>FileInputStream</span><span>(</span>srcFile<span>[</span>i<span>]</span><span>)</span><span>;</span>
            out<span>.</span><span>putNextEntry</span><span>(</span><span>new</span> <span>ZipEntry</span><span>(</span>srcFile<span>[</span>i<span>]</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
            <span>int</span> length<span>;</span>
            <span>while</span> <span>(</span><span>(</span>length <span>=</span> in<span>.</span><span>read</span><span>(</span>byt<span>)</span><span>)</span> <span>></span> <span>0</span><span>)</span> <span>{</span>
                out<span>.</span><span>write</span><span>(</span>byt<span>,</span> <span>0</span><span>,</span> length<span>)</span><span>;</span>
            <span>}</span>
            out<span>.</span><span>closeEntry</span><span>(</span><span>)</span><span>;</span>
            in<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        out<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>

        <span>// 2.删除服务器上的临时文件(excel)</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> srcFile<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>File</span> temFile <span>=</span> srcFile<span>[</span>i<span>]</span><span>;</span>
            <span>if</span> <span>(</span>temFile<span>.</span><span>exists</span><span>(</span><span>)</span> <span>&amp;&amp;</span> temFile<span>.</span><span>isFile</span><span>(</span><span>)</span><span>)</span> <span>{</span>
                temFile<span>.</span><span>delete</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>// 3.返回客户端压缩文件</span>
        <span>FileInputStream</span> inStream <span>=</span> <span>new</span> <span>FileInputStream</span><span>(</span>zip<span>)</span><span>;</span>
        <span>byte</span><span>[</span><span>]</span> buf <span>=</span> <span>new</span> <span>byte</span><span>[</span><span>4096</span><span>]</span><span>;</span>
        <span>int</span> readLenght<span>;</span>
        <span>while</span> <span>(</span><span>(</span>readLenght <span>=</span> inStream<span>.</span><span>read</span><span>(</span>buf<span>)</span><span>)</span> <span>!=</span> <span>-</span><span>1</span><span>)</span> <span>{</span>
            outPut<span>.</span><span>write</span><span>(</span>buf<span>,</span> <span>0</span><span>,</span> readLenght<span>)</span><span>;</span>
        <span>}</span>
        inStream<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
        outPut<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>

        <span>// 4.删除压缩文件</span>
        <span>if</span> <span>(</span>zip<span>.</span><span>exists</span><span>(</span><span>)</span> <span>&amp;&amp;</span> zip<span>.</span><span>isFile</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            zip<span>.</span><span>delete</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>/**
     * 设置excel样式和数值
     *
     * @param wb
     * @param listMap
     * @param companyatr
     * @return
     * @throws Exception
     */</span>
    <span>private</span> <span>static</span> <span>SXSSFWorkbook</span> <span>exportDataToExcelXLSX</span><span>(</span><span>SXSSFWorkbook</span> wb<span>,</span> <span>List</span><span><span>&lt;</span><span>Object</span><span>></span></span> listMap<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        <span>String</span><span>[</span><span>]</span> assetHeadTemp <span>=</span> <span>{</span> <span>"ID"</span><span>,</span> <span>"路径"</span><span>}</span><span>;</span>
        <span>String</span><span>[</span><span>]</span> assetNameTemp <span>=</span> <span>{</span> <span>"id"</span><span>,</span> <span>"path"</span><span>}</span><span>;</span>
        <span>Sheet</span> sheet <span>=</span> <span>null</span><span>;</span>
        <span>CellStyle</span> columnHeadStyle <span>=</span> wb<span>.</span><span>createCellStyle</span><span>(</span><span>)</span><span>;</span>
        columnHeadStyle<span>.</span><span>setBorderBottom</span><span>(</span><span>HSSFCellStyle</span><span>.</span>BORDER_THIN<span>)</span><span>;</span><span>// 下边框</span>
        columnHeadStyle<span>.</span><span>setBorderLeft</span><span>(</span><span>HSSFCellStyle</span><span>.</span>BORDER_THIN<span>)</span><span>;</span><span>// 左边框</span>
        columnHeadStyle<span>.</span><span>setBorderRight</span><span>(</span><span>HSSFCellStyle</span><span>.</span>BORDER_THIN<span>)</span><span>;</span><span>// 右边框</span>
        columnHeadStyle<span>.</span><span>setBorderTop</span><span>(</span><span>HSSFCellStyle</span><span>.</span>BORDER_THIN<span>)</span><span>;</span><span>// 上边框</span>
        columnHeadStyle<span>.</span><span>setAlignment</span><span>(</span><span>HSSFCellStyle</span><span>.</span>ALIGN_CENTER<span>)</span><span>;</span>
        columnHeadStyle<span>.</span><span>setVerticalAlignment</span><span>(</span><span>HSSFCellStyle</span><span>.</span>VERTICAL_CENTER<span>)</span><span>;</span>
        columnHeadStyle<span>.</span><span>setWrapText</span><span>(</span><span>true</span><span>)</span><span>;</span>
        <span>Font</span> f <span>=</span> wb<span>.</span><span>createFont</span><span>(</span><span>)</span><span>;</span><span>// 字体</span>
        f<span>.</span><span>setFontHeightInPoints</span><span>(</span><span>(</span><span>short</span><span>)</span> <span>9</span><span>)</span><span>;</span><span>// 字号</span>
        f<span>.</span><span>setBoldweight</span><span>(</span><span>HSSFFont</span><span>.</span>BOLDWEIGHT_BOLD<span>)</span><span>;</span><span>// BOLDWEIGHT_BOLD);// 加粗</span>
        columnHeadStyle<span>.</span><span>setFont</span><span>(</span>f<span>)</span><span>;</span>
        <span>Row</span> row<span>;</span>
        <span>Cell</span> cell<span>;</span>
        sheet <span>=</span> wb<span>.</span><span>createSheet</span><span>(</span><span>"sheet"</span><span>)</span><span>;</span>
        row <span>=</span> sheet<span>.</span><span>createRow</span><span>(</span><span>0</span><span>)</span><span>;</span>
        sheet<span>.</span><span>createFreezePane</span><span>(</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> assetHeadTemp<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            cell <span>=</span> row<span>.</span><span>createCell</span><span>(</span>i<span>)</span><span>;</span>
            cell<span>.</span><span>setCellStyle</span><span>(</span>columnHeadStyle<span>)</span><span>;</span>
            cell<span>.</span><span>setCellValue</span><span>(</span>assetHeadTemp<span>[</span>i<span>]</span><span>)</span><span>;</span>
            sheet<span>.</span><span>setColumnWidth</span><span>(</span>i<span>,</span> <span>(</span><span>int</span><span>)</span> <span>7000</span><span>)</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>listMap <span>!=</span> <span>null</span> <span>&amp;&amp;</span> listMap<span>.</span><span>size</span><span>(</span><span>)</span> <span>></span> <span>0</span><span>)</span> <span>{</span>
            <span>int</span> rowIndex <span>=</span> <span>1</span><span>;</span>
            <span>for</span> <span>(</span><span>Object</span> m <span>:</span> listMap<span>)</span> <span>{</span>
                <span>Map</span> map <span>=</span> <span>objectToMap</span><span>(</span>m<span>)</span><span>;</span>
                row <span>=</span> sheet<span>.</span><span>createRow</span><span>(</span>rowIndex<span>++</span><span>)</span><span>;</span>
                <span>int</span> index <span>=</span> <span>0</span><span>;</span>
                <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> assetNameTemp<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
                    cell <span>=</span> row<span>.</span><span>createCell</span><span>(</span>index<span>++</span><span>)</span><span>;</span>
                    cell<span>.</span><span>setCellValue</span><span>(</span>map<span>.</span><span>get</span><span>(</span>assetNameTemp<span>[</span>i<span>]</span><span>)</span> <span>!=</span> <span>null</span> <span>?</span> map<span>.</span><span>get</span><span>(</span>assetNameTemp<span>[</span>i<span>]</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span> <span>:</span> <span>""</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> wb<span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> <span>objectToMap</span><span>(</span><span>Object</span> obj<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        <span>if</span><span>(</span>obj <span>==</span> <span>null</span><span>)</span>
        <span>return</span> <span>null</span><span>;</span>
        <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>BeanInfo</span> beanInfo <span>=</span> <span>Introspector</span><span>.</span><span>getBeanInfo</span><span>(</span>obj<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>PropertyDescriptor</span><span>[</span><span>]</span> propertyDescriptors <span>=</span> beanInfo<span>.</span><span>getPropertyDescriptors</span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>PropertyDescriptor</span> property <span>:</span> propertyDescriptors<span>)</span> <span>{</span>
        <span>String</span> key <span>=</span> property<span>.</span><span>getName</span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>key<span>.</span><span>compareToIgnoreCase</span><span>(</span><span>"class"</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>continue</span><span>;</span>
        <span>}</span>
        <span>Method</span> getter <span>=</span> property<span>.</span><span>getReadMethod</span><span>(</span><span>)</span><span>;</span>
        <span>Object</span> value <span>=</span> getter<span>!=</span><span>null</span> <span>?</span> getter<span>.</span><span>invoke</span><span>(</span>obj<span>)</span> <span>:</span> <span>null</span><span>;</span>
        map<span>.</span><span>put</span><span>(</span>key<span>,</span> value<span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> map<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br><span>196</span><br><span>197</span><br><span>198</span><br><span>199</span><br><span>200</span><br><span>201</span><br><span>202</span><br><span>203</span><br><span>204</span><br><span>205</span><br><span>206</span><br></div></div>]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="note"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-03-24T05:27:46.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">humorous</title>
    <id>http://www.zhangsj.xyz/blog/note/%E5%B9%BD%E9%BB%98%E6%AE%B5%E5%AD%90/</id>
    <link href="http://www.zhangsj.xyz/blog/note/%E5%B9%BD%E9%BB%98%E6%AE%B5%E5%AD%90/"/>
    <updated>2022-03-24T05:27:46.000Z</updated>
    <content type="html"><![CDATA[<p>搞学术的为什么都睡得那么晚，难道只有到晚上才有灵感？不是，姑娘，搞学术不靠灵感，靠的是碌碌无为的白天引发的愧疚心。</p>
<p>单身程序狗解决了一个技术难题后没有妹子可以炫耀或夸一下自己怎么办？</p>
<p>现在你明白了吧，为什么那么多程序员要写技术博客。</p>
<p>“玩算法的码农，打拼靠蓝条，像是法师。数学就等于蓝条最大值，数学差，魔法值不高，很快就到瓶颈了。外语影响回蓝速度。经验和智力加急速和穿透的。不玩算法的码农，像是战士，打拼靠血条，体质加生命，精神加生命回复，经验和敏捷加急速和破甲。</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-03-24T05:27:46.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">daily report</title>
    <id>http://www.zhangsj.xyz/blog/note/%E5%A6%82%E4%BD%95%E5%86%99%E6%97%A5%E6%8A%A5/</id>
    <link href="http://www.zhangsj.xyz/blog/note/%E5%A6%82%E4%BD%95%E5%86%99%E6%97%A5%E6%8A%A5/"/>
    <updated>2022-04-12T12:32:31.000Z</updated>
    <content type="html"><![CDATA[<h2 id="_01-多使用序号-每行尽量精简"> 01 多使用序号，每行尽量精简</h2>
<p>一些PM的日报为了描述上的完整性，喜欢用大段的文字去阐述一件事情。</p>
<p>但其实人是会有视觉疲劳的，大家如果看到大段的文字，就不太会仔细地阅读了，非常容易错过重点信息。</p>
<p>所以我一般会把大段的文字进行拆分，用1、2、3来标注区分，同时对内容进行筛减，提炼重点话术。我给大家举个例子：</p>
<p>A：今天一共评审了10个模块，其中5个模块顺利通过，2个模块需要修改，3个模块因为不符合业务诉求所以退回重新和业务对焦方案，5个已通过的模块已经安排产品和技术对接，技术评估后明确可行，需要进行技术方案设计，预计2天后出。</p>
<p>B（推荐）：</p>
<ol>
<li>6.17组织评审会，共10个模块，5个通过，2 个需修改，3个退回</li>
<li>已通过的模块，产品与技术已经对齐，技术方案预计6 .19输出</li>
</ol>
<p>拆分和精简可以让日报的整体看上去清晰明了易读，大家会更愿意看。</p>
<h2 id="_02-不要进行开放性描述-一定要有闭环"> 02 不要进行开放性描述，一定要有闭环</h2>
<p>什么叫开放性描述？比如，今天xxx延期了，今天业务方案变更了等，类似这种没有原因、没有结论、没有后续动作的语句称之为开放性描述。</p>
<p>大家看到开放性描述的时候，大多会很懵：这个东西延期了到底要不要紧？是某一环延期了，还是整体延期了？为什么延期？有没有解决方案？方案变更对项目有没有影响？影响有多大？这些信息如果都看不到，大家就会产生疑问，项目经理要回复大家的各种疑问，来回反复既增加沟通成本又繁琐。</p>
<p>那啥叫闭环呢？不是说给一个解决方案就叫闭环，而是要把这件事挖到底，做到最无可做的时候，给出的结论叫闭环。</p>
<p>例如：“直播功能业务方案变更了，今天与业务协商需要给出解决方案”。</p>
<p>这个描述看上去找了业务，推进了后续的发展，但其实并没有完结，业务方案为什么变更了？有没有牵涉到外部问题？什么时候能给出新的方案？业务方案的变更对当前的项目进展有没有影响？如果有影响，怎么处理，怎么补救？这些都是需要PM去挖掘的。</p>
<p>当这些信息挖掘到以后，重新组织的结论才是一个可闭环的结论。所以我会先去把所有能挖掘的都挖掘一遍，再将结论输出出来：</p>
<p>1.直播功能因为预算问题需要变更方案，已同步给所有相关方
2.与业务方及财务共同对齐，6.18 进行预算重新申报审核，最晚6.19给出最新业务方案
3.（无影响版本）与产研对齐，6.19 之前给出业务方案对当前进度不影响
4.（有影响版本）与产研对齐，业务方案变更导致当前开发进度停滞，会优先启动另一需求，待6.19业务方案给出后重新评估，目前延期风险较高。 这样一来，无论是问题的根本原因，还是信息同步、解决方案以及后续时间规划都能清晰地反馈出来，大家会更容易看懂。</p>
<p>日报的内容，很多时候反映出了PM的项目管理方式，我们需要刨根问底，追本溯源，才能将项目管理做到极致，真正帮助团队解决问题。</p>
<h2 id="_03-要着眼全局-日报开头写总结性话语"> 03 要着眼全局，日报开头写总结性话语</h2>
<p>常规的日报都有固定的版式，如项目信息、本周目标、今日进展、问题风险变更等。</p>
<p>这些内容大多是比较丰富而详细的，但是对整体项目而言，其中的每一条其实都只是一个点，比如某个任务延期，比如某个方案变更，比如突然发现了某个依赖方没加进来等等。</p>
<p>那些通过日报来了解项目的人，很难通过一个个点去想象项目的整体情况。</p>
<p>这时候，作为PM——你的作用就显现出来了，你需要帮助他们去了解整个的项目，在日报开头加上今日总结的目的就是为了将这些点汇总成面，从全局的角度去看整个项目，给项目做个判断，给看日报的人做一个输入。</p>
<p>比方说今天延期特别多，你可以总结一下今日延期较多，对项目有一定影响，与各方对齐后预计明天输出解决方案；</p>
<p>如果变更很多，但是都在可控范围内，也可以总结一下，今天共有8个变更，但目前评估下来，风险可控；</p>
<p>如果今天开了好几个会，并且都没有结论，可以总结一下，今日针对xx问题已拉多方沟通，结论还未输出，会持续推进。</p>
<p>有了这些开头的总结，大家对于项目的体感会进一步加深，不是停留在某个点的问题上，而是对整体项目有了一个感观。</p>
<h2 id="日报模板"> 日报模板</h2>
<p>持续优化 xxx；</p>
<p>重构了 xxx；</p>
<p>梳理 xxx，总结 xxx；</p>
<p>排查 xxx 问题；</p>
<p>改进了 xxx 逻辑，性能得到提升；</p>
<p>通过 xxx 降低了 xxx 至 xxx；</p>
<p>为了 xxx 重新设计了 xxx；</p>
<p>为了 xxx 通过 xxx 完成了 xxx；</p>
<p>通过 xxx 优化了 xxx 为 xxx；</p>
<p>为了 xxx 将 xxx 应用到了 xxx；</p>
<p>通过 xxx 提高了 xxx 至 xxx；</p>
<p>为了 xxx 通过 xxx 将 xxx 集成；</p>
<p>为了 xxx 通过 xxx 成立了 xxx；</p>
<p>阅读文档，熟悉了面向对象的特征、</p>
<p>sql、null、下标越界、找不到类、数字格式化异常</p>
<p>BlockingDeque.class，双端阻塞队列接口</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-03-24T05:27:46.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">regex</title>
    <id>http://www.zhangsj.xyz/blog/note/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <link href="http://www.zhangsj.xyz/blog/note/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <updated>2022-03-24T05:27:46.000Z</updated>
    <content type="html"><![CDATA[<h2 id="regular-expression"> regular expression</h2>
<p><a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md#22-%E5%AD%97%E7%AC%A6%E9%9B%86" target="_blank" rel="noopener noreferrer">https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md#22-字符集</a></p>
<p><a href="https://regex101.com/" target="_blank" rel="noopener noreferrer">正则表达式在线测试工具</a></p>
<h2 id="什么是正则表达式"> 什么是正则表达式？</h2>
<p><a href="https://gum.co/learn-regex" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/badge/-Download PDF -0a0a0a.svg?style=flat&amp;colorA=0a0a0a" alt="" loading="lazy"></a></p>
<blockquote>
<p>正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。
一个正则表达式是一种从左到右匹配主体字符串的模式。
“Regular expression”这个词比较拗口，我们常使用缩写的术语“regex”或“regexp”。
正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等。</p>
</blockquote>
<p>想象你正在写一个应用，然后你想设定一个用户命名的规则，让用户名包含字符、数字、下划线和连字符，以及限制字符的个数，好让名字看起来没那么丑。
我们使用以下正则表达式来验证一个用户名：</p>
<p>以上的正则表达式可以接受 <code>john_doe</code>、<code>jo-hn_doe</code>、<code>john12_as</code>。
但不匹配<code>Jo</code>，因为它包含了大写的字母而且太短了。</p>
<h2 id="_1-基本匹配"> 1. 基本匹配</h2>
<p>正则表达式其实就是在执行搜索时的格式，它由一些字母和数字组合而成。
例如：一个正则表达式 <code>the</code>，它表示一个规则：由字母<code>t</code>开始，接着是<code>h</code>，再接着是<code>e</code>。</p>
<pre>
"the" => The fat cat sat on  mat.
</pre>
<p><a href="https://regex101.com/r/dmRygT/1" target="_blank" rel="noopener noreferrer">在线练习</a></p>
<p>正则表达式<code>123</code>匹配字符串<code>123</code>。它逐个字符的与输入的正则表达式做比较。</p>
<p>正则表达式是大小写敏感的，所以<code>The</code>不会匹配<code>the</code>。</p>
<pre>
"The" =>  fat cat sat on the mat.
</pre>
<p><a href="https://regex101.com/r/1paXsy/1" target="_blank" rel="noopener noreferrer">在线练习</a></p>
<h2 id="_2-元字符"> 2. 元字符</h2>
<p>正则表达式主要依赖于元字符。
元字符不代表他们本身的字面意思，他们都有特殊的含义。一些元字符写在方括号中的时候有一些特殊的意思。以下是一些元字符的介绍：</p>
<table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td>句号匹配任意单个字符除了换行符。</td>
</tr>
<tr>
<td style="text-align:center">[ ]</td>
<td>字符种类。匹配方括号内的任意字符。</td>
</tr>
<tr>
<td style="text-align:center">[^ ]</td>
<td>否定的字符种类。匹配除了方括号里的任意字符</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td>匹配&gt;=0 个重复的在*号之前的字符。</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td>匹配&gt;=1 个重复的+号前的字符。</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td>标记?之前的字符为可选.</td>
</tr>
<tr>
<td style="text-align:center">{n,m}</td>
<td>匹配 num 个大括号之前的字符或字符集 (n &lt;= num &lt;= m).</td>
</tr>
<tr>
<td style="text-align:center">(xyz)</td>
<td>字符集，匹配与 xyz 完全相等的字符串.</td>
</tr>
<tr>
<td style="text-align:center">|</td>
<td>或运算符，匹配符号前或后的字符.</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td>转义字符,用于匹配一些保留的字符 <code>[ ] ( ) { } . * + ? ^ $ \ |</code></td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td>从开始行开始匹配.</td>
</tr>
<tr>
<td style="text-align:center">$</td>
<td>从末端开始匹配.</td>
</tr>
</tbody>
</table>
<h2 id="_2-1-点运算符"> 2.1 点运算符 <code>.</code></h2>
<p><code>.</code>是元字符中最简单的例子。
<code>.</code>匹配任意单个字符，但不匹配换行符。
例如，表达式<code>.ar</code>匹配一个任意字符后面跟着是<code>a</code>和<code>r</code>的字符串。</p>
<pre>
".ar" => The  ked in the age.
</pre>
<p><a href="https://regex101.com/r/xc9GkU/1" target="_blank" rel="noopener noreferrer">在线练习</a></p>
<h2 id="_2-2-字符集"> 2.2 字符集</h2>
<p>字符集也叫做字符类。
方括号用来指定一个字符集。
在方括号中使用连字符来指定字符集的范围。
在方括号中的字符集不关心顺序。
例如，表达式<code>[Tt]he</code> 匹配 <code>the</code> 和 <code>The</code>。</p>
<pre>
"[Tt]he" =>  car parked in  garage.
</pre>
<p><a href="https://regex101.com/r/2ITLQ4/1" target="_blank" rel="noopener noreferrer">在线练习</a></p>
<p>方括号的句号就表示句号。
表达式 <code>ar[.]</code> 匹配 <code>ar.</code>字符串</p>
<pre>
"ar[.]" => A garage is a good place to park a c
</pre>
<p><a href="https://regex101.com/r/wL3xtE/1" target="_blank" rel="noopener noreferrer">在线练习</a></p>
<h3 id="_2-2-1-否定字符集"> 2.2.1 否定字符集</h3>
<p>一般来说 <code>^</code> 表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是否定的。
例如，表达式<code>[^c]ar</code> 匹配一个后面跟着<code>ar</code>的除了<code>c</code>的任意字符。</p>
<pre>
"[^c]ar" => The car ked in the age.
</pre>
<p><a href="https://regex101.com/r/nNNlq3/1" target="_blank" rel="noopener noreferrer">在线练习</a></p>
<h2 id="_2-3-重复次数"> 2.3 重复次数</h2>
<p>后面跟着元字符 <code>+</code>，<code>*</code> or <code>?</code> 的，用来指定匹配子模式的次数。
这些元字符在不同的情况下有着不同的意思。</p>
<h3 id="_2-3-1-号"> 2.3.1 <code>*</code> 号</h3>
<p><code>*</code>号匹配 在<code>*</code>之前的字符出现<code>大于等于0</code>次。
例如，表达式 <code>a*</code> 匹配 0 或更多个以 a 开头的字符。表达式<code>[a-z]*</code> 匹配一个行中所有以小写字母开头的字符串。</p>
<pre>
"[a-z]*" => T      #21.
</pre>
<p><a href="https://regex101.com/r/7m8me5/1" target="_blank" rel="noopener noreferrer">在线练习</a></p>
<p><code>*</code>字符和<code>.</code>字符搭配可以匹配所有的字符<code>.*</code>。
<code>*</code>和表示匹配空格的符号<code>\s</code>连起来用，如表达式<code>\s*cat\s*</code>匹配 0 或更多个空格开头和 0 或更多个空格结尾的 cat 字符串。</p>
<pre>
"\s*cat\s*" => The fatsat on the conenation.
</pre>
<p><a href="https://regex101.com/r/gGrwuz/1" target="_blank" rel="noopener noreferrer">在线练习</a></p>
<h3 id="_2-3-2-号"> 2.3.2 <code>+</code> 号</h3>
<p><code>+</code>号匹配<code>+</code>号之前的字符出现 &gt;=1 次。
例如表达式<code>c.+t</code> 匹配以首字母<code>c</code>开头以<code>t</code>结尾，中间跟着至少一个字符的字符串。</p>
<pre>
"c.+t" => The fat .
</pre>
<p><a href="https://regex101.com/r/Dzf9Aa/1" target="_blank" rel="noopener noreferrer">在线练习</a></p>
<h3 id="_2-3-3-号"> 2.3.3 <code>?</code> 号</h3>
<p>在正则表达式中元字符 <code>?</code> 标记在符号前面的字符为可选，即出现 0 或 1 次。
例如，表达式 <code>[T]?he</code> 匹配字符串 <code>he</code> 和 <code>The</code>。</p>
<pre>
"[T]he" =>  car is parked in the garage.
</pre>
<p><a href="https://regex101.com/r/cIg9zm/1" target="_blank" rel="noopener noreferrer">在线练习</a></p>
<pre>
"[T]?he" =>  car is parked in t garage.
</pre>
<p><a href="https://regex101.com/r/kPpO2x/1" target="_blank" rel="noopener noreferrer">在线练习</a></p>
<h2 id="_2-4-号"> 2.4 <code>{}</code> 号</h2>
<p>在正则表达式中 <code>{}</code> 是一个量词，常用来限定一个或一组字符可以重复出现的次数。
例如， 表达式 <code>[0-9]{2,3}</code> 匹配最少 2 位最多 3 位 0~9 的数字。</p>
<pre>
"[0-9]{2,3}" => The number was 9.7 but we rounded it off to .0.
</pre>
<p><a href="https://regex101.com/r/juM86s/1" target="_blank" rel="noopener noreferrer">在线练习</a></p>
<p>我们可以省略第二个参数。
例如，<code>[0-9]{2,}</code> 匹配至少两位 0~9 的数字。</p>
<pre>
"[0-9]{2,}" => The number was 9. but we rounded it off to .0.
</pre>
<p><a href="https://regex101.com/r/Gdy4w5/1" target="_blank" rel="noopener noreferrer">在线练习</a></p>
<p>如果逗号也省略掉则表示重复固定的次数。
例如，<code>[0-9]{3}</code> 匹配 3 位数字</p>
<pre>
"[0-9]{3}" => The number was 9.7 but we rounded it off to 10.0.
</pre>
<p><a href="https://regex101.com/r/Sivu30/1" target="_blank" rel="noopener noreferrer">在线练习</a></p>
<h2 id="_2-5-特征标群"> 2.5 <code>(...)</code> 特征标群</h2>
<p>特征标群是一组写在 <code>(...)</code> 中的子模式。<code>(...)</code> 中包含的内容将会被看成一个整体，和数学中小括号( )的作用相同。例如, 表达式 <code>(ab)*</code> 匹配连续出现 0 或更多个 <code>ab</code>。如果没有使用 <code>(...)</code> ，那么表达式 <code>ab*</code> 将匹配连续出现 0 或更多个 <code>b</code> 。再比如之前说的 <code>{}</code> 是用来表示前面一个字符出现指定次数。但如果在 <code>{}</code> 前加上特征标群 <code>(...)</code> 则表示整个标群内的字符重复 N 次。</p>
<p>我们还可以在 <code>()</code> 中用或字符 <code>|</code> 表示或。例如，<code>(c|g|p)ar</code> 匹配 <code>car</code> 或 <code>gar</code> 或 <code>par</code>.</p>
<pre>
"(c|g|p)ar" => The  is ked in the age.
</pre>
<p><a href="https://regex101.com/r/tUxrBG/1" target="_blank" rel="noopener noreferrer">在线练习</a></p>
<h2 id="_2-6-或运算符"> 2.6 <code>|</code> 或运算符</h2>
<p>或运算符就表示或，用作判断条件。</p>
<p>例如 <code>(T|t)he|car</code> 匹配 <code>(T|t)he</code> 或 <code>car</code>。</p>
<pre>
"(T|t)he|car" =>   is parked in  garage.
</pre>
<p><a href="https://regex101.com/r/fBXyX0/1" target="_blank" rel="noopener noreferrer">在线练习</a></p>
<h2 id="_2-7-转码特殊字符"> 2.7 转码特殊字符</h2>
<p>反斜线 <code>\</code> 在表达式中用于转码紧跟其后的字符。用于指定 <code>{ } [ ] / \ + * . $ ^ | ?</code> 这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 <code>\</code>。</p>
<p>例如 <code>.</code> 是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 <code>.</code> 则要写成 <code>\.</code> 以下这个例子 <code>\.?</code>是选择性匹配<code>.</code></p>
<pre>
"(f|c|m)at\.?" => The   sat on the 
</pre>
<p><a href="https://regex101.com/r/DOc5Nu/1" target="_blank" rel="noopener noreferrer">在线练习</a></p>
<h2 id="_2-8-锚点"> 2.8 锚点</h2>
<p>在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。<code>^</code> 指定开头，<code>$</code> 指定结尾。</p>
<h3 id="_2-8-1-号"> 2.8.1 <code>^</code> 号</h3>
<p><code>^</code> 用来检查匹配的字符串是否在所匹配字符串的开头。</p>
<p>例如，在 <code>abc</code> 中使用表达式 <code>^a</code> 会得到结果 <code>a</code>。但如果使用 <code>^b</code> 将匹配不到任何结果。因为在字符串 <code>abc</code> 中并不是以 <code>b</code> 开头。</p>
<p>例如，<code>^(T|t)he</code> 匹配以 <code>The</code> 或 <code>the</code> 开头的字符串。</p>
<pre>
"(T|t)he" =>  car is parked in  garage.
</pre>
<p><a href="https://regex101.com/r/5ljjgB/1" target="_blank" rel="noopener noreferrer">在线练习</a></p>
<pre>
"^(T|t)he" =>  car is parked in the garage.
</pre>
<p><a href="https://regex101.com/r/jXrKne/1" target="_blank" rel="noopener noreferrer">在线练习</a></p>
<h3 id="_2-8-2-号"> 2.8.2 <code>$</code> 号</h3>
<p>同理于 <code>^</code> 号，<code>$</code> 号用来匹配字符是否是最后一个。</p>
<p>例如，<code>(at\.)$</code> 匹配以 <code>at.</code> 结尾的字符串。</p>
<pre>
"(at\.)" => The fat c s on the m
</pre>
<p><a href="https://regex101.com/r/y4Au4D/1" target="_blank" rel="noopener noreferrer">在线练习</a></p>
<pre>
"(at\.)$" => The fat cat. sat. on the m
</pre>
<p><a href="https://regex101.com/r/t0AkOd/1" target="_blank" rel="noopener noreferrer">在线练习</a></p>
<h2 id="_3-简写字符集"> 3. 简写字符集</h2>
<p>正则表达式提供一些常用的字符集简写。如下:</p>
<table>
<thead>
<tr>
<th style="text-align:center">简写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td>除换行符外的所有字符</td>
</tr>
<tr>
<td style="text-align:center">\w</td>
<td>匹配所有字母数字，等同于 <code>[a-zA-Z0-9_]</code></td>
</tr>
<tr>
<td style="text-align:center">\W</td>
<td>匹配所有非字母数字，即符号，等同于： <code>[^\w]</code></td>
</tr>
<tr>
<td style="text-align:center">\d</td>
<td>匹配数字： <code>[0-9]</code></td>
</tr>
<tr>
<td style="text-align:center">\D</td>
<td>匹配非数字： <code>[^\d]</code></td>
</tr>
<tr>
<td style="text-align:center">\s</td>
<td>匹配所有空格字符，等同于： <code>[\t\n\f\r\p{Z}]</code></td>
</tr>
<tr>
<td style="text-align:center">\S</td>
<td>匹配所有非空格字符： <code>[^\s]</code></td>
</tr>
<tr>
<td style="text-align:center">\f</td>
<td>匹配一个换页符</td>
</tr>
<tr>
<td style="text-align:center">\n</td>
<td>匹配一个换行符</td>
</tr>
<tr>
<td style="text-align:center">\r</td>
<td>匹配一个回车符</td>
</tr>
<tr>
<td style="text-align:center">\t</td>
<td>匹配一个制表符</td>
</tr>
<tr>
<td style="text-align:center">\v</td>
<td>匹配一个垂直制表符</td>
</tr>
<tr>
<td style="text-align:center">\p</td>
<td>匹配 CR/LF（等同于 <code>\r\n</code>），用来匹配 DOS 行终止符</td>
</tr>
</tbody>
</table>
<h2 id="_4-零宽度断言-前后预查"> 4. 零宽度断言(前后预查)</h2>
<p>先行断言和后发断言(合称 lookaround)都属于<strong>非捕获组</strong>(用于匹配模式，但不包括在匹配列表中)。当我们需要一个模式的前面或后面有另一个特定的模式时，就可以使用它们。</p>
<p>例如，我们希望从下面的输入字符串 <code>$4.44</code> 和 <code>$10.88</code> 中获得所有以 <code>$</code> 字符开头的数字，我们将使用以下的正则表达式 <code>(?&lt;=\$)[0-9\.]*</code>。意思是：获取所有包含 <code>.</code> 并且前面是 <code>$</code> 的数字。</p>
<p>零宽度断言如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">?=</td>
<td>正先行断言-存在</td>
</tr>
<tr>
<td style="text-align:center">?!</td>
<td>负先行断言-排除</td>
</tr>
<tr>
<td style="text-align:center">?&lt;=</td>
<td>正后发断言-存在</td>
</tr>
<tr>
<td style="text-align:center">?&lt;!</td>
<td>负后发断言-排除</td>
</tr>
</tbody>
</table>
<h3 id="_4-1-正先行断言"> 4.1 <code>?=...</code> 正先行断言</h3>
<p><code>?=...</code> 正先行断言，表示第一部分表达式之后必须跟着 <code>?=...</code>定义的表达式。</p>
<p>返回结果只包含满足匹配条件的第一部分表达式。
定义一个正先行断言要使用 <code>()</code>。在括号内部使用一个问号和等号： <code>(?=...)</code>。</p>
<p>正先行断言的内容写在括号中的等号后面。
例如，表达式 <code>(T|t)he(?=\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>，在括号中我们又定义了正先行断言 <code>(?=\sfat)</code> ，即 <code>The</code> 和 <code>the</code> 后面紧跟着 <code>(空格)fat</code>。</p>
<pre>
"(T|t)he(?=\sfat)" =>  fat cat sat on the mat.
</pre>
<p><a href="https://regex101.com/r/IDDARt/1" target="_blank" rel="noopener noreferrer">在线练习</a></p>
<h3 id="_4-2-负先行断言"> 4.2 <code>?!...</code> 负先行断言</h3>
<p>负先行断言 <code>?!</code> 用于筛选所有匹配结果，筛选条件为 其后不跟随着断言中定义的格式。
<code>正先行断言</code> 定义和 <code>负先行断言</code> 一样，区别就是 <code>=</code> 替换成 <code>!</code> 也就是 <code>(?!...)</code>。</p>
<p>表达式 <code>(T|t)he(?!\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>，且其后不跟着 <code>(空格)fat</code>。</p>
<pre>
"(T|t)he(?!\sfat)" => The fat cat sat on  mat.
</pre>
<p><a href="https://regex101.com/r/V32Npg/1" target="_blank" rel="noopener noreferrer">在线练习</a></p>
<h3 id="_4-3-正后发断言"> 4.3 <code>?&lt;= ...</code> 正后发断言</h3>
<p>正后发断言 记作<code>(?&lt;=...)</code> 用于筛选所有匹配结果，筛选条件为 其前跟随着断言中定义的格式。
例如，表达式 <code>(?&lt;=(T|t)he\s)(fat|mat)</code> 匹配 <code>fat</code> 和 <code>mat</code>，且其前跟着 <code>The</code> 或 <code>the</code>。</p>
<pre>
"(?<=(T|t)he\s)(fat|mat)" => The  cat sat on the .
</pre>
<p><a href="https://regex101.com/r/avH165/1" target="_blank" rel="noopener noreferrer">在线练习</a></p>
<h3 id="_4-4-负后发断言"> 4.4 <code>?&lt;!...</code> 负后发断言</h3>
<p>负后发断言 记作 <code>(?&lt;!...)</code> 用于筛选所有匹配结果，筛选条件为 其前不跟随着断言中定义的格式。
例如，表达式 <code>(?&lt;!(T|t)he\s)(cat)</code> 匹配 <code>cat</code>，且其前不跟着 <code>The</code> 或 <code>the</code>。</p>
<pre>
"(?&lt;!(T|t)he\s)(cat)" => The cat sat on .
</pre>
<p><a href="https://regex101.com/r/8Efx5G/1" target="_blank" rel="noopener noreferrer">在线练习</a></p>
<h2 id="_5-标志"> 5. 标志</h2>
<p>标志也叫模式修正符，因为它可以用来修改表达式的搜索结果。
这些标志可以任意的组合使用，它也是整个正则表达式的一部分。</p>
<table>
<thead>
<tr>
<th style="text-align:center">标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">i</td>
<td>忽略大小写。</td>
</tr>
<tr>
<td style="text-align:center">g</td>
<td>全局搜索。</td>
</tr>
<tr>
<td style="text-align:center">m</td>
<td>多行修饰符：锚点元字符 <code>^</code> <code>$</code> 工作范围在每行的起始。</td>
</tr>
</tbody>
</table>
<h3 id="_5-1-忽略大小写-case-insensitive"> 5.1 忽略大小写 (Case Insensitive)</h3>
<p>修饰语 <code>i</code> 用于忽略大小写。
例如，表达式 <code>/The/gi</code> 表示在全局搜索 <code>The</code>，在后面的 <code>i</code> 将其条件修改为忽略大小写，则变成搜索 <code>the</code> 和 <code>The</code>，<code>g</code> 表示全局搜索。</p>
<pre>
"The" =>  fat cat sat on the mat.
</pre>
<p><a href="https://regex101.com/r/dpQyf9/1" target="_blank" rel="noopener noreferrer">在线练习</a></p>
<pre>
"/The/gi" =>  fat cat sat on  mat.
</pre>
<p><a href="https://regex101.com/r/ahfiuh/1" target="_blank" rel="noopener noreferrer">在线练习</a></p>
<h3 id="_5-2-全局搜索-global-search"> 5.2 全局搜索 (Global search)</h3>
<p>修饰符 <code>g</code> 常用于执行一个全局搜索匹配，即(不仅仅返回第一个匹配的，而是返回全部)。
例如，表达式 <code>/.(at)/g</code> 表示搜索 任意字符(除了换行)+ <code>at</code>，并返回全部结果。</p>
<pre>
"/.(at)/" => The  cat sat on the mat.
</pre>
<p><a href="https://regex101.com/r/jnk6gM/1" target="_blank" rel="noopener noreferrer">在线练习</a></p>
<pre>
"/.(at)/g" => The    on the .
</pre>
<p><a href="https://regex101.com/r/dO1nef/1" target="_blank" rel="noopener noreferrer">在线练习</a></p>
<h3 id="_5-3-多行修饰符-multiline"> 5.3 多行修饰符 (Multiline)</h3>
<p>多行修饰符 <code>m</code> 常用于执行一个多行匹配。</p>
<p>像之前介绍的 <code>(^,$)</code> 用于检查格式是否是在待检测字符串的开头或结尾。但我们如果想要它在每行的开头和结尾生效，我们需要用到多行修饰符 <code>m</code>。</p>
<p>例如，表达式 <code>/at(.)?$/gm</code> 表示小写字符 <code>a</code> 后跟小写字符 <code>t</code> ，末尾可选除换行符外任意字符。根据 <code>m</code> 修饰符，现在表达式匹配每行的结尾。</p>
<pre>
"/.at(.)?$/" => The fat
                cat sat
                on the 
</pre>
<p><a href="https://regex101.com/r/hoGMkP/1" target="_blank" rel="noopener noreferrer">在线练习</a></p>
<pre>
"/.at(.)?$/gm" => The 
                  cat 
                  on the 
</pre>
<p><a href="https://regex101.com/r/E88WE2/1" target="_blank" rel="noopener noreferrer">在线练习</a></p>
<h3 id="_6-贪婪匹配与惰性匹配-greedy-vs-lazy-matching"> 6. 贪婪匹配与惰性匹配 (Greedy vs lazy matching)</h3>
<p>正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 <code>?</code> 将贪婪匹配模式转化为惰性匹配模式。</p>
<pre>
"/(.*at)/" => . </pre>
<p><a href="https://regex101.com/r/AyAdgJ/1" target="_blank" rel="noopener noreferrer">在线练习</a></p>
<pre>
"/(.*?at)/" =>  cat sat on the mat. </pre>
<p><a href="https://regex101.com/r/AyAdgJ/2" target="_blank" rel="noopener noreferrer">在线练习</a></p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="note"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2021-08-01T00:00:00.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">how-programmers-do-not-go-astray-in-their-busy-schedules</title>
    <id>http://www.zhangsj.xyz/blog/note/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E5%9C%A8%E7%99%BE%E5%BF%99%E4%B9%8B%E4%B8%AD%E4%B8%8D%E8%B5%B0%E5%B2%94%E8%B7%AF%EF%BC%8C%E4%B8%8D%E7%99%BD%E5%BF%99/</id>
    <link href="http://www.zhangsj.xyz/blog/note/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E5%9C%A8%E7%99%BE%E5%BF%99%E4%B9%8B%E4%B8%AD%E4%B8%8D%E8%B5%B0%E5%B2%94%E8%B7%AF%EF%BC%8C%E4%B8%8D%E7%99%BD%E5%BF%99/"/>
    <updated>2022-04-13T01:22:00.587Z</updated>
    <content type="html"><![CDATA[<h2 id="程序员如何在百忙之中不走岔路-不白忙"> 程序员如何在百忙之中不走岔路，不白忙!</h2>
<p>程序员忙，似乎是个公论，有些程序员甚至会认为，不忙的程序员无法快速地进步，从而会落伍。或者说，不忙的程序员有可能被公司末尾淘汰掉。对此，一直危机感很重的我深以为然。</p>
<p>因为，我见过不少得过且过的的程序员工资明显低于同等条件下的平均水平，我更见过更多忙成狗的程序员，因为不知道在忙什么以及为什么忙，所以进步很慢，这真就叫做白忙了。</p>
<p>不论程序员对“忙”持有什么态度，但似乎很少有程序员能主动地逃避，除非得过且过，但这样似乎是透支日后的发展前景，以此来换取当前的舒适度。</p>
<p>本文不讨论程序员该不该忙，而是根据切身体会和所见所闻，交流下如下方面感受。</p>
<p>1、如何在百忙中更有效地干活，从而让自己能有更多自己的时间，至于这个时间里是休息还是自己发展，那每个人自己看着办。</p>
<p>2、如何不被过于繁忙的琐事牵着走，从而迷失自己的发展方向，这里会写些我见过的走岔路程序员的情景，供大家警示。</p>
<p>3、如何利用不多的个人时间，快速地提升自己的能力。</p>
<p>好了，正文开始。</p>
<p>一、忙的程序员心态更得好</p>
<p>最理想的情况是：不忙，钱多，而且个人还能不断地升级。这是每个程序员都想的，但似乎这类工作很少，至少我没见过。</p>
<p>次一等的是：忙，但拿到的钱能对的上忙的程度，或者通过忙能提升自己（忙得有收获）。</p>
<p>再差一等的是：忙，虽然能挣到钱，但很大程度上不是为自己忙，即忙了一段时间回顾后，说不上个人有啥提高。</p>
<p>最差的是：看着别人忙，自己不忙了，（别高兴太早），原因是在公司里或社会上被边缘化了。</p>
<p>除此之外，不忙的情况我还能想到一种：虽然被分配很多活，但由于个人因素，得过且过。这离被边缘化也不远了。</p>
<p>总之一句话，很少有程序员不忙。但人一忙，心就烦，不少程序员火气就很大，平时就有可能对测试，对需求方，甚至对领导发火。</p>
<p>这里想说的是：很多事情是我们无法改变的，那只有改变自己。这话说得很无奈，我们换种说法：心态不好，没法让自己不忙，更办不成事，最终倒霉受累的还是自己，与其这样，还不是待人接物和气些，指不定大家谈得开心，事情还办快些，还能让别人有个好印象。</p>
<h2 id="二、别什么事都做-得分优先级-必要时更得和别人和领导沟通"> 二、别什么事都做，得分优先级，必要时更得和别人和领导沟通</h2>
<p>浑身都是铁，能打几颗钉？再牛的程序员也不可能啥事都自己做，或者任何与自己相关的事情都自己做。</p>
<p>再换个说法，一些领导，经理和老板，事情比我们更多了，他们该怎么办？</p>
<p>如下是结论和建议：</p>
<p><strong>建议一：不该自己做的事，而且不做是没有风险的事，别做！</strong></p>
<p>比如在安排任务时，不属于自己分管的，在做好自己的本职前，可以不做。或者超出程序员范围的，比如谈需求，或装系统，装机器，也可以不做。</p>
<p>可能不少程序员遇到别人来请求帮忙时，拉不下脸来拒绝，或者怕不做会得罪人。一个人在公司里地位的提升，是靠做好自己的本职，而不是靠到处打杂，而且，如果真的到处打杂，做和自己不相干的事的话，分配你活的领导会怎么想？</p>
<p>那怎么样才能拒掉一些事情呢？</p>
<h2 id="建议二-靠沟通"> 建议二：靠沟通</h2>
<p>多和对方沟通，说自己事情已经很多，不做会有xxx后果，而且说自己的时间都已经排满了。这样遇到通情达理的人，那么自然就不会让你做了。</p>
<p>如果还是推不了，那么得和领导沟通，比如说，您交办的事情，我正在做，但目前XXX让我做其他的事情，这样您的事情我就无法按时完成了。这样让领导去拒，如果领导也拒不掉，那至少领导就知道你完不成任务的原因了。</p>
<h2 id="建议三-直接拒"> 建议三：直接拒</h2>
<p>比如事情已经很忙了，而且此类事情有过领导和同事拒掉的先例，那么直接拒掉，不拒白不拒。</p>
<h2 id="建议四-分清优先级"> 建议四：分清优先级</h2>
<p>比如某个事情，不得不做，但优先级不高，那么可以直接说，这事情目前没时间，估计要等到3天后再做。</p>
<p>指不定别人3天后这个事情就自己解决了。</p>
<h2 id="三、百忙中如何提升效率"> 三、百忙中如何提升效率</h2>
<p>1、在可以的情况下，工作中可以去掉些没有意义的事，比如刷手机看网页。</p>
<p>2、多问，不断学习别人之前的解决方法，别什么都自己想。</p>
<p>3、最重要的其实大家都知道：提升自己的能力，多了解业务。</p>
<p>4、平时一定得多积累，多思考，多学习。</p>
<p>我在上下班的路上，看到很多人在刷手机，这个也正常，毕竟人都是要放松的，我有时候自己也这样的。</p>
<p>但我至少会留下足够多的时间反思：这事情做好后，我反思下如何能做更好，或者我该提升哪些方面的能力，或者我该去了解哪块的业务知识。</p>
<h2 id="四、我见过的在百忙中迷失自己的案例-警示效果"> 四、我见过的在百忙中迷失自己的案例（警示效果）</h2>
<p>1、小甲，工作确实辛苦，工作之余，刷手机，看连续剧，除了学习其他都干。结果3年后，能力丝毫没有提升，至于大幅度提升工资呢，只能呵呵了。</p>
<p>2、小乙，一年换一行，总感觉当前太累，想换个轻松点的，第一年做java开发，嫌累，转行做.NET，第二年又转行做测试，第三年去做需求分析，结果3年后，有3类经验，但没有一个是精的，所以工作3年后依然无法在某一领域升级为高级。</p>
<p>3、小丙，工作压力太大，所以学会了得过且过，结果很快被后进超越。</p>
<p>4、小丁，在一个公司里工作有些年头了，属于老油条了，也能仗着资历推掉一些事情，自认为“钱不少人不累”。但随着年纪增长，过了初级或高级开发的年限，但能力无法提升，最终工资远低于平均水平。</p>
<h2 id="五、在百忙中提升自己能力的一些方法"> 五、在百忙中提升自己能力的一些方法</h2>
<p>我好歹也在一些大公司里呆过，在其中也见过不少牛人，他们至少属于架构师级别的，可想而知他们平时工作的繁忙程度（至少比我忙），说下我看到的他们平时学习的场景。</p>
<p>1、见缝插针，有机会就学习，比如在开会间隙，或下班之余，都会看教学视频或纸质书。</p>
<p>2、不会光看，而是边动笔边运行代码边学习。比如打开电脑，手上有本书，电脑里是有书的代码，边看书，边运行代码，从代码里仔细体会书上的内容。</p>
<p>3、不仅限于书，会在读书的基础上记笔记，写博客，甚至写书，当然更会把学到的内容落实到平时的代码里。</p>
<p>六、说下我自己的感受</p>
<p>图片</p>
<p>1、再忙，也一定得学习，可能干开始学的时候，甚至不知道学习的途径，不知道该学什么以及怎么学，但一回生两回熟，多看几本书就知道了。比如本人从架构小白到能忽悠一般的架构师，就用了大概半年的时间。</p>
<p>2、至于学习的时间，一定是有的，比如最近我早上少用半小时看手机，那么一周5天工作日就有两个半小时了，可以写至少2篇博文了。又如晚上，回到家里，脑子不怎么灵了，但可以看些资料，积累些框架上的技能，待到周末再仔细阅读。</p>
<p>我自己感觉，远没有达到“一有空就学习”的地步，但相比之前“有空就玩”的场景，感觉确实有进步。</p>
<p>3、得靠一定的目标来激励自己，比如发博文能名利双收，就凭这点，我会努力写博客。又如，我听说写书更能展示自己的实例，我就用了2年时间，完成了两本，有一本尚在写作中。</p>
<p>4、自己学习的方法、途径以及学习的内容未必是最有效的，比如有可能学到内容在平时是用不到的，或者学了一些将要被淘汰的技术。所以一定得通过某些途径来“试错”，比如多看些大牛的博客，看下自己学的内容是不是恰当，或者学习的层次是不是大牛们推荐的。甚至可以去多参加面试，通过真刀真枪的实战来检验自己的学习效果。</p>
<p>5、最关键的，得给自己明确一个长远的目标，这个目标可以不断被修正，但一定得有。比如3年后，我得升级到高级java开发，为了这个，我得学xxx，xxx等的技术。n年后，我得升到高级架构，为此，我该看xxx书，得实践xxx技能。</p>
<p>其实上述方法大家都知道，但能做到的寥寥无几，所以大家可以看到，在自己身边，因忙而迷失前进方向的比比皆是，但在百忙中通过努力升级到大牛的人也不少。 本人自然不想成为警示别人的案例，所以在百忙中写了这篇博文来警示自己，顺便把我的一些所见所闻和大家来分享，同时也希望大家别成为被别人警示的典型。</p>
<h2 id="六、总结"> 六、总结</h2>
<p>不忙的程序员不多，至少我见到的程序员都很忙，如果各位程序员朋友在阅读本文时产生共鸣，那么本文就没算白写。如果本文中提到的一些方法能让大家受益，本人就更加欣慰了，大家也可以顺手点个赞支持一下哈。至于本文会误人子弟？想想也不大可能，至少在文本里都是些四平八稳的内容。</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="personal-planning"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">SimpleDateFormat</title>
    <id>http://www.zhangsj.xyz/blog/note/%E8%BF%98%E5%9C%A8%E4%BD%BF%E7%94%A8SimpleDateFormat%EF%BC%9F%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%B4%A9%E6%B2%A1%EF%BC%9F/</id>
    <link href="http://www.zhangsj.xyz/blog/note/%E8%BF%98%E5%9C%A8%E4%BD%BF%E7%94%A8SimpleDateFormat%EF%BC%9F%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%B4%A9%E6%B2%A1%EF%BC%9F/"/>
    <updated>2022-03-24T05:27:46.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一、前言"> 一、前言</h2>
<p>日常开发中，我们经常需要使用时间相关类，说到时间相关类，想必大家对SimpleDateFormat并不陌生。主要是用它进行时间的格式化输出和解析，挺方便快捷的，但是SimpleDateFormat并不是一个线程安全的类。在多线程情况下，会出现异常，想必有经验的小伙伴也遇到过。下面我们就来分析分析SimpleDateFormat为什么不安全？是怎么引发的？以及多线程下有那些SimpleDateFormat的解决方案？</p>
<p>先看看《阿里巴巴开发手册》对于SimpleDateFormat是怎么看待的：</p>
<blockquote>
<ol start="5">
<li>【强制】SimpleDateFormat
是线程不安全的类，一般不要定义为static变量，如果定义为static，必须加锁，或者使用DateUtils工具类。 正例：注意线程安全，使用DateUtils。亦推荐如下处理：</li>
</ol>
</blockquote>
<div><pre><code><span>private</span> <span>static</span> <span>final</span> <span>ThreadLocal</span><span><span>&lt;</span><span>DateFormat</span><span>></span></span> df <span>=</span> <span>new</span> <span>ThreadLocal</span><span><span>&lt;</span><span>DateFormat</span><span>></span></span><span>(</span><span>)</span> <span>{</span>
<span>@Override</span>
<span>protected</span> <span>DateFormat</span> <span>initialValue</span><span>(</span><span>)</span> <span>{</span>
<span>return</span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>"yyyy-MM-dd"</span><span>)</span><span>;</span>
<span>}</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><blockquote>
<p>说明：如果是JDK8的应用，可以使用Instant
代替Date，LocalDateTime代替Calendar，DateTimeFormatter代替SimpleDateFormat，官方给出的解释：simple beautiful strong immutable thread-safe。</p>
</blockquote>
<h2 id="二、问题场景复现"> 二、问题场景复现</h2>
<p>一般我们使用SimpleDateFormat的时候会把它定义为一个静态变量，避免频繁创建它的对象实例，如下代码：</p>
<div><pre><code><span>public</span> <span>class</span> <span>SimpleDateFormatTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>final</span> <span>SimpleDateFormat</span> sdf <span>=</span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>"yyyy-MM-dd HH:mm:s"</span><span>)</span><span>;</span>

    <span>public</span> <span>static</span> <span>String</span> <span>formatDate</span><span>(</span><span>Date</span> date<span>)</span> <span>{</span>
        <span>return</span> sdf<span>.</span><span>format</span><span>(</span>date<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>Date</span> <span>parse</span><span>(</span><span>String</span> strDate<span>)</span> <span>throws</span> <span>ParseException</span> <span>{</span>
        <span>return</span> sdf<span>.</span><span>parse</span><span>(</span>strDate<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>sdf<span>.</span><span>format</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><div><pre><code>    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>
        <span>ExecutorService</span> executorService <span>=</span> <span>Executors</span><span>.</span><span>newFixedThreadPool</span><span>(</span><span>100</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>20</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            executorService<span>.</span><span>execute</span><span>(</span><span>(</span><span>)</span><span>-></span><span>{</span>
                <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> <span>10</span><span>;</span> j<span>++</span><span>)</span> <span>{</span>
                    <span>try</span> <span>{</span>
                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>parse</span><span>(</span><span>"2020-01-02 09:45:59"</span><span>)</span><span>)</span><span>;</span>
                    <span>}</span> <span>catch</span> <span>(</span><span>ParseException</span> e<span>)</span> <span>{</span>
                        e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
                    <span>}</span>
                <span>}</span>
            <span>}</span><span>)</span><span>;</span>
        <span>}</span>
        executorService<span>.</span><span>shutdown</span><span>(</span><span>)</span><span>;</span>
        executorService<span>.</span><span>awaitTermination</span><span>(</span><span>1</span><span>,</span> <span>TimeUnit</span><span>.</span>DAYS<span>)</span><span>;</span>

    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>你看这不崩了？部分线程获取的时间不对，部分线程直接报 java.lang.NumberFormatException:multiple points错，线程直接挂死了</p>
<h2 id="三、多线程不安全原因"> 三、多线程不安全原因</h2>
<p>因为我们把SimpleDateFormat定义为静态变量，那么多线程下SimpleDateFormat的实例就会被多个线程共享，B线程会读取到A线程的时间，就会出现时间差异和其它各种问题。SimpleDateFormat和它继承的DateFormat类也不是线程安全的。</p>
<p>来看看SimpleDateFormat的format()方法的源码：</p>
<div><pre><code><span>// Called from Format after creating a FieldDelegate</span>
    <span>private</span> <span>StringBuffer</span> <span>format</span><span>(</span><span>Date</span> date<span>,</span> <span>StringBuffer</span> toAppendTo<span>,</span>
                                <span>FieldDelegate</span> delegate<span>)</span> <span>{</span>
        <span>// Convert input date to time field list</span>
        calendar<span>.</span><span>setTime</span><span>(</span>date<span>)</span><span>;</span>

        <span>boolean</span> useDateFormatSymbols <span>=</span> <span>useDateFormatSymbols</span><span>(</span><span>)</span><span>;</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> compiledPattern<span>.</span>length<span>;</span> <span>)</span> <span>{</span>
            <span>int</span> tag <span>=</span> compiledPattern<span>[</span>i<span>]</span> <span>>>></span> <span>8</span><span>;</span>
            <span>int</span> count <span>=</span> compiledPattern<span>[</span>i<span>++</span><span>]</span> <span>&amp;</span> <span>0xff</span><span>;</span>
            <span>if</span> <span>(</span>count <span>==</span> <span>255</span><span>)</span> <span>{</span>
                count <span>=</span> compiledPattern<span>[</span>i<span>++</span><span>]</span> <span>&lt;&lt;</span> <span>16</span><span>;</span>
                count <span>|=</span> compiledPattern<span>[</span>i<span>++</span><span>]</span><span>;</span>
            <span>}</span>

            <span>switch</span> <span>(</span>tag<span>)</span> <span>{</span>
            <span>case</span> TAG_QUOTE_ASCII_CHAR<span>:</span>
                toAppendTo<span>.</span><span>append</span><span>(</span><span>(</span><span>char</span><span>)</span>count<span>)</span><span>;</span>
                <span>break</span><span>;</span>

            <span>case</span> TAG_QUOTE_CHARS<span>:</span>
                toAppendTo<span>.</span><span>append</span><span>(</span>compiledPattern<span>,</span> i<span>,</span> count<span>)</span><span>;</span>
                i <span>+=</span> count<span>;</span>
                <span>break</span><span>;</span>

            <span>default</span><span>:</span>
                <span>subFormat</span><span>(</span>tag<span>,</span> count<span>,</span> delegate<span>,</span> toAppendTo<span>,</span> useDateFormatSymbols<span>)</span><span>;</span>
                <span>break</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> toAppendTo<span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>注意， calendar.setTime(date)，SimpleDateFormat的format方法实际操作的就是Calendar。</p>
<p>因为我们声明SimpleDateFormat为static变量，那么它的Calendar变量也就是一个共享变量，可以被多个线程访问。</p>
<p>假设线程A执行完calendar.setTime(date)，把时间设置成2019-01-02，这时候被挂起，线程B获得CPU执行权。</p>
<p>线程B也执行到了calendar.setTime(date)，把时间设置为2019-01-03。</p>
<p>线程挂起，线程A继续走，calendar还会被继续使用(<code>subFormat</code>方法)，而这时calendar用的是线程B设置的值了，而这就是引发问题的根源，出现时间不对，线程挂死等等。</p>
<p>其实SimpleDateFormat源码上作者也给过我们提示：</p>
<p>意思就是：</p>
<blockquote>
<p>日期格式不同步。
建议为每个线程创建单独的格式实例。
如果多个线程同时访问一种格式，则必须在外部同步该格式。</p>
</blockquote>
<h2 id="四、解决方案"> 四、解决方案</h2>
<p>只在需要的时候创建新实例，不用static修饰。</p>
<p>如上代码，仅在需要用到的地方创建一个新的实例，就没有线程安全问题，不过也加重了创建对象的负担，会频繁地创建和销毁对象，效率较低。</p>
<p><strong>synchronized大法好</strong></p>
<div><pre><code>    <span>public</span> <span>static</span> <span>String</span> <span>formatDate</span><span>(</span><span>Date</span> date<span>)</span> <span>{</span>
        <span>synchronized</span> <span>(</span>sdf<span>)</span> <span>{</span>
            <span>return</span> sdf<span>.</span><span>format</span><span>(</span>date<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>Date</span> <span>parse</span><span>(</span><span>String</span> strDate<span>)</span> <span>throws</span> <span>ParseException</span> <span>{</span>
        <span>synchronized</span> <span>(</span>sdf<span>)</span> <span>{</span>
            <span>return</span> sdf<span>.</span><span>parse</span><span>(</span>strDate<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>简单粗暴，synchronized往上一套也可以解决线程安全问题，缺点自然就是并发量大的时候会对性能有影响，线程阻塞。</p>
<p><strong>ThreadLocal</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>SimpleDateFormatTLTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>final</span> <span>ThreadLocal</span><span><span>&lt;</span><span>SimpleDateFormat</span><span>></span></span> sdf <span>=</span> <span>new</span> <span>ThreadLocal</span><span><span>&lt;</span><span>SimpleDateFormat</span><span>></span></span><span>(</span><span>)</span><span>{</span>
        <span>@Override</span>
        <span>protected</span> <span>SimpleDateFormat</span> <span>initialValue</span><span>(</span><span>)</span> <span>{</span>
            <span>return</span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>"yyyy-MM-dd HH:mm:ss"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span><span>;</span>

    <span>public</span> <span>static</span> <span>String</span> <span>formatDate</span><span>(</span><span>Date</span> date<span>)</span> <span>{</span>
        <span>return</span> sdf<span>.</span><span>get</span><span>(</span><span>)</span><span>.</span><span>format</span><span>(</span>date<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>Date</span> <span>parse</span><span>(</span><span>String</span> strDate<span>)</span> <span>throws</span> <span>ParseException</span> <span>{</span>
        <span>return</span> sdf<span>.</span><span>get</span><span>(</span><span>)</span><span>.</span><span>parse</span><span>(</span>strDate<span>)</span><span>;</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>ThreadLocal可以确保每个线程都可以得到单独的一个SimpleDateFormat的对象，那么自然也就不存在竞争问题了。</p>
<p><strong>基于JDK1.8的DateTimeFormatter</strong></p>
<p>也是《阿里巴巴开发手册》给我们的解决方案，对之前的代码进行改造：</p>
<div><pre><code><span>public</span> <span>class</span> <span>DateTimeFormatterTest</span> <span>{</span>
    <span>private</span> <span>static</span> <span>final</span> <span>DateTimeFormatter</span> formatter <span>=</span> <span>DateTimeFormatter</span><span>.</span><span>ofPattern</span><span>(</span><span>"yyyy-MM-dd HH:mm:ss"</span><span>)</span><span>;</span>

    <span>public</span> <span>static</span> <span>String</span> <span>formateDate2</span><span>(</span><span>LocalDateTime</span> date<span>)</span> <span>{</span>
        <span>return</span> formatter<span>.</span><span>format</span><span>(</span>date<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>LocalDateTime</span> <span>parse2</span><span>(</span><span>String</span> dateNow<span>)</span> <span>{</span>
        <span>return</span> <span>LocalDateTime</span><span>.</span><span>parse</span><span>(</span>dateNow<span>,</span>formatter<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>
        <span>ExecutorService</span> service <span>=</span> <span>Executors</span><span>.</span><span>newFixedThreadPool</span><span>(</span><span>100</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>20</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            service<span>.</span><span>execute</span><span>(</span><span>(</span><span>)</span><span>-></span><span>{</span>
                <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> <span>10</span><span>;</span> j<span>++</span><span>)</span> <span>{</span>
                    <span>// System.out.println(formateDate2(LocalDateTime.now()));</span>
                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>parse2</span><span>(</span><span>"2020-01-02 09:45:59"</span><span>)</span><span>)</span><span>;</span>

                <span>}</span>
            <span>}</span><span>)</span><span>;</span>
        <span>}</span>
        service<span>.</span><span>shutdown</span><span>(</span><span>)</span><span>;</span>
        service<span>.</span><span>awaitTermination</span><span>(</span><span>1</span><span>,</span> <span>TimeUnit</span><span>.</span>DAYS<span>)</span><span>;</span>

    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>运行结果就不贴了，不会出现报错和时间不准确的问题。</p>
<p>DateTimeFormatter源码上作者也加注释说明了，他的类是不可变的，并且是线程安全的。</p>
]]></content>
    <author>
      <name>Felix zyf</name>
    </author>
    <category term="note"/>
    <contributor>
      <name>Felix zyf</name>
    </contributor>
    <published>2022-03-24T05:27:46.000Z</published>
    <rights>Copyright by Felix zyf</rights>
  </entry>
  <entry>
    <title type="html">docker</title>
    <id>http://www.zhangsj.xyz/blog/tool/docker/</id>
    <link href="http://www.zhangsj.xyz/blog/tool/docker/"/>
    <updated>2022-03-13T16:47:56.000Z</updated>
    <content type="html"><![CDATA[<div><p>相关信息</p>
<p>Docker 是一个软件容器化平台，它以容器的形式将您的应用程序及其所有依赖项打包在一起，以确保你的应用程序在任何环境中无缝运行。</p>
</div>
<p>Docker 容器包括应用程序及其所有依赖项，作为操作系统的独立进程运行。</p>
<p>Docker 镜像是 Docker 容器的源代码，Docker 镜像用于创建容器。使用 build 命令创建镜像。</p>
<p>Docker 容器有几种状态</p>
<p>四种状态：运行、已暂停、重新启动、已退出。</p>
<h2 id="dockerfile"> Dockerfile</h2>
<p>Dockerfile 中最常见的指令是什么</p>
<p>FROM：指定基础镜像</p>
<p>LABEL：功能是为镜像指定标签</p>
<p>RUN：运行指定的命令</p>
<p>CMD：容器启动时要运行的命令</p>
<p>Dockerfile 中的命令 COPY 和 ADD 命令有什么区别?</p>
<p>COPY 与 ADD 的区别 COPY 的 SRC 只能是本地文件，其他用法一致</p>
<h2 id="docker-常用命令"> docker 常用命令</h2>
<h3 id="docker-run"> docker run</h3>
<p>创建容器,将数据,日志,配置文件映射到本机</p>
<ul>
<li>-d: 后台运行容器</li>
<li>-p 将容器的端口映射到本机的端口</li>
<li>-v 将主机目录挂载到容器的目录</li>
<li>-e 设置参数</li>
</ul>
<div><pre><code><span>docker</span> run 
-d 
-P 
--name nginx2 
-v /home/nginx:/usr/share/nginx/HTML 
nginx

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="docker-pull"> docker pull</h3>
<p>拉取或者更新指定镜像</p>
<h3 id="docker-push"> docker push</h3>
<p>将镜像推送至远程仓库</p>
<h3 id="docker-rmi"> docker rmi</h3>
<p>删除镜像</p>
<h3 id="docker-rm"> docker rm</h3>
<p>删除容器</p>
<h3 id="docker-images"> docker images</h3>
<p>查看镜像库，列出所有镜像</p>
<h3 id="docker-ps"> docker ps</h3>
<p>列出所有容器</p>
<h2 id="容器与主机之间的数据拷贝"> 容器与主机之间的数据拷贝</h2>
<p>容器与主机之间的数据拷贝命令</p>
<p>docker cp 命令用于容器与主机之间的数据拷贝</p>
<p>主机到容器：</p>
<p>docker cp /www 96f7f14e99ab:/www/</p>
<p>容器到主机：</p>
<p>docker cp 96f7f14e99ab:/www /tmp/</p>
<h2 id="启动-nginx-容器-随机端口映射-并挂载本地文件目录到容器-html-的命令"> 启动 nginx 容器(随机端口映射)，并挂载本地文件目录到容器 HTML 的命令</h2>
<p>启动 nginx 容器(随机端口映射)，并挂载本地文件目录到容器 HTML 的命令</p>
<h2 id="生产中监控-docker"> 生产中监控 Docker</h2>
<p>Docker 提供 docker stats 和 docker 事件等工具来监控生产中的 Docker。我们可以使用这些命令获取重要统计数据的报告。</p>
<p>Docker 统计数据：当我们使用容器 ID 调用 docker stats 时，我们获得容器的 CPU，内存使用情况等。它类似于 Linux 中的 top 命令。</p>
<p>Docker 事件：Docker 事件是一个命令，用于查看 Docker 守护程序中正在进行的活动流。</p>
<p>一些常见的 Docker 事件是：</p>
<p>Attach，commit，die，detach，rename，destroy 等。我们还可以使用各种选项来限制或过滤我们感兴趣的事件</p>
<h2 id="dockerfile-的-onbuild-指令"> dockerfile 的 ONBUILD 指令</h2>
<p>当镜像用作另一个镜像构建的基础时，</p>
<p>ONBUILD 指令向镜像添加将在稍后执行的触发指令。</p>
<p>如果要构建将用作构建其他镜像的基础的镜像(例如，可以使用特定于用户的配置自定义的应用程序构建环境或守护程序)，这将非常有用。</p>
<div><pre><code><span>docker</span> <span>exec</span> -it <span>&lt;</span>container id<span>></span> <span>&lt;</span>path_of_nginx<span>></span> reload

<span>docker</span> <span>exec</span> -it nginx /home/userfile reload
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>##案例：创建mysql容器</p>
<p>1、在本地创建mysql的映射目录</p>
<div><pre><code><span>mkdir</span> -p /root/mysql/data /root/mysql/logs /root/mysql/conf
</code></pre>
<div><span>1</span><br></div></div><p>在/root/mysql/conf中创建 *.cnf 文件(叫什么都行)</p>
<div><pre><code><span>touch</span> my.cnf
</code></pre>
<div><span>1</span><br></div></div><p>2、拉取官方mysql5.7镜像</p>
<div><pre><code><span>docker</span> pull mysql:5.7
</code></pre>
<div><span>1</span><br></div></div><p>3、创建容器,将数据,日志,配置文件映射到本机</p>
<div><pre><code><span>docker</span> run -d -p <span>3306</span>:3306 --name mysql -v /root/mysql/conf:/etc/mysql/conf.d -v /root/mysql/logs:/logs -v /root/mysql/data:/var/lib/mysql -e <span>MYSQL_ROOT_PASSWORD</span><span>=</span>root mysql:5.7
</code></pre>
<div><span>1</span><br></div></div><p>4、启动mysql容器</p>
<div><pre><code><span>docker</span> start mysql
</code></pre>
<div><span>1</span><br></div></div><p>5、查看/root/mysql/data目录是否有数据文件</p>
<div><pre><code><span>cd</span> /root/mysql/data
</code></pre>
<div><span>1</span><br></div></div><p>6、使用navicat工具连接测试</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="tool"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-24T06:32:54.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">git-use</title>
    <id>http://www.zhangsj.xyz/blog/tool/git/</id>
    <link href="http://www.zhangsj.xyz/blog/tool/git/"/>
    <updated>2022-04-11T06:31:58.000Z</updated>
    <content type="html"><![CDATA[<p>git对于大家应该都不太陌生，熟练使用git已经成为程序员的一项基本技能，尽管在工作中有诸如 Sourcetree这样牛X的客户端工具，使得合并代码变的很方便。但找工作面试和一些需彰显个人实力的场景，仍然需要我们掌握足够多的git命令。</p>
<h2 id="git-add-git-stage区别"> git add&amp;git stage区别</h2>
<p>在回答这个问题之前需要先了解 git 仓库的三个组成部分：工作区(Working Directory)、暂存区(Stage)和历史记录区(History)：</p>
<p>工作区：在 git 管理下的正常目录都算是工作区，我们平时的编辑工作都是在工作区完成。</p>
<p>暂存区：临时区域。里面存放将要提交文件的快照。</p>
<p>历史记录区：git commit 后的记录区。</p>
<p>然后是这三个区的转换关系以及转换所使用的命令：</p>
<h2 id="git-reset、git-revert-git-checkout"> git reset、git revert &amp; git checkout</h2>
<p>这个问题同样也需要先了解 git 仓库的三个组成部分：工作区(Working Directory)、暂存区(Stage)和历史记录区(History)。</p>
<p>首先是它们的共同点：用来撤销代码仓库中的某些更改。</p>
<p>然后是不同点：</p>
<h2 id="从-commit-层面来说"> 从 commit 层面来说</h2>
<p>Git reset</p>
<p>可以将一个分支的末端指向之前的一个 commit。</p>
<p>然后再下次 git 执行垃圾回收的时候，会把这个 commit 之后的 commit 都扔掉。</p>
<p>还支持三种标记，用来标记 reset 指令影响的范围：</p>
<p>--mixed：会影响到暂存区和历史记录区。也是默认选项；
--soft：只影响历史记录区；
--hard：影响工作区、暂存区和历史记录区。</p>
<p>Git checkout</p>
<p>可以将 HEAD 移到一个新的分支，并更新工作目录。因为可能会覆盖本地的修改，所以执行这个指令之前，你需要 stash 或者 commit 暂存区和工作区的更改。</p>
<p>Git revert</p>
<p>和 git reset 的目的是一样的，但是做法不同，它会以创建新的 commit 的方式来撤销 commit，这样能保留之前的 commit 历史，比较安全。</p>
<p>另外，同样因为可能会覆盖本地的修改，所以执行这个指令之前，你需要 stash 或者 commit 暂存区和工作区的更改。</p>
<h3 id="从文件层面来说"> 从文件层面来说</h3>
<p>Git reset 只是把文件从历史记录区拿到暂存区，不影响工作区的内容，而且不支持 --mixed、--soft 和 --hard。</p>
<p>Git checkout 则是把文件从历史记录拿到工作区，不影响暂存区的内容。</p>
<p>Git revert 不支持文件层面的操作。</p>
<h2 id="gitflow-基本流程"> GitFlow 基本流程</h2>
<p>GitFlow 是由 Vincent Driessen 提出的一个 git 操作流程标准。包含如下几个关键分支：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">master</td>
<td>主分支</td>
</tr>
<tr>
<td style="text-align:center">develop</td>
<td>主开发分支，包含确定即将发布的代码</td>
</tr>
<tr>
<td style="text-align:center">feature</td>
<td>新功能分支，一般一个新功能对应一个分支，对于功能的拆分需要比较合理，以避免一些后面不必要的代码冲突</td>
</tr>
<tr>
<td style="text-align:center">release</td>
<td>发布分支，发布时候用的分支，一般测试时候发现的 bug 在这个分支进行修复</td>
</tr>
<tr>
<td style="text-align:center">hotfix</td>
<td>hotfix 分支，紧急修 bug 的时候用</td>
</tr>
</tbody>
</table>
<p>对于 feature 流程，都是从 develop 分支发起，然后通过 PR／MR 的方式合并回 develop 分支；</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="tool"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-24T06:03:53.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">easy-to-use-idea-plugins-and-configurations</title>
    <id>http://www.zhangsj.xyz/blog/tool/idea%E6%8F%92%E4%BB%B6/</id>
    <link href="http://www.zhangsj.xyz/blog/tool/idea%E6%8F%92%E4%BB%B6/"/>
    <updated>2022-03-13T16:47:56.000Z</updated>
    <content type="html"><![CDATA[<h2 id="好用的idea插件"> 好用的idea插件</h2>
<ol>
<li>Alibaba Java Coding Guidelines</li>
<li>iBATIS/MyBatis plugin</li>
<li>GsonFormat</li>
<li>Stack Overflow</li>
<li>Background Image Plus</li>
<li>Lombok</li>
<li>CodeGlance</li>
<li>generatAllSetter</li>
<li>gitee</li>
<li>copilot（代码补全）</li>
<li>GrepFormatPlus</li>
<li>GrepConsole</li>
<li>JRebel and XRebel</li>
<li>Markdown Image Support</li>
<li>MetricsReloaded</li>
<li>CamelCase</li>
<li>RestfulTool</li>
<li>statistic</li>
<li>Translation</li>
<li>vue.js</li>
</ol>
<p>IDE eval reset
jrebel and xrebel
camelcase</p>
<h2 id="idea的这八条配置你一定要改"> IDEA的这八条配置你一定要改！</h2>
<p>自动编译开关（代码完成-&gt; 区分大小写）</p>
<p>取消单行显示tabs的操作（编辑器-&gt;编辑器选项卡-&gt;在单行显示选项卡）</p>
<p>项目文件编码（编辑器-》文件编码）</p>
<p>滚轴修改字体大小（常规-》鼠标控制）</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="tool"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-03-13T16:47:56.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">kubernetes</title>
    <id>http://www.zhangsj.xyz/blog/tool/k8s/</id>
    <link href="http://www.zhangsj.xyz/blog/tool/k8s/"/>
    <updated>2022-02-26T01:14:14.000Z</updated>
    <content type="html"><![CDATA[<div><p>介绍</p>
<p>Docker 提供容器的生命周期管理，Docker 镜像构建运行时容器。</p>
<p>但是，由于这些单独的容器必须通信，因此使用 Kubernetes。因此，我们说 Docker 构建容器，这些容器通过 Kubernetes 相互通信。因此，可以使用 Kubernetes 手动关联和编排在多个主机上运行的容器。</p>
</div>
<h2 id="container-orchestration"> Container Orchestration</h2>
<p>一个应用程序有 5-6 个微服务的场景。现在，这些微服务被放在单独的容器中，但如果没有容器编排就无法进行通信。因此，由于编排意味着所有乐器在音乐中和谐共处，所以类似的容器编排意味着各个容器中的所有服务协同工作以满足单个服务器的需求。</p>
<h2 id="待完善"> 待完善</h2>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="tool"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-24T06:32:54.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">tool-content</title>
    <id>http://www.zhangsj.xyz/blog/tool/</id>
    <link href="http://www.zhangsj.xyz/blog/tool/"/>
    <updated>2022-02-26T14:37:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="工具目录"> 工具目录</h2>
<ul>
<li><a href="./git.html">gi</a></li>
<li><a href="./k8s.html">k8s</a></li>
<li><a href="./docker.html">docker</a></li>
<li><a href="./tool.html">代码注释</a></li>
<li><a href="./idea插件.html">idea插件</a></li>
<li><a href="./API开发调式神器Apipost.html">API开发调式神器Apipost</a></li>
</ul>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="mulu"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-24T06:32:54.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">frontend-content</title>
    <id>http://www.zhangsj.xyz/blog/vue/</id>
    <link href="http://www.zhangsj.xyz/blog/vue/"/>
    <updated>2022-03-17T16:44:46.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前端目录"> 前端目录</h2>
<ul>
<li><a href="./Typescript.html">Typescript</a></li>
<li><a href="./vue知识点.html">vue知识点1</a></li>
<li><a href="./常见的问题.html">vue知识点2</a></li>
<li><a href="./指令.html">vue指令</a></li>
</ul>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="mulu"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-24T06:03:53.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">code note</title>
    <id>http://www.zhangsj.xyz/blog/tool/tool/</id>
    <link href="http://www.zhangsj.xyz/blog/tool/tool/"/>
    <updated>2022-02-26T14:37:30.000Z</updated>
    <content type="html"><![CDATA[<p>代码注释中经常用到的 TODO、XXX、FIXME 有什么区别?</p>
<ol>
<li>TODO 等待实现的功能</li>
<li>FIXME 需要修正的功能</li>
<li>XXX 需要改进的功能</li>
</ol>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="tool"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-24T06:03:53.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">es6</title>
    <id>http://www.zhangsj.xyz/blog/vue/vue%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <link href="http://www.zhangsj.xyz/blog/vue/vue%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <updated>2022-02-26T03:15:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="es6"> es6</h2>
<p>一种通过重用组件构建类的方法。</p>
<p>不通过类的直接继承来实现，而是将基类作为接口来实现。对于基类实例化部分在子类中实现，基类中原型的部分在子类中进行声明占位，然后通过一个 Minxin 函数将基类上的原型属性拷贝到子类上。</p>
<h2 id="promise"> promise</h2>
<p>用来处理异步任务的一个对象，一个 Promise 对象有三个状态，resolved 异步任务执行成功，rejected 异步任务执行失败</p>
<h3 id="使用"> 使用</h3>
<p>初始化一个 Promise 对象
new Promise(fn)</p>
<p>然后调用上一步返回的 promise 对象的 then 方法，注册回调函数。</p>
<p>Then 中的回调函数可以有一个参数，也可以不带参数。如果 then 中的回调函数依赖上一步的返回结果，那么要带上参数。比如:</p>
<p>最后注册 catch 异常处理函数，处理前面回调中可能抛出的异常。</p>
<p>回调地狱带来的负面作用有以下几点：</p>
<p>处理一个异步网络请求</p>
<div><pre><code><span>请求1</span><span>(</span><span>function</span> <span>(</span><span>请求结果<span>1</span></span><span>)</span> <span>{</span>
  <span>请求2</span><span>(</span><span>function</span> <span>(</span><span>请求结果<span>2</span></span><span>)</span> <span>{</span>
    处理请求结果<span>2</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>代码臃肿。
可读性差。
耦合度过高，可维护性差。
代码复用性差。
容易滋生 bug。
只能在回调里处理异常。</p>
<p>比传统的异步解决方案【回调函数】和【事件】更合理、更强大。</p>
<div><pre><code><span>new</span> <span>Promise</span><span>(</span>请求<span>1</span><span>)</span>
  <span>.</span><span>then</span><span>(</span><span>请求2</span><span>(</span>请求结果<span>1</span><span>)</span><span>)</span>
  <span>.</span><span>then</span><span>(</span><span>请求3</span><span>(</span>请求结果<span>2</span><span>)</span><span>)</span>
  <span>.</span><span>then</span><span>(</span><span>请求4</span><span>(</span>请求结果<span>3</span><span>)</span><span>)</span>
  <span>.</span><span>then</span><span>(</span><span>请求5</span><span>(</span>请求结果<span>4</span><span>)</span><span>)</span>
  <span>.</span><span>catch</span><span>(</span><span>处理异常</span><span>(</span>异常信息<span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>比较一下这种写法和上面的回调式的写法。我们不难发现，Promise 的写法更为直观，并且能够在外层捕获异步函数的异常信息。</p>
<h3 id="promise-resolve-value"> Promise.resolve(value)</h3>
<p>类方法，该方法返回一个以 value 值解析后的 Promise 对象 1、如果这个值是个 thenable(即带有 then 方法)，返回的 Promise 对象会“跟随”这个 thenable 的对象，采用它的最终状态(指 resolved/rejected/pending/settled)
2、如果传入的 value 本身就是 Promise 对象，则该对象作为 Promise.resolve 方法的返回值返回。
3、其他情况以该值为成功状态返回一个 Promise 对象。</p>
<p>上面是 resolve 方法的解释，传入不同类型的 value 值，返回结果也有区别。这个 API 比较重要，建议大家通过练习一些小例子，并且配合上面的解释来熟悉它。如下几个小例子：</p>
<div><pre><code><span>//如果传入的 value 本身就是 Promise 对象，则该对象作为 Promise.resolve 方法的返回值返回。</span>
<span>function</span> <span>fn</span><span>(</span><span>resolve</span><span>)</span> <span>{</span>
  <span>setTimeout</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>resolve</span><span>(</span><span>123</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>3000</span><span>)</span><span>;</span>
<span>}</span>
<span>let</span> p0 <span>=</span> <span>new</span> <span>Promise</span><span>(</span>fn<span>)</span><span>;</span>
<span>let</span> p1 <span>=</span> Promise<span>.</span><span>resolve</span><span>(</span>p0<span>)</span><span>;</span>
<span>// 返回为true，返回的 Promise 即是 入参的 Promise 对象。</span>
console<span>.</span><span>log</span><span>(</span>p0 <span>===</span> p1<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="promise-prototype-then"> Promise.prototype.then</h3>
<p>实例方法，为 Promise 注册回调函数，函数形式：fn(vlaue){}，value 是上一个任务的返回结果，then 中的函数一定要 return 一个结果或者一个新的 Promise 对象，才可以让之后的 then 回调接收</p>
<h3 id="promise-prototype-catch"> Promise.prototype.catch</h3>
<p>实例方法，捕获异常，函数形式：fn(err){}, err 是 catch 注册 之前的回调抛出的异常信息。</p>
<h2 id="promise-的升级-async-await"> Promise 的升级 async / await</h2>
<p>Async/await 也是基于 Promise 实现的，</p>
<p>Async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="js"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2021-09-20T00:00:00.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">vue directives</title>
    <id>http://www.zhangsj.xyz/blog/vue/%E6%8C%87%E4%BB%A4/</id>
    <link href="http://www.zhangsj.xyz/blog/vue/%E6%8C%87%E4%BB%A4/"/>
    <updated>2022-03-17T16:44:46.000Z</updated>
    <content type="html"><![CDATA[<h2 id="directives"> directives</h2>
<p>表格临时回车跳转</p>
<div><pre><code>    <span>nextSelect</span><span>:</span> <span>{</span>
      <span>bind</span><span>:</span> <span>function</span> <span>(</span><span>el<span>,</span> <span>{</span> value <span>}</span><span>,</span> vnode</span><span>)</span> <span>{</span>
        el<span>.</span><span>onkeydown</span> <span>=</span> <span>function</span> <span>(</span><span>ev</span><span>)</span> <span>{</span>
          <span>if</span> <span>(</span>ev<span>.</span>keyCode <span>===</span> <span>13</span><span>)</span> <span>{</span>
            <span>let</span> nextInput <span>=</span> vnode<span>.</span>context<span>.</span>$refs<span>[</span>value<span>]</span>
            <span>if</span> <span>(</span>nextInput <span>&amp;&amp;</span> <span>typeof</span> nextInput<span>.</span>focus <span>===</span> <span>'function'</span><span>)</span> <span>{</span>
              nextInput<span>.</span><span>focus</span><span>(</span><span>)</span>
            <span>}</span> <span>else</span> <span>{</span>
            <span>}</span>
          <span>}</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>浅拷贝 ： 只是将数据中所有的数据引用下来，依旧指向同一个存放地址，拷贝之后的数据修改之后，也会影响到原数据的中的对象数据。例如:Object.assign(),...扩展运算符</p>
<p>深拷贝： 将数据中所有的数据拷贝下来，对拷贝之后的数据进行修改不会影响到原数据。</p>
<p>JSON.parse(JSON.stringify(obj))深拷贝的问题</p>
<p>JSON.parse(JSON.stringify(obj))深拷贝的问题</p>
<ol>
<li>如果 obj 里面存在时间对象,JSON.parse(JSON.stringify(obj))之后，时间对象变成了字符串。</li>
<li>如果 obj 里有 RegExp、Error 对象，则序列化的结果将只得到空对象。</li>
<li>如果 obj 里有函数，undefined，则序列化的结果会把函数， undefined 丢失。</li>
<li>如果 obj 里有 NaN、Infinity 和-Infinity，则序列化的结果会变成 null。</li>
<li>JSON.stringify()只能序列化对象的可枚举的自有属性。如果 obj 中的对象是有构造函数生成的， 则使用 JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的 constructor。</li>
<li>如果对象中存在循环引用的情况也无法正确实现深拷贝。</li>
</ol>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="js"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-22T05:00:12.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">vuequestion</title>
    <id>http://www.zhangsj.xyz/blog/vue/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <link href="http://www.zhangsj.xyz/blog/vue/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <updated>2022-02-26T01:14:14.000Z</updated>
    <content type="html"><![CDATA[<h2 id="vue-常见问题"> vue 常见问题</h2>
<h2 id="spa"> SPA</h2>
<p>单页应用</p>
<p>仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。</p>
<p>一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转，利用路由机制实现 HTML 内容的变换来代替，UI 与用户的交互，避免页面的重新加载。</p>
<p>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
基于上面一点，SPA 相对对服务器压力小；
前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</p>
<h3 id="缺点"> 缺点</h3>
<p>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</p>
<p>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</p>
<h3 id="v-show-与-v-if"> v-show 与 v-if</h3>
<p>V-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>
<p>V-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。</p>
<h3 id="computed-和-watch"> computed 和 watch</h3>
<p>Computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；</p>
<p>Watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p>
<h2 id="vue-生命周期"> Vue 生命周期</h2>
<p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p>
<table>
<thead>
<tr>
<th style="text-align:center">生命周期</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">beforeCreate</td>
<td>组件实例被创建之初，组件的属性生效之前</td>
</tr>
<tr>
<td style="text-align:center">created</td>
<td>组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用</td>
</tr>
<tr>
<td style="text-align:center">beforeMount</td>
<td>在挂载开始之前被调用：相关的 render 函数首次被调用</td>
</tr>
<tr>
<td style="text-align:center">mounted</td>
<td>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</td>
</tr>
<tr>
<td style="text-align:center">beforeUpdate</td>
<td>组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td>
</tr>
<tr>
<td style="text-align:center">update</td>
<td>组件数据更新之后</td>
</tr>
<tr>
<td style="text-align:center">activited</td>
<td>keep-alive 专属，组件被激活时调用</td>
</tr>
<tr>
<td style="text-align:center">deactivated</td>
<td>keep-alive 专属，组件被销毁时调用</td>
</tr>
<tr>
<td style="text-align:center">beforeDestory</td>
<td>组件销毁前调用</td>
</tr>
<tr>
<td style="text-align:center">destoryed</td>
<td>组件销毁后调用</td>
</tr>
</tbody>
</table>
<h2 id="哪个生命周期内调用异步请求"> 哪个生命周期内调用异步请求</h2>
<p>可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点</p>
<p>能更快获取到服务端数据，减少页面 loading 时间；
服务端渲染不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</p>
<h2 id="在什么阶段才能访问操作-dom"> 在什么阶段才能访问操作 DOM</h2>
<p>在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM。V</p>
<h2 id="父子通信"> 父子通信</h2>
<ol>
<li>
<p>$emit props 触发父组件的事件</p>
</li>
<li>
<p>ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</p>
</li>
<li>
<p>EventBus (emit /on) 适用于 父子、隔代、兄弟组件通信</p>
</li>
<li>
<p>Vuex 适用于 父子、隔代、兄弟组件通信</p>
</li>
<li>
<p>provide / inject 适用于 隔代组件通信</p>
</li>
</ol>
<p><a href="https://www.jianshu.com/p/9f460e66ce01" target="_blank" rel="noopener noreferrer">参考</a></p>
<h2 id="keep-alive"> keep-alive</h2>
<p>Keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p>
<p>一般结合路由和动态组件一起使用，用于缓存组件；</p>
<p>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；</p>
<p>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="js"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-22T13:39:52.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
  <entry>
    <title type="html">Typescript</title>
    <id>http://www.zhangsj.xyz/blog/vue/Typescript/</id>
    <link href="http://www.zhangsj.xyz/blog/vue/Typescript/"/>
    <updated>2022-02-26T14:37:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="typescript"> TypeScript</h2>
<div><p>介绍</p>
<p>TypeScript 是强类型的 JavaScript 超集，支持 ES6 语法，支持面向对象编程的概念，如类、接口、继承、泛型等。</p>
<p>TypeScript 并不直接在浏览器上运行，需要编译器编译成纯 JavaScript 来运行。</p>
<p>支持泛型，es6 语法，强类型和静态类型</p>
</div>
<p>1：快速简单，易于学习。
2：编译时提供错误检查， 在代码运行前就会进行错误提示。
3：支持所有的 JS 库。
4：支持 ES6，提供了 ES6 所有优点和更高的生产力。
5：使用继承提供可重用性。
6：有助于代码结构。
7：通过定义模块来定义命名空间。</p>
<p>1：需要长时间的来编译代码。
2：在使用第三方库时，需要有三方库的定义文件，并不是所有三方库都提供了定义文件，提供的定义文件是否准确也值得商榷。</p>
<h2 id="基本数据类型"> 基本数据类型</h2>
<h3 id="js"> js</h3>
<p>基本数据类型:Undefined、Null、Boolean、Number、String,Symbol 引用数据类型 :Object</p>
<h3 id="ts"> ts</h3>
<p>1：number
2：string
3：boolean
4：Symbol
5：Array
6：Tuple(元组)
7：enum(枚举)
8：object
9：never
表示那些永不存在的值类型。如总是抛出异常或者根本不会有返回值的函数的返回值类型。
10：void
与 any 相反表示没有任何类型。函数没有返回值时用 void。
11：null 和 undefined
它们是所有类型的子类型。当你指定 structNullChecks 时，它们只能赋值给 void 或者它们自己本身。
12：any</p>
]]></content>
    <author>
      <name>zhangsj</name>
    </author>
    <category term="js"/>
    <contributor>
      <name>zhangsj</name>
    </contributor>
    <published>2022-02-22T13:39:52.000Z</published>
    <rights>Copyright by zhangsj</rights>
  </entry>
</feed>