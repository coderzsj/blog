重载和重写的区别

重载

a

a

override

## 1.8、网络/IO基础

BIO：
BIO 其实就是IO，文件读写，scoket通信，都是io操作

BIO又被称为阻塞式I/O模型，那为什么会被叫做这个名字呢，原因就是BIO的特性是同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，处理完成后返回应答给客户端，也就是经典的请求－应答通信模型。但是随着客户端并发量上升，服务端的线程数膨胀，系统性能急剧下降，最终会导致系统不可用。这种模型无法满足高并发，高性能的场景。

它的具体通信流程为：

（1）服务器监听

服务器监听：是服务端scoket并不定位具体的客户端scoket，而是处于等待连接的状态，实时监控网络的状态

（2）客户端请求服务器

客户端请求：是指由客户端的scoket提出连接请求，要连接的目标是服务器端的scoket。为此，客户端的scoket必须首先描述它要连接的服务器的scoket，指出服务器scoket的地址和端口号，然后就想服务器端scoket提出连接请求

说说 SQL 优化之道

void use select *

很多时候，我们写sql时，直接使用select * ，一次性查处表中所有列的数据。

内存或者CPUss

网络io传输的过程中，也会增加数据传输的时间。

不会走覆盖索引，会出现大量的回表操作，

用union all 代替union

小标驱动大表

## buffer - 缓冲区

buffer是一个对象，它包含一些要写入或者要读取的数据。在NIO类库中加入Buffer对象，体现了新库与原IO的一个重要的区别。

在面向流的IO中，可以将数据直接写入或读取到Stream中。在NIO库中，所有的数据都是用缓冲区处理的（读写）。缓冲区实质上是一个数组，通常它是一个字节数组（ByteBuffer)，这个字节输出同时存储输入及输出数据，当然也可以使用其他类型的数组，这个数组为缓冲区提供了数据的访问读写等操作属性，如位置，容量，上限等概念。

Buffer类型：我们最常用的ByteBuffer，实际上每一种Java基本类型都对应了一种缓冲区（除了BOOlean类型）

## 通道（Channel）

通道（Channel），也被称为管道，它就像自来水管道一样，网络数据通过Channel读取和写入，通道与流不同之处在于通道是双向的，而流只是一个方向上向移动（一个流必须是inputStream或者outputStream的子类），而通道可以用于读，写或者二者同时进行，最关键的是可以与多路复用器结合起来，有多钟的状态位，方便多路复用器去识别，以此执行不同的handler。

事实上通道分为两大类，一类是网络读写的（SelectableChannel),一类是用于文件操作的（FileChannel），我们通常使用的Socket和ServerSockerChannel都是SelectableChannel的子类。

## 多路复用器（selector）

多路复用器，它是NIO编程的基础，非常重要，多路复用器提供选择已经就绪的任务的能力。

意思就是Selector会不断的轮询注册在其上的通道，如果每个通道发生了读写操作，这个通道就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以取得就绪的Channel集合。从而进行后续的IO操作。

总结起来，selector线程就类似于一个管理者，管理了成千上万个管道，然后轮询哪个管道的数据已经准备好，通知CPU执行IO的读取或写入操作。

Selector模式：当IO事件注册到选择器以后，selector会分配给每个通道一个key值，相当于标签。selector选择器是以轮询的方式进行查找注册的所有通道。

当我们的IO事件（通道）准备就绪后，selector就会识别，会通过Key值来找到相应的管道，进行相关的数据处理操作（从通道读或写数据，写入我们的数据缓冲区中）。

一个多路复用器（selector）可以负责成千上万个Channel，效率比起BIO大大的提升了，由于JDK使用了epoll代替传统的select实现，所以没有最大连接句柄1024/2048的限制，这也意味着我们只要一个线程负责selector的轮询，就可以接入成千上万个客户端，这是JDK，NIO库的巨大进步。

但是NIO也有自己的缺点，NIO会等数据准备好后，再交由应用进行处理，数据的读取写入过程依然在应用线程中完成，只是将等待的时间剖离到单独的线程中去，节省了数据准备时间，因为多路复用机制，channel会得到复用，对于那些读写过程时间长的，NIO就不打适合。

但是，我们需要注意，虽然说NIO是非阻塞的，但是，selector中的selector.select()，是阻塞的，所以，你是不是有什么有趣的想法呢？例如，把selector这个线程，也是用线程池来分配。

分布式系统消息系统的对比：

## 二、Kafka基本架构

它的架构包括以下组件：

1、话题（Topic）：是特定类型的消息流。消息是字节的有效负载（Payload），话题是消息的分
