---
title: Java性能优化之字符串优化处理
icon: string
category: java基础
tag:
  - string
---

## String不可变吗？

由于缓存的字符串在多个客户之间共享，因此始终存在风险，其中一个客户的操作会影响所有其他客户。

例如，如果一段代码将 String “Test” 的值更改为 “TEST”，则所有其他客户也将看到该值。由于 String 对象的缓存是性能的重要保证，因此通过使 String 类不可变来避免这种风险。同时，String 是 final 的，因此没有人可以通过扩展和覆盖行为来破坏 String 类的不变性、缓存、散列值的计算等。String 类不可变的另一个原因可能是由于 HashMap。

由于把字符串作为 HashMap 键很受欢迎。对于键值来说，不可变性是非常的重要，以便用它们检索存储在 HashMap 中的值对象。由于 HashMap 的工作原理是散列，因此需要具有相同的值才能正常运行。如果在插入后修改了 String 的内容，可变的 String 将在插入和检索时生成两个不同的哈希码，可能会丢失 Map 中的值对象。

String是数据类型，也传输对象和中间人。这种多重角色的重要性和流行性，也使这个问题在 Java 面试中很常见。

1. 想象字符串池没有使字符串不可变，它根本不可能，因为在字符串池的情况下，一个字符串对象/文字，例如 “Test” 已被许多参考变量引用，因此如果其中任何一个更改了值，其他参数将自动受到影响，即假设

```java
String A="Test";String B="Test";
```

现在字符串 B 调用 "Test".toUpperCase(), 将同一个对象改为“TEST”，所以 A 也是 “TEST”，这不是期望的结果。

2. 字符串已被广泛用作许多 Java 类的参数，例如，为了打开网络连接，你可以将主机名和端口号作为字符串传递，你可以将数据库 URL 作为字符串传递, 以打开数据库连接，你可以通过将文件名作为参数传递给 File I/O 类来打开 Java 中的任何文件。

如果 String 不是不可变的，这将导致严重的安全威胁，我的意思是有人可以访问他有权授权的任何文件，然后可以故意或意外地更改文件名并获得对该文件的访问权限。

由于不变性，你无需担心这种威胁。这个原因也说明了，为什么 String 在 Java 中是最终的，通过使`java.lang.String`final，Java设计者确保没有人覆盖 String 类的任何行为。

3. 由于 String 是不可变的，它可以安全地共享许多线程，这对于多线程编程非常重要. 并且避免了 Java 中的同步问题，不变性也使得String 实例在 Java 中是线程安全的，这意味着你不需要从外部同步 String 操作。

4. 为什么`String`在Java中是不可变的另一个原因是允许String缓存其哈希码，Java中的不可变String缓存其哈希码，并且不会在每次调用String的`hashcode`方法时重新计算，这使得它在Java中的HashMap中使用的HashMap键非常快。

简而言之，因为String是不可变的，所以没有人可以在创建后更改其内容，这保证了String的hashCode在多次调用时是相同的。

5. String不可变的绝对最重要的原因是它被类加载机制使用，因此具有深刻和基本的安全考虑。如果String是可变的，`java.io.Writer`的请求可能已被更改为加载“`mil.vogoon.DiskErasingWriter`”.

譬如你想加载`java.sql.Connection`类，而这个值被改成了`myhacked.Connection`，那么会对你的数据库造成不可知的破坏。

安全性和字符串池是使字符串不可变的主要原因。

p：顺便说一句，上面的理由很好回答另一个Java面试问题: “为什么String在Java中是最终的”。要想是不可变的，你必须是最终的，这样你的子类不会破坏不变性。你怎么看？


```java
public class Test {
    public static void main(String[] args) {
        String a = "111";
        a = "222";
        System.out.println(a);
    }
}
```

有的人会认为上面这段代码应该输出：111，但输出的值是222

这不对呀，不是不变吗？怎么变了呢？ 其实在JVM的运行中，会单独给一块地分给String。

上面的：

```java
Stirng a="111"；
```

我们知道字符串的分配和其他对象分配一样，是需要消耗高昂的时间和空间的，而且字符串我们使用的非常多。JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：

使用字符串常量池。每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性我们可以十分肯定常量池中一定不存在两个相同的字符串。

这里先去JVM给常量池里找，找到了就不用创建对象了，直接把对象的引用地址赋给a。找不到会重新创建一个对象，然后把对象的引用地址赋给a。同理a="222";也是先找，找不到就重新创建一个对象，然后把对象的引用地址赋给a。

大家有没有发现我上面的描述中“引用地址”。比如说`Object obj = new Object();`很多人喜欢成obj为对象，其实obj不是对象，他只是一个变量，然后这个变量里保存一个Object对象的引用地址罢了。

引用类型声明的变量是指该变量在内存中实际存储的是一个引用地址，实体在堆中。

## 字符串常量池详解

在JVM中，为了减少字符串对象的重复创建，维护了一块特殊的内存空间，这块内存空间就被称为字符串常量池。

在JDK1.6及之前，字符串常量池存放在方法区中。到JDK1.7之后，就从方法区中移除了，而存放在堆中。一下是《深入理解虚Java虚拟机》第二版原文：

对于HotSpot 虚拟机，根据官方发布的路线图信息，现在也有放弃永久代并逐步改为采用Native Memory来实现方法区的规划了，在目前已经发布的JDK1.7 的HotSpot中，已经把原本放在永久代的字符串常量池移出。

根据查阅的资料显示在JDK1.7以后的版本中字符串常量池移到堆内存区域；同时在jdk1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域

创建字符串对象的两种方法

1. 直接使用双引号声明出来的String对象会直接储存在常量池中。
2. 使用new方法创建出来的String对象，可以使用String提供的intern方法。`intern`方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。

```java
class Test{
    public static void main(String[] args){
        String s1 = "abc";
        String s2 = "abc";
        System.out.println(s1);//abc
        System.out.println(s1 == s2);//true

        char[] charArray = {'a','b','c'};
        String s3 = new String(charArray);
        System.out.println(s3);//abc
        System.out.println(s1 == s3);//false
    }
}

```

从结果看，两个布尔值的结果不相同，虽然两个输出两个字符串的结果相同，都为abc，但比较两者时则不同，这是因为引用类型比较时，比较的是其地址值；不同于基本数据类型比较的是其数据值。

双引号声明的方法创建字符串对象，JVM首先会去字符串常量池中查找是否存在"abc"这个对象，如果存在，直接将存在的“abc”的地址返回给对象s2，如果不存在，则在字符串常量池中创建”abc“这个对象并返回其引用地址返回给对象s1。

而通过new方法创建的String对象，其创建的字符串是放在堆当中的，将堆当中的字符串地址返回赋值给s3，s1和s3的存放位置不同，一个在字符串常量池中，一个在堆中，因此返回的值是false。

由于String字符串的不可变性我们可以十分肯定常量池中一定不存在两个相同的字符串。
```java
User user = new User()
```

创建了一个user对象，老喜欢把user称之为对象。这里不接受反驳。

所以上面`String a = "111";`表达的是变量a里保存了“111”，这个对象的引用地址。变量是可以变的，不能变的是“111”。

## String 为什么是不可变的？

String对象还有一个方法`intern`（可惜是个本地方法，不能看到内部如何实现的），这个方法可以动态的扩展运行时常量池。

当调用 intern 方法时，如果池已经包含一个等于此 String 对象的字符串（用 equals(Object) 方法确定），则返回池中的字符串。否则，将此 String 对象添加到池中，并返回此 String 对象的引用。
