---
title: MySQL事务
icon: shiwu
category: mysql
date: 2022-02-28
tag:
  - mysql
  - 事务
description: MySQL事务
---

## mysql特性

原子性：事务是一个不可分割的工作单位，事务中的操作要么都成功（commit），要么都失败（rollback）。

一致性：事务前后数据的完整性必须保持一致。 事务执行的结果必须使数据库从一个一致性状态变到另一个一致性的状态。在多个事务并行情况下；

持久性：指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。

隔离性： 事务的隔离性是多个事务并行，每个事务不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。

## mysql事务隔离级别

|事务隔离级别|概念|
|:--: | --- |
|read uncommitted(未提交读)|允许当前事务读取到其他事务未提交的数据,会出现脏读、不可重复读、幻读|
|read committed(读已提交)|对事务已经提交的数据进行读取，解决了脏读。会出现幻读和不可重复读|
|repeatable read(可重复读)|在同一个事务中，对相同查询条件，读取数据都是一致的。该级别会出现幻读|
|serializable(串行化)|完全服从数据库的ACID，读写数据都会锁住在事务中涉及到的数据库表，并发性能极低|

MySQL 默认使用 RR 的事务隔离级别。

- 脏读：没有提交就可以读取到数据；
- 不可重复读：再重复读一次，数据与上次读到的数据不一样；
- 幻读：在查询某一条件的数据，开始查询后，别人又加入或删除某些数据，再读取时与原来的数据不一样了。

不可重复读形成原因在于数据的修改：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）。

幻读形成原因主要在于数据的新增或删除：在同一事务中，同样的条件，第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）。

### redo log

redo log是重做日志，提供前滚操作，

记录的是数据修改之后的值，不管事务是否提交都会记录下来。在mysql服务器宕机时，InnoDB存储引擎会使用redo log恢复到掉电前的时刻，以此来保证数据的完整性。

### undo log

undo log是回滚日志，提供回滚操作。

保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读

### binlog

binlog是追加日志,又称为归档日志，属于逻辑日志，

binlog是属于MySQL Server层面的，又称为归档日志，属于逻辑日志，是记录原始的sql语句，逻辑

不支持高并发，以读为主

共享锁，排它锁，意向锁

## mvvc实现原理

MVCC (`Multi-Version Concurrency Control`) (注：与MVCC相对的，是基于锁的并发控制，`Lock-Based Concurrency Control`)是一种基于多版本的并发控制协议，只有在`InnoDB`引擎下存在。 `MVCC`是为了实现事务的隔离性，通过版本号，避免同一数据在不同事务间的竞争，你可以把它当成基于多版本号的一种乐观锁。 当然，这种乐观锁只在事务级别提交读和可重复读有效。`MVCC`最大的好处，相信也是耳熟能详：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大地增加了系统的并发性能。

::: info OLTP

`On-Line Transaction Processing`联机事务处理过程(OLTP)，也称为面向交易的处理过程，其基本特征是前台接收的用户数据可以立即传送到计算中心进行处理，并在很短的时间内给出处理结果，是对用户操作快速响应的方式之一。

:::

你可以简单的理解为MVCC为每一行增加了两个隐藏字段，两个字段分别保存了这个行的当前事务ID跟行的删除事务ID。

**1、insert时：**

`InnoDB`为新插入的每一行保存当前系统版本号作为版本号。

**2、select时：**

1. `InnoDB`只会查找版本早于当前事务版本的数据行(也就是行的系统版本号<=事务的系统版本号)，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。
2. 行的删除版本要么未定义，要么大于当前事务版本号，这可以确保事务读取到的行在事务开始之前未被删除。
3. 只有1，2 同时满足的记录，才能返回作为查询结果。

**3、delete时：**

InnoDB会为删除的每一行保存当前系统的版本号(事务的ID)作为删除标识.

**4、`update`时：**

`InnoDB`执行`update`，实际上是新插入了一行记录，并保存其创建时间为当前事务的ID，同时保存当前事务ID到要update的行的删除时间。

上面只是一个浅显地讲解`MVCC`选择标准流程，源码层面应该是根据低水位跟高水位来截取的。具体实现可自行百度。

重点：

1. 事务中快照读的结果是非常依赖该事务首次出现快照读的地方，即某个事务中首次出现快照读的地方非常关键，它有决定该事务后续快照读结果的能力。
2. 在`RC`隔离级别下，是每个快照读都会生成并获取最新的`ReadView`；而在`RR`隔离级别下，则是同一个事务中的第一个快照读才会创建`ReadView`, 之后的快照读获取的都是同一个`ReadView`。

四个隐式字段：

1. `DB_TRX_ID`：6byte，最近修改(修改/插入)事务ID，记录创建这条记录/最后一次修改该记录的事务ID；
2. `DB_ROLL_PTR`：7byte，回滚指针，指向这条记录的上一个版本（存储于`rollback segment`里）；
3. `DB_ROW_ID`：6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以`DB_ROW_ID`产生一个聚簇索引；
4. `FLAG`：一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了；

事务对一条记录的修改，会导致该记录的undo log成为一条记录版本线性表(链表)，undo log的链首就是最新的旧记录，链尾就是最早的旧记录。

undo日志：此知识点上文已经说过了，对MVCC有帮助的实质是`update undo log`，`undo log`实际上就是存在`rollback segment`中旧记录链。

一致读视图 `Consistent Read View`：`Read View`是事务进行快照读操作的时候生产的读视图(`Read View`)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(InnoDB里面每个事务有一个唯一的事务ID，叫作transaction id。它是在事务开始的时候向InnoDB的事务系统申请的，是按申请顺序严格递增的)。拿着这个ID跟记录中ID对比进行选择性展示，这里说下大致的思维。


## 当前读

1. 像`select lock in share mode`(共享锁)、`select for update` 、`update`、`insert`、`delete`(排他锁)这些操作都是一种当前读，就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会**对读取的记录进行加锁**。
2. 当前读可以认为是悲观锁的具体功能实现

### 快照读

1. 不加锁的`select`就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC，可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。
2. 快照读就是`MVCC`思想在MySQL的具体非阻塞读功能实现，`MVCC`的目的就是为了实现读-写冲突不加锁，提高并发读写性能，而这个读指的就是快照读。

