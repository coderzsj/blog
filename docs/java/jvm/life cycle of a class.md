## 类的生命周期

## 七大阶段

类从被加载到虚拟机内存中开始，到卸载出内存为止，加载、验证、准备、解析、初始化、使用、卸载七个阶段。其实验证、准备、解析三个部分统称为连接。


加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、 初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3个部分统称为连接（Linking）

```flow
loading=>operation: 加载
verification=>operation: 验证
preparation=>operation: 准备
resolution=>operation: 解析
initialization=>operation: 初始化
using=>operation: 使用
unloading=>operation: 卸载

loading(right)->verification(right)->preparation(right)->resolution(right)->initialization(right)->using(right)->unloading
```

2. 阶段顺序

加载、校验、准备、初始化和卸载这五个阶段的顺序是确定的，但是对于“解析”阶段则不一定，它在某些情况下可以在初始化之后再开始，这样做是 为了支持 java 的运行时绑定特征（也称为动态绑定或晚期绑定）。

3. 加载的时机

什么是需要开始类第一个阶段“加载”，虚拟机规范没有强制约束，这点交给虚拟机的具体实现来自由把控。 “加载 loading”阶段是整个类加载（class loading）过程的一个阶段。

加载阶段虚拟机需要完成以下3件事情：

- 通过一个类的全限定名来获取定义此类的二进制字节流。
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
- 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。

注意：比如“通过一个类的全限定名来获取定义此类的二进制字节流”没有指定一定得从某个class文件中获取，所以我们可以从zip压缩包、从网络中 获取、运行时计算生成、数据库中读取、或者从加密文件中获取等等。
我们也可以通过前面的工具JHSD可以看到，JVM 启动后，相关的类已经加载进入了方法区，成为了方法区的运行时结构。

Attarch上JVM启动的进程

### 4.验证

验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。但从整体 上看，验证阶段大致上会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证.

4.1 文件格式验证
第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点:

是否以魔数OxCAFEBABE开头。
主、次版本号是否在当前Java虚拟机接受范围之内。
常量池的常量中是否有不被支持的常量类型(检查常量tag标志)。
指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。
CONSTANT Utf8 info型的常量中是否有不符合UTF-8编码的数据。
Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。
…
以上的部分还只是一小部分，没必要进行深入的研究
这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进人Java虚拟机内存的方法区中进行存储，所以后面 的三个验证阶段全部是基于方法区的存储结构（内存）上进行的，不会再直接读取、操作字节流了

4.2 元数据验证
第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java 语言规范》的要求，这个阶段可能包括的验证点如下:

这个类是否有父类(除了java.lang.Object之外，所有的类都应当有父类)。
这个类的父类是否继承了不允许被继承的类(被final修饰的类)。
如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。
类中的字段、方法是否与父类产生矛盾(例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都-致，但返回值类型却不同等)。
…
以上的部分还只是一小部分，没必要进行深入的研究。
元数据验证是验证的第二阶段，主要目的是对类的元数据信息进行语义校验，保证不存在与《Java语言规范》定义相悖的元数据信息。

4.3 字节码验证
字节码验证第三阶段是整个验证过程中最复杂的一一个阶段， 主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。在第二 阶段对元数据信息中的数据类型校验完毕以后，这阶段就要对类的方法体(Class文件中的Code属性)进行校验分析，保证被校验类的方法在运行时不会做 出危害虚拟机安全的行为，例如:

保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作栈放置了一个int类型的数据，使用时却按long类型 来加载入本地变量表中”这样的情况。
保证任何跳转指令都不会跳转到方法体以外的字节码指令上。
保证方法体中的类型转换总是有效的，例如可以把-个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对 象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。
…
以上的部分还只是一小部分，没必要进行深入的研究。
如果一个类型中有方法体的字节码没有通过字节码验证，那它肯定是有问题的
4.4 符号引用验证
最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段一解析阶段中发生。符号引用验证可以看 作是对类自身以外(常量池中的各种符号引用)的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。本阶段通常需要校验下列内容:

符号引用中通过字符串描述的全限定名是否能找到对应的类。
在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。
符号引用中的类、字段、方法的可访问性( private、 protected. public、 )
是否可被当前类访问。
…
符号引用验证的主要目的是确保解析行为能正常执行，如果无法通过符号引用验证，将会抛出异常
验证（总结）
验证阶段对于虚拟机的类加载机制来说，是一个非常重要的、 但却不是必须要执行的阶段，因为验证阶段只有通过或者不通过的差别，只要通过了验证， 其后就对程序运行期没有任何影响了。如果程序运行的全部代码(包括自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码)都已经被反复 使用和验证过，在生产环境的实施阶段就可以考虑使用-Xverify:none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

### 5. 准备

准备阶段是正式为类中定义的变量（被static修饰的变量）分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。

这个阶段中有两个容易产生混淆的概念需要强调一下：

首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。
其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：
public static int value=123；
那变量value在准备阶段过后的初始值为0而不是 123，因为这时候尚未开始执行任何 Java方法，而把value赋值为123是后续的初始化环节.

### 6. 解析

解析阶段是JVM将常量池内的符号引用替换为直接引用的过程。

符号引用是一种定义，可以是任何字面上的含义，而直接引用就是直接指向目标的指针、相对偏移量。

直接引用的对象都存在于内存中，你可以把通讯录里的女友手机号码，类比为符号引用，把面对面和你吃饭的女朋友，类比为直接引用。 解析大体可以分为：

-类或接口的解析
-字段解析
-类方法解析
-接口方法解析

我们了解几个经常发生的异常，就与这个阶段有关。

- `java.lang.NoSuchFieldError`根据继承关系从下往上，找不到相关字段时的报错。（字段解析异常）
- `java.lang.IllegalAccessError`字段或者方法，访问权限不具备时的错误。（类或接口的解析异常）
- `java.lang.NoSuchMethodError`找不到相关方法时的错误。（类方法解析、接口方法解析时发生的异常）

### 7. 初始化

初始化主要是对一个`class`中的`static{}`语句进行操作（对应字节码就是`clinit`方法）。
`<clinit>()`方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成`<clinit>()`方法。
   初始化阶段，虚拟机规范则是严格规定了有且只有6种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：

1. 遇到`new`、`getstatic`、`putstatic`或`invokestatic`这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的`Java`代码场景是：
使用`new`关键字实例化对象的时候。
读取或设置一个类的静态字段（被`final`修饰、已在编译期把结果放入常量池的静态字段除外）的时候
调用一个类的静态方法的时候。
2. 使用`java.lang.reflect`包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含`main()`方法的那个类），虚拟机会先初始化这个主类。
5. 当使用JDK1.7的动态语言支持时，如果一个`java.lang.invoke.MethodHandle`实例最后的解析结果`REF_getStatic`、`REF_putStatic`、`REF_invokeStatic`的方法 句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。
6. 当一个接口中定义了`JDK1.8`新加入的默认方法（被`default`关键字修饰的接口方法）时，如果这个接口的实现类发生了初始化，那该接口要在其之前 被初始化。
