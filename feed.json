{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "ShijingSpace",
  "home_page_url": "http://www.zhangsj.xyz/blog/",
  "feed_url": "http://www.zhangsj.xyz/blog/feed.json",
  "description": "Java学习&&面试指南",
  "items": [
    {
      "title": "费曼技巧：最强的学习方法",
      "url": "http://www.zhangsj.xyz/blog/tool/feynman-technique.html",
      "id": "http://www.zhangsj.xyz/blog/tool/feynman-technique.html",
      "content_html": "<h1 id=\"费曼技巧-最强的学习方法\" tabindex=\"-1\"> 费曼技巧：最强的学习方法</h1>\n<ol>\n<li>choose conception</li>\n<li>noob</li>\n<li>Encounter problems，recheck the material</li>\n<li>Simplify your language</li>\n</ol>\n",
      "date_published": "2022-05-24T07:59:53.000Z",
      "date_modified": "2022-05-24T09:00:04.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "精英都是方法控，做人做事必备的100套思维框架工具",
      "url": "http://www.zhangsj.xyz/blog/tool/thinking-framing-tool.html",
      "id": "http://www.zhangsj.xyz/blog/tool/thinking-framing-tool.html",
      "content_html": "<h2 id=\"前言\" tabindex=\"-1\"> 前言</h2>\n<p>精英都是高手，他们无论思考什么还是从事什么，都逻辑严谨、条理清晰、重点突出。</p>\n<p>普通人则不一样，他们喜欢天马行空，思考和做事没有任何章法，随心所欲。他们偶尔会超常发挥，大部分时间却表现得一塌糊涂，输出极为不稳定。</p>\n<p>很多人误以为，这只不过是精英的智商高而已。其实不然，人与人的智商差别完全没有想像地那么大，远远不足以拉开人与人的距离。如果你观察得够仔细，你一定会发现工作中有很多精英其实是资质平常的人，他们根本谈不上聪明。</p>\n<p>他们之所以能成为精英，绝不是智商商，而是因为他们掌握了正确的方法。无论他们思考什么和沟通什么，都有自己的一套方法。他们所谓的严谨和条理，不过是方法的外在表现而已。一切皆有方法，做任何事都讲究方式和方法，让他们在人生的高效快速，远远超过普通人。</p>\n<p>本专栏收集了100套思维框架工具，可以适用于工作和生活的方面，旨在提高大家的思考质量和做事的方式。专栏涵盖时间、沟通、阅读、思考、笔记、工作等多个领域，每一个领域都提供了多套思维工具方法。</p>\n<h2 id=\"一-时间思维工具\" tabindex=\"-1\"> 一.时间思维工具</h2>\n<ol>\n<li>四象时间管理：分清每一件事情</li>\n<li>8020 时间管理原则：做最有价值的事情</li>\n<li>GT时间管理法则：把事情做完</li>\n<li>ZT时间管理法则：终极简单的效率系统</li>\n<li>柳比夫时间管理法：记录你的时间</li>\n<li>番茄作法：高效实用的时间管理方法</li>\n<li>清单作法：让复杂工作变简单</li>\n<li>精力理：建立个人精力管理系统</li>\n</ol>\n<h2 id=\"二-沟通思维工具\" tabindex=\"-1\"> 二.沟通思维工具</h2>\n<ol>\n<li>乔哈里视窗：沟通什么最有效</li>\n<li>PREP原则：清晰表达自己的观点</li>\n<li>STAR沟通法则：面试怎么说明自己的个人成就</li>\n<li>关键沟通七原则：如何解决难题，不伤感情</li>\n<li>即兴发言四大原则：做一个合格的发言者</li>\n<li>即兴发言万能公式01：告别语无伦次</li>\n<li>即兴发言万能公式02：告别语无伦次</li>\n<li>即兴发言万能公式03：告别语无伦次</li>\n<li>回答问题的发言公式01：让方案更有说服力</li>\n<li>回答问题的发言公式02：让方案更有说服力</li>\n<li>回答问题的发言公式03：让方案更有说服力</li>\n<li>回答问题的发言公式04：让方案更有说服力</li>\n<li>SCRTV表达：把你的思想装进别人的脑袋里</li>\n<li>FFC赞美法则：简单使用的赞美方法</li>\n<li>上堆下切平移沟通法</li>\n<li>沟通黄金三点论：快速即兴构思</li>\n<li>FIRE模型：用事实说话</li>\n<li>钩子表达法则：临场讲话有套路</li>\n<li>RIDE说服模型：改变他人的决定</li>\n<li>FABE销售法则：行销百万的说服公式</li>\n<li>SPIN销售法：顾问式销售技巧</li>\n<li>ADISC建设性反馈:怎么反馈最有效</li>\n<li>非暴力沟通：告别爱吵架的沟通之术</li>\n</ol>\n<h2 id=\"三-目标思维工具\" tabindex=\"-1\"> 三.目标思维工具</h2>\n<ol>\n<li>SMART原则：管理你的目标</li>\n<li>MORS法则：所有目标都可被执行</li>\n<li>目标多杈树法：分解你的目标</li>\n<li>6W3H目标管理：分析细化目标</li>\n</ol>\n<h2 id=\"四-思考管理工具\" tabindex=\"-1\"> 四.思考管理工具</h2>\n<ol>\n<li>六顶思考帽：全面创意思考工具</li>\n<li>5Why思考法：探究问题的本质</li>\n<li>CAF思考法：考虑所有因素</li>\n<li>RAD决策：如何认识一件事物</li>\n<li>PMI：发现兴趣点</li>\n<li>MECE法则：麦肯锡思考术</li>\n<li>C&amp;S决策：推演结果和结局</li>\n<li>DOCA：决策量化</li>\n<li>PrOACT决策模型：决策是一套流程</li>\n<li>WRAP决策模型：掌握关键决策</li>\n<li>KT决策法：最负盛名的决策模型</li>\n<li>麦肯锡方法：解决问题的七个步骤</li>\n<li>ORID模型：深层次思考</li>\n<li>U型思考：本质思考法</li>\n</ol>\n<h2 id=\"五-工作管理工具\" tabindex=\"-1\"> 五.工作管理工具</h2>\n<ol>\n<li>7W工作分析公式：寻找合适的下属去完成项目</li>\n<li>6W2H工作分析表：三张表提升你的工作效率</li>\n<li>WOOP模型：制定一个切实可行的计划</li>\n<li>PDCA工作术：让工作更高效</li>\n<li>WBS工作分解结构法：细分你的工作</li>\n<li>如何提高效率：提升效率的原则</li>\n<li>橄榄球定律：做事要抓重点</li>\n<li>TIS工作法：工作要讲方法</li>\n<li>结构化思维工作法：麦肯锡高效工作法</li>\n<li>谷歌OKR工作法：高绩效工作</li>\n<li>断舍离：极简生活</li>\n<li>5S管理原则：整理是一套管理流程</li>\n<li>整理生活步骤：走上品质的人生</li>\n<li>减压工具：职场之减压妙法</li>\n<li>冥想五步法：精于内心平和的艺术</li>\n<li>PPT工作流程：好的PPT不只是设计</li>\n<li>ECRS分析原则：改善和优化自己的工作流程</li>\n<li>POA行动力：提升你的执行力</li>\n</ol>\n<h2 id=\"六-阅读思维工具\" tabindex=\"-1\"> 六.阅读思维工具</h2>\n<ol>\n<li>费曼技巧：最强的学习方法</li>\n<li>整体性学习法：知识不是孤立的</li>\n<li>茂木式速读法：快速读完一本书</li>\n<li>整体阅读：30分钟内读完一本书</li>\n<li>RIA便签读书法：将知识转化为能力</li>\n<li>多重阅读：快速吸收一本书的精华</li>\n<li>SQRRR读书法：世界公认读书最快的学习方法</li>\n<li>SCORE学习法：综合性学习方法</li>\n<li>主题阅读：最快掌握一门学科</li>\n</ol>\n<h2 id=\"七-笔记思维工具\" tabindex=\"-1\"> 七.笔记思维工具</h2>\n<ol>\n<li>5R笔记法：学霸的笔记法</li>\n<li>黄金三分法笔记术：结构化你的笔记</li>\n<li>麦肯锡流笔记：解决问题的笔记</li>\n<li>子弹笔记：快速录入的方式</li>\n<li>知识管理：知识生产者管理知识流程</li>\n</ol>\n<h2 id=\"八-写作思维工具\" tabindex=\"-1\"> 八.写作思维工具</h2>\n<ol>\n<li>写作流程：写作可以很简单</li>\n<li>写作20原则：写作也是有原则的</li>\n<li>英雄之旅：好莱坞创作故事模板</li>\n<li>STORY模型：好故事的标准</li>\n<li>Tell Story Process：如何写好一个故事</li>\n<li>SCQA模型：结构化写作</li>\n<li>制作简历的三个步骤：制作HR喜欢的简历</li>\n<li>30秒电梯三法则：快速打动对方</li>\n</ol>\n<h2 id=\"九-成长思维工具\" tabindex=\"-1\"> 九.成长思维工具</h2>\n<ol>\n<li>成功人士的七大习惯：成功只是一种习惯</li>\n<li>个人商业模式画布：建立个人商业系统</li>\n<li>VRIO模型：打造个人核心竞争力</li>\n<li>OGSM模型：一页纸搞定计划</li>\n<li>个人品牌建设五部曲：科学建设个人品牌</li>\n<li>复盘思维：利用经验快速自我提升</li>\n<li>情绪管理四步法：轻松管理自己的情绪</li>\n<li>人生规划四个阶段：美好人生需要规划</li>\n</ol>\n",
      "date_published": "2022-05-24T07:59:53.000Z",
      "date_modified": "2022-05-24T09:00:04.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "2b&2c",
      "url": "http://www.zhangsj.xyz/blog/programlife/2b&2c.html",
      "id": "http://www.zhangsj.xyz/blog/programlife/2b&2c.html",
      "content_html": "<h1 id=\"_2b-2c\" tabindex=\"-1\"> 2B&amp;2C</h1>\n<p>作为互联网从业者，我们经常听到to B（或2B）和to C（或2C）两个概念。</p>\n<ul>\n<li>to B即面向企业客户，to business</li>\n<li>to C即面向普通用户。to consumer</li>\n</ul>\n<p>只要是互联网人基本都懂知道这两个概念，但如果别人再问“to B和to C产品到底有什么区别”，我们可能就“呃……”了。</p>\n<p>要理解它们的区别，就需要理解两者面向的对象（<code>customer</code>），产品特点（<code>product</code>），商业模式（<code>business</code>）。</p>\n<p>这三块依次对应文章以下三个标题：</p>\n<p>以下分析并不一定能套用在所有的2B和2C产品上，但大体上这两者会有这些区别。下面细细道来。</p>\n<p>1.客户与用户\\面向的对象</p>\n<p>要了解两者的区别先看它们面向的对象有什么区别。2B产品面向的是客户，什么叫客户，简单通俗地说就是给钱的合作方，它们通常是一个企业。个人使用者则是用户。</p>\n<p>本文所说的客户即2B客户，用户则指的是2C用户。</p>\n<p>客户是理性的，用户则偏感性</p>\n<p>先举个例子。双十一现在基本上成为一个全名狂欢节，很多人吃土也要剁手。为啥？</p>\n<p>便宜呀（表面上便宜哈哈），很多人一冲动心一狠就各种买了。但我们很少听说有2B的产品在搞大促销。原因很简单呀，一是企业的采购是有计划安排的，可能还需要财务各种审批，不太可能刚好就在你促销的时候企业就需要采购；二是企业的采购是要考虑投入产出比的，而不会因为你打个小折就决定采购，但个人用户不一样，本来一直在考虑要不要买一个扫地机器人，买吧觉得贵不太划算，可是看到双十一突然来个5折，这下便有了冲动的借口，毕竟错过了得等一年。</p>\n<p>客户关心的是<code>ROI</code>（投入产出比），用户要的就是玩的爽（满足了人性的某个弱点）</p>\n<p>举个例子同样是要去推销自己的产品，一个2B的BD和一个2C的BD的常见手法是不一样的。2B的BD可能会反复跟企业主安利自己产品能带来多少效率的提升，能省多少钱，能多大程度提高生产力等等。。。其实总结起来本质上就是你买我们的产品“投入产出比”很高。而一个2C的BD可能就会大打情感牌，说你身边的朋友都在玩，大家都说好玩，你要不要也试试啊。。。强调的重点是“好玩，爽”。</p>\n<p>为什么会有这种区别？</p>\n<p>这就要层层剥开，看客户和用户的本质区别是什么。客户即企业，企业的定义是什么。高中政治我们都学过“企业是指以营利为目的的经济组织”，要实现挣钱的目的，那每一次掏钱当然就得考虑清楚这钱掏了值不值，或者说花出去是不是能挣回更多，否则就不值得花。举个例子，企业之所以购买CRM系统，就是为了提高员工的效率，少招人从而降低成本，因此这里省钱才是企业购买CRM的驱动力。</p>\n<p>用户则是个人，人性是有弱点的，比如懒惰，贪婪等。我们常说产品一定是为了满足用户的某种需求而存在的，那需求是从哪里来的，根源还是人性的某些弱点。举一个最常见的例子比如微信，满足的是人性的哪些弱点？随便都能说出几个：贪婪，虚荣，懒惰。有个段子说社交产品有一个发展路径“始于约X，盛于炫耀，衰于鸡汤，亡于微商”，可能这个说法并不准确，但不得不承认很多时候发朋友圈不就是为了告诉别人我做了哪些高逼格的事情，本质上就是炫耀，这个场景下微信满足的正是人性虚荣的弱点。还有，很多人之所以喜欢看一些公众号的心灵鸡汤文章，比如“教你获得成功的十个XX”，该类文章抓住的正是人性懒惰的弱点，很多人懒得行动总是幻想着看完这些鸡汤很快就能成功了。</p>\n<p>客户有大小之分，用户则基本一样</p>\n<p>我们文章中提到的客户指的都是2B产品面向的企业，用户指的都是2C产品面向的个人。</p>\n<p>企业是有大小之分的，10个人的微企业和100个人的小型企业是不一样的，同样1000个人的中型企业和10000个人的大型企业也是不一样的。或者更准确地说对于同类产品不同大小的企业它们的需求是不一样的。</p>\n<p>比如同样需要内部沟通产品，10个人的企业大家都坐在一个办公室里，需要找谁商量直接吼一嗓子，需要的产品只是传播声音的介质—空气就可以了；但如果是100个人的小企业，可能吼一嗓子就没那么好用了，因为不是每个人你都特别熟况且座位不一定离的很近，这时候可能就需要一个微信群方便大家沟通；但如果是1000人的中型企业，跨部门协同的机率就大很多，很多时候要找的人是不认识的，可能对方装死半天不回，对方就说没看到你也没办法，打电话吧也没那么方便，干着急。</p>\n<p>这个时候如何提高沟通效率就特别重要。所以钉钉的“已读，未读”功能就很受这种场景的欢迎，对方是否在装死就看是不是已读，如果未读那就可以通过语音或短信“钉一下”，再不行直接用钉钉打电话。所以中型企业就很适合用钉钉这种产品。那10000人以上的企业呢，可能原生的钉钉也不一定能满足其复杂的协同需求，需要更多定制化的功能，这种企业要么就自己开发相应产品，要么就利用钉钉提供的接口自己或找ISV开发，这也是钉钉会引入ISV的原因。</p>\n<p>所以，2B产品得考虑大小不同的客户它们对同类工具的需求也是不一样的，面对这样的问题作为提供2B产品的企业一般会有两种出路，第一种是提供一个最基础的原型，然后找合作伙伴，打造一个生态，让各种合作伙伴在原型的基础上为特定类型的企业提供产品和服务。</p>\n<p>像近几年来比较火热的云计算行业，这个行业的产品层次很明显，分最底层是IaaS,上面一层是PaaS,再上一层是SaaS,最顶层是DaaS，原因就在于企业类型繁多需求也是多种多样，任一层都无法满足所有客户的需求，所以需要生态共赢。第二种是作为提供2B产品的企业自己提供好几款同类型产品，分别针对不同类型的企业。比如微软的数据库就是这样一个典型的例子，提供excel给数据量不大比如只有几千条记录的微型企业使用，提供access数据库给需要对上万条数据进行处理的企业使用，提供sql server给需要对上百万条数据进行处理的大型企业使用。</p>\n<p>上面说的是2B产品面向的客户有大小之分，下面我们再看看2C产品面向的用户基本是一样的。</p>\n<p>再举微信这个例子，从身份地位，收入上看微信的用户也是千差万别，但是从微信满足的人性弱点角度来看用户之间并没有什么差别的。一个成功人士和一个穷学生都是人，都有懒惰，虚荣等弱点。只是程度可能略有差别，他们都有通过朋友圈各种晒的需求，只是晒的东西可能不一样而已。所以作为2C的产品微信，它理论上是能满足所有用户的需求的。</p>\n<p>2.工具与玩具\\产品特点</p>\n<p>第1部分我们一直在分析2B和2C产品面向的对象的不同。接下来我们看看2B和2C产品特性的区别，总的概括就是“工具与玩具”的区别。</p>\n<p>先声明，对于两类产品小编并没有感情上的偏袒，两者没有高低贵贱之分，2B产品偏生产特性所以统称为工具，2C产品偏娱乐特性所以统称玩具。</p>\n<p>不难理解两者为什么一个偏工具，一个偏玩具。产品的源头是需求，需求的主体是customer／user。2B产品的需求主体是企业，而企业的核心功能是生产，生产当然就需要工具，因此2B的产品就偏工具。2C产品的需求主体是个人，人都喜欢玩，所谓玩就是进行娱乐性的活动，因此2C产品就偏玩具。</p>\n<p>那工具和玩具的区别有哪些呢？至少我们可以从目标，生命周期，易用性三个方面进行区分。</p>\n<p>工具的主要目标是性价比，玩具的主要目标是好玩</p>\n<p>工具的主要目标是性价比。性价比包含了两个指标，一个是性能（或者说效率），另一个是价格。不难理解的是，企业之间的竞争本质上就是生产效率的竞争。所以企业采购的工具（2B产品）肯定是为了提高生产效率，比如各种CRM系统是为了提高客户管理的效率，数据库系统是为了提高记录和运算的效率。在此基础上再横向对比价格，性价比最高的当然最适合。所以要吸引企业来购买产品，2B产品不得不考虑的最重要的两个指标是效率和价格，或者说性价比。</p>\n<p>玩具的主要目标是好玩。好玩指的是用户体验做的好，人性化做的好。什么叫用户体验做的好？我的理解就是能恰好满足人性弱点的体验就是好的体验。《don’t make me think》作者说好的用户体验最重要一条原则就是尽量不要让用户思考。讲的就是要满足用户“懒得思考”这一弱点。比如我们都感觉微信用户体验做的好，其中有一点就是使用简单，傻子都能用，满足了“懒”这一人性弱点，再加上其它的一些功能满足“虚荣（炫耀）”“偷窥”等人性弱点，就能让产品变得好玩，只有好玩才能吸引更多的用户使用，这正是2C产品追逐的目标，因为很多2C产品的商业模式都是建立在巨大的用户群体基础之上（关于商业模式本文的第三部分会分析）。</p>\n<p>工具的生命周期比玩具的生命周期更长久</p>\n<p>产品都是有生命周期的概念。</p>\n<p>为什么说相对于2C产品，2B产品的生命周期更长？一是因为2B产品作为工具本身比较复杂，开发这样的产品是需要大量的行业经验积累和技术积累，因此一款2B产品一旦或得市场认可就能建立经验和技术壁垒。二是2B产品基本都是要花钱购买的，一旦企业采购了产品，员工也熟悉了如何使用，再换新的产品成本就比较大，所以更换的意愿比较低。举个例子比如数据库系统oracle，面向的就是大型企业，从1970年左右到现在都40几年了依然存在。</p>\n<p>2C产品为好玩而存在，同样满足需求当新推出的产品更好玩的时候，那老产品的生命周期可能要面临着结束。比如qq和微信推出后，短信就被替代了，同样是通讯产品，微信和qq就好玩多了。可能有人会说因为短信收费，这不是最重要的原因，即使短信现在完全免费估计也没几个人用了，因为微信不止能发消息，还能发各种表情，图片，语音，视频，用户体验好的不是一点点，也就是微信比短信好玩的不是一点点，自然前者就被后者替代了。同样微信的用户体验做的比qq好，所以微信推出几年后用户量已经赶上了qq。当微信被玩腻，人们发现下一个XX更好玩时，微信也同样会被代替。对比下两年前和现在的朋友圈好友原创的文章比例就知道了。还有，各种游戏类产品也都是2C的，一般也不会有几十年的生命周期，游戏界的传奇《魔兽》到目前也就20多年，这已经是奇迹。玩具是满足人性弱点而存在的，和工具相比较而言生命周期较短。</p>\n<p>工具比较复杂难用，玩具简单易用</p>\n<p>一般来说2B产品比较复杂难用，2C的产品简单易用。为什么？一方面，2B产品是工具用于生产而不是人平常的生活，使用工具很多时候不是人的本能行为，而是为了达到某一目的学会的技能，因此一般是要经过培训学习才会使用。另一方面，这和2B产品的主要目标是“高效率”有关，当资源都用在打造产品的效率的时候，用在体验方面的资源难免会不足。2C产品的目标就是要易用，因此用户体验就做的很好才能赢得用户，试想一个2C产品需要用户拿着说明说才能使用那用户体验做的得多糟糕，基本就被淘汰了，好比之前的全键盘手机，当然会被智能手机所淘汰。</p>\n<p>从产品的目标，生命周期，易用性三个角度来看2B和2C产品的区别，从上面的分析中应该多少能感受到一点：2B产品偏工具，2C产品偏玩具。</p>\n<p>3.卖身与卖艺\\商业模式</p>\n<p>先不要被标题吓到哈，主要是为了配合前面两个标题的格式所以总结了这么一个短句。这部分主要从商业模式的角度来分析2B和2C产品的区别。</p>\n<p>先说2B产品的“卖身” 之所以说2B产品的商业模式像是“卖身”，是因为2B是实打实的一手交钱一手交货，签合同就好比在签卖身契。也就是说2B产品开发出来是要直接卖钱的。即2B产品从诞生第一天起就要考虑如何挣钱。一般来说一款2B产品如果能用几十万客户已经是用户量特别大的产品，不像2C产品动不动就是上亿甚至上十亿用户量。因此走间接变现，通过流量变现的方法行不通。而且可以想象如果一个生产工具里面插入各种广告，得有多影响生产效率。另一方面，对于性价比高的工具企业是愿意付费的。自然而然就形成了直接变现的商业模式，通过“卖身”的方式获得收入。</p>\n<p>2C产品则是“卖艺”</p>\n<p>2C产品的商业模式通常是间接变现，“羊毛出在狗身上”。通过开发出用户需要的产品，把产品的体验做好，从而吸引用户来使用。产品本身是免费的，比如百度，支付宝，微信等产品。在用户量足够大的前提下，通过广告，排名等方式变现，本质上都是流量间接变现的商业模式。这就有点像街头卖狗皮膏药者，先在街头做些小表演，完了再拿出真正要卖的东西。因此称之为“卖艺”。之所以2C产品能这么干，是因为用户群体足够大，当用户量很大的时候每个用户的边际成本在逐渐降低甚至趋于0。比如10000个人使用微信，和10001个人使用微信对腾讯来说成本几乎是一样的。当用户足够大的时候广告产生的收入就很可观，同时还能实现引流，把用户引导到各种应用上实现变现。</p>\n<p>本文从产品面向对象，产品的特点，产品的商业模式三个大的方面对2B和2C产品的区别做分析。其实两者的区别远不止这三方面，甚至不同的2C产品之间，也是天差地别，只是我们抽象的程度高一些便有了可比性。</p>\n",
      "date_published": "2022-05-24T07:58:00.000Z",
      "date_modified": "2022-05-24T07:58:00.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "���꣬���������������",
      "url": "http://www.zhangsj.xyz/blog/programlife/four-years-software-testing-in-my-eyes.html",
      "id": "http://www.zhangsj.xyz/blog/programlife/four-years-software-testing-in-my-eyes.html",
      "content_html": "<h1 id=\"���꣬���������������\" tabindex=\"-1\"> ���꣬���������������</h1>\n<p>һλ��ҵ���ڷ����Լ��ĳɹ�֮��ʱ˵���Լ��ĳɹ�������������һ�����й�������ҵ�����������������30�����ң����������������ҵ���������������15��20�����ҵ�ʱ�䡣̹�׵Ľ��������������������ˡ������й���������Ʒ���������߳����ţ�ֻ�ܸ�������������������������ʱ��ITҵ�������ֶ�����һȺIT����������̳�޵�����Լ�˼����һ����Ʒ��ʧ�ܣ������г������⣬�������������У�����������Ϊ������Ʒ�����Ŀ��ƻ��ڣ��ӵ���������������Կ������ڵ���������ҵ�ж�ô�ı������Զ���������Ϊ�������Ե���������Ǳ���������</p>\n<p>�������Դ�ҵ��Ա��������������ˮƽƫ�ͣ�������ձ����󡣹��������������Աְҵ��չ�Ӳ���Ա�����Ծ��������ר�ң�ƽ����Ҫ10�����ϵ�ְҵ��չʱ�䣬�����ǵ��ٶ��Եÿ���ˣ�����6����Ե��ϲ��Ծ����ıȱȽ��ǣ���������ٴӲ��淴ӳ����������ҵ�Ĳ����졣�����Լ����ӱ�ҵ�����ڣ�������������ְҵ���ĸ�����ͷ���ڼ�Ҳ���˺ܶ�ʱ���о�Web�Զ������Լ�����Ҳ��������һ���Զ������Կ�ܣ����ǣ��Ծ��ñ��ߣ���Ϊ����Ǿ�����ҵ����QTP֮�Ͽ����ģ���ζ�źϷ�ʵʩ�Զ�����ǰ��û�һ���Ǯ������˵Ĳ�Ʒ�������Ŀ�ܳ�����ֻ���ǻ�ƿ����û�����յ��Զ������Եĺ��ļ�����Ȼ�������˻��ʣ���Դ���߲���������Selenium֮�ࡣ��Դ��ѹ�Ȼ�Ǻö��������ǿ�ԴҲ�����Ǵ��뿪Դ������һ���Ǽ�����Դ����ο�Դ�Ĺ���������Ҫ���ߵļ���֧�ţ�������ˣ���ȸ߰�����ҵ�������һ��ǿ��ÿ�Դ���Զ���������ϣ���������Զ������Լ�����������ͬ����ϵͳ����һ�㣬�����յ������ߴ���������</p>\n<p>�������Ͻ���������˾���ʹܲ��ţ�QM���������飬һ�����������ԣ�QC����һ����Ʒ�ʱ�֤��QA��������֮��ְ�ܻ��н��棬���ǹ�ע��ͽ���ĵ㲻ͬ����ͬ��˾�Խ�ɫ�Ķ�λҲ��ͬ����������£�QC�����ע��Ʒ��������QA�����ע��Ʒ���з����̡����ԣ�QC���ŵĳ�Ա�ǲ��ϵ��ڲ��Բ�Ʒ��������Ʒ�������Ƿ�ﵽ����Ҫ�󡣶�QA���ŵĳ�Ա�����ڲ��ϵع淶������Ʒ�Ĺ��̣�����ԭ�й��̵Ļ����϶Թ��̽��иĽ����������ߵ�ְ���ڲ�Ʒ���϶���Ϊ��Ҫ���Ӳ�ͬ�ĽǶ��ϱ�֤�˲�Ʒ����������ʵ�ʵ��������������أ����˴����ĵ�һ��������˾������QA����QC���Ŷ�û�У���ȫһ˽��С������������Ա�����г���Ա��Ҫ����������ж��ƣ��г���Ա�򵥶Բ�Ʒ���в����¾ͽ������û����û�����һƬ�����ж��г���Աʩѹ�����յĽ���ǲ�Ʒһֱȱ���г����������������٣��ݶ��½����쵼��ֱ���������Ŀǰ�Ĺ�˾��ͨ����CMMI3����֤���ڹ�������ҵ��Ҳ�����õó��֡������������������ķ�չ������������ԭ����������ģʽ���������ݿ�����˼�룬QA����ȱ���Թ��̵ĸĽ�������QC���ŵĲ��Լ�����Ȼ���þ��еĲ���ģʽ�������ݵ���ģʽ�£�������Ա����ƣ�ڱ����ڷ�����������������Ʊ�д��ϵͳ���ԵĹ����У�������ЧӦ�ǲ�����Աû��ʱ������߲��Լ��ܣ�����ڲ��ŵĳɳ��ǲ����ġ���Ȼ���쵼�㲻�ǲ��������������������Ͷ������������������κ�һ˿�Ķ�������ǣ�����������ϵĸ������ڣ�˭��������ȥ�е������ķ��ա���ʵ���κ�һ�ֱ�ﶼ���������˵�����Ϊ���ۣ���������һ����˳�Ͳ��ܽб����������ǸĽ�����֮����һ����Ҫȡ�����쵼���������</p>\n<p>������Ա��ְҵ��չ�����������˶����ģ��׻�˵��Ů�¼޴��ɣ���������С�ѡ��һ����ȷ����ҵ���ڸ��˵���ҵ��չ������Ҫ��ƾ�Ķ��ۣ������������в�û��������������ô��ʲô���ձ�ҵ��н10��ɶ�ģ��Ƕ������ף��ü�����İ���˵���Ƕ��Ǳ������ĵ���ı�ҡ�����������Ա�����������Ĳ�ҵ����н��ˮƽ�����ߣ���Ҫԭ���ǲ��ԵĹ����ļ��������ձ�ƫ�ͺ��쵼����������Բ����ӡ��������Ե���Ҫ�����Ǳ�֤������Ʒ����������˳ɹ���������û�У�û���Ǹ��쵼Ը���������һ�Ѳ�������˵�£��԰ɣ��ɹ��޷����֣�н�������͵÷Ż������ǣ���ʵҲ���ܱ��ۣ�������ҵ��Ϊ�߼�����ҵ�ĳ�����ҵ������������Ȼ���ڷ�չ�����׶Σ�����Ҫ�������𲽱��Ͽɣ����ң��������Եļ���Ҳ����ϸ����Խ��Խ��ķ�֧������ϵ�Ͳ��Լ���Ҳ���ڱ�ϵͳ�����ƹ㡣</p>\n<p>�ոս����������Ե��˹��˸�һ��������������ã����Ϊ����һ����ĺںв��ԣ�����ҵ���Ѿ����ղ�࣬�ո�һ�յ��ظ�ִ���������������⸡�꣬��ʱ���û�кܺõع滮ְҵ��չ��������������ͻ���Լ���ƿ������ʱ���������Ϊ�����ˣ�һ����ͣ�Ͳ�ǰ��һ���˿��ٳɳ�Ϊ����ר�һ���Թ����ߡ����ԣ�һ�������Լ���ã�ˣ�Ǳ��ʶӦ�÷����Լ���ְҵ��չ�Ѿ�����ƿ����Ӧ�����������µ�ְҵĿ�꣬ѡ��һ���ʺ��Լ���ְҵĿ��Ŭ����̣�����������Ǹ�ͣ�Ͳ�ǰ��С����</p>\n<p>������Ա�Ĺ���ѹ����ʵ�������ڿ�����Ա�����õĹ���ϰ�������ڸ����������ٵĹ���ѹ������ͳ��ְҵ����Ҫ���������ģ�ר�ġ�ϸ�ġ����ġ������ġ������ģ����Ǵ��ڼ�������ҹ���������ҵ�У���Ҫ���Ͻ��ġ������ܽ���˶������ĵ����⣺</p>\n<p>ר�ģ��ϰ�ʱ�䣬�쵼��Ҫ����ר����ɹ������������������һ�߲��Բ�Ʒ��һ�߸ɱ�����飬����Ч���ܸ��𣬱��˷�����һ��ȱ�ݣ��������ô�������鳤һ�飬��С�Ӹ����ģ����©��һ������û���֣����Ժ�͵ò������ã��ڲ�����ֻ������ĩ����һ���Ŷ��˭���úã�˭���ò�����ױ���������������ʱ���������ֻ����Լ����£�һ���������⣬�쵼һ��������Ĳ硣</p>\n<p>ϸ�ģ������Ծ�����bug�ģ���仰��Ȼ��ʧˮ׼����������ȷʵ�󲿷�ʱ��������bug���������ĵ���bug���Ұ�װ�ĵ���bug�����û��ֲ��bug���Ҳ���������bug���Ҳ�Ʒ��bug������ô���bug��Ҫ���Ƿ���˼ȥѰ�ң���˵�ܲ�ϸ����bug�������ǵ�����·�ϵ�Ӳ�ң����׿�ʰ��������Ҫ���ǽ��������Լ��ľ�����۽����ۺϷ��������˷������Ե�bug��ҲҪ�ھ����Ե�bug�������ϸ�Ĳ��ԣ�һ���ܱȱ��˷��ָ����ȱ�ݣ���Ȼ����Ĺ�����Ч�ͱȱ��˺á�</p>\n<p>���ģ�ΪɶҪ�����أ���ʵ�����Գ���Ҫ�����ڲ�ͬ����ȷ�����⡢���磺��Ҫ��������Ʋ�ȷ�Ͻ������⡢����Ʒ��ȷ���������⡢����Ŀ��ȷ�Ϲ������⡣����Щ�����ڵĹ�ͨ�����У���Ҫ��ַ��ӹ�ͨ�ļ��ɣ���ͨ��ǰ�������������˵��Ͷ��ɹ���ǰ����Ҫ���㹻�����ģ��ر����Կ�����Ա����Ϊ������Ա�ƺ������Բ�����Ա�����ų⣨�ط�������Щ�����Ҳ�ģ������������˸���Ʒ�⣬һ�㿪����Ա���ǱȽ����ز�����Ա��������Ա���㹵ͨ�����������ǵĿ������Ժ������ҵ���ܣ�����㲻������ͻ��ɣ����˾ͻ�һ֪����ȥ�������⣬�����໨����˼�����ĺ������ٹ�ͨ��ͨ��������ɻ�˵�ø����Щ�������ﵽ��Ч�����á����⣬Ϊ���ܵõ����õĹ�ͨЧ����ƽʱ������͸������ŵĳ�Ա�����죬������������к����Ժ����ϵ��������ⶼ�ܵõ��Ϻõ�Э����</p>\n<p>�����ģ�û�������ĵ����˵ò���Ů���ӵķ��ģ���Ȼ����ְ���ϣ�������Ů��û�����������Ȼ�ò����쵼�ġ����ġ������κ�Ȩ�������ǲ��еģ���е���������Σ��������Ի�ø���ִ��Ȩ������������ȥ�е�һЩ�Լ������ܼ������ΰɣ���Ҫ���������ô�������ڳе����ε��������Ǳ����صġ��������һ�����ˣ�Ҫ�������������ص�վ�ڸ����˵ĽǶ��Ͽ������⣬��Ϊ��Ŀ�������ṩ��Ŀ���������������أ�������ڲ�ͬ��</p>\n<p>�����ģ���Ҫ��Ϊ�����ںв��ԣ�û�м����������Ϳ�����Ա���������û���˵�����������Ա����֪���Ǻ�����Ʒ�����ı�׼���ܺ�����Ʒ������׼�������衢���裬������ȷ������������ʱ������Ӳ�����˺Ϳ�����Ա�����װɡ���Ȼ�����Լ������ţ�ǰ��Ҫ�������Լ����㹻�����Ļ����ϣ�����Լ�û���������ֱ��ֵú����ţ����˻���Ϊ�����Դ���ˡ��������������Ա��ֳ��Լ�������ְҵ���󣬵õ�ͬ�µ��Ͽɡ�</p>\n<p>�Ͻ��ģ�����ITȦ�ﱣ����������һ��Ҫ���ϵ�ѧϰ�����ܳ��ϱ����������������ñ��ϻ�����һ��������IT��û���Ǹ�����ÿ�춼Ҫ����һ����֪ʶ�����ٳɶ࣬��Ҫ�鵽��ʱ�����١����������Ե�ѧϰ�и��ص㣬�Ǿ��ǲ�����������Ҫ����IT��������źͼ������ڲ�����ǰ���»�������ѧϰ�ľ�ͨ�������޷���ͨ������ȫ������ͨ������Ҫ�ڲ�����ǰ���¾�ͨһ���ż�������������ְ���ϲ��о����������˷ǿư���������������ԣ�ͨ��4���Ŭ�����ڲ������ۺͼ��������ȱ��˲���ľ���ÿ�յĻ��ۺ�ѧϰ������һ���Ͻ��ģ����������ھ������ҵ�ְ���ϴ��ڲ���֮�ء�</p>\n<p>�ۼ��ž�Ҫ��ְ�������������Ҹ�������Լ��ܽ����⼸�����������������е���֪�����꣬����һ������������ҵ���ԣ�Ҳ�����Ǹ������ż��Ľ׶Σ������������������ĵ�·Ҫ�ߣ��������ľ����ȴ��ſ�Խ��Ը�Լ�������������������Խ��Խ������</p>\n",
      "date_published": "2022-05-24T07:58:00.000Z",
      "date_modified": "2022-05-24T07:58:00.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "ppt技巧",
      "url": "http://www.zhangsj.xyz/blog/programlife/ppt-production-skills.html",
      "id": "http://www.zhangsj.xyz/blog/programlife/ppt-production-skills.html",
      "content_html": "<h1 id=\"ppt技巧\" tabindex=\"-1\"> ppt技巧</h1>\n<p>为了不再挨骂（不要再花钱），我果断在网上找了一个高性价比ppt课程，当天就报上了名开始学！上面放的那个ppt就是我学习完这个课程后做出来的效果～！～我上的那个课程我给大家把链接搬来了，实用又带劲，实用是因为课程中会手把手教各种ppt小技巧，带劲是因为学习时间短，主要在于你多练习！！！</p>\n<p>其实做ppt没有想象的难，有些低级错误是可以避免的，这里给大家讲几个常见的影ppt美观错误操作。文字太多！这是大家最常犯的错误，PPT页面上密密麻麻的文字，看的人头痛，大家是来听你演讲，又不是看小说。如果你在演讲的时候需要读出来，需要小抄那请放在备注里。（至于备注怎么加以后有机会再说~~）</p>\n<h2 id=\"背景\" tabindex=\"-1\"> 背景</h2>\n<p>程序员日常工作中最多的应该是接收需求、编码实现需求。但也有些时候需要做一些非代码的文字工作。</p>\n<p>比如做述职报告、工作总结等，这些一般的都是通过<code>ppt</code>的形式进行展示。</p>\n<p>近一年我做了几次 <code>ppt</code>，刚开始写 <code>ppt</code> 简直不要太痛苦，真的不如写代码来的简单，每晚熬到深夜但也是收效甚微。</p>\n<p>后来又写了几次，慢慢地找到了一些感觉，现在就赶紧把这个灵感进行总结并记录下来。（仅个人理解哈）</p>\n<h2 id=\"概论\" tabindex=\"-1\"> 概论</h2>\n<p>当写过几次 ppt 后，现在感觉写 ppt 也不是那么难（可能我想的有点简单）。ppt 其实就包含两个需要我们深度思考的东西，</p>\n<p>一个是内容，一个是形式。</p>\n<p>内容即文字-你要表达的东西，另外一个就是形式，形式就是展示形式，也就是我们应该以怎样的美感去展示我们的内容。为什么要美感？其实不是为了自己，而是为了体贴你的观众，用心组织你的内容，用心让内容变得更好看就是对观众的体贴和负责，同时也可以锻炼自己的ppt能力。</p>\n<p>记得《马原》里我们学过内容和形式的辩证关系（下面这段可以不看哈）。</p>\n<p>内容是事物存在的基础。同一种内容在不同条件下可以采取不同的形式，同一种形式在不同条件下可以体现不同的内容。内容与形式互相联系、互相制约，在一定条件下可以互相转化。内容决定形式，形式依赖于内容，并随内容的发展而发展。形式对内容的发展起着促进或阻碍的作用。内容活跃，形式相对稳定，两者既相适合又不绝对适合。\n————马克思主义基本原理</p>\n<p>那应该怎样确定内容和丰富内容的表现形式呢？ 下面就说说我的理解</p>\n<h3 id=\"_1、结构化内容-切记长篇大论-切记堆字\" tabindex=\"-1\"> 1、结构化内容，切记长篇大论（切记堆字）</h3>\n<p>内容其实就是我们日常工作的一些总结，如果是写成文章的话我们倒是可以把要表达的细节都写上去。</p>\n<p>但是如果是写 ppt，就要把细节隐藏，简洁明了，突出主题。把自己的内容进行结构化的整理，梳理成大纲。文字太多会丧失美感，降低专业度（ 忍住，不要喷）。细节的文字是要在讲ppt的时候说的，倒是可以写到备注里，想不起来了偷偷的瞄几眼。</p>\n<p>比如完成了什么业绩，学习了哪些技术，个人思考有哪些等，然后把这些再细化一层后就是具体的模块了。</p>\n<p>最后形成一个简单的树形结构。</p>\n<p>是否还有下一级模块就看个人的需要了。比如在某个业绩里有一些特别突出的亮点，就可以单独的列出来，在演讲的时候着重的介绍下。</p>\n<h3 id=\"_2、确定色调\" tabindex=\"-1\"> 2、确定色调</h3>\n<p>网站的UI有基调和配色，PPT也有，为了视觉的舒适和ppt的整体性，配色是必须的。不然后面内容美化的颜色就没有了参考。相信一会儿蓝色一会儿绿色一会儿红色的谁看着都不会舒服。</p>\n<p>举个栗子</p>\n<p>整体蓝色</p>\n<p>整体灰色</p>\n<p>整体深灰</p>\n<p>能看到突出的颜色和基调的搭配都是比较自然的，没有冲突。</p>\n<h3 id=\"_3、美化内容-丰富表现形式-积累素材\" tabindex=\"-1\"> 3、美化内容（丰富表现形式，积累素材）</h3>\n<p>这个阶段就好比我们做前端开发，需要用css 来美化页面，其实是一个道理。然而这个展示形式我觉得是最难的，最繁琐的。因为没有现成的素材，总不能把每张 ppt 都搞成双胞胎吧。</p>\n<p>这个时候我们已经有了结构化的内容和基本色调，现在就要开始写 ppt 了。 这个阶段主要是美化和优化之前的内容，让内容和图形结合展示，同时也是对内容斟酌优化的一个过程。</p>\n<p>这里的图形指的是形状和图片，形状就是 ppt 里自带的一些形状，图片就是根据我们要表达的内容而确定的。</p>\n<p>我也只做到了图形搭配阶段，配图就比较麻烦，如果要是能确定关键词也可以，百度搜索即可。</p>\n<p>具体的展示图形可以用系统自带的或者参考网上模板，主要就是一个打磨和积累素材的过程，用合适的图形组合来展示你的内容。</p>\n<p>举几个栗子</p>\n<p>业绩项目的展示</p>\n<p>自带图形</p>\n<p>以下是网上的模板</p>\n<p>完成进度展示</p>\n<p>自带图形</p>\n<p>图文结合</p>\n<p>表现形式虽然看上去有很多种，但按照每个人的喜好和风格来说其实并不多，主要是自己习惯和喜欢那种风格。然而网上的大部分模板也都是使用图形结合展示，配图的也不多。而配图就要看是否能提炼出关键字或者能够找个一张和当前内容和谐共存的图片。</p>\n<h2 id=\"_4、ppt-展示形式体验\" tabindex=\"-1\"> 4、ppt 展示形式体验</h2>\n<p>这段可以不看。</p>\n<p>如果你不是很了解ppt的展示形式，可以多看看网上的模板，对展示形式有个印象。那么自己在丰富自己的ppt 的时候就会有一些感觉了。</p>\n<p>具体的网站百度找下就可以了，就不发地址了。</p>\n<h2 id=\"_5、ppt-资源、素材参考\" tabindex=\"-1\"> 5、ppt 资源、素材参考</h2>\n<p>网上的模板基本上都是收费的，很早之前我在淘宝买过一堆。里面有很多模板，有需要可以存一下。（我主要是用来找素材，最好不要直接套用，一个怕过时，一个是会影响你原有思路）</p>\n<p>链接: https://pan.baidu.com/s/189K0... 提取码: ghs5</p>\n<h2 id=\"总结\" tabindex=\"-1\"> 总结</h2>\n<p>写ppt主要有3步：</p>\n<ol>\n<li>结构化内容（确定内容，突出主题，不要堆字）</li>\n<li>确定ppt风格（也就是配色，黄色、蓝色还是什么，突出ppt的整体性）</li>\n<li>美化展示（根据配色进行美化，具体使用什么图形展示）</li>\n</ol>\n<p>第一次写ppt确实挺麻烦的，但是当自己完整的写完一个后，并且做了大量的优化后，后面你会觉得很简单，但是ppt这个展示形式没有最好只有更好，这个打磨的过程才是最累人的，这个速度也快不了，一两天能搞定一个ppt算是比较快的了，后面做的多了就会提升了。</p>\n<p>好的内容和表现形式还是通过自己的深度思考得来的，这里做好了还不算完，还有后面的演讲阶段，演讲前需要做几次预演，尽可能的准备充分，把自己要表达的内容表达出来，就更完美了。</p>\n<p>（本文是大胖自己的理解，大胖用着还行，希望对你有用，也仅仅供参考，肯定还有其他的方法和见解，欢迎留言学习交流。）</p>\n<p>另外和大家说下我的公众号“重度前端“要改名了，改成“前端张大胖”，感觉这个名字更生动和可爱一些，从一个名字变成了一个人，目前已经提交申请了，过两天就变更了。</p>\n<p>https://zhuanlan.zhihu.com/p/90248501</p>\n",
      "date_published": "2022-05-24T07:58:00.000Z",
      "date_modified": "2022-05-24T07:58:00.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "冷备份和热备份",
      "url": "http://www.zhangsj.xyz/blog/java/datasource/cold-and-hot-backup.html",
      "id": "http://www.zhangsj.xyz/blog/java/datasource/cold-and-hot-backup.html",
      "content_html": "<p>冷备份</p>\n<p>发生在数据库已经正常关闭的情况下，当正常关闭时会提供给我们一个完整的数据库。冷备份时将关键性文件烤到硬盘上里头；</p>\n<ol>\n<li>速度快</li>\n<li>容易归档</li>\n<li>容易回复到某个时间点</li>\n<li>低度维护，高度安全</li>\n</ol>\n<div><pre><code>sqlplus <span>/</span>nolog\n<span>sql</span><span>></span> <span>connect</span> <span>/</span> <span>as</span> sysdba\n<span>sql</span><span>></span> shoutdown normal\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>用拷贝命令把全部的时间文件，重做日志、控制文件初始化参数备份</p>\n<p>备份</p>\n<p>sql&gt; cp</p>\n<p>重启数据库</p>\n<p>sql&gt; startup</p>\n<p>热备：</p>\n<p>库还在运行的时候，采用archivelog mode模式备份，恢复更多的信息，需要大量的档案空间。</p>\n",
      "date_published": "2022-05-24T07:41:43.000Z",
      "date_modified": "2022-05-24T07:41:43.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "Java零拷贝",
      "url": "http://www.zhangsj.xyz/blog/java/concurrent/zero-copy.html",
      "id": "http://www.zhangsj.xyz/blog/java/concurrent/zero-copy.html",
      "content_html": "<h1 id=\"java零拷贝\" tabindex=\"-1\"> Java零拷贝</h1>\n<p>DMA(直接存储器访问)</p>\n<p>DMA(Direct Memory Access，直接内存存取) 是所有现代电脑的重要特色，它允许不同速度的硬件装置来沟通，而不需要依赖于 CPU 的大量中断负载。否则，CPU 需要从来源把每一片段的资料复制到暂存器，然后把它们再次写回到新的地方。在这个时间中，CPU 对于其他的工作来说就无法使用。</p>\n<p>零复制(英语：Zero-copy；也译零拷贝)技术是指计算机执行操作时，CPU不需要先将数据从某处内存复制到另一个特定区域。这种技术通常用于通过网络传输文件时节省CPU周期和内存带宽。</p>\n<p>1、<code>MappedByteBuffer</code></p>\n<p>java nio提供的<code>FileChannel</code>提供了map()方法，该方法可以在一个打开的文件和MappedByteBuffer之间建立一个虚拟内存映射，MappedByteBuffer继承于ByteBuffer，类似于一个基于内存的缓冲区，只不过该对象的数据元素存储在磁盘的一个文件中；调用get()方法会从磁盘中获取数据，此数据反映该文件当前的内容，调用put()方法会更新磁盘上的文件，并且对文件做的修改对其他阅读者也是可见的；下面看一个简单的读取实例，然后在对MappedByteBuffer进行分析：</p>\n<p>分别提供了三个参数，MapMode，Position和size；分别表示：</p>\n<ul>\n<li><code>MapMode</code>：映射的模式，可选项包括：READ_ONLY，READ_WRITE，PRIVATE；</li>\n<li><code>Position</code>：从哪个位置开始映射，字节数的位置；</li>\n<li><code>Size</code>：从position开始向后多少个字节；</li>\n</ul>\n<p>重点看一下MapMode，请两个分别表示只读和可读可写，当然请求的映射模式受到Filechannel对象的访问权限限制，如果在一个没有读权限的文件上启用READ_ONLY，将抛出NonReadableChannelException；PRIVATE模式表示写时拷贝的映射，意味着通过put()方法所做的任何修改都会导致产生一个私有的数据拷贝并且该拷贝中的数据只有MappedByteBuffer实例可以看到；该过程不会对底层文件做任何修改，而且一旦缓冲区被施以垃圾收集动作(garbage collected)，那些修改都会丢失；大致浏览一下map()方法的源码：</p>\n<p>大致意思就是通过native方法获取内存映射的地址，如果失败，手动gc再次映射；最后通过内存映射的地址实例化出MappedByteBuffer，MappedByteBuffer本身是一个抽象类，其实这里真正实例话出来的是DirectByteBuffer；</p>\n<p>2、DirectByteBuffer</p>\n<p>DirectByteBuffer继承于MappedByteBuffer，从名字就可以猜测出开辟了一段直接的内存，并不会占用jvm的内存空间；上一节中通过Filechannel映射出的MappedByteBuffer其实际也是DirectByteBuffer，当然除了这种方式，也可以手动开辟一段空间：</p>\n<p>如上开辟了100字节的直接内存空间；</p>\n<p>3、<code>Channel-to-Channel</code> 传输</p>\n<p>经常需要从一个位置将文件传输到另外一个位置，FileChannel提供了transferTo()方法用来提高传输的效率，首先看一个简单的实例：</p>\n<p>通过FileChannel的transferTo()方法将文件数据传输到System.out通道，接口定义如下：</p>\n<p>几个参数也比较好理解，分别是开始传输的位置，传输的字节数，以及目标通道；transferTo()允许将一个通道交叉连接到另一个通道，而不需要一个中间缓冲区来传递数据；</p>\n<p>注：这里不需要中间缓冲区有两层意思：第一层不需要用户空间缓冲区来拷贝内核缓冲区，另外一层两个通道都有自己的内核缓冲区，两个内核缓冲区也可以做到无需拷贝数据；</p>\n<h2 id=\"netty零拷贝\" tabindex=\"-1\"> <code>Netty</code>零拷贝</h2>\n<p>netty提供了零拷贝的buffer，在传输数据时，最终处理的数据会需要对单个传输的报文，进行组合和拆分，Nio原生的ByteBuffer无法做到，netty通过提供的Composite(组合)和Slice(拆分)两种buffer来实现零拷贝；看下面一张图会比较清晰：</p>\n<p>TCP层HTTP报文被分成了两个<code>ChannelBuffer</code>，这两个Buffer对我们上层的逻辑(HTTP处理)是没有意义的。但是两个<code>ChannelBuffer</code>被组合起来，就成为了一个有意义的HTTP报文，这个报文对应的ChannelBuffer，才是能称之为”Message”的东西，这里用到了一个词”<code>Virtual Buffer</code>”。</p>\n<p>可以看一下netty提供的CompositeChannelBuffer源码：</p>\n<h2 id=\"java-nio中对零拷贝的使用有哪些呢\" tabindex=\"-1\"> Java NIO中对零拷贝的使用有哪些呢？</h2>\n<p>NIO <code>DirectByteBuffer</code></p>\n<p>Java NIO引入了用于通道的缓冲区的<code>ByteBuffer</code>。 ByteBuffer有三个主要的实现：</p>\n<p>HeapByteBuffer</p>\n<p>在调用<code>ByteBuffer.allocate()</code>时使用。 它被称为堆，因为它保存在JVM的堆空间中，因此您可以获得所有优势，如GC支持和缓存优化。 但是，它不是页面对齐的，这意味着如果您需要通过JNI与本地代码交谈，JVM将不得不复制到对齐的缓冲区空间。</p>\n<p>DirectByteBuffer</p>\n<p>在调用<code>ByteBuffer.allocateDirect()</code>时使用。 JVM将使用malloc()在堆空间之外分配内存空间。 因为它不是由JVM管理的，所以你的内存空间是页面对齐的，不受GC影响，这使得它成为处理本地代码的完美选择。 然而，你要C程序员一样，自己管理这个内存，必须自己分配和释放内存来防止内存泄漏。</p>\n<p>MappedByteBuffer</p>\n<p>在调用<code>FileChannel.map()</code>时使用。 与<code>DirectByteBuffer</code>类似，这也是JVM堆外部的情况。 它基本上作为<code>OS mmap()</code>系统调用的包装函数，以便代码直接操作映射的物理内存数据。</p>\n<h2 id=\"总结\" tabindex=\"-1\"> 总结</h2>\n<p>零拷贝是操作系统底层的一种实现，我们在网络编程中，利用操作系统这一特性，可以大大提高数据传输的效率。这也是目前网络编程框架中都会采用的方式，理解好零拷贝，有助于我们进一步学习Netty等网络通信框架的底层原理。</p>\n",
      "date_published": "2022-05-24T07:41:09.000Z",
      "date_modified": "2022-05-24T07:41:09.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "SpringBoot + Nacos实现配置中心",
      "url": "http://www.zhangsj.xyz/blog/java/soa/apollo.html",
      "id": "http://www.zhangsj.xyz/blog/java/soa/apollo.html",
      "content_html": "<h1 id=\"springboot-nacos实现配置中心\" tabindex=\"-1\"> SpringBoot + Nacos实现配置中心</h1>\n<h2 id=\"为什么需要配置中心\" tabindex=\"-1\"> 为什么需要配置中心</h2>\n<ul>\n<li>同一个项目有多套配置，分布在不同的配置文件中，需要修改时，要改多个文件，有时候会遗漏配置（复用性，减少重复，统一管理）</li>\n<li>项目外包时，一些秘钥配置不想提供给第三方（安全）</li>\n<li>某天突然需要修改线上的一个配置，只能修改、提交，重启服务（热部署）</li>\n</ul>\n<p>配置中心一般提供什么功能</p>\n<ul>\n<li>统一管理不同环境、不同集群的配置</li>\n<li>配置修改实时生效（热发布）</li>\n<li>版本管理，每次配置的修改都会有版本记录，可随时回滚</li>\n<li>权限管理。配置中心可交给专人来管理，做到配置的权限管理</li>\n</ul>\n<h2 id=\"nacos-的关键特性包括\" tabindex=\"-1\"> Nacos 的关键特性包括:</h2>\n<p>nacos(naming configuration service)是一款阿里巴巴开源的服务注册与发现、配置管理的组件，相当于是Euraka+Config的组合形态。</p>\n<ul>\n<li>动态<code>DNS</code>服务</li>\n<li>动态配置服务</li>\n<li>服务及其元数据管理</li>\n<li>服务发现和服务健康监测</li>\n</ul>\n<p>Nacos实现配置中心，在使用配置中心之前，我们一般这样实现配置：</p>\n<p>1、在配置文件增加配置（application.yml）</p>\n<div><pre><code><span>datasource</span><span>:</span>\n  <span>url</span><span>:</span> localhost<span>:</span><span>3306</span>\n  <span>username</span><span>:</span> root\n  <span>password</span><span>:</span> root\n\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>",
      "date_published": "2022-05-19T10:22:17.000Z",
      "date_modified": "2022-05-19T10:22:17.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Cookie和Session的区别",
      "url": "http://www.zhangsj.xyz/blog/java/basic/cookie&session-connect.html",
      "id": "http://www.zhangsj.xyz/blog/java/basic/cookie&session-connect.html",
      "content_html": "<h2 id=\"_1、存储位置不同\" tabindex=\"-1\"> 1、存储位置不同</h2>\n<ul>\n<li>cookie的数据信息存放在客户端浏览器上。对于并发用户十分多的网站，cookie是很好的选择。</li>\n<li>session的数据信息存放在服务器上。每个用户都会产生一个session。假如并发访问的用户十分多，会产生十分多的session，耗费大量的内存。</li>\n</ul>\n<h2 id=\"_2、存储容量不同\" tabindex=\"-1\"> 2、存储容量不同</h2>\n<p>单个cookie保存的数据&lt;=4KB，一个站点最多保存20个Cookie。</p>\n<p>对于session来说并没有上限，但出于对服务器端的性能考虑，session内不要存放过多的东西，并且设置session删除机制。</p>\n<h2 id=\"_3、存储方式不同\" tabindex=\"-1\"> 3、存储方式不同</h2>\n<p><code>cookie</code>中只能保管<code>ASCII</code>字符串，并需要通过编码方式存储为<code>Unicode</code>字符或者二进制数据。</p>\n<p>session中能够存储任何类型的数据，包括且不限于<code>string</code>，<code>integer</code>，<code>list</code>，<code>map</code>等。</p>\n<h2 id=\"_4、隐私策略不同\" tabindex=\"-1\"> 4、隐私策略不同</h2>\n<p>cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的。</p>\n<p><code>session</code>存储在服务器上，对客户端是透明的，不存在敏感信息泄漏的风险。</p>\n<h2 id=\"_5、有效期上不同\" tabindex=\"-1\"> 5、有效期上不同</h2>\n<p>开发可以通过设置<code>cookie</code>的属性，达到使cookie长期有效的效果。</p>\n<p><code>session</code>依赖于名为<code>JSESSIONID</code>的<code>cookie</code>，而<code>cookie JSESSIONID</code>的过期时间默认为<code>-1</code>，只需关闭窗口该<code>session</code>就会失效，因而<code>session</code>不能达到长期有效的效果。</p>\n<h2 id=\"_6、浏览器支持不同\" tabindex=\"-1\"> 6、浏览器支持不同</h2>\n<p>假如客户端浏览器不支持cookie：</p>\n<p><code>cookie</code>是需要客户端浏览器支持的，假如客户端禁用了cookie，或者不支持cookie，则会话跟踪会失效。关于WAP上的应用，常规的cookie就派不上用场了。</p>\n<p>运用session需要使用URL地址重写的方式。一切用到session程序的URL都要进行URL地址重写，否则session会话跟踪还会失效。</p>\n<p>假如客户端支持cookie：\nFleet\ncookie既能够设为本浏览器窗口以及子窗口内有效，也能够设为一切窗口内有效。</p>\n<p>session只能在本窗口以及子窗口内有效。</p>\n<h2 id=\"_7、跨域支持上不同\" tabindex=\"-1\"> 7、跨域支持上不同</h2>\n<p><code>cookie</code>支持跨域名访问。</p>\n<p><code>session</code>不支持跨域名访问。</p>\n",
      "date_published": "2022-04-24T22:51:18.000Z",
      "date_modified": "2022-04-24T22:51:18.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "线程池数量设置",
      "url": "http://www.zhangsj.xyz/blog/java/concurrent/thread-pool-nums-set.html",
      "id": "http://www.zhangsj.xyz/blog/java/concurrent/thread-pool-nums-set.html",
      "content_html": "<p>cookie&amp;session-connect</p>\n<h2 id=\"一、前言\" tabindex=\"-1\"> 一、前言</h2>\n<p>“不好了，线上服务器超时严重，请求非常慢，好像报连接数<code>too many</code>了，怎么办？“小伙伴们在反馈。一般我们的技术老大的处理方式，把连接数和线程池调大点，重启，再观察。</p>\n<p>往往这个方式是应急措施，<strong>治标不治本，因为不知道问题的原因</strong>。</p>\n<p>有个严重误区，以为<strong>线程池设置太小了，调大点请求就会快了。</strong></p>\n<p>今天就带着小伙伴们沟通一下，线程池的大小应该如何合理的设置其大小？</p>\n<h2 id=\"二、问题\" tabindex=\"-1\"> 二、问题</h2>\n<p>如果有两个任务需要处理，一个任务A，一个任务B</p>\n<ul>\n<li>方案一：一个线程执行任务A和B，A执行完后，执行B</li>\n<li>方案二：两个线程A和B去执行任务A 和 B，同时进行</li>\n</ul>\n<p><strong>哪个方案会快点？</strong></p>\n<p>应该很多人会回答，<strong>肯定是方案二啊</strong>，多线程并行去处理任务A和B，肯定快啊。</p>\n<p>是这样吗？**回答这个问题之前，**先带着大家去回顾梳理一下。</p>\n<p>Arithmetic</p>\n<h2 id=\"三、线程执行\" tabindex=\"-1\"> 三、线程执行</h2>\n<p>线程的执行，是由CPU进行调度的，一个CPU在同一时刻只会执行一个线程，我们看上去的线程A和线程B并发执行。</p>\n<p>为了让用户感觉这些任务正在同时进行，操作系统利用了时间片轮转的方式，CPU给每个任务都服务一定的时间，然后把当前任务的状态保存下来，在加载下一任务的状态后，继续服务下一任务。任务的状态保存及再加载，这段过程就叫做上下文切换。</p>\n<p>上下文切换过程是需要时间的，现在我们来看一下上面的问题，小伙伴们再看一下是哪个方案快呢？</p>\n<p>是不是有些小伙伴们会说方案一，因为不需要线程切换；方案二需要来回切换这两个线程，耗时会多点。</p>\n<p>小伙伴们心中此时是不是会有疑惑，**那为什么会有多线程？**先不急，再往下看。</p>\n<h2 id=\"四、为什么要多线程\" tabindex=\"-1\"> 四、为什么要多线程</h2>\n<p>小伙伴想想在我们<strong>真实业务中，我们是什么流程？</strong></p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/UtWdDgynLdb0iauAicBo9uqdvwjMiaYWkpegKoXJfibJXniaTTuB2JuiaWYyqAHC0KRiaAVpK2UBRMZzrbvcXaYUHicEzA/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" alt=\"图片\" loading=\"lazy\"></p>\n<p>上图的流程：</p>\n<ol>\n<li>先发起网络请求</li>\n<li>Web服务器解析请求</li>\n<li>请求后端的数据库获取数据</li>\n<li>获取数据后，进行处理</li>\n<li>把处理结果放回给用户</li>\n</ol>\n<p>这个是我们处理业务的时候，<strong>常规的请求流程</strong>；我们看一下整个过程<strong>涉及到什么计算机处理。</strong></p>\n<ol>\n<li>网络请求-----&gt;网络IO</li>\n<li>解析请求-----&gt;CPU</li>\n<li>请求数据库-----&gt;网络IO</li>\n<li>MySQL查询数据-----&gt;磁盘IO</li>\n<li>MySQL返回数据-----&gt;网络IO</li>\n<li>数据处理-----&gt;CPU</li>\n<li>返回数据给用户-----&gt;网络IO</li>\n</ol>\n<p>讲到这里，小伙伴们是不是感觉又不乱了，在<strong>真实业务中我们不单单会涉及CPU计算，还有网络IO和磁盘IO处理</strong>，这些处理是非常耗时的。如果一个线程整个流程是上图的流程，真正涉及到CPU的只有2个节点，其他的节点都是IO处理，那么线程在做IO处理的时候，CPU就空闲出来了，CPU的利用率就不高。</p>\n<p>小伙伴们现在知道<strong>多线程的用处了吧，对，就是为了提升CPU利用率</strong>。</p>\n<h2 id=\"五、提升qps-tps\" tabindex=\"-1\"> 五、提升QPS/TPS</h2>\n<p>衡量系统性能如何，主要指标系统的（QPS/TPS）</p>\n<ol>\n<li>QPS/TPS：每秒能够处理请求/事务的数量</li>\n<li>并发数：系统同时处理的请求/事务的数量</li>\n<li>响应时间：就是平均处理一个请求/事务需要时长</li>\n</ol>\n<p><code>QPS/TPS = 并发数/响应时间</code></p>\n<p>上面公式代表<strong>并发数越大，QPS就越大</strong>；所以很多人就会以为调大线程池，并发数就会大，也会提升QPS，所以才会出现一开始前言所说的，大多数人的误区。</p>\n<p><strong>其实QPS还跟响应时间成反比，响应时间越大，QPS就会越小。</strong></p>\n<p>虽然并发数调大了，就会提升QPS，但<strong>线程数也会影响响应时间</strong>，因为上面我们也提到了上下文切换的问题，那<strong>怎么设置线程数的呢？</strong></p>\n<h2 id=\"六、如何设置线程数\" tabindex=\"-1\"> 六、如何设置线程数</h2>\n<p>那我们如何分配线程？我们提供一个公式：</p>\n<div><pre><code>最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目\n</code></pre><div aria-hidden=\"true\"><span>1</span><br></div></div><blockquote>\n<p>备注这个公式也是<strong>前辈们分享</strong>的，当然之前看了<strong>淘宝前台系统优化实践</strong>的文章，和上面的公式很类似，不过在CPU数目那边，他们更细化了，<strong>上面的公式只是参考</strong>。不过不管什么公式，<strong>最终还是在生产环境中运行后，再优化调整。</strong></p>\n</blockquote>\n<p>我们继续上面的任务，我们的<strong>服务器CPU核数为4核，一个任务线程cpu耗时为20ms，线程等待（网络IO、磁盘IO）耗时80ms，那最佳线程数目：( 80 + 20 )/20 * 4 = 20</strong>。也就是设置20个线程数最佳。</p>\n<p>从这个公式上面我们就得出，<strong>线程的等待时间越大，线程数就要设置越大</strong>，这个正好符合我们上面的分析，可提升CPU利用率。那从另一个角度上面说，<strong>线程数设置多大，是根据我们自身的业务的，需要自己去压力测试，设置一个合理的数值。</strong></p>\n<h2 id=\"七、基础常规标准\" tabindex=\"-1\"> 七、基础常规标准</h2>\n<p>那我们小伙伴们会问，<strong>因为很多业务集中到一个线程池中，不像上面的案例比较简单，事实上业务太多，怎么设置呢</strong>？这个就是要去压力测试去调整。不过我们的前辈已经帮我们总结了一个基础的值（最终还是要看运行情况自行调整）</p>\n<ol>\n<li>CPU密集型：**操作内存处理的业务，一般线程数设置为：CPU核数 + 1 或者 CPU核数*2。核数为4的话，一般设置 5 或 8</li>\n<li>IO密集型：**文件操作，网络操作，数据库操作，一般线程设置为：cpu核数 / (1-0.9)，核数为4的话，一般设置 40</li>\n</ol>\n<h2 id=\"八、总结\" tabindex=\"-1\"> 八、总结</h2>\n<p>今天介绍了线程数大小的设置，一些小伙伴们的误区。讲到这里我们小伙伴们是不是对线程有了更新的理解，<strong>不像之前那么粗暴，应该要去分析为什么这么慢，系统的瓶颈出现在什么地方，减少瓶颈的耗时。</strong></p>\n<p>另外，推荐小伙伴们再去看一下Redis、Nginx；为什么他们会那么快呢？其实和这篇文章的知识点有共同的地方。</p>\n",
      "image": "https://mmbiz.qpic.cn/mmbiz_jpg/UtWdDgynLdb0iauAicBo9uqdvwjMiaYWkpegKoXJfibJXniaTTuB2JuiaWYyqAHC0KRiaAVpK2UBRMZzrbvcXaYUHicEzA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1",
      "date_published": "2022-04-24T22:51:18.000Z",
      "date_modified": "2022-04-24T22:51:18.000Z",
      "authors": [],
      "tags": [
        "并发"
      ]
    },
    {
      "title": "面试题汇总",
      "url": "http://www.zhangsj.xyz/blog/java/interview/interview-question.html",
      "id": "http://www.zhangsj.xyz/blog/java/interview/interview-question.html",
      "content_html": "<h2 id=\"一、基础篇\" tabindex=\"-1\"> 一、基础篇</h2>\n<h3 id=\"_1-1、java基础\" tabindex=\"-1\"> 1.1、Java基础</h3>\n<ul>\n<li>面向对象的特征：继承、封装和多态</li>\n<li>final, finally, finalize 的区别</li>\n<li>Exception、Error、运行时异常与一般异常有何异同</li>\n<li>请写出5种常见到的 <code>runtime exception</code></li>\n<li>int 和 Integer 有什么区别，Integer的值缓存范围</li>\n<li>包装类，装箱和拆箱</li>\n<li>String、StringBuilder、StringBuffer</li>\n<li>重载和重写的区别</li>\n<li>抽象类和接口有什么区别</li>\n<li>说说反射的用途及实现</li>\n<li>说说自定义注解的场景及实现</li>\n<li>HTTP请求的GET与POST方式的区别</li>\n<li>Session与Cookie区别</li>\n<li>列出自己常用的JDK包</li>\n<li>MVC设计思想</li>\n<li>equals与==的区别</li>\n<li>hashCode和equals方法的区别与联系</li>\n<li>什么是Java序列化和反序列化，如何实现Java序列化？或者请解释Serializable 接口的作用</li>\n<li>Object类中常见的方法，为什么wait notify会放在Object里边？</li>\n<li>Java的平台无关性如何体现出来的</li>\n<li>JDK和JRE的区别</li>\n<li>Java 8有哪些新特性</li>\n</ul>\n<h3 id=\"_1-2、java常见集合\" tabindex=\"-1\"> 1.2、Java常见集合</h3>\n<ul>\n<li>List 和 Set 区别</li>\n<li>Set和hashCode以及equals方法的联系</li>\n<li>List 和 Map 区别</li>\n<li>Arraylist 与 LinkedList 区别</li>\n<li>ArrayList 与 Vector 区别</li>\n<li>HashMap 和 Hashtable 的区别</li>\n<li>HashSet 和 HashMap 区别</li>\n<li>HashMap 和 ConcurrentHashMap 的区别</li>\n<li>HashMap 的工作原理及代码实现，什么时候用到红黑树</li>\n<li>多线程情况下HashMap死循环的问题</li>\n<li>HashMap出现Hash DOS攻击的问题</li>\n<li>ConcurrentHashMap 的工作原理及代码实现，如何统计所有的元素个数</li>\n<li>手写简单的HashMap</li>\n<li>看过那些Java集合类的源码</li>\n</ul>\n<p>1.3、进程和线程</p>\n<ul>\n<li>线程和进程的概念、并行和并发的概念</li>\n<li>创建线程的方式及实现</li>\n<li>进程间通信的方式</li>\n<li>说说 CountDownLatch、CyclicBarrier 原理和区别</li>\n<li>说说 Semaphore 原理</li>\n<li>说说 Exchanger 原理</li>\n<li>ThreadLocal 原理分析，ThreadLocal为什么会出现OOM，出现的深层次原理</li>\n<li>讲讲线程池的实现原理</li>\n<li>线程池的几种实现方式</li>\n<li>线程的生命周期，状态是如何转移的</li>\n<li>可参考：《<a href=\"http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247484881&amp;idx=2&amp;sn=b0ecf85cd7c9e543c84e7a9859c20a26&amp;chksm=e9c5fc60deb27576a6a9c453dabc585f43d9f29fd8a8f37ed0e7cc2f012c86b23fbd21763a39&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">Java多线程编程核心技术</a>》</li>\n</ul>\n<h3 id=\"_1-4、锁机制\" tabindex=\"-1\"> 1.4、锁机制</h3>\n<ul>\n<li>说说线程安全问题，什么是线程安全，如何保证线程安全</li>\n<li>重入锁的概念，重入锁为什么可以防止死锁</li>\n<li>产生死锁的四个条件（互斥、请求与保持、不剥夺、循环等待）</li>\n<li>如何检查死锁（通过jConsole检查死锁）</li>\n<li>volatile 实现原理（禁止指令重排、刷新内存）</li>\n<li>synchronized 实现原理（对象监视器）</li>\n<li>synchronized 与 lock 的区别</li>\n<li>AQS同步队列</li>\n<li>CAS无锁的概念、乐观锁和悲观锁</li>\n<li>常见的原子操作类</li>\n<li>什么是ABA问题，出现ABA问题JDK是如何解决的</li>\n<li>乐观锁的业务场景及实现方式</li>\n<li>Java 8并法包下常见的并发类</li>\n<li>偏向锁、轻量级锁、重量级锁、自旋锁的概念</li>\n<li>可参考：《<a href=\"http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247484881&amp;idx=2&amp;sn=b0ecf85cd7c9e543c84e7a9859c20a26&amp;chksm=e9c5fc60deb27576a6a9c453dabc585f43d9f29fd8a8f37ed0e7cc2f012c86b23fbd21763a39&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">Java多线程编程核心技术</a>》</li>\n</ul>\n<h3 id=\"_1-5、jvm\" tabindex=\"-1\"> 1.5、JVM</h3>\n<ul>\n<li>JVM运行时内存区域划分</li>\n<li>内存溢出OOM和堆栈溢出SOE的示例及原因、如何排查与解决</li>\n<li>如何判断对象是否可以回收或存活</li>\n<li>常见的GC回收算法及其含义</li>\n<li>常见的JVM性能监控和故障处理工具类：jps、jstat、jmap、jinfo、jconsole等</li>\n<li>JVM如何设置参数</li>\n<li>JVM性能调优</li>\n<li>类加载器、双亲委派模型、一个类的生命周期、类是如何加载到JVM中的</li>\n<li>类加载的过程：加载、验证、准备、解析、初始化</li>\n<li>强引用、软引用、弱引用、虚引用</li>\n<li>Java内存模型JMM</li>\n</ul>\n<h3 id=\"_1-6、设计模式\" tabindex=\"-1\"> 1.6、设计模式</h3>\n<ul>\n<li>常见的设计模式</li>\n<li>设计模式的的六大原则及其含义</li>\n<li>常见的单例模式以及各种实现方式的优缺点，哪一种最好，手写常见的单利模式</li>\n<li>设计模式在实际场景中的应用</li>\n<li>Spring中用到了哪些设计模式</li>\n<li>MyBatis中用到了哪些设计模式</li>\n<li>你项目中有使用哪些设计模式</li>\n<li>说说常用开源框架中设计模式使用分析</li>\n<li>动态代理很重要！！！</li>\n</ul>\n<p>1.7、数据结构</p>\n<ul>\n<li>树（二叉查找树、平衡二叉树、红黑树、B树、B+树）</li>\n<li>深度有限算法、广度优先算法</li>\n<li>克鲁斯卡尔算法、普林母算法、迪克拉斯算法</li>\n<li>什么是一致性Hash及其原理、Hash环问题</li>\n<li>常见的排序算法和查找算法：快排、折半查找、堆排序等</li>\n</ul>\n<h3 id=\"_1-8、网络-io基础\" tabindex=\"-1\"> 1.8、网络/IO基础</h3>\n<ul>\n<li>BIO、NIO、AIO的概念</li>\n<li>什么是长连接和短连接</li>\n<li>Http1.0和2.0相比有什么区别，可参考《<a href=\"http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247484611&amp;idx=1&amp;sn=66c875392eedff8150633ddcd5d83e7a&amp;chksm=e9c5fd72deb274648a607b9bc39bac34adadd768577b77354f6dc85422691605e210b69eeb7b&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">Http 2.0</a>》</li>\n<li>Https的基本概念</li>\n<li>三次握手和四次挥手、为什么挥手需要四次</li>\n<li>从游览器中输入URL到页面加载的发生了什么？可参考《<a href=\"http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247483724&amp;idx=1&amp;sn=e58dd30d124971c795584e8673d6cc71&amp;chksm=e9c5f8fddeb271ebebbb6c350ed1abc252f1f26b4f35c4ce36e10bde9659a37520feabed2290&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">从输入URL到页面加载发生了什么</a>》</li>\n</ul>\n<p>二、数据存储和消息队列</p>\n<h3 id=\"_2-1、数据库\" tabindex=\"-1\"> 2.1、数据库</h3>\n<ul>\n<li>MySQL 索引使用的注意事项</li>\n<li>DDL、DML、DCL分别指什么</li>\n<li>explain命令</li>\n<li>left join，right join，inner join</li>\n<li>数据库事物ACID（原子性、一致性、隔离性、持久性）</li>\n<li>事物的隔离级别（读未提交、读以提交、可重复读、可序列化读）</li>\n<li>脏读、幻读、不可重复读</li>\n<li>数据库的几大范式</li>\n<li>数据库常见的命令</li>\n<li>说说分库与分表设计</li>\n<li>分库与分表带来的分布式困境与应对之策（如何解决分布式下的分库分表，全局表？）</li>\n<li>说说 SQL 优化之道</li>\n<li>MySQL遇到的死锁问题、如何排查与解决</li>\n<li>存储引擎的 InnoDB与MyISAM区别，优缺点，使用场景</li>\n<li>索引类别（B+树索引、全文索引、哈希索引）、索引的原理</li>\n<li>什么是自适应哈希索引（AHI）</li>\n<li>为什么要用 B+tree作为MySQL索引的数据结构</li>\n<li>聚集索引与非聚集索引的区别</li>\n<li>遇到过索引失效的情况没，什么时候可能会出现，如何解决</li>\n<li>limit 20000 加载很慢怎么解决</li>\n<li>如何选择合适的分布式主键方案</li>\n<li>选择合适的数据存储方案</li>\n<li>常见的几种分布式ID的设计方案</li>\n<li>常见的数据库优化方案，在你的项目中数据库如何进行优化的</li>\n</ul>\n<h3 id=\"_2-2、redis\" tabindex=\"-1\"> 2.2、Redis</h3>\n<ul>\n<li>Redis 有哪些数据类型，可参考《<a href=\"http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247483987&amp;idx=1&amp;sn=5c5e4cd5bc73a7e6f84e5d6adfab0935&amp;chksm=e9c5fbe2deb272f4b5b75bd2ac92bb27950452623ec83c0e1add7e30c773160421fab1571680&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">Redis常见的5种不同的数据类型详解</a>》</li>\n<li>Redis 内部结构</li>\n<li>Redis 使用场景</li>\n<li>Redis 持久化机制，可参考《<a href=\"http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247483992&amp;idx=1&amp;sn=8f554bc490c4db1a78a30144f873e911&amp;chksm=e9c5fbe9deb272fff47483c241e6d2a7aae99dc8f6fe9fee31f2dd214d0cf81b33d51f7a7dbe&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">使用快照和AOF将Redis数据持久化到硬盘中</a>》</li>\n<li>Redis 集群方案与实现</li>\n<li>Redis 为什么是单线程的？</li>\n<li>缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级</li>\n<li>使用缓存的合理性问题</li>\n<li>Redis常见的回收策略</li>\n</ul>\n<h3 id=\"_2-3、消息队列\" tabindex=\"-1\"> 2.3、消息队列</h3>\n<ul>\n<li>消息队列的使用场景</li>\n<li>消息的重发补偿解决思路</li>\n<li>消息的幂等性解决思路</li>\n<li>消息的堆积解决思路</li>\n<li>自己如何实现消息队列</li>\n<li>如何保证消息的有序性</li>\n</ul>\n<h2 id=\"三、开源框架和容器\" tabindex=\"-1\"> 三、开源框架和容器</h2>\n<h3 id=\"_3-1、ssm-servlet\" tabindex=\"-1\"> 3.1、SSM/Servlet</h3>\n<ul>\n<li>Servlet的生命周期</li>\n<li>转发与重定向的区别</li>\n<li>BeanFactory 和 ApplicationContext 有什么区别</li>\n<li>Spring Bean 的生命周期</li>\n<li>Spring IOC 如何实现</li>\n<li>Spring中Bean的作用域，默认的是哪一个</li>\n<li>说说 Spring AOP、Spring AOP 实现原理</li>\n<li>动态代理（CGLib 与 JDK）、优缺点、性能对比、如何选择</li>\n<li>Spring 事务实现方式、事务的传播机制、默认的事务类别</li>\n<li>Spring 事务底层原理</li>\n<li>Spring事务失效（事务嵌套），JDK动态代理给Spring事务埋下的坑，可参考《<a href=\"http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247484940&amp;idx=1&amp;sn=0a0a7198e96f57d610d3421b19573002&amp;chksm=e9c5ffbddeb276ab64ff3b3efde003193902c69acda797fdc04124f6c2a786255d58817b5a5c&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">JDK动态代理给Spring事务埋下的坑！</a>》</li>\n<li>如何自定义注解实现功能</li>\n<li>Spring MVC 运行流程</li>\n<li>Spring MVC 启动流程</li>\n<li>Spring 的单例实现原理</li>\n<li>Spring 框架中用到了哪些设计模式</li>\n<li>Spring 其他产品（Srping Boot、Spring Cloud、Spring Secuirity、Spring Data、Spring AMQP 等）</li>\n<li>有没有用到Spring Boot，Spring Boot的认识、原理</li>\n<li>MyBatis的原理</li>\n<li>可参考《<a href=\"http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247484822&amp;idx=1&amp;sn=6fbee2a12b31b6102a18d3725671d41b&amp;chksm=e9c5fc27deb275319641c3f30d168b85c7c196fd276d47efa35046b5dc54f5b77174c5bf8808&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">为什么会有Spring</a>》</li>\n<li>可参考《<a href=\"http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247484827&amp;idx=1&amp;sn=b9d82f3fced6a875f8dfc22e5849b28e&amp;chksm=e9c5fc2adeb2753c516ef8fc959c0c9dd84ccacaa40473b64bc58b5137c30562a0b45803ba8e&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">为什么会有Spring AOP</a>》</li>\n</ul>\n<h3 id=\"_3-2、netty\" tabindex=\"-1\"> 3.2、Netty</h3>\n<ul>\n<li>为什么选择 Netty</li>\n<li>说说业务中，Netty 的使用场景</li>\n<li>原生的 NIO 在 JDK 1.7 版本存在 epoll bug</li>\n<li>什么是TCP 粘包/拆包</li>\n<li>TCP粘包/拆包的解决办法</li>\n<li>Netty 线程模型</li>\n<li>说说 Netty 的零拷贝</li>\n<li>Netty 内部执行流程</li>\n<li>Netty 重连实现</li>\n</ul>\n<p>3.3、Tomcat</p>\n<ul>\n<li>Tomcat的基础架构（Server、Service、Connector、Container）</li>\n<li>Tomcat如何加载Servlet的</li>\n<li>Pipeline-Valve机制</li>\n<li>可参考：《<a href=\"http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247484905&amp;idx=1&amp;sn=6c8acd89476fadbc4cb9ccfda9c9c2e4&amp;chksm=e9c5fc58deb2754e7519511bb0ed8dcbfa3fe29179663b53f3626643f8b9c82068d9b0464ee6&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">四张图带你了解Tomcat系统架构</a>！》</li>\n</ul>\n<h2 id=\"四、分布式\" tabindex=\"-1\"> 四、分布式</h2>\n<h3 id=\"_4-1、nginx\" tabindex=\"-1\"> 4.1、Nginx</h3>\n<ul>\n<li>请解释什么是C10K问题或者知道什么是C10K问题吗？</li>\n<li>Nginx简介，可参考《<a href=\"http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247483994&amp;idx=1&amp;sn=b6591f62c7ea6b4adc5a5bf1bf4eac40&amp;chksm=e9c5fbebdeb272fdd865a9c61a380f6b909fc988f99d00ce0aa8c3efca501644db46c40bd4f2&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">Nginx简介</a>》</li>\n<li>正向代理和反向代理.</li>\n<li>Nginx几种常见的负载均衡策略</li>\n<li>Nginx服务器上的Master和Worker进程分别是什么</li>\n<li>使用“反向代理服务器”的优点是什么?</li>\n</ul>\n<h3 id=\"_4-2、分布式其他\" tabindex=\"-1\"> 4.2、分布式其他</h3>\n<ul>\n<li>谈谈业务中使用分布式的场景</li>\n<li>Session 分布式方案</li>\n<li>Session 分布式处理</li>\n<li>分布式锁的应用场景、分布式锁的产生原因、基本概念</li>\n<li>分布是锁的常见解决方案</li>\n<li>分布式事务的常见解决方案</li>\n<li>集群与负载均衡的算法与实现</li>\n<li>说说分库与分表设计，可参考《<a href=\"http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247483931&amp;idx=1&amp;sn=6eda41aa81c1243422a603205d2fad22&amp;chksm=e9c5fbaadeb272bc92537803c14a6f55e1170b1a3b8f60160f66417800c0ace960dfe192717a&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">数据库分库分表策略的具体实现方案</a>》</li>\n<li>分库与分表带来的分布式困境与应对之策</li>\n</ul>\n<h3 id=\"_4-3、dubbo\" tabindex=\"-1\"> 4.3、Dubbo</h3>\n<ul>\n<li>什么是Dubbo，可参考《<a href=\"http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247483791&amp;idx=1&amp;sn=49345f1a022734e81e9257f2b8d38a52&amp;chksm=e9c5f83edeb2712805a77c1e1589e8f1d04bd17e55eeb2a45cabddb46d03615636908f058628&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">Dubbo入门</a>》</li>\n<li>什么是RPC、如何实现RPC、RPC 的实现原理，可参考《<a href=\"http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247483900&amp;idx=1&amp;sn=c5ca198a66a701f81c2ab118fe7a734a&amp;chksm=e9c5f84ddeb2715bc574e467cd6537ef81f223453e0989ffd136976b48dcc2d961a75be596de&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">基于HTTP的RPC实现</a>》</li>\n<li>Dubbo中的SPI是什么概念</li>\n<li>Dubbo的基本原理、执行流程</li>\n</ul>\n<h2 id=\"五、微服务\" tabindex=\"-1\"> 五、微服务</h2>\n<h3 id=\"_5-1、微服务\" tabindex=\"-1\"> 5.1、微服务</h3>\n<ul>\n<li>前后端分离是如何做的？</li>\n<li>微服务哪些框架</li>\n<li>Spring Could的常见组件有哪些？可参考《<a href=\"http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247484125&amp;idx=1&amp;sn=ddba9fba6ae900f5ef71a68f70afebe5&amp;chksm=e9c5fb6cdeb2727a1e8d16a05adb7d9df0170e392ae579d1e40075fb488d680f0c061aa45327&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Cloud概述</a>》</li>\n<li>领域驱动有了解吗？什么是领域驱动模型？充血模型、贫血模型</li>\n<li>JWT有了解吗，什么是JWT，可参考《<a href=\"http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247485183&amp;idx=1&amp;sn=05dac824dbb534710dd99d6c895fbaf5&amp;chksm=e9c5ff4edeb27658173c8b06ad6d1241d3b7822c734ddf6ac064d40e63cb0cb0a0c90804b9c7&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">前后端分离利器之JWT</a>》</li>\n<li>你怎么理解 RESTful</li>\n<li>说说如何设计一个良好的 API</li>\n<li>如何理解 RESTful API 的幂等性</li>\n<li>如何保证接口的幂等性</li>\n<li>说说 CAP 定理、BASE 理论</li>\n<li>怎么考虑数据一致性问题</li>\n<li>说说最终一致性的实现方案</li>\n<li>微服务的优缺点，可参考《<a href=\"http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247485005&amp;idx=1&amp;sn=78a1d286c6a15a81ea5dcf6634a70b54&amp;chksm=e9c5fffcdeb276ea3c766a6e5954685db0e89bea8ff0f47c9a3ff2c0c02991f791a5160287c4&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">微服务批判</a>》</li>\n<li>微服务与 SOA 的区别</li>\n<li>如何拆分服务、水平分割、垂直分割</li>\n<li>如何应对微服务的链式调用异常</li>\n<li>如何快速追踪与定位问题</li>\n<li>如何保证微服务的安全、认证</li>\n</ul>\n<h3 id=\"_5-2、安全问题\" tabindex=\"-1\"> 5.2、安全问题</h3>\n<ul>\n<li>如何防范常见的Web攻击、如何方式SQL注入</li>\n<li>服务端通信安全攻防</li>\n<li>HTTPS原理剖析、降级攻击、HTTP与HTTPS的对比</li>\n</ul>\n<h3 id=\"_5-3、性能优化\" tabindex=\"-1\"> 5.3、性能优化</h3>\n<ul>\n<li>性能指标有哪些</li>\n<li>如何发现性能瓶颈</li>\n<li>性能调优的常见手段</li>\n<li>说说你在项目中如何进行性能调优</li>\n</ul>\n<h2 id=\"六、其他\" tabindex=\"-1\"> 六、其他</h2>\n<h3 id=\"_6-1、设计能力\" tabindex=\"-1\"> 6.1、设计能力</h3>\n<ul>\n<li>说说你在项目中使用过的UML图</li>\n<li>你如何考虑组件化、服务化、系统拆分</li>\n<li>秒杀场景如何设计</li>\n<li>可参考：《<a href=\"http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247485294&amp;idx=1&amp;sn=681b3fc8833bc978344f66c8dd33ff32&amp;chksm=e9c5fedfdeb277c96e03e8943bff709ad5354cbbe0c0d894cdb9d1e8cc8da92bf51f1e832e37&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">秒杀系统的技术挑战、应对策略以及架构设计总结一二！</a>》</li>\n</ul>\n<h3 id=\"_6-2、业务工程\" tabindex=\"-1\"> 6.2、业务工程</h3>\n<ul>\n<li>说说你的开发流程、如何进行自动化部署的</li>\n<li>你和团队是如何沟通的</li>\n<li>你如何进行代码评审</li>\n<li>说说你对技术与业务的理解</li>\n<li>说说你在项目中遇到感觉最难Bug，是如何解决的</li>\n<li>介绍一下工作中的一个你认为最有价值的项目，以及在这个过程中的角色、解决的问题、你觉得你们项目还有哪些不足的地方</li>\n</ul>\n<h3 id=\"_6-3、软实力\" tabindex=\"-1\"> 6.3、软实力</h3>\n<ul>\n<li>说说你的优缺点、亮点</li>\n<li>说说你最近在看什么书、什么博客、在研究什么新技术、再看那些开源项目的源代码</li>\n<li>说说你觉得最有意义的技术书籍</li>\n<li>工作之余做什么事情、平时是如何学习的，怎样提升自己的能力</li>\n<li>说说个人发展方向方面的思考</li>\n<li>说说你认为的服务端开发工程师应该具备哪些能力</li>\n<li>说说你认为的架构师是什么样的，架构师主要做什么</li>\n<li>如何看待加班的问题</li>\n</ul>\n",
      "date_published": "2022-04-24T22:51:18.000Z",
      "date_modified": "2022-04-24T22:51:18.000Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "二叉树的最大路径",
      "url": "http://www.zhangsj.xyz/blog/algo/maximum-path-of-binary-tree.html",
      "id": "http://www.zhangsj.xyz/blog/algo/maximum-path-of-binary-tree.html",
      "content_html": "<div><pre><code><span>class</span> <span>T</span><span>{</span>\n    <span>public</span> <span>int</span> <span>maxPathLen</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>\n        <span>int</span><span>[</span><span>]</span> max <span>=</span> <span>new</span> <span>int</span><span>[</span><span>]</span><span>{</span><span>Integer</span><span>.</span>MIN_VALUE<span>}</span><span>;</span>\n        <span>dfs</span><span>(</span>root<span>,</span> max<span>)</span><span>;</span>\n        <span>return</span> max<span>[</span><span>0</span><span>]</span><span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>int</span> <span>dfs</span><span>(</span><span>TreeNode</span> root<span>,</span> <span>int</span><span>[</span><span>]</span> max<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>0</span><span>;</span>\n\n        <span>int</span> lHeight <span>=</span> <span>dfs</span><span>(</span>root<span>.</span>left<span>,</span> max<span>)</span><span>;</span>\n        <span>int</span> rHeight <span>=</span> <span>dfs</span><span>(</span>root<span>.</span>right<span>,</span> max<span>)</span><span>;</span>\n\n        <span>if</span> <span>(</span>lHeight <span>+</span> root<span>.</span>val <span>+</span> rHeight <span>></span> max<span>[</span><span>0</span><span>]</span><span>)</span> max<span>[</span><span>0</span><span>]</span> <span>=</span> lHeight <span>+</span> root<span>.</span>val <span>+</span> rHeight<span>;</span>\n        <span>if</span> <span>(</span>lHeight <span>+</span> root<span>.</span>val <span>></span> max<span>[</span><span>0</span><span>]</span><span>)</span> max<span>[</span><span>0</span><span>]</span> <span>=</span> lHeight <span>+</span> root<span>.</span>val<span>;</span>\n        <span>if</span> <span>(</span>root<span>.</span>val <span>+</span> rHeight <span>></span> max<span>[</span><span>0</span><span>]</span><span>)</span> max<span>[</span><span>0</span><span>]</span> <span>=</span> root<span>.</span>val <span>+</span> rHeight<span>;</span>\n        <span>if</span> <span>(</span>root<span>.</span>val <span>></span> max<span>[</span><span>0</span><span>]</span><span>)</span> max<span>[</span><span>0</span><span>]</span> <span>=</span> root<span>.</span>val<span>;</span>\n\n        <span>return</span> <span>Math</span><span>.</span><span>max</span><span>(</span>root<span>.</span>val<span>,</span> <span>Math</span><span>.</span><span>max</span><span>(</span>lHeight <span>+</span> root<span>.</span>val<span>,</span> root<span>.</span>val <span>+</span> rHeight<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div>",
      "date_published": "2022-04-24T09:56:06.000Z",
      "date_modified": "2022-04-24T09:56:06.000Z",
      "authors": [],
      "tags": [
        "算法"
      ]
    },
    {
      "title": "做一个有批判性思维的程序员",
      "url": "http://www.zhangsj.xyz/blog/programlife/be-a-critical-thinking-programmer.html",
      "id": "http://www.zhangsj.xyz/blog/programlife/be-a-critical-thinking-programmer.html",
      "content_html": "<h2 id=\"做一个有批判性思维的程序员\" tabindex=\"-1\"> 做一个有批判性思维的程序员</h2>\n<blockquote>\n<blockquote>\n<p>作为一名程序员，我也喜欢对自己和别人的代码进行批判，为什么要这样写，这个注解有什么用、有没有更好的实现方式等等。对自己写的每一行代码、用到的每一个工具类，都要理解，不然不知道这个工具类都做了什么，怎么敢保证用了之后不会带来Bug？</p>\n</blockquote>\n</blockquote>\n<p>好的游戏一定要让玩家玩的很爽吗？王者荣耀和吃鸡游戏的成功，让这个问题的答案似乎毫无争议，不能带给玩家刺激的游戏就不是好游戏。</p>\n<p>什么样的游戏才能吸引玩家不断的玩下去？答案就一个字，爽，用罗胖的话说就是，从前打一局CS，让你十几分钟爽一次，现在，来一盘农药，让你几分钟就爽一次。然后，吃鸡，一款让你爽的更频繁的游戏又出来了，紧接着，各个大厂的吃鸡游戏陆续上线，大家都在力争带给玩家更多的刺激，因为他们都相信，只有让玩家爽下去，他们才不会把游戏卸载掉。</p>\n<p>就在游戏制造商们为生产出更加痛快的游戏杀红了眼的时候，一只青蛙，一边旅行着，一边给家里寄照片，默默的嘲笑道，“他们真俗！”。</p>\n<h3 id=\"不会批判性思维的你-显得很傻\" tabindex=\"-1\"> 不会批判性思维的你，显得很傻</h3>\n<p>有人说，整天疑神疑鬼的，过着会很累，但是，我想说，如果不学会质疑，你不仅会错过旅行的蛙，而且还会显得你很傻。</p>\n<p>你看到一篇文章，《成功的人，没有哪个是不阅读的》，文章写得非常励志，让很久没有读书的你非常惭愧，心想，都怪自己太懒，要是利用业余时间多读点书，现在说不定都身家千万了，于是你转发了这篇文章，转发时还不忘附上一句：从今天起，我要坚持天天读书[奋斗脸]</p>\n<p>朋友看到你的朋友圈，心想，这人真傻，这话也信，没读过书造样过得很舒服很幸福的人多得是。 于是你成了朋友眼中那个很傻的人。其实，阅读是件好事，但是转发这样的文章，就显得你很没主见，显得很low，很鸡汤，甚至有点“中老年表情包”的范。</p>\n<p>缺少批判性思维给你带来的傻还不止与此，你看了上面那篇文章后开始看书、开始关注各种微信公众号，你看到一篇文章说“晚上吃姜对身体有害”，于是有一天晚上聚餐，你看到服务员上了一盘姜葱鸡，就硬是让服务员把菜退了。</p>\n<p>你聚餐完回到家，刷朋友圈时发现刚刚一起吃饭的小刘，转发了一篇文章，《晚上吃姜有害健康？哈佛教授用实验告诉你真相》，文章中列举了各种真实可靠的实验数据，你顿时有点脸红了，更要命的是，你看到小刘这条朋友圈下面，一堆点赞，而且，点赞的，都是晚上一块吃饭的同事……</p>\n<p>因为没有批判性思维，你把所有的书都视若珍宝，把作者说的话都当成金玉良言，还为了显摆自己看过很多书，不断地再别人面前宣扬书中的各种错误观点，一个字，傻！</p>\n<p>所以，是累好还是傻好呢？我想大多数人还是宁愿累点吧。</p>\n<p>批判性思维就像给大脑装上了一道防火墙，外界的输入在进入我们大脑之前，都要经过筛选，通过筛选的观点和想法，才能进入我们的大脑。</p>\n<p>那么，要怎样进行批判性思维呢，最近阅读了《学会提问——批判性思维指南》，作者Marcia Brown对如何批判性思维进行了系统性的介绍。</p>\n<h3 id=\"如何进行批判性思维\" tabindex=\"-1\"> 如何进行批判性思维</h3>\n<p>要想对一个推理进行批判，首先就要找准这个推理的论题和结论，如果连对方在谈论什么话题、对方的立场是什么都不清楚，那就谈不上什么批判了。</p>\n<p>确定了对方的论题和结论之后，就要找到对方的理由，也就是支撑结论的证据。</p>\n<p>找到对方提供的证据之后，接下来你就可以开始对它进行全方位的批判了。</p>\n<p>总结一下：</p>\n<p>对方在讨论什么（论题）-&gt; 对方想说服我相信什么（结论）-&gt; 对方给出的理由是什么（证据） -&gt; 这些证据靠谱不（批判）</p>\n<p>其中前面三步都很简单，这里就不细说，我们直接谈谈，如何对证据进行批判。</p>\n<h3 id=\"哪些词语意思不明确\" tabindex=\"-1\"> 哪些词语意思不明确</h3>\n<p>你以为的不一定是他以为的。</p>\n<p>“某某牌贴膏，只需三片，即可见效”。</p>\n<p>上面是很多药品广告的广告语，药商往往还会请上几个健康活泼的老人来念这些广告词，但是“见效”这个词是什么含义呢？是指让你再也不会疼痛呢，还是让你一个月内不再疼痛呢，还是只是短暂地缓解病情？显然，这个歧义不解决，你就无法决定是否信服。</p>\n<p>类似的歧义还有很多，最常见的就是模糊不清的需求。客户要求提供一个登录界面，你以为只需要做简单的用户名密码校验就好了，结果呢，客户不单要求输错密码一次后要输入验证码，还要求输错密码五次后当天不得再次登录，甚至还要求可以通过手机和邮箱找回密码……</p>\n<p>解决这类问题的办法——不断质疑：</p>\n<p>“你的意思是……吗？”</p>\n<p>“除了……还需要……吗？”</p>\n<p>“这样子可以满足要求吗？”</p>\n<p>在向客户或者SE的不断提问的过程中，需求也慢慢得到澄清，我们也慢慢看到了客户的真实“验收标准”。</p>\n<p>总之，不要猜测，弄清歧义，才可以下决定。</p>\n<h3 id=\"推理过程中有没有谬误\" tabindex=\"-1\"> 推理过程中有没有谬误</h3>\n<p>总有一些推理听起来非常有说服力，但往往经不起推敲。</p>\n<p>“你代码不能这样写，我们组基本上不用这种写法，而且老黄（某组内专家级人物）推荐要采用另一种写法……”</p>\n<p>很多项目的新人都会遇到类似的说辞，有些人听完就点点头，把自己代码改了。</p>\n<p>然而如果你是一个求知欲很强的程序员，听到类似的解释，至少会在心里回怼一句：“凭什么？？？”</p>\n<p>其实只要仔细思考一下对方的说辞，就会发现对方根本不是在说服你，而是在要挟。</p>\n<p>首先，“我们组基本上不用这种写法”，这是用组内的“江湖规矩”在要挟你，意思是你要入乡随俗；</p>\n<p>其次，“老黄推荐要采用另一种写法”，这是用权威在要挟你，你不可以不服从权威。</p>\n<p>然而，这些都不属于证据，真正的证据应该是像这样的：这样写会有什么性能问题，或者是耦合性问题，用“江湖规矩”和”权威“来试图说服别人，恰恰犯了书中提到的诉诸公众谬误和诉诸可疑权威谬误。</p>\n<p>类似的推理谬误还有很多，我们不可能一一记住。只需记得，在接受对方观点之前，不妨多问一句，凭什么？？？，唤醒自己的懒人脑，进行理性的批判思考。</p>\n<h3 id=\"证据的效力如何\" tabindex=\"-1\"> 证据的效力如何</h3>\n<p>证据的来源有很多，常见的有这四种：</p>\n<ul>\n<li>个人经历</li>\n<li>典型案例</li>\n<li>专家意见</li>\n<li>研究报告</li>\n</ul>\n<p>这些证据的可信度有多少呢？</p>\n<p>1、个人经历和典型案例</p>\n<p>很多人都知道个人经历不可信，可是当看到别人炒股赚的盆满钵满、别人追求自己的理想出去创业收获人生巅峰时，还是忍不住想把对方当做偶像去模仿。</p>\n<p>然而，现实是，那些炒股炒的倾家荡产的、那些创业失败破产倒闭的人，你是看不到对他们的报道的。《清醒思考的艺术》的作者罗尔夫·多贝里，在书中建议读者，多去失败者的“墓地”走走，想想也是很有道理的。</p>\n<p>2、专家意见和研究报告</p>\n<p>既然称为专家，那么也就意味着对方经验丰富、技术高深，在大多数情况下，专家都是对的，不然也不能被人叫做专家。</p>\n<p>然而，专家并不总是对的，在这个时候，你也不必对其冷嘲热讽。我们要做的是，即使是专家的意见，也要批判性对待，不断提出质疑，敢于挑战权威，即使最后证明你的质疑是错的，你的收获，也比那些把专家意见当做真理的人要多很多。</p>\n<p>研究报告也是类似的，很多研究报告都出自著名的实验室，但是这并不代表他们的结论就是正确的。他们做了那些实验，不代表就可以得出那些结论，我们同样需要对他们的实验过程和推理过程进行批判性思考。</p>\n<h3 id=\"数据有没有欺骗性\" tabindex=\"-1\"> 数据有没有欺骗性</h3>\n<p>“大人总是喜欢数字”，小王子的这句话恰恰说明了人性的弱点。</p>\n<p>人们往往容易被带有数字的证据说服，最常见的就是“平均数”陷阱，“XX公司员工平均年收入XXX万”，这种平均数，根本无法说明问题。九个年薪十万的员工和一个年薪千万的员工，平均下来，每人年薪超百万，但是他们十个人中却只有一个过上年薪百万的生活。在很多时候，中位数和众数，比平均数更能说明问题。</p>\n<p>除此之外，数据来源也是你非常值得批判的一个角度，人们总喜欢使用不明来历的数据来证明自己的观点。</p>\n<p>下次再看到金光闪闪的数据或者图表时，先想想数据从何而来，这些数据又有多大意义。</p>\n<h3 id=\"哪些场合要使用批判性思维\" tabindex=\"-1\"> 哪些场合要使用批判性思维</h3>\n<p>生活中有很多场合都需要用到批判性思维：</p>\n<p>1、评价别人的观点</p>\n<p>我们每天都会从各种各样的渠道获取各种新的观点，书籍、微信公众号推送、知乎、简书等等。在接纳这些新观点，或者为之付诸行动之前，应该先批判思考一下，有歧义吗？有谬误吗？凭什么这么说？？？</p>\n<p>2、评价自己的想法</p>\n<p>批判性思维不仅仅是对外进行批判，对自己进行批判也很重要。</p>\n<p>养成记日记的习惯，在回顾自己一天做了什么的时候，顺便批判思考一下，自己今天的哪些行为做的不好。比如我某天晚上记日记的时候，发现自己写了一天代码，但是效率很低，于是第二天就给自己的屏幕录了视频，研究一下自己一天对着电脑都做了什么，看看有哪些可以提高效率的地方。</p>\n<p>3、写作</p>\n<p>既然对别人的文章可以进行批判，那么对自己的文章也同样可以。不妨把自己当做读者，看看自己写的文章里，有哪些没有依据的断言、有哪些词语带有歧义、有哪些论据带有谬误等等。</p>\n<p>同时，对于那些技术性较强的文章，在写完文章初稿之后，不妨接着寻找更多的相关主题的文献，来证明和冲击你的观点。永远不要满足于少量文献，这也是论文通常对参考文献的数量达到一定数量的原因。</p>\n<p>4、学习</p>\n<p>很多人学习一项知识时，喜欢把书或者其他学习资料从头看到尾。事实上，这样做是很没效率的，因为你很难保持那么长时间的专注，尤其是在阅读一些英文的文献时，更是如此。</p>\n<p>这时候就有一个好办法，你可以在粗读了文章，比如文章的标题、文章的开头结尾、段落开头结尾之后，向自己提问题，记下问题清单，然后带着问题清单去文章中找答案，这样学习起来会非常有效率。</p>\n<p>我在学习Kafka的时候，就是阅读了Kafka官方文档中Introduction的章节，对着Get Started做了个Hello World，然后就给自己提了一堆问题，什么Kafka的broker.partition都是啥、Kafka的架构是怎样体现分布式和集群的、Kafka和RabbitMQ相比，有什么优势和劣势，诸如此类自己非常感兴趣、很想了解的问题，接着下一步就是把一个个问题给解决掉，在寻找答案的过程中，不知不觉就把文档翻了好几遍，而且由于我是主动学习，学习的时候十分专注，效率奇高。</p>\n<p>5、批判代码</p>\n<p>作为一名程序员，我也喜欢对自己和别人的代码进行批判，为什么要这样写，这个注解有什么用、有没有更好的实现方式等等。对自己写的每一行代码、用到的每一个工具类，都要理解，不然不知道这个工具类都做了什么，怎么敢保证用了之后不会带来Bug？如果实在来不及去弄清楚，我也会把问题先记下来，等后面有空闲时间了再来慢慢学习。</p>\n<h3 id=\"哪些场合不必使用批判性思维\" tabindex=\"-1\"> 哪些场合不必使用批判性思维</h3>\n<p>也不是所有场合都适合使用批判性思维的，我们也要用批判性思维去看待批判性思维。</p>\n<p>比方说看电影、电视剧， 我身边很多朋友，喜欢在看到电影一些非常不可思议的巧合的时候，说一句，“怎么可能这么凑巧”，每当这时，我就在心里默默的怼一句，“你这人不适合看电影……”</p>\n<p>电影、电视剧、小说等很多虚构的故事，不一定完全符合正常逻辑，但是我们看电影不就是为了放松么？只要在那一瞬间，剧情打动了你或者逗的你哈哈大笑，看电影的目的就达到了。</p>\n<p>我看到的最搞笑的事是，有一次和朋友去看一部喜剧片，看的时候他笑得眼泪都出来了，然后看完电影，他却在朋友圈发了一张图片，晒了他在豆瓣上给这部电影打了两颗星的影评……</p>\n<p>总之，善用批判性思维，看穿生活中的那些谬论，做一个清醒思考的程序员。</p>\n",
      "date_published": "2018-02-04T00:00:00.000Z",
      "date_modified": "2022-04-24T09:56:06.000Z",
      "authors": [
        {
          "name": "SexyCode"
        }
      ],
      "tags": [
        "note"
      ]
    },
    {
      "title": "如何在忙碌的日程安排中不要误入歧途",
      "url": "http://www.zhangsj.xyz/blog/programlife/how-can-programmers-not-take-a-fork.html",
      "id": "http://www.zhangsj.xyz/blog/programlife/how-can-programmers-not-take-a-fork.html",
      "content_html": "<p>程序员忙，似乎是个公论，有些程序员甚至会认为，不忙的程序员无法快速地进步，从而会落伍。或者说，不忙的程序员有可能被公司末尾淘汰掉。对此，一直危机感很重的我深以为然。</p>\n<p>因为，我见过不少得过且过的的程序员工资明显低于同等条件下的平均水平，我更见过更多忙成狗的程序员，因为不知道在忙什么以及为什么忙，所以进步很慢，这真就叫做白忙了。</p>\n<p>不论程序员对“忙”持有什么态度，但似乎很少有程序员能主动地逃避，除非得过且过，但这样似乎是透支日后的发展前景，以此来换取当前的舒适度。</p>\n<p>本文不讨论程序员该不该忙，而是根据切身体会和所见所闻，交流下如下方面感受。</p>\n<ol>\n<li>如何在百忙中更有效地干活，从而让自己能有更多自己的时间，至于这个时间里是休息还是自己发展，那每个人自己看着办。</li>\n<li>如何不被过于繁忙的琐事牵着走，从而迷失自己的发展方向，这里会写些我见过的走岔路程序员的情景，供大家警示。</li>\n<li>如何利用不多的个人时间，快速地提升自己的能力。</li>\n</ol>\n<p>好了，正文开始。</p>\n<h2 id=\"一、忙的程序员心态更得好\" tabindex=\"-1\"> 一、忙的程序员心态更得好</h2>\n<p>最理想的情况是：不忙，钱多，而且个人还能不断地升级。这是每个程序员都想的，但似乎这类工作很少，至少我没见过。</p>\n<p>次一等的是：忙，但拿到的钱能对的上忙的程度，或者通过忙能提升自己（忙得有收获）。</p>\n<p>再差一等的是：忙，虽然能挣到钱，但很大程度上不是为自己忙，即忙了一段时间回顾后，说不上个人有啥提高。</p>\n<p>最差的是：看着别人忙，自己不忙了，（别高兴太早），原因是在公司里或社会上被边缘化了。</p>\n<p>除此之外，不忙的情况我还能想到一种：虽然被分配很多活，但由于个人因素，得过且过。这离被边缘化也不远了。</p>\n<p>总之一句话，很少有程序员不忙。但人一忙，心就烦，不少程序员火气就很大，平时就有可能对测试，对需求方，甚至对领导发火。</p>\n<p>这里想说的是：很多事情是我们无法改变的，那只有改变自己。这话说得很无奈，我们换种说法：心态不好，没法让自己不忙，更办不成事，最终倒霉受累的还是自己，与其这样，还不是待人接物和气些，指不定大家谈得开心，事情还办快些，还能让别人有个好印象。</p>\n<h2 id=\"二、别什么事都做-得分优先级-必要时更得和别人和领导沟通\" tabindex=\"-1\"> 二、别什么事都做，得分优先级，必要时更得和别人和领导沟通</h2>\n<p>浑身都是铁，能打几颗钉？再牛的程序员也不可能啥事都自己做，或者任何与自己相关的事情都自己做。</p>\n<p>再换个说法，一些领导，经理和老板，事情比我们更多了，他们该怎么办？</p>\n<p>如下是结论和建议：</p>\n<h3 id=\"建议一-不该自己做的事-而且不做是没有风险的事-别做\" tabindex=\"-1\"> 建议一：不该自己做的事，而且不做是没有风险的事，别做！</h3>\n<p>比如在安排任务时，不属于自己分管的，在做好自己的本职前，可以不做。或者超出程序员范围的，比如谈需求，或装系统，装机器，也可以不做。</p>\n<p>可能不少程序员遇到别人来请求帮忙时，拉不下脸来拒绝，或者怕不做会得罪人。一个人在公司里地位的提升，是靠做好自己的本职，而不是靠到处打杂，而且，如果真的到处打杂，做和自己不相干的事的话，分配你活的领导会怎么想？</p>\n<p>那怎么样才能拒掉一些事情呢？</p>\n<h3 id=\"建议二-靠沟通\" tabindex=\"-1\"> 建议二：靠沟通</h3>\n<p>多和对方沟通，说自己事情已经很多，不做会有xxx后果，而且说自己的时间都已经排满了。这样遇到通情达理的人，那么自然就不会让你做了。</p>\n<p>如果还是推不了，那么得和领导沟通，比如说，您交办的事情，我正在做，但目前XXX让我做其他的事情，这样您的事情我就无法按时完成了。这样让领导去拒，如果领导也拒不掉，那至少领导就知道你完不成任务的原因了。</p>\n<h3 id=\"建议三-直接拒\" tabindex=\"-1\"> 建议三：直接拒</h3>\n<p>比如事情已经很忙了，而且此类事情有过领导和同事拒掉的先例，那么直接拒掉，不拒白不拒。</p>\n<h3 id=\"建议四-分清优先级\" tabindex=\"-1\"> 建议四：分清优先级</h3>\n<p>比如某个事情，不得不做，但优先级不高，那么可以直接说，这事情目前没时间，估计要等到3天后再做。</p>\n<p>指不定别人3天后这个事情就自己解决了。</p>\n<h2 id=\"三、百忙中如何提升效率\" tabindex=\"-1\"> 三、百忙中如何提升效率</h2>\n<ol>\n<li>在可以的情况下，工作中可以去掉些没有意义的事，比如刷手机看网页。</li>\n<li>多问，不断学习别人之前的解决方法，别什么都自己想。</li>\n<li>最重要的其实大家都知道：提升自己的能力，多了解业务。</li>\n<li>平时一定得多积累，多思考，多学习。</li>\n</ol>\n<p>我在上下班的路上，看到很多人在刷手机，这个也正常，毕竟人都是要放松的，我有时候自己也这样的。</p>\n<p>但我至少会留下足够多的时间反思：这事情做好后，我反思下如何能做更好，或者我该提升哪些方面的能力，或者我该去了解哪块的业务知识。</p>\n<h2 id=\"四、我见过的在百忙中迷失自己的案例-警示效果\" tabindex=\"-1\"> 四、我见过的在百忙中迷失自己的案例（警示效果）</h2>\n<ol>\n<li>小甲，工作确实辛苦，工作之余，刷手机，看连续剧，除了学习其他都干。结果3年后，能力丝毫没有提升，至于大幅度提升工资呢，只能呵呵了。</li>\n<li>小乙，一年换一行，总感觉当前太累，想换个轻松点的，第一年做java开发，嫌累，转行做.NET，第二年又转行做测试，第三年去做需求分析，结果3年后，有3类经验，但没有一个是精的，所以工作3年后依然无法在某一领域升级为高级。</li>\n<li>小丙，工作压力太大，所以学会了得过且过，结果很快被后进超越。</li>\n<li>小丁，在一个公司里工作有些年头了，属于老油条了，也能仗着资历推掉一些事情，自认为“钱不少人不累”。但随着年纪增长，过了初级或高级开发的年限，但能力无法提升，最终工资远低于平均水平。</li>\n</ol>\n<h2 id=\"五、在百忙中提升自己能力的一些方法\" tabindex=\"-1\"> 五、在百忙中提升自己能力的一些方法</h2>\n<p>我好歹也在一些大公司里呆过，在其中也见过不少牛人，他们至少属于架构师级别的，可想而知他们平时工作的繁忙程度（至少比我忙），说下我看到的他们平时学习的场景。</p>\n<ol>\n<li>见缝插针，有机会就学习，比如在开会间隙，或下班之余，都会看教学视频或纸质书。</li>\n<li>不会光看，而是边动笔边运行代码边学习。比如打开电脑，手上有本书，电脑里是有书的代码，边看书，边运行代码，从代码里仔细体会书上的内容。</li>\n<li>不仅限于书，会在读书的基础上记笔记，写博客，甚至写书，当然更会把学到的内容落实到平时的代码里。</li>\n</ol>\n<p>六、说下我自己的感受</p>\n<ol>\n<li>再忙，也一定得学习，可能干开始学的时候，甚至不知道学习的途径，不知道该学什么以及怎么学，但一回生两回熟，多看几本书就知道了。比如本人从架构小白到能忽悠一般的架构师，就用了大概半年的时间。</li>\n<li>至于学习的时间，一定是有的，比如最近我早上少用半小时看手机，那么一周5天工作日就有两个半小时了，可以写至少2篇博文了。又如晚上，回到家里，脑子不怎么灵了，但可以看些资料，积累些框架上的技能，待到周末再仔细阅读。 我自己感觉，远没有达到“一有空就学习”的地步，但相比之前“有空就玩”的场景，感觉确实有进步。</li>\n<li>得靠一定的目标来激励自己，比如发博文能名利双收，就凭这点，我会努力写博客。又如，我听说写书更能展示自己的实力，我就用了2年时间，完成了两本，有一本尚在写作中。</li>\n<li>自己学习的方法、途径以及学习的内容未必是最有效的，比如有可能学到内容在平时是用不到的，或者学了一些将要被淘汰的技术。所以一定得通过某些途径来“试错”，比如多看些大牛的博客，看下自己学的内容是不是恰当，或者学习的层次是不是大牛们推荐的。甚至可以去多参加面试，通过真刀真枪的实战来检验自己的学习效果。</li>\n<li>最关键的，得给自己明确一个长远的目标，这个目标可以不断被修正，但一定得有。比如3年后，我得升级到高级java开发，为了这个，我得学xxx，xxx等的技术。n年后，我得升到高级架构，为此，我该看xxx书，得实践xxx技能。</li>\n</ol>\n<p>其实上述方法大家都知道，但能做到的寥寥无几，所以大家可以看到，在自己身边，因忙而迷失前进方向的比比皆是，但在百忙中通过努力升级到大牛的人也不少。 本人自然不想成为警示别人的案例，所以在百忙中写了这篇博文来警示自己，顺便把我的一些所见所闻和大家来分享，同时也希望大家别成为被别人警示的典型。</p>\n<h2 id=\"六、总结\" tabindex=\"-1\"> 六、总结</h2>\n<p>不忙的程序员不多，至少我见到的程序员都很忙，如果各位程序员朋友在阅读本文时产生共鸣，那么本文就没算白写。如果本文中提到的一些方法能让大家受益，本人就更加欣慰了，大家也可以顺手点个赞支持一下哈。至于本文会误人子弟？想想也不大可能，至少在文本里都是些四平八稳的内容。\n负载均衡，限流，模块间的消息队列，缓存，热备冗余，数据库集群等知识。</p>\n",
      "date_published": "2022-04-24T09:56:06.000Z",
      "date_modified": "2022-04-24T09:56:06.000Z",
      "authors": [],
      "tags": [
        "程序人生"
      ]
    },
    {
      "title": "日报写作指南",
      "url": "http://www.zhangsj.xyz/blog/programlife/how-to-write-daily-report.html",
      "id": "http://www.zhangsj.xyz/blog/programlife/how-to-write-daily-report.html",
      "content_html": "<h2 id=\"_01-多使用序号-每行尽量精简\" tabindex=\"-1\"> 01 多使用序号，每行尽量精简</h2>\n<p>一些PM的日报为了描述上的完整性，喜欢用大段的文字去阐述一件事情。</p>\n<p>但其实人是会有视觉疲劳的，大家如果看到大段的文字，就不太会仔细地阅读了，非常容易错过重点信息。</p>\n<p>所以我一般会把大段的文字进行拆分，用1、2、3来标注区分，同时对内容进行筛减，提炼重点话术。我给大家举个例子：</p>\n<p>A：今天一共评审了10个模块，其中5个模块顺利通过，2个模块需要修改，3个模块因为不符合业务诉求所以退回重新和业务对焦方案，5个已通过的模块已经安排产品和技术对接，技术评估后明确可行，需要进行技术方案设计，预计2天后出。</p>\n<p>B（推荐）：</p>\n<ol>\n<li>6.17组织评审会，共10个模块，5个通过，2 个需修改，3个退回</li>\n<li>已通过的模块，产品与技术已经对齐，技术方案预计6 .19输出</li>\n</ol>\n<p>拆分和精简可以让日报的整体看上去清晰明了易读，大家会更愿意看。</p>\n<h2 id=\"_02-不要进行开放性描述-一定要有闭环\" tabindex=\"-1\"> 02 不要进行开放性描述，一定要有闭环</h2>\n<p>什么叫开放性描述？比如，今天xxx延期了，今天业务方案变更了等，类似这种没有原因、没有结论、没有后续动作的语句称之为开放性描述。</p>\n<p>大家看到开放性描述的时候，大多会很懵：这个东西延期了到底要不要紧？是某一环延期了，还是整体延期了？为什么延期？有没有解决方案？</p>\n<p>方案变更对项目有没有影响？影响有多大？这些信息如果都看不到，大家就会产生疑问，项目经理要回复大家的各种疑问，来回反复既增加沟通成本又繁琐。</p>\n<p>那啥叫闭环呢？不是说给一个解决方案就叫闭环，而是要把这件事挖到底，做到最无可做的时候，给出的结论叫闭环。</p>\n<p>例如：“直播功能业务方案变更了，今天与业务协商需要给出解决方案”。</p>\n<p>这个描述看上去找了业务，推进了后续的发展，但其实并没有完结，业务方案为什么变更了？有没有牵涉到外部问题？什么时候能给出新的方案？业务方案的变更对当前的项目进展有没有影响？如果有影响，怎么处理，怎么补救？这些都是需要PM去挖掘的。</p>\n<p>当这些信息挖掘到以后，重新组织的结论才是一个可闭环的结论。所以我会先去把所有能挖掘的都挖掘一遍，再将结论输出出来：</p>\n<p>1.直播功能因为预算问题需要变更方案，已同步给所有相关方\n2.与业务方及财务共同对齐，6.18 进行预算重新申报审核，最晚6.19给出最新业务方案\n3.（无影响版本）与产研对齐，6.19 之前给出业务方案对当前进度不影响\n4.（有影响版本）与产研对齐，业务方案变更导致当前开发进度停滞，会优先启动另一需求，待6.19业务方案给出后重新评估，目前延期风险较高。 这样一来，无论是问题的根本原因，还是信息同步、解决方案以及后续时间规划都能清晰地反馈出来，大家会更容易看懂。</p>\n<p>日报的内容，很多时候反映出了PM的项目管理方式，我们需要刨根问底，追本溯源，才能将项目管理做到极致，真正帮助团队解决问题。</p>\n<h2 id=\"_03-要着眼全局-日报开头写总结性话语\" tabindex=\"-1\"> 03 要着眼全局，日报开头写总结性话语</h2>\n<p>常规的日报都有固定的版式，如项目信息、本周目标、今日进展、问题风险变更等。</p>\n<p>这些内容大多是比较丰富而详细的，但是对整体项目而言，其中的每一条其实都只是一个点，比如某个任务延期，比如某个方案变更，比如突然发现了某个依赖方没加进来等等。</p>\n<p>那些通过日报来了解项目的人，很难通过一个个点去想象项目的整体情况。</p>\n<p>这时候，作为PM——你的作用就显现出来了，你需要帮助他们去了解整个的项目，在日报开头加上今日总结的目的就是为了将这些点汇总成面，从全局的角度去看整个项目，给项目做个判断，给看日报的人做一个输入。</p>\n<p>比方说今天延期特别多，你可以总结一下今日延期较多，对项目有一定影响，与各方对齐后预计明天输出解决方案；</p>\n<p>如果变更很多，但是都在可控范围内，也可以总结一下，今天共有8个变更，但目前评估下来，风险可控；</p>\n<p>如果今天开了好几个会，并且都没有结论，可以总结一下，今日针对xx问题已拉多方沟通，结论还未输出，会持续推进。</p>\n<p>有了这些开头的总结，大家对于项目的体感会进一步加深，不是停留在某个点的问题上，而是对整体项目有了一个感观。</p>\n<h2 id=\"日报模板\" tabindex=\"-1\"> 日报模板</h2>\n<p>持续优化 xxx；</p>\n<p>重构了 xxx；</p>\n<p>梳理 xxx，总结 xxx；</p>\n<p>排查 xxx 问题；</p>\n<p>改进了 xxx 逻辑，性能得到提升；</p>\n<p>通过 xxx 降低了 xxx 至 xxx；</p>\n<p>为了 xxx 重新设计了 xxx；</p>\n<p>为了 xxx 通过 xxx 完成了 xxx；</p>\n<p>通过 xxx 优化了 xxx 为 xxx；</p>\n<p>为了 xxx 将 xxx 应用到了 xxx；</p>\n<p>通过 xxx 提高了 xxx 至 xxx；</p>\n<p>为了 xxx 通过 xxx 将 xxx 集成；</p>\n<p>为了 xxx 通过 xxx 成立了 xxx；</p>\n<p>阅读文档，熟悉了面向对象的特征、</p>\n<p>sql、null、下标越界、找不到类、数字格式化异常</p>\n<p>BlockingDeque.class，双端阻塞队列接口</p>\n",
      "date_published": "2022-04-24T09:56:06.000Z",
      "date_modified": "2022-04-24T09:56:06.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "在你的业余时间，请不要接受个人工作，但要提高自己",
      "url": "http://www.zhangsj.xyz/blog/programlife/in-your-spare-time-please-don-not-take-personal-work-but-improve-yourself.html",
      "id": "http://www.zhangsj.xyz/blog/programlife/in-your-spare-time-please-don-not-take-personal-work-but-improve-yourself.html",
      "content_html": "<h2 id=\"在你的业余时间-请不要接受个人工作-但要提高自己\" tabindex=\"-1\"> 在你的业余时间，请不要接受个人工作，但要提高自己</h2>\n<p>这个话题很纠结</p>\n<p>现在社会，有很多人都在利用个人时间兼职赚钱，程序员俗称“接私活”，其他行业称作兼职，比如下了班出去跑滴滴，周末兼职抢单送外卖等等，都是普通人很常见的兼职方式。</p>\n<p>甚至很多技术同行，我听说也有周末去跑滴滴和送外卖的，我觉得很不可思议，然而我的观点是如果你想成为成功人士，高收入人群那么你不应该去做兼职，不要把你宝贵的时间，浪费在兼职上。</p>\n<h2 id=\"简单经济学分析\" tabindex=\"-1\"> 简单经济学分析</h2>\n<p>涉及到收入，文字洗脑显得很空洞了就，那么今天我给你来一个简单的经济学论调。</p>\n<p>我们看一个案例，李嘉诚是香港首富，但是李嘉诚会亲自修剪自家的草坪吗？除非某一天他想体验一下劳动乐趣什么的，否则一定是请人来修剪草坪。</p>\n<p>李嘉诚请人修剪草坪是因为他有钱吗？不全是，哪怕李嘉诚没钱，他也不会亲自修剪草坪，这里面就要涉及经济学的比较优势了。</p>\n<p>假设请来的李大叔花费3个小时就能修理完草坪，而李嘉诚2个小时就能修理完草坪，因为李嘉诚聪明又能干，不然不会活到90岁了，还不退休，那么李嘉诚这么牛鼻应该做香港第一的修草工吗？</p>\n<p>那肯定不应该，因为李嘉诚做自己的事情，一小时可以赚100万港币，而李大叔不修草坪，去做其他事情的话，一小时只能赚20港币，那么帮李嘉诚修草坪的价格只要高于20港币，低于100万港币每小时，李嘉诚就不应该自己修草坪，而应该花钱请李大叔来做修。</p>\n<p>这就是18世纪经济学家李嘉图提出的比较优势理论，写在了大学的每一个经济学课本里，贸易的基础并不是绝对优势，而是比较优势。如果有绝对优势那就叫垄断，不存在比较了。</p>\n<p>比较优势的核心理论就是，单独一个人或者单独一个国家机构，其精力和机会成本都是有限的，哪怕你各方面都是全球第一的人才，最聪明的做法也不是四处出击，事必躬亲，而是把有限的时间、精力和资源放在自己最擅长的地方，换句话说就是最赚钱的地方。</p>\n<p>那么好，涉及到我们普通人，其实也是一样，你的精力和时间包括知识很有限，这都是你仅有的也最擅长的赚钱财富，做兼职也是这个道理，如果你做自己的本职工作一小时能赚200元，兼职跑滴滴一小时能赚30元，送外卖一小时能赚15元，你的最佳选择是什么?不傻的应该都会选择吧？不是去跑滴滴，而是集中精力去做好自己的本职工作。</p>\n<h3 id=\"社会分工\" tabindex=\"-1\"> 社会分工</h3>\n<p>马化腾、李嘉诚、马云这么牛逼，这么聪明为何他们不把所有的钱都挣了呢？请几万几十万的员工来干活发工资干什么？</p>\n<p>因为他们一天只有24个小时啊，能力再强，你也只能工作20小时，4个小时吃饭睡觉吧？所以他们把自己每天有限的时间集中在自己最能赚钱的领域，然后请别人来做其他他不擅长或者压根不值得做的事情，这一过程，叫社会分工。</p>\n<p>社会分工是市场经济条件下，整个社会所有人都充分发挥自己劳动力的最优选择，也是最理想、最人性化的社会现象，每一个人应该只从事一份工作，而且这个工作会细分到极致，分工到极致的社会，会让一个人专门负责做其中的一件事和一种事，这就是俗语360行，360行就是这么来的。</p>\n<h2 id=\"一、为什么要做私活\" tabindex=\"-1\"> 一、为什么要做私活？</h2>\n<p><strong>我可以毫不避讳的说：就是想赚钱</strong>。讨论赚钱这个事没什么不好意思的，有欲望想要赚更多的钱更没有什么好羞耻的。大家都知道，程序员是一个起薪高、但个人发展差异明显、中年危机感严重的一个职业。35岁之后何去何从，是否会被裁员，是很多中年人焦虑感的来源。而中年，又是一个面临各方面压力的时期，所以尽早的积累财富+增加被动收入是一个不容忽视的问题。我毕业的时候一直很有焦虑感，满脑子就想着赚钱买房，解决基本的经济问题，所以跳槽多（并不是很可取）+疯狂熬夜做私活，然后顺利的办了工作居住证买了房。所以现在在工作的时候，能够焦虑感不那么严重的去专心工作，全力以赴的去工作，做自己真正想做的事。</p>\n<p>除了赚钱以外，我更想通过私活逼着自己提升自己的技术能力。我在选择私活的时候，都是跟工作方向是一致的，这样能保证自己在下班时间，不想学习的时候也能疯狂push自己去完成跟甲方签好合同，必须做的活，无形之中保证了自己的学习和练习时间。</p>\n<p>其实除了赚钱和逼着自己提升技术能力以外，还有一个更长期的收益：人脉。做私活会极大的扩展你的圈子，甲方乙方、志同道合的人、资深大牛等，对你未来的职业发展道路都有不少帮助，我以前会做三年职业规划，但是后来认识的人多了，发现根本预测不了三年后的职业发展，只能预测一年的就不错了，三年后的发展比自己预想的要好多了。所以也很感谢之前做私活的这段经历。</p>\n<h2 id=\"二、私活的原则\" tabindex=\"-1\"> 二、私活的原则</h2>\n<p>私活的种类太多了，选择的成本也是不可忽视的，选了A，就没有时间做B，A和B哪个更好？虽然不能有100%的判断标准，但是根据我的经验，总结了三条关于接私活的原则，希望对大家有所帮助：</p>\n<ol>\n<li>本职工作永远是第一位的：如果公司不允许、或者所在的团队默认不允许，放弃吧。刚开始做私活赚的那点钱，远不及本职工作带来的长期收益大。</li>\n<li>充分考虑自己的沉没成本：时薪最低不低于你现在工作时薪。我的原则是衡量好难度+人力成本后，再至少乘以2，报交付时间和报酬，然后再协商。这样能保证自己能够及时交付，也不至于做的时候很勉强。</li>\n<li>做长期收益的事：切忌捡芝麻丢西瓜，最好与自己的工作内容强相关。兼职滴滴司机、低价格的家教、餐馆服务员等时间和汇报不成正比的工作，不在我说的范围内（当然没有任何其实以上各种职位的意思，只是表述选择很重要）</li>\n</ol>\n<h2 id=\"三、做什么私活比较好\" tabindex=\"-1\"> 三、做什么私活比较好？</h2>\n<p>现在的环境和几年前已经很不一样了，以前程序员常见的私活有不少是猪八戒等外包网站，我其实不是很推荐，自己也从来没有在这些网站上注册过，因为前期付出的花时间挑选匹配的成本太高。不符合我的第二个原则。我要推荐的有好几类，篇幅原因，今天先说推荐的第一类——<strong>打比赛/做模型</strong></p>\n<p>最后需要提醒的一点是：永远永远不要用公司的电脑、资源、工作时间来去打比赛！没有查出来的，只是公司不想查你，实际上你的所有操作都是有记录的，谨慎为好，不要忘了前面说的第三个原则，不要捡了芝麻丢西瓜，非常得不偿失。一般打比赛，主办方会提供充足的计算资源，如果不提供，那，可以明年不考虑参加这家了，换家吧，下一个更香~</p>\n<p>写到这里，可能有些朋友们觉得，你说的这个难度好高啊，我不会怎么办？有没有可以练习的地方，我积累积累再去打比赛？自学写代码嘛？还是自学去复现？一个人感觉很没有动力去做，总是坚持不下来怎么办？</p>\n<p>contribute</p>\n",
      "date_published": "2022-04-24T09:56:06.000Z",
      "date_modified": "2022-05-24T07:58:00.000Z",
      "authors": [],
      "tags": [
        "随笔"
      ]
    },
    {
      "title": "杀死程序员不需要枪，只需更改要求三遍",
      "url": "http://www.zhangsj.xyz/blog/programlife/killing-a-programmer-doesnt-require-a-gun-just-change-the-requirements-three-times.html",
      "id": "http://www.zhangsj.xyz/blog/programlife/killing-a-programmer-doesnt-require-a-gun-just-change-the-requirements-three-times.html",
      "content_html": "<h1 id=\"杀死程序员不需要枪-只需更改要求三遍\" tabindex=\"-1\"> 杀死程序员不需要枪，只需更改要求三遍</h1>\n<p><a href=\"https://www.cnblogs.com/charliechu\" target=\"_blank\" rel=\"noopener noreferrer\">原文出处</a></p>\n<p>在很多软件公司，特别是一些创业型的团队中，对于这样的情景可能大家都很熟悉：项目经理或者产品经理（产品狗）口头或者简单记录一下软件产品的大致要做的功能，直接就让研发团队的兄弟（程序猿）去狂撸代码。然后他就去喝茶撩妹或者回家陪老婆了...</p>\n<p>这种撸起袖子就开干的方式，看似简单高效，便于直接沟通，能够快速迭代。却不知，发现没有一份正规且实时更新的功能需求设计文档，会付出三四倍的代价来弥补。</p>\n<p>最终会引发一场产品狗和程序猿之间的“猿狗大战”...</p>\n<h2 id=\"一、why-为什么需要功能需求设计说明书\" tabindex=\"-1\"> 一、WHY - 为什么需要功能需求设计说明书</h2>\n<p>在没有功能设计文档时，主要有如下几个问题：</p>\n<p>1、前期研究团队沟通成本</p>\n<p>如何要让团队里面的所有人员对软件产品的功能需求设计有一个共识？没有功能设计文档，反正我是想不出有什么办法。当该项目的团队人员越多，沟通成本就变得很高。</p>\n<p>研发人员很容易有一个通病：以为自己了解了一小块需求就立即开始埋头狂撸......代码。最终很可能与项目经理和客户真正想要的功能相差甚远。</p>\n<p>更可怕的，研发人员把数据库设计好了，代码也已经写得差不多了，这时产品狗突然跑到程序猿这，说我们的需求要做一点变化，大家都知道，“对产品狗来说那一点变化，可能会害得程序猿撸过几天几夜”。那很小的变更可能导致之前设计的数据库，码的代码都不能用了。对于程序猿没有什么比加班加点写了几个月的代码，最终被产品狗告知需求变了，代码要删除重新写更可怕的。估计只能用涨工资来安慰一下那受伤的心灵了。</p>\n<p>还有一个比较隐藏的事情是，每个程序猿都认为自己写的代码很牛逼（其实对于大多数人这只是一个错觉，你写得代码并不优秀），不太愿意删除之前所写的东西，总是想在原有的代码基础上进行修改，让他们删除代码比杀了他还难。</p>\n<p>作为公司的技术负责人，我每几天都会<code>Code Review</code>团队里面所有人的代码，一直要求他们把不用的代码去掉，但他们的应对方式总是加两个//。注释掉他们写的代码，而不是去做真正的删除动作。他们总有自己的理由，“这只是暂时注释掉，后面会用到”，但最终的结果是那些代码就像尸体一样，一直在那里，干扰着团队人员正常的思路。所以我只能强制性让他们那些“暂时没有用，以后会用到的代码”干掉 。</p>\n<p>2、前期任务进度安排和分配</p>\n<p>该文档也是任务进度安排和分配的重要依据。在没有功能需求设计文档之前的所有任务进度计划都是瞎扯淡，都不知道具体要做什么东西，哪能拿出合理的任务进度计划。如果你拿出来了，我也不相信那是经过认真分析做的进度计划，我知道那只是用来看领导看的。</p>\n<p>3、中期产品经理需求变更</p>\n<p>软件在开发过程中难免会遇到功能的需求变更，将程序猿们召集在一起把所有的变更讲一遍？当走出会议室的时候可能每个人都有自己的理解。下一场战争已悄然临近...</p>\n<p>4、后期测试团队产品测试</p>\n<p>测试团队应该在项目Kickoff之时就应该介入，而不是在产品开发完成之后。测试团队应该对功能需求设计文档充分了解，且以此来编写具体的测试用例文档。否则，只能是在界面上进行简单的表面测试，而真正的BUG并不在表面，这些BUG会藏得很深，等发现的时候可能已经造成很大的损失。测试团队想覆盖全部的测试用例此时已经相当困难，他们甚至都不知道产品有哪些功能。</p>\n<p>测试用例应该尽可能详细，尽量保证测试用例走完能确保产品能上线发布。下图是我们在登录注册时用到的一部分用例：</p>\n<p><img src=\"@source/programlife/assets/killing-a-programmer-doesnt-require-a-gun-just-change-the-requirements-three-times-1649933460463.png\" alt=\"登录注册用到的一部分用例\" loading=\"lazy\"></p>\n<h2 id=\"二、where-文档应该放在何处\" tabindex=\"-1\"> 二、WHERE - 文档应该放在何处</h2>\n<p>功能说明文档一定要保持实时性，任何变更的需求，新增的需求都必须在该文档中体现。</p>\n<p>一只产品狗（或一群）在编写完文档后，要发给项目经理、研发人员、销售人员、运营推广人员等人，如何保证每个人的文档都是最新的呢？如果通过QQ，邮件等方式，是不是每次更新都要重新通知所有人：“嘿，各位兄弟，文档作了一次修改，我给大家都重新发一份新的”。每个人电脑里面都有好几个版本的文档，时间长了，自己都忘记哪个文档是最新的；产品狗也记不清是否是所有相关的人都发了最新的文档。</p>\n<p>研发人员可能会说通过SVN来作版本管理啊，给每个人分配一个帐号。“天啊，SVN是啥？”-销售人员、运营推广人员估计一脸懵逼。</p>\n<p>更好的办法是通过团队实时协作的云端工具。从而实现分享和实时讨论，告别反复修改版本再发送邮件的麻烦。如果你会FQ，那你可以使用Google Docs、Office Online。否则你可以使用石墨文档、一起写。</p>\n<h2 id=\"三、what-什么是功能需求设计文档-应该包含那些内容\" tabindex=\"-1\"> 三、WHAT - 什么是功能需求设计文档 &amp; 应该包含那些内容</h2>\n<p>功能需求设计文档最重要的是描述产品所要包含的所有功能，越详细越好，可以结合产品的原型设计图来讲解。</p>\n<p>让项目所有相关人知道产品是什么，包含哪些页面，页面如何跳转等。</p>\n<p>该文档是产品经理、项目经理、研发人员、销售人员、运营推广人员沟通的一个桥梁，一份好的功能需求设计文档是软件产品是否能成功的关键。</p>\n<p>考虑是该文档的受众，这份文档不应该包含具体的编程技术上的说明。不管你是用C#/.NET、JAVA还是其它，这应该是另外研发团队内部使用的一份文档。</p>\n<p>一般人第一反映就是去网上找一份功能需求设计文档模板，我个人感觉那些模板90%根本没有存在的必要。都太过形式化，不要没有实际意义和模板化的内容，只会使文档成为一个摆饰，反而是在浪费大家的时间。</p>\n<p>那么一份合格的软件需求设计文档应该包括哪些内容呢？</p>\n<p>1、项目背景</p>\n<p>项目产生的实际背景、具体的运用场景、大致要解决什么样的问题、针对的阅读对象、版本修改记录、文档作者以及修改人信息。</p>\n<p>2、详细的功能点描述</p>\n<p>写明产品所包含的所有功能点，对功能、界面、接口的描述一定要充分详细，每处可以交互的地方都要给出具体的说明。再次强调，一定要详细描述每一个页面所拥有的功能。</p>\n<p>3、产品不包含的功能点说明</p>\n<p>除了写明产品所包含的所有功能点外，还应该写明软件所不包含的功能，这一点也很重要。</p>\n<p>4、使用场景（画面感）</p>\n<p>将复杂的业务逻辑融入到具体的使用场景中，更容易让项目经理、研发人员、销售人员、运营推广人员不同背景的人产生共识。</p>\n<p>5、流程图</p>\n<p>大家都知道“一图胜千言”，能用图说明的尽量用图来说明，只通过大量枯燥的文字可能效果并不太好。流程图是一种用图形表示逻辑和算法的工具，特别对研发人员撸代码很有帮助。\nWindows用户可以使用Visio，Mac用户可以使用<code>OmniGraffle</code>，还可以使用免费在线作图,实时协作工具<code>ProcessOn</code>。</p>\n<p>我之前就用ProcessOn画了一个设置了缓存的网络请求的流程图，这里作个参考：</p>\n<p><img src=\"@source/programlife/assets/killing-a-programmer-doesnt-require-a-gun-just-change-the-requirements-three-times-1649933535494.png\" alt=\"缓存的网络请求的流程图\" loading=\"lazy\"></p>\n<p>6、人员角色“实例化”</p>\n<p>跟上面提到的“画面感”相结合，将人员和角色能够实例化。比如我们的产品要实现如下功能，有两种表达方式：</p>\n<blockquote>\n<p>医生给患者测量血压，并记录到系统中。\n上海华山医院肾内科的王主任医生在给32号病区1 号病床的患者刘阿姨测量血压，将测量到的血压100/70mmHg输入到透析管理系统。</p>\n</blockquote>\n<p>哪种方式更便于理解？特别是对医疗知识不太了解的码农们。当然可能有人觉得第一种方式更简洁。可能是我举的例子不够好，也可能是我的理解能力不够强。（但不要怀疑我的智商！哈哈哈...）</p>\n<p>7、结合产品原型设计图</p>\n<p>产品原型设计图可以粗枝大叶地产品大致的框架。便于项目经理、研发人员、销售人员、运营推广人员等人在产品未开发之前对产品有一个相对直观的认识。没有一个原型图，想到这帮人拉到同一个频道沟通一定是不可能的事。（如果你做到了，那么赶紧把你的简历发我，我决定录用你！）</p>\n<p>常用的原型设计工具有墨刀、Mockplus、Axure。</p>\n<p>扯了这么多，来个例子吧。</p>\n<blockquote>\n<p>本软件是给北京某医院集团肾内科透析患者所使用的软件，包括院内管理系统、院外大数据平台、医护端APP、患者端APP...</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>版本</th>\n<th>作者</th>\n<th>修订时间</th>\n<th>审核人</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>v1.0.0</td>\n<td>Charlie Chu</td>\n<td>2017-2-12</td>\n<td>Vivian Wong</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>使用场景一：</p>\n</blockquote>\n<blockquote>\n<p>肾内科的医生王医生给31号病床刘阿姨进行透析上机操作，王医生在院内透析管理系统上点击上机操作，信息会传递到院外的大数据平台以及医护端APP、患者端APP上...</p>\n</blockquote>\n<blockquote>\n<p>刘阿姨患者的家属登录到患者端APP后，可以实时查看刘阿姨透析过程中的所有信息，还可以查看血压、血糖、体重等历史数据...</p>\n</blockquote>\n<blockquote>\n<p>当刘阿姨在家中通过蓝牙血压计测量血压时，自动同步到医院内部，如果刘阿姨的血压超过预先设置的值，院内的王医生则会在自己的手机上查看到刘阿姨的血压异常报警信息，王医生可以立即跟刘阿姨的家属进行实时沟通...</p>\n</blockquote>\n<blockquote>\n<p>...&lt;此处省略N字&gt;...</p>\n</blockquote>\n<blockquote>\n<p>本软件(v1.0.1版本)不包括的功能需求如下：</p>\n<ul>\n<li>医生与患者的实时IM</li>\n<li>医生排班设置</li>\n<li>修改密码</li>\n<li>患者积分</li>\n</ul>\n</blockquote>\n<p>功能模块详细描述：</p>\n<p>一、APP登录页面</p>\n<p>由于本产品不存在患者自己注册的场景，所有的患者录入都发生在院外透析系统中，患者及家属在院外只需要输入相应的手机号，即可登录系统。</p>\n<p>登录页面只有两个输入框，一个手机号，一个密码。</p>\n<p>当用户要输入手机号时，手机应该弹出纯数字键盘，最多只能输入手机号固定的11位。密码最多输入10位。</p>\n<p>当用户点击登录时，APP与后台服务器进行交互：</p>\n<ol>\n<li>不输入手机号和密码，直接点击登录按钮，应该提示用户输入手机号和密码。</li>\n<li>输入手机号但不输入密码，点击登录，提示“请输入密码”。</li>\n<li>输入不正确的手机号，点击登录，应该提示“不存在该用户”。</li>\n<li>输入小于11位的手机号，应该提示“请输入正确的手机号”。</li>\n</ol>\n<p>二、登录后首页</p>\n<p>下图是左侧是一个首页，右侧是一个点击透析预警的详细页面:</p>\n<p><img src=\"@source/programlife/assets/killing-a-programmer-doesnt-require-a-gun-just-change-the-requirements-three-times-1649934048137.png\" alt=\"登录后首页\" loading=\"lazy\"></p>\n<p>首页包括功能点：</p>\n<ol>\n<li>资讯信息轮播 首页顶部资讯信息轮播功能，点击可以跳转到新的页面可以查看资讯详情。</li>\n<li>病情咨询 点击“病情咨询”模块，患者查看向指定的医生了解自己的病情。</li>\n<li>透析记录 点击透析记录，患者可以随时随地查看自己的过往透析记录。</li>\n<li>食物速查 点击食物速查，可以查看所有类别的食物成份含量。</li>\n<li>透析上下机实时信息列表 当患者在医院内进行透析上下机等操作时，会记录患者的透析上机时间 、下机时间等信息。点击其中的一条记录，跳转到透析详情页面，如上图右侧所示。</li>\n</ol>\n<h2 id=\"四、how-如何保证文档质量\" tabindex=\"-1\"> 四、HOW - 如何保证文档质量</h2>\n<p>要保证文档能够实时更新同步，而不是疲于应付。那就是让大家都通过该文档来进行沟通，谁有问题直接去看文档，需求一旦变更首先就更新到文档。</p>\n<p>研发人员严格按文档上的描述来开发，在没有文档之前，对不起，拒绝开发！任何口头、QQ或邮件上的新的功能需求一概不理！提前是产品狗要比较给力，否则老板还是会让你狂撸代码...</p>\n",
      "date_published": "2018-09-05T00:00:00.000Z",
      "date_modified": "2022-05-24T09:58:20.000Z",
      "authors": [],
      "tags": [
        "程序人生"
      ]
    },
    {
      "title": "大型网站技术架构",
      "url": "http://www.zhangsj.xyz/blog/programlife/large-website-architecture-patterns.html",
      "id": "http://www.zhangsj.xyz/blog/programlife/large-website-architecture-patterns.html",
      "content_html": "<h2 id=\"异步\" tabindex=\"-1\"> 异步</h2>\n<p>计算机软件发展的一个重要目标和驱动力是降低软件耦合性。事物之间直接关系越少，就越少被彼此影响。</p>\n<ul>\n<li>分层</li>\n<li>分割</li>\n<li>分布式</li>\n<li>集群</li>\n<li>缓存</li>\n<li>冗余</li>\n<li>自动化</li>\n<li>安全</li>\n</ul>\n",
      "date_published": "2022-04-24T09:56:06.000Z",
      "date_modified": "2022-04-24T09:56:06.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "作为技术人员的快速成长",
      "url": "http://www.zhangsj.xyz/blog/programlife/rapid-growth-as-a-technologist.html",
      "id": "http://www.zhangsj.xyz/blog/programlife/rapid-growth-as-a-technologist.html",
      "content_html": "<ul>\n<li>理论型，理论能力很强，对前沿技术略有了解，性格比较强势，需求分析和方案设计头头是道，对自己的设计的内容比较自信固执，反观代码，质量差的一匹，逻辑乱，难维护难拓展，但是往往这种在公司评级还都挺高；</li>\n<li>潜力型，业务能力强，开发设计和问题排查思路清晰，可以提出优化/改进方案，能对业务适当抽象，自我技术要求比较高，代码质量好，平时会调研前沿技术；</li>\n<li>表面型，业务需求基本都可以完成，但是代码质量比较差，bug多，问题排查效率低，难维护难拓展，很少了解前沿技术，空闲时间就刷刷微博，看新闻，聊天；</li>\n<li>老实型，做事勤勤恳恳，代码质量一般，平时表现比较不起眼，与同事沟通少，业余时间也不清楚具体在做什么；</li>\n<li>大神型，总结就是各方面都很NB，问啥都能给予建议或者解决方案，但是这种人很少；</li>\n</ul>\n<h2 id=\"《阿里感悟》如何在三年内成长为一名技术专家\" tabindex=\"-1\"> 《阿里感悟》如何在三年内成长为一名技术专家</h2>\n<p>工作前三年是职业生涯中成长最快的几年，在这段时间里你会充满激情，做事专注，也容易养成良好的习惯。</p>\n<p>在我们公司有些同学在前三年中就快速成为某一个领域的技术专家，有些同学也可能止步不前。本文和大家一起探讨下如何在三年内快速成长为一名技术专家。\nrapid-growth-as-a-technologist\n学习方法</p>\n<p>1：掌握良好的学习心态\n2：掌握系统化的学习方法\n3：知识如何内化成能力\n4：广度和深度的选择</p>\n<p>实战技巧</p>\n<p>1：你需要学会的编码习惯\n2：在业务团队做开发如何成长</p>\n<h2 id=\"空杯心态\" tabindex=\"-1\"> 空杯心态</h2>\n<h2 id=\"二、拒绝寻求帮助\" tabindex=\"-1\"> 二、拒绝寻求帮助</h2>\n<p>这一条在学习和工作场景中都很常见。我们很多人都不寻求帮助。原因很多，但我认为最主要的原因无非是自尊以及害怕让人认为自己啥也不会。我们很多人都有冒名顶替综合征，觉得自己不完全胜任自己的工作。我在公司里、在和客户打交道时、甚至在上课和辅导中都有这种感觉。我们认为寻求帮助会强化这种感觉。但事实上，它浪费了大量时间，阻碍了你的成长。</p>\n<p>其他真正的开发人员们都是视频或书籍一般的资源，甚至要比这些好太多。他们可以直接回答你的问题，帮助你真正的理解它。</p>\n<p>只有混蛋才会因为你问问题而批评你，这时候我会尽力避开这些人。</p>\n<p>如果你想要自己找到答案，不想寻求帮助，那也没问题，给自己一个时间限制。当你的前辈就在你旁边，他可能知道或至少可以帮到你的时候，千万不要浪费几天时间来寻找答案。</p>\n<h2 id=\"四、混乱的代码\" tabindex=\"-1\"> 四、混乱的代码</h2>\n<p>这一条更多地是一种技术习惯，但也可能意味着很多事情。你应当以一种直观、高效、安全的方式写代码。这在自学的时候简直太难了，因为在相关的课程中，你学到的不是写某些代码的最佳方法，而是导师认为这么写最容易理解一些核心概念。所以，你必须进行一些额外的研究，找出清理你代码的最佳方法。</p>\n<p>我绝对建议你使用“避免重复代码原则”（DRY principle，don’t repeat yourself）。如果你遇到常见的代码块，那就创建某种“类”（class）或“函数”（function）来合并这部分功能，而不是仅仅重复它。这让代码更加简洁，节省了大量代码行，并且便于他人使用。</p>\n<p>你也要注意性能，比如压缩图片、缩小JavaScript和CSS。你可以使用task runner（如gulp）或其他工具自动完成压缩，面对小型任务，你甚至可以使用minifier.org等手动完成。</p>\n<p>另外，不要进行不必要的API接口调用，要使你的全栈应用程序以尽可能少的请求完成你需要的全部功能。以及测试……我在这上面犯了很多错，没有做足够的测试。就我所知，单元测试有助于搭建更健全的应用程序，避免潜在问题，节约时间和开销。但我就是很讨厌它，这可能是我最坏的习惯之一，也是我成为更好的开发人员需要解决的大问题。有时候我们回了节约时间减少测试，但在现实中，这样做会降低应用程序的性能、效率和可读性，而且与一开始就采用正确的方法相比，它可能在将来引起更大的麻烦。所以请记住这一点。</p>\n<h2 id=\"六、糟糕的办公室政治\" tabindex=\"-1\"> 六、糟糕的办公室政治</h2>\n<p>这一条是给那些在公司工作的人们的。你和其他人一起工作，但这反过来又会引起冲突、分歧、争论等等。许多开发人员十分傲慢，总认为自己是正确的，即使他们知道自己犯了错，他们中的一些人也永远不会承认。我不是说这是大多数开发人员，但我认为我们至少会遇到一位这样的人。我听很多人说，他们的团队非常棒，成员之间相处得非常融洽，这很好，但不是所有团队都是这样子。</p>\n<ul>\n<li>很多时候你们会在想法和解决方案上发生冲突，试着表现得老练和对对方的尊重，但同时，也不要太容易就被说服，尤其是当你对自己的提案非常有信心的时候。</li>\n<li>不要大喊大叫，不要骂人，千万别做这些事情，这什么用也没有。</li>\n<li>如果他们开始这样对待你，你就离开，做一个更强大的人。</li>\n<li>如果你不幸遇到了一个十足混蛋的团队成员，他完全不听理由，你除了想办法避开他之外，别无他法。</li>\n<li>在某些情况下，你可能不得不和你们的领导交谈，不过我还是建议你先和那个人谈谈。</li>\n</ul>\n<h2 id=\"九、做一个无所不知的人\" tabindex=\"-1\"> 九、做一个无所不知的人</h2>\n<p>我之前提到过，我认为一些开发人员十分傲慢的原因是，他们认为自己无所不知。他们从不听其他人的意见，他们为啥要听呢？他们知道所有的答案。如果你周围全是这样的人，那真是糟透了，这对你也没好处，因为你也会认为自己无所不知，就会不积极学习、不改善自己。我敢打赌，总有一天你会被自己犯下的错误叫醒，这源于你不听取任何人的意见，也不自己进行调研。</p>\n<p>这些人大多数都是 Stack Overflow 网站（一个IT技术问答网站）的魔鬼，他们取笑新开发人员的问题，嘲笑他人的回答，一有机会就点击“反对”。我讨厌死这些人了。我认为他们中的许多人在学校里就总是被人找茬，他们利用自己的知识欺负其他可能有问题或是没有所得的开发人员，看上去像是忘掉了被欺负的感受，只想要复仇。我这个理论可能有问题，只是一家之言。</p>\n<p>无论他们出于什么原因这么做，我认为如果他们思想开放、欢迎不同的想法、尊重他人，那他们就会比总是想要“正确”的人快乐多了。他们可能是团队中最聪明的人，也是最糟糕的人，因为没人愿意和他们合作，无法进行良好的沟通。对于一个想要成功的团队来说，沟通和团结是必需的，而无所不知的人会破坏这些。所以，如果你是这样的人，试着别那么自负，开放一点，尊重一点，你会走得更远。</p>\n",
      "date_published": "2017-09-16T00:00:00.000Z",
      "date_modified": "2022-04-24T09:56:06.000Z",
      "authors": [],
      "tags": [
        "随笔"
      ]
    },
    {
      "title": "随笔目录",
      "url": "http://www.zhangsj.xyz/blog/programlife/",
      "id": "http://www.zhangsj.xyz/blog/programlife/",
      "content_html": "<h2 id=\"note\" tabindex=\"-1\"> note</h2>\n<ul>\n<li><a href=\"/programlife/be-a-critical-thinking-programmer.html\">做一个有批判性思维的程序员</a></li>\n<li><a href=\"/programlife/rapid-growth-as-a-technologist.html\">如何在三年内成长为一名技术专家</a></li>\n<li><a href=\"/programlife/killing-a-programmer-doesnt-require-a-gun-just-change-the-requirements-three-times.html\">杀死程序员不需要枪，只需更改要求三遍</a></li>\n</ul>\n",
      "date_published": "2022-04-24T09:56:06.000Z",
      "date_modified": "2022-04-24T09:56:06.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "究竟啥才是互联网架构中的高并发！",
      "url": "http://www.zhangsj.xyz/blog/java/concurrent/high-concurrency.html",
      "id": "http://www.zhangsj.xyz/blog/java/concurrent/high-concurrency.html",
      "content_html": "<h2 id=\"一、什么是高并发\" tabindex=\"-1\"> 一、什么是高并发</h2>\n<p>高并发是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。</p>\n<p>高并发相关常用的一些指标有响应时间、吞吐量、每秒查询率QPS、并发用户数等。</p>\n<ul>\n<li>响应时间：系统对请求做出响应的时间。例如系统处理一个HTTP请求需要200ms，这个200ms就是系统的响应时间。</li>\n<li>吞吐量：单位时间内处理的请求数量。</li>\n<li><code>QPS</code>：每秒响应请求数。在互联网领域，这个指标和吞吐量区分的没有这么明显。</li>\n<li>并发用户数：同时承载正常使用系统功能的用户数量。例如一个即时通讯系统，同时在线量一定程度上代表了系统的并发用户数。</li>\n</ul>\n<h2 id=\"二、如何提升系统的并发能力\" tabindex=\"-1\"> 二、如何提升系统的并发能力</h2>\n<p>互联网分布式架构设计，提高系统并发能力的方式，方法论上主要有两种：垂直扩展（<code>Scale Up</code>）与水平扩展（<code>Scale Out</code>）。</p>\n<p>1、垂直扩展：提升单机处理能力</p>\n<p>垂直扩展的方式又有两种：</p>\n<p>增强单机硬件性能，例如：增加CPU核数如32核，升级更好的网卡如万兆，升级更好的硬盘如<code>SSD</code>，扩充硬盘容量如2T，扩充系统内存如128G；</p>\n<p>提升单机架构性能，例如：使用Cache来减少IO次数，使用异步来增加单服务吞吐量，使用无锁数据结构来减少响应时间；</p>\n<p>在互联网业务发展非常迅猛的早期，如果预算不是问题，强烈建议使用“增强单机硬件性能”的方式提升系统并发能力，因为这个阶段，公司的战略往往是发展业务抢时间，而“增强单机硬件性能”往往是最快的方法。</p>\n<p>不管是提升单机硬件性能，还是提升单机架构性能，都有一个致命的不足：单机性能总是有极限的。所以互联网分布式架构设计高并发终极解决方案还是水平扩展。</p>\n<p>2、水平扩展：只要增加服务器数量，就能线性扩充系统性能</p>\n<p>水平扩展对系统架构设计是有要求的，如何在架构各层进行可水平扩展的设计，以及互联网公司架构各层常见的水平扩展实践，是本文重点讨论的内容。</p>\n<h2 id=\"三、常见的互联网分层架构\" tabindex=\"-1\"> 三、常见的互联网分层架构</h2>\n<p><img src=\"@source/java/concurrent/assets/high-concurrency-1650790170565.png\" alt=\"典型互联网分层架构\" loading=\"lazy\"></p>\n<p>常见互联网分布式架构如上，分为：</p>\n<ol>\n<li>客户端层：典型调用方是浏览器Browser或者手机应用App；</li>\n<li>反向代理层：系统入口，反向代理；</li>\n<li>站点应用层：实现核心应用逻辑，返回HTML或者JSON；</li>\n<li>服务层：如果实现了服务化，就有这一层；</li>\n<li>数据-缓存层：缓存加速访问存储；</li>\n<li>数据-数据库层：数据库固化数据存储；</li>\n</ol>\n<p>整个系统各层次的水平扩展，又分别是如何实施的呢？</p>\n<h2 id=\"四、分层水平扩展架构实践\" tabindex=\"-1\"> 四、分层水平扩展架构实践</h2>\n<p>1、反向代理层的水平扩展</p>\n<p>反向代理层的水平扩展，是通过“DNS轮询”实现的：dns-server对于一个域名配置了多个解析ip，每次DNS解析请求来访问dns-server，会轮询返回这些ip。</p>\n<p>当nginx成为瓶颈的时候，只要增加服务器数量，新增nginx服务的部署，增加一个外网ip，就能扩展反向代理层的性能，做到理论上的无限高并发。</p>\n<p>2、站点层的水平扩展</p>\n<p>站点层的水平扩展，是通过“nginx”实现的。通过修改nginx.conf，可以设置多个web后端。</p>\n<p>当web后端成为瓶颈的时候，只要增加服务器数量，新增web服务的部署，在nginx配置中配置上新的web后端，就能扩展站点层的性能，做到理论上的无限高并发。</p>\n<p>3、服务层的水平扩展</p>\n<p>服务层的水平扩展，是通过“服务连接池”实现的。</p>\n<p>站点层通过RPC-client调用下游的服务层RPC-server时，RPC-client中的连接池会建立与下游服务多个连接，当服务成为瓶颈的时候，只要增加服务器数量，新增服务部署，在RPC-client处建立新的下游服务连接，就能扩展服务层性能，做到理论上的无限高并发。如果需要优雅的进行服务层自动扩容，这里可能需要配置中心里服务自动发现功能的支持。</p>\n<p>4、数据层的水平扩展</p>\n<p>在数据量很大的情况下，数据层（缓存，数据库）涉及数据的水平扩展，将原本存储在一台服务器上的数据（缓存，数据库）水平拆分到不同服务器上去，以达到扩充系统性能的目的。</p>\n<p>互联网数据层常见的水平拆分方式有这么几种，以数据库为例：</p>\n<p>5、按照范围水平拆分</p>\n<p>每一个数据服务，存储一定范围的数据，上图为例：</p>\n<p>user0库，存储uid范围1-1kw\nuser1库，存储uid范围1kw-2kw</p>\n<p>好处是：</p>\n<ol>\n<li>规则简单，service只需判断一下uid范围就能路由到对应的存储服务；</li>\n<li>数据均衡性较好；</li>\n<li>比较容易扩展，可以随时加一个uid[2kw,3kw]的数据服务；</li>\n</ol>\n<p>不足是：</p>\n<p>请求的负载不一定均衡，一般来说，新注册的用户会比老用户更活跃，大range的服务请求压力会更大；</p>\n<p>6、按照哈希水平拆分</p>\n<p>每一个数据库，存储某个key值hash后的部分数据，上图为例：</p>\n<ul>\n<li>user0库，存储偶数uid数据</li>\n<li>user1库，存储奇数uid数据</li>\n</ul>\n<p>好处是：</p>\n<ol>\n<li>规则简单，service只需对uid进行hash能路由到对应的存储服务；</li>\n<li>数据均衡性较好；</li>\n<li>请求均匀性较好；</li>\n</ol>\n<p>不足是：</p>\n<p>（1）不容易扩展，扩展一个数据服务，hash方法改变时候，可能需要进行数据迁移；</p>\n<p>这里需要注意的是，通过水平拆分来扩充系统性能，与主从同步读写分离来扩充数据库性能的方式有本质的不同。</p>\n<p>7、通过水平拆分扩展数据库性能：</p>\n<ol>\n<li>每个服务器上存储的数据量是总量的1/n，所以单机的性能也会有提升；</li>\n<li>n个服务器上的数据没有交集，那个服务器上数据的并集是数据的全集；</li>\n<li>数据水平拆分到了n个服务器上，理论上读性能扩充了n倍，写性能也扩充了n倍（其实远不止n倍，因为单机的数据量变为了原来的1/n）；</li>\n</ol>\n<p>8、通过主从同步读写分离扩展数据库性能：</p>\n<ol>\n<li>每个服务器上存储的数据量是和总量相同；</li>\n<li>n个服务器上的数据都一样，都是全集；</li>\n<li>理论上读性能扩充了n倍，写仍然是单点，写性能不变；</li>\n</ol>\n<p>9、缓存层的水平拆分</p>\n<p>缓存层的水平拆分和数据库层的水平拆分类似，也是以范围拆分和哈希拆分的方式居多，就不再展开。</p>\n<p>五、总结</p>\n<p>高并发是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。</p>\n<p>提高系统并发能力的方式，方法论上主要有两种：垂直扩展与水平扩展。前者垂直扩展可以通过提升单机硬件性能，或者提升单机架构性能，来提高并发性，但单机性能总是有极限的，互联网分布式架构设计高并发终极解决方案还是后者：水平扩展。</p>\n<p>互联网分层架构中，各层次水平扩展的实践又有所不同：</p>\n<ol>\n<li>反向代理层可以通过“DNS轮询”的方式来进行水平扩展；</li>\n<li>站点层可以通过nginx来进行水平扩展；</li>\n<li>服务层可以通过服务连接池来进行水平扩展；</li>\n<li>数据库可以按照数据范围，或者数据哈希的方式来进行水平扩展；</li>\n</ol>\n<p>各层实施水平扩展后，能够通过增加服务器数量的方式来提升系统的性能，做到理论上的性能无限。</p>\n",
      "date_published": "2022-04-24T09:56:06.000Z",
      "date_modified": "2022-04-24T09:56:06.000Z",
      "authors": [],
      "tags": [
        "Concurrency"
      ]
    },
    {
      "title": "MySQL脏页",
      "url": "http://www.zhangsj.xyz/blog/java/datasource/mysql-dirty-page.html",
      "id": "http://www.zhangsj.xyz/blog/java/datasource/mysql-dirty-page.html",
      "content_html": "<h2 id=\"脏页\" tabindex=\"-1\"> 脏页</h2>\n<p>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。</p>\n<p>不论是脏页还是干净页，都在内存中。</p>\n<p>平时很快地更新操作，都是在写内存和日志。</p>\n<p>一条 SQL 语句，正常执行的时候特别快，但是有时也不知道怎么回事，它就会变得特别慢。</p>\n<p>那这时候可能就是在刷脏页到磁盘中了~ flush</p>\n<h2 id=\"_2、什么时候会引起flush\" tabindex=\"-1\"> 2、什么时候会引起flush</h2>\n<p>（1） InnoDB的redo log写满了。这时候系统会停止所有的更新操作，然后让日志可以继续写。</p>\n<p>把这部分数据日志都flush到磁盘上面。</p>\n<p>(2) 也可能是系统内存不足，需要新的内存页，那么就淘汰一些内存页，空出来的给别的数据页使用。</p>\n<p>先把脏页写到磁盘。</p>\n<p>PS:使用内存是为了效率更好，</p>\n<p>因为如果内存存在数据页，那么数据就一定正确，直接返回；</p>\n<p>如果内存没有数据，才需要去磁盘中取，读入到内存，返回；</p>\n<h2 id=\"qa\" tabindex=\"-1\"> qa</h2>\n<p>Q：buffer pool？</p>\n<p>缓存区域，缓存数据和索引在内存中。</p>\n<p><code>innodb</code>使用了一些链表。</p>\n<ul>\n<li><code>lru</code>链表：用来存储内存中的缓存数据。</li>\n<li><code>free</code>链表：用来存放所有的空闲页，每次需要数据页存储数据时，就首先检测free中有没有空闲的页来分配。</li>\n<li><code>flush</code>链表：在内存中被修改但还没有刷新到磁盘的数据页列表，就是所谓的脏页列表，内存中的数据跟对应的磁盘上的数据不一致，属于该列表的页面同样存在于lru列表中，但反之未必。</li>\n</ul>\n<p>Q:LSN？</p>\n<p>Log sequence number: 当前系统最大的<code>LSN</code>号</p>\n<p>每个数据页有LSN，重做日志有LSN，<code>checkpoint</code>有LSN。</p>\n<p>占用8字节，LSN主要用于发生crash时对数据进行<code>recovery</code>，LSN是一个一直递增的整型数字，表示事务写入到日志的字节总量。\nLSN不仅只存在于重做日志中，在每个数据页头部也会有对应的LSN号，该LSN记录当前页最后一次修改的LSN号，用于在recovery时对比重做日志LSN号决定是否对该页进行恢复数据。前面说的checkpoint也是有LSN号记录的，LSN号串联起一个事务开始到恢复的过程。</p>\n<p>程序人生\nprogram-life</p>\n<p>Q:刷写的答题过程？</p>\n<p><code>buffer pool</code>里维护着一个脏页列表，假设现在<code>redo log</code> 的 <code>checkpoint</code> 记录的 <code>LSN</code> 为 10，现在内存中的一干净页有修改，修改后该页的LSN为12，大于 checkpoint 的LSN，则在写redo log的同时该页也会被标记为脏页记录到脏页列表中，现在内存不足，该页需要被淘汰掉，该页会被刷到磁盘，磁盘中该页的LSN为12，该页也从脏页列表中移除，现在redo log 需要往前推进checkpoint，到LSN为12的这条log时，发现内存中的脏页列表里没有该页，且磁盘上该页的LSN也已经为12，则该页已刷脏，已为干净页，跳过。</p>\n<p>Q:如果系统性能差，为什么会慢？</p>\n<p>因为脏页刷得很慢，堆积了之后，就会等待脏页刷完之后在进行更新和读取。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/pmdream/article/details/103668933?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165076788816782391885620%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165076788816782391885620&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-103668933.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&amp;utm_term=MySQL+%E8%84%8F%E9%A1%B5&amp;spm=1018.2226.3001.4187\" target=\"_blank\" rel=\"noopener noreferrer\">[MySQL]脏页</a></li>\n<li><a href=\"https://blog.csdn.net/qq_27347991/article/details/81052728\" target=\"_blank\" rel=\"noopener noreferrer\">Mysql Buffer Pool</a></li>\n<li><a href=\"https://www.cnblogs.com/drizzle-xu/p/9713378.html\" target=\"_blank\" rel=\"noopener noreferrer\">MySQL-LSN</a></li>\n</ul>\n",
      "date_published": "2022-04-24T09:56:06.000Z",
      "date_modified": "2022-04-24T09:56:06.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "redis脑裂",
      "url": "http://www.zhangsj.xyz/blog/java/redis/redis-split-brain.html",
      "id": "http://www.zhangsj.xyz/blog/java/redis/redis-split-brain.html",
      "content_html": "<h2 id=\"什么是redis脑裂\" tabindex=\"-1\"> 什么是redis脑裂</h2>\n<p>下面我们解释一下什么是redis脑裂：</p>\n<p>关于reids集群会由于网络等原因出现脑裂的情况，所谓的集群脑裂就是，</p>\n<p>由于redis master节点和redis salve节点和sentinel处于不同的网络分区，使得sentinel没有能够心跳感知到master，所以通过选举的方式提升了一个salve为master，这样就存在了两个master，就像大脑分裂了一样，这样会导致客户端还在old master那里写入数据，新节点无法同步数据，当网络恢复后，sentinel会将old master降为salve，这时再从新master同步数据，这会导致大量数据丢失。</p>\n<p>CAP定理中的P指的就是网络分区 ，当不同节点分布在不同的子网络中时，在内部子网络正常的情况下，由于某些原因导致这些子节点之间出现网络不通的情况，导致整个系统环境被切分成若干个独立的区域，就形成了网络分区，然后就需要在C(一致性)，A(可用性)之间做权衡了。</p>\n",
      "date_published": "2022-04-24T09:56:06.000Z",
      "date_modified": "2022-04-24T09:56:06.000Z",
      "authors": [],
      "tags": [
        "redis"
      ]
    },
    {
      "title": "VSCode插件和配置",
      "url": "http://www.zhangsj.xyz/blog/tool/vscode-plugins-and-configuration.html",
      "id": "http://www.zhangsj.xyz/blog/tool/vscode-plugins-and-configuration.html",
      "content_html": "<h2 id=\"vscode插件\" tabindex=\"-1\"> vscode插件</h2>\n<p>安装插件</p>\n<ul>\n<li>one dark pro</li>\n<li>google translate</li>\n<li>github copilot</li>\n<li>gitee</li>\n<li>git history</li>\n<li>markdown all in one</li>\n</ul>\n<p>注意：markdown和copilot插件的tab键和发生冲突，markdown扩展插件的<code>markdown.extension.onShiftTabKey</code>快捷键修改，替换tab键或者取消，如<code>shift+tab</code>。</p>\n<h2 id=\"快捷键修改\" tabindex=\"-1\"> 快捷键修改</h2>\n<p>因为习惯使用Idea，所以将尽量将vscode的配置和idea保持一致。</p>\n<ul>\n<li>将下一个查找匹配项添加到选择 ctrl+d 替换成 ctrl+w</li>\n<li>向下复制行 <code>shift+alt+upArrow</code> 替换成 <code>ctrl+d</code></li>\n<li>视图：切换主侧栏的可见：ctrl+b 改成 alt+1</li>\n<li>删除行：<code>ctrl+y</code></li>\n</ul>\n<h2 id=\"vscode配置修改\" tabindex=\"-1\"> vscode配置修改</h2>\n<p>1、选中单词的分隔符</p>\n<p>Editor: <code>Word Separators</code>：执行单词相关的导航或操作时作为单词分隔符的字符。</p>\n<p>双击选中单词，有一些中文的字符识别不了，设置单词分隔符，添加中文分隔符包括<code>，：；、？。！（）</code>等；</p>\n<p>2、自动保存</p>\n<p><code>autosave</code>：选为<code>onfocuschange</code></p>\n<p>其它选项分别是</p>\n<ul>\n<li><code>off</code>：永不自动保存更新后的文件 （他是个默认选项）</li>\n<li><code>afterDelay</code>：当文件修改后的时间超过<code>Files:Auto Save Delay</code>中配置的值时自动进行保存</li>\n<li><code>onWindowChange</code>：窗口失去焦点时自动保存更新后的文件</li>\n</ul>\n<p>3、 搜索文件，排除某些文件夹</p>\n<p><code>exclude</code></p>\n<p>功能-》搜索 配置glob模式以在全文搜索和快速打开中排除文件和文件夹</p>\n<p><img src=\"@source/tool/assets/vscode-plugins-and-configuration-1650151717352.png\" alt=\"排除某些文件夹\" loading=\"lazy\"></p>\n",
      "date_published": "2022-04-16T11:33:50.000Z",
      "date_modified": "2022-05-19T10:22:17.000Z",
      "authors": [],
      "tags": [
        "工具"
      ]
    },
    {
      "title": "转账引发的一致性思考",
      "url": "http://www.zhangsj.xyz/blog/exam/yewu/transfer-triggers-data-consistency-thinking.html",
      "id": "http://www.zhangsj.xyz/blog/exam/yewu/transfer-triggers-data-consistency-thinking.html",
      "content_html": "<h2 id=\"转账引发的一致性思考\" tabindex=\"-1\"> 转账引发的一致性思考</h2>\n<h2 id=\"转账引发的一致性思考-1\" tabindex=\"-1\"> 转账引发的一致性思考</h2>\n<p>A账户给B账户转账100元(A、B处于同一个库中)，</p>\n<p>如果A的账户发生扣款，B的账户却没有到账，这就出现了数据的不一致！</p>\n<p>为了保证数据的一致性，数据库的事务机制会让A账户扣款和B在账户到账的两个操作要么同时成功，如果有一个操作失败，则多个操作同时回滚，这就是事务的原子性，为了保证事务操作的原子性，就必须实现基于日志的REDO/UNDO机制。</p>\n<p>但是，仅有原子性还不够，因为我们的系统是运行在多线程环境下，如果多个事务并行，即使保证了每一个事务的原子性，仍然会出现数据不一致的情况。</p>\n<p>例如</p>\n<p>A账户原来有200元的余额，A账户给B账户转账100元，先读取A账户的余额，然后在这个值上减去100元，但是在这两个操作之间，A账户又给C账户转账100元，那么最后的结果应该是A减去了200元。但事实上，A账户给B账户最终完成转账后，A账户只减掉了100元，因为A账户向C账户转账减掉的100元被覆盖了！</p>\n<p>所以为了保证并发情况下的一致性，又引入的隔离性，即多个事务并发执行后的状态，和它们串行执行后的状态是等价的！</p>\n<p>隔离性又有多种隔离级别，为了实现隔离性(最终都是为了保证一致性)数据库又引入了悲观锁、乐观锁等等……本文的主题是分布式事务，所以本地事务就只是简单回顾一下，需要记住的一点是，事务是为了保证数据的一致性</p>\n<h2 id=\"事务隔离性理解\" tabindex=\"-1\"> 事务隔离性理解</h2>\n<p>H1：当 A 转给 B 100 之后，</p>\n<p>H2:A 又转给 C 100，</p>\n<p>但是在 H2 未提交之前，A 查询到的余额还是 H1，所以 A 此时余额只减少了 100 元，与实际应该减少 200 元，并发情况下数据不一致。</p>\n<h2 id=\"分布式事务\" tabindex=\"-1\"> 分布式事务</h2>\n<p>与本地事务不同的是，分布式事务需要保证的是分布式环境下，不同数据库表中的数据的一致性问题。分布式事务的解决方案有多种，如 XA 协议、TCC 三阶段提交、基于消息队列等等，本文只会涉及基于消息队列的解决方案。</p>\n<p>本地事务讲到了一致性，分布式事务不可避免的面临着一致性的问题！回到最开始跨行转账的例子，如果 A 银行用户向 B 银行用户转账，正常流程应该是</p>\n<blockquote>\n<ol>\n<li>A 银行对转出账户执行检查校验，进行金额扣减。</li>\n<li>A 银行同步调用 B 银行转账接口。</li>\n<li>B 银行对转入账户进行检查校验，进行金额增加。</li>\n<li>B 银行返回处理结果给 A 银行。</li>\n</ol>\n</blockquote>\n<p>在正常情况对一致性要求不高的场景，这样的设计是可以满足需求的。但是像银行这样的系统，如果这样实现大概早就破产了吧。我们先看看这样的设计最主要的问题：</p>\n<ol>\n<li>同步调用远程接口，如果接口比较耗时，会导致主线程阻塞时间较长。</li>\n<li>流量不能很好控制，A 银行系统的流量高峰可能压垮 B 银行系统(当然 B 银行肯定会有自己的限流机制)。</li>\n<li>如果“第 1 步”刚执行完，系统由于某种原因宕机了，那会导致 A 银行账户扣款了，但是 B 银行没有收到接口的调用，这就出现了两个系统数据的不一致。</li>\n<li>如果在执行“第 3 步”后，B 银行由于某种原因宕机了而无法正确回应请求(实际上转账操作在 B 银行系统已经执行且入库)，这时候 A 银行等待接口响应会异常，误以为转账失败而回滚“第 1 步”操作，这也会出现了两个系统数据的不一致。\n   对于问题的 1、2 都很好解决，如果对消息队列熟悉的朋友应该很快能想到可以引入消息中间件进行异步和削峰处理，</li>\n</ol>\n<p>于是又重新设计了一个方案，流程如下：</p>\n<ol>\n<li>A 银行对账户进行检查校验，进行金额扣减。</li>\n<li>将对 B 银行的请求异步写入队列，主线程返回。</li>\n<li>启动后台程序从队列获取待处理数据。</li>\n<li>后台程序对 B 银行接口进行远程调用。</li>\n<li>B 银行对转入账户进行检查校验，进行金额增加。</li>\n<li>B 银行处理完成回调 A 银行接口通知处理结果。</li>\n</ol>\n<p>所以，我们这里最核心的就是</p>\n<ul>\n<li>A 银行通过本地事务保证日志记录+后台线程轮询保证消息不丢失。</li>\n<li>B 银行通过本地事务保证日志记录从而保证消息不重复消费！B 银行在回调 A 银行的接口时会通知处理结果，如果转账失败，A 银行会根据处理结果进行回滚。</li>\n</ul>\n<p><a href=\"https://blog.csdn.net/ZrZrZr666666/article/details/113388852?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164549796916781683945697%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164549796916781683945697&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-113388852.pc_search_result_positive&amp;utm_term=%E8%BD%AC%E8%B4%A6+%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7&amp;spm=1018.2226.3001.4187\" target=\"_blank\" rel=\"noopener noreferrer\">参考：转账引发数据一致性思考</a></p>\n",
      "date_published": "2021-11-21T00:00:00.000Z",
      "date_modified": "2022-04-16T14:05:13.000Z",
      "authors": [],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "计算机组成",
      "url": "http://www.zhangsj.xyz/blog/java/concurrent/computer-composition.html",
      "id": "http://www.zhangsj.xyz/blog/java/concurrent/computer-composition.html",
      "content_html": "<h2 id=\"计算机由五大组成部分\" tabindex=\"-1\"> 计算机由五大组成部分</h2>\n<p>输入设备，输出设备存储器，控制器，运算器。计算机的主要组成CPU，内存，输入设备，输出设备。</p>\n<p><img src=\"@source/java/concurrent/img/2-1-1.png\" alt=\"计算机五大组成\" loading=\"lazy\"></p>\n<p>CPU 中央处理器，是计算机的控制和运的核心，我们的程序最终都会变成指令让CPU去执行，处理程序中的数据。</p>\n<p>内存：我们的程序都是在内存中运行的，内存会保存程序运行时的数据，供 CPU 处理。</p>\n<p>缓存：CPU的运算速度和内存的访问速度相差比较大。这就导致CPU每次操作内存都要耗费很多等待时间。内存的读写速度成为了计算机运行的瓶颈。于是就有了在CPU和主内存之间增加缓存的设计。最靠近CPU的缓存称为L1，然后依次是L2，L3和主内存，CPU缓存模型如图下图所示。</p>\n<p><img src=\"@source/java/concurrent/img/2-1-4.png\" alt=\"CPU缓存结构\" loading=\"lazy\"></p>\n<p>CPU Cache分成了三个级别:L1，L2，L3。级别越小越接近CPU，速度也更快，同时也代表着容量越小。</p>\n<ol>\n<li><code>L1</code>是最接近CPU的，它容量最小，例如32K，速度最快，每个核上都有一个L1Cache。</li>\n<li><code>L2Cache</code>更大一些，例如256K，速度要慢一些，一般情况下每个核上都有一个独立的L2Cache。</li>\n<li><code>L3Cache</code>是三级缓存中最大的一级，例如12MB，同时也是缓存中最慢的一级，在同一个CPU插槽之间的核共享一个L3Cach e。</li>\n</ol>\n<p><img src=\"@source/java/concurrent/img/2-1-5.png\" alt=\"缓存\" loading=\"lazy\"></p>\n<p>Cache的出现是为了解决CPU直接访问内存效率低下问题的，</p>\n<p>程序在运行的过程中，CPU接收到指令后，它会最先向CPU中的一级缓存(<code>L1Cache</code>)去寻找相关的数据，如果命中缓存，CPU进行计算时就可以直接对CPUCache中的数据进行读取和写人，</p>\n<p>当运算结束之后，再将CPUCache中的最新数据刷新到主内存当中，CPU通过直接访问Cache的方式替代直接访问主存的方式极大地提高了CPU的吞吐能力。</p>\n<p>但是由于一级缓存(L1Cache)容量较小，所以不可能每次都命中。</p>\n<p>这时CPU会继续向下一级的二级缓存(L2Cache)寻找，同样的道理，当所需要的数据在二级缓存中也没有的话，会继续转向L3Cache、内存(主存)和硬盘。</p>\n",
      "date_published": "2022-04-16T06:46:59.000Z",
      "date_modified": "2022-04-16T14:05:13.000Z",
      "authors": [],
      "tags": [
        "计算机原理"
      ]
    },
    {
      "title": "仍在使用SimpleDateFormat？",
      "url": "http://www.zhangsj.xyz/blog/java/basic/still-using-SimpleDateFormat.html",
      "id": "http://www.zhangsj.xyz/blog/java/basic/still-using-SimpleDateFormat.html",
      "content_html": "<h2 id=\"一、前言\" tabindex=\"-1\"> 一、前言</h2>\n<p>日常开发中，我们经常需要使用时间相关类，说到时间相关类，想必大家对SimpleDateFormat并不陌生。主要是用它进行时间的格式化输出和解析，挺方便快捷的，但是SimpleDateFormat并不是一个线程安全的类。在多线程情况下，会出现异常，想必有经验的小伙伴也遇到过。下面我们就来分析分析SimpleDateFormat为什么不安全？是怎么引发的？以及多线程下有那些SimpleDateFormat的解决方案？</p>\n<p>先看看《阿里巴巴开发手册》对于SimpleDateFormat是怎么看待的：</p>\n<blockquote>\n<ol start=\"5\">\n<li>【强制】SimpleDateFormat\n是线程不安全的类，一般不要定义为static变量，如果定义为static，必须加锁，或者使用DateUtils工具类。 正例：注意线程安全，使用DateUtils。亦推荐如下处理：</li>\n</ol>\n</blockquote>\n<div><pre><code><span>private</span> <span>static</span> <span>final</span> <span>ThreadLocal</span><span><span>&lt;</span><span>DateFormat</span><span>></span></span> df <span>=</span> <span>new</span> <span>ThreadLocal</span><span><span>&lt;</span><span>DateFormat</span><span>></span></span><span>(</span><span>)</span> <span>{</span>\n<span>@Override</span>\n<span>protected</span> <span>DateFormat</span> <span>initialValue</span><span>(</span><span>)</span> <span>{</span>\n<span>return</span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>\"yyyy-MM-dd\"</span><span>)</span><span>;</span>\n<span>}</span>\n<span>}</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><blockquote>\n<p>说明：如果是JDK8的应用，可以使用Instant\n代替Date，LocalDateTime代替Calendar，DateTimeFormatter代替SimpleDateFormat，官方给出的解释：simple beautiful strong immutable thread-safe。</p>\n</blockquote>\n<h2 id=\"二、问题场景复现\" tabindex=\"-1\"> 二、问题场景复现</h2>\n<p>一般我们使用SimpleDateFormat的时候会把它定义为一个静态变量，避免频繁创建它的对象实例，如下代码：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>SimpleDateFormatTest</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>SimpleDateFormat</span> sdf <span>=</span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>\"yyyy-MM-dd HH:mm:s\"</span><span>)</span><span>;</span>\n\n    <span>public</span> <span>static</span> <span>String</span> <span>formatDate</span><span>(</span><span>Date</span> date<span>)</span> <span>{</span>\n        <span>return</span> sdf<span>.</span><span>format</span><span>(</span>date<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>Date</span> <span>parse</span><span>(</span><span>String</span> strDate<span>)</span> <span>throws</span> <span>ParseException</span> <span>{</span>\n        <span>return</span> sdf<span>.</span><span>parse</span><span>(</span>strDate<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>sdf<span>.</span><span>format</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><div><pre><code>    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>\n        <span>ExecutorService</span> executorService <span>=</span> <span>Executors</span><span>.</span><span>newFixedThreadPool</span><span>(</span><span>100</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>20</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            executorService<span>.</span><span>execute</span><span>(</span><span>(</span><span>)</span><span>-></span><span>{</span>\n                <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> <span>10</span><span>;</span> j<span>++</span><span>)</span> <span>{</span>\n                    <span>try</span> <span>{</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>parse</span><span>(</span><span>\"2020-01-02 09:45:59\"</span><span>)</span><span>)</span><span>;</span>\n                    <span>}</span> <span>catch</span> <span>(</span><span>ParseException</span> e<span>)</span> <span>{</span>\n                        e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span>\n            <span>}</span><span>)</span><span>;</span>\n        <span>}</span>\n        executorService<span>.</span><span>shutdown</span><span>(</span><span>)</span><span>;</span>\n        executorService<span>.</span><span>awaitTermination</span><span>(</span><span>1</span><span>,</span> <span>TimeUnit</span><span>.</span>DAYS<span>)</span><span>;</span>\n\n    <span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>你看这不崩了？部分线程获取的时间不对，部分线程直接报 java.lang.NumberFormatException:multiple points错，线程直接挂死了</p>\n<h2 id=\"三、多线程不安全原因\" tabindex=\"-1\"> 三、多线程不安全原因</h2>\n<p>因为我们把SimpleDateFormat定义为静态变量，那么多线程下SimpleDateFormat的实例就会被多个线程共享，B线程会读取到A线程的时间，就会出现时间差异和其它各种问题。SimpleDateFormat和它继承的DateFormat类也不是线程安全的。</p>\n<p>来看看SimpleDateFormat的format()方法的源码：</p>\n<div><pre><code><span>// Called from Format after creating a FieldDelegate</span>\n    <span>private</span> <span>StringBuffer</span> <span>format</span><span>(</span><span>Date</span> date<span>,</span> <span>StringBuffer</span> toAppendTo<span>,</span>\n                                <span>FieldDelegate</span> delegate<span>)</span> <span>{</span>\n        <span>// Convert input date to time field list</span>\n        calendar<span>.</span><span>setTime</span><span>(</span>date<span>)</span><span>;</span>\n\n        <span>boolean</span> useDateFormatSymbols <span>=</span> <span>useDateFormatSymbols</span><span>(</span><span>)</span><span>;</span>\n\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> compiledPattern<span>.</span>length<span>;</span> <span>)</span> <span>{</span>\n            <span>int</span> tag <span>=</span> compiledPattern<span>[</span>i<span>]</span> <span>>>></span> <span>8</span><span>;</span>\n            <span>int</span> count <span>=</span> compiledPattern<span>[</span>i<span>++</span><span>]</span> <span>&amp;</span> <span>0xff</span><span>;</span>\n            <span>if</span> <span>(</span>count <span>==</span> <span>255</span><span>)</span> <span>{</span>\n                count <span>=</span> compiledPattern<span>[</span>i<span>++</span><span>]</span> <span>&lt;&lt;</span> <span>16</span><span>;</span>\n                count <span>|=</span> compiledPattern<span>[</span>i<span>++</span><span>]</span><span>;</span>\n            <span>}</span>\n\n            <span>switch</span> <span>(</span>tag<span>)</span> <span>{</span>\n            <span>case</span> TAG_QUOTE_ASCII_CHAR<span>:</span>\n                toAppendTo<span>.</span><span>append</span><span>(</span><span>(</span><span>char</span><span>)</span>count<span>)</span><span>;</span>\n                <span>break</span><span>;</span>\n\n            <span>case</span> TAG_QUOTE_CHARS<span>:</span>\n                toAppendTo<span>.</span><span>append</span><span>(</span>compiledPattern<span>,</span> i<span>,</span> count<span>)</span><span>;</span>\n                i <span>+=</span> count<span>;</span>\n                <span>break</span><span>;</span>\n\n            <span>default</span><span>:</span>\n                <span>subFormat</span><span>(</span>tag<span>,</span> count<span>,</span> delegate<span>,</span> toAppendTo<span>,</span> useDateFormatSymbols<span>)</span><span>;</span>\n                <span>break</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> toAppendTo<span>;</span>\n    <span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>注意， calendar.setTime(date)，SimpleDateFormat的format方法实际操作的就是Calendar。</p>\n<p>因为我们声明SimpleDateFormat为static变量，那么它的Calendar变量也就是一个共享变量，可以被多个线程访问。</p>\n<p>假设线程A执行完calendar.setTime(date)，把时间设置成2019-01-02，这时候被挂起，线程B获得CPU执行权。</p>\n<p>线程B也执行到了calendar.setTime(date)，把时间设置为2019-01-03。</p>\n<p>线程挂起，线程A继续走，calendar还会被继续使用(<code>subFormat</code>方法)，而这时calendar用的是线程B设置的值了，而这就是引发问题的根源，出现时间不对，线程挂死等等。</p>\n<p>其实SimpleDateFormat源码上作者也给过我们提示：</p>\n<p>意思就是：</p>\n<blockquote>\n<p>日期格式不同步。\n建议为每个线程创建单独的格式实例。\n如果多个线程同时访问一种格式，则必须在外部同步该格式。</p>\n</blockquote>\n<h2 id=\"四、解决方案\" tabindex=\"-1\"> 四、解决方案</h2>\n<p>只在需要的时候创建新实例，不用static修饰。</p>\n<p>如上代码，仅在需要用到的地方创建一个新的实例，就没有线程安全问题，不过也加重了创建对象的负担，会频繁地创建和销毁对象，效率较低。</p>\n<p>synchronized大法好</p>\n<div><pre><code><span>class</span> <span>T</span><span>{</span>\n    <span>public</span> <span>static</span> <span>String</span> <span>formatDate</span><span>(</span><span>Date</span> date<span>)</span> <span>{</span>\n        <span>synchronized</span> <span>(</span>sdf<span>)</span> <span>{</span>\n            <span>return</span> sdf<span>.</span><span>format</span><span>(</span>date<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>Date</span> <span>parse</span><span>(</span><span>String</span> strDate<span>)</span> <span>throws</span> <span>ParseException</span> <span>{</span>\n        <span>synchronized</span> <span>(</span>sdf<span>)</span> <span>{</span>\n            <span>return</span> sdf<span>.</span><span>parse</span><span>(</span>strDate<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>  \n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>简单粗暴，synchronized往上一套也可以解决线程安全问题，缺点自然就是并发量大的时候会对性能有影响，线程阻塞。</p>\n<p>ThreadLocal方法</p>\n<div><pre><code><span>public</span> <span>class</span> <span>SimpleDateFormatTLTest</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>ThreadLocal</span><span><span>&lt;</span><span>SimpleDateFormat</span><span>></span></span> sdf <span>=</span> <span>new</span> <span>ThreadLocal</span><span><span>&lt;</span><span>SimpleDateFormat</span><span>></span></span><span>(</span><span>)</span><span>{</span>\n        <span>@Override</span>\n        <span>protected</span> <span>SimpleDateFormat</span> <span>initialValue</span><span>(</span><span>)</span> <span>{</span>\n            <span>return</span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>\"yyyy-MM-dd HH:mm:ss\"</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span><span>;</span>\n\n    <span>public</span> <span>static</span> <span>String</span> <span>formatDate</span><span>(</span><span>Date</span> date<span>)</span> <span>{</span>\n        <span>return</span> sdf<span>.</span><span>get</span><span>(</span><span>)</span><span>.</span><span>format</span><span>(</span>date<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>Date</span> <span>parse</span><span>(</span><span>String</span> strDate<span>)</span> <span>throws</span> <span>ParseException</span> <span>{</span>\n        <span>return</span> sdf<span>.</span><span>get</span><span>(</span><span>)</span><span>.</span><span>parse</span><span>(</span>strDate<span>)</span><span>;</span>\n    <span>}</span>\n\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>ThreadLocal可以确保每个线程都可以得到单独的一个SimpleDateFormat的对象，那么自然也就不存在竞争问题了。</p>\n<p>基于JDK1.8的DateTimeFormatter</p>\n<p>也是《阿里巴巴开发手册》给我们的解决方案，对之前的代码进行改造：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>DateTimeFormatterTest</span> <span>{</span>\n    <span>private</span> <span>static</span> <span>final</span> <span>DateTimeFormatter</span> formatter <span>=</span> <span>DateTimeFormatter</span><span>.</span><span>ofPattern</span><span>(</span><span>\"yyyy-MM-dd HH:mm:ss\"</span><span>)</span><span>;</span>\n\n    <span>public</span> <span>static</span> <span>String</span> <span>formateDate2</span><span>(</span><span>LocalDateTime</span> date<span>)</span> <span>{</span>\n        <span>return</span> formatter<span>.</span><span>format</span><span>(</span>date<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>LocalDateTime</span> <span>parse2</span><span>(</span><span>String</span> dateNow<span>)</span> <span>{</span>\n        <span>return</span> <span>LocalDateTime</span><span>.</span><span>parse</span><span>(</span>dateNow<span>,</span>formatter<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>\n        <span>ExecutorService</span> service <span>=</span> <span>Executors</span><span>.</span><span>newFixedThreadPool</span><span>(</span><span>100</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>20</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            service<span>.</span><span>execute</span><span>(</span><span>(</span><span>)</span><span>-></span><span>{</span>\n                <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> <span>10</span><span>;</span> j<span>++</span><span>)</span> <span>{</span>\n                    <span>// System.out.println(formateDate2(LocalDateTime.now()));</span>\n                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>parse2</span><span>(</span><span>\"2020-01-02 09:45:59\"</span><span>)</span><span>)</span><span>;</span>\n\n                <span>}</span>\n            <span>}</span><span>)</span><span>;</span>\n        <span>}</span>\n        service<span>.</span><span>shutdown</span><span>(</span><span>)</span><span>;</span>\n        service<span>.</span><span>awaitTermination</span><span>(</span><span>1</span><span>,</span> <span>TimeUnit</span><span>.</span>DAYS<span>)</span><span>;</span>\n\n    <span>}</span>\n<span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>运行结果就不贴了，不会出现报错和时间不准确的问题。</p>\n<p>DateTimeFormatter源码上作者也加注释说明了，他的类是不可变的，并且是线程安全的。</p>\n",
      "date_published": "2018-02-04T00:00:00.000Z",
      "date_modified": "2022-04-14T16:12:43.000Z",
      "authors": [
        {
          "name": "Felix zyf"
        }
      ],
      "tags": [
        "note"
      ]
    },
    {
      "title": "Java性能优化之字符串优化处理",
      "url": "http://www.zhangsj.xyz/blog/java/basic/string-optimization-processing-for-java-performance-optimization.html",
      "id": "http://www.zhangsj.xyz/blog/java/basic/string-optimization-processing-for-java-performance-optimization.html",
      "content_html": "<h2 id=\"string不可变吗\" tabindex=\"-1\"> String不可变吗？</h2>\n<p>由于缓存的字符串在多个客户之间共享，因此始终存在风险，其中一个客户的操作会影响所有其他客户。</p>\n<p>例如，如果一段代码将 String “Test” 的值更改为 “TEST”，则所有其他客户也将看到该值。由于 String 对象的缓存是性能的重要保证，因此通过使 String 类不可变来避免这种风险。同时，String 是 final 的，因此没有人可以通过扩展和覆盖行为来破坏 String 类的不变性、缓存、散列值的计算等。String 类不可变的另一个原因可能是由于 HashMap。</p>\n<p>由于把字符串作为 HashMap 键很受欢迎。对于键值来说，不可变性是非常的重要，以便用它们检索存储在 HashMap 中的值对象。由于 HashMap 的工作原理是散列，因此需要具有相同的值才能正常运行。如果在插入后修改了 String 的内容，可变的 String 将在插入和检索时生成两个不同的哈希码，可能会丢失 Map 中的值对象。</p>\n<p>String是数据类型，也传输对象和中间人。这种多重角色的重要性和流行性，也使这个问题在 Java 面试中很常见。</p>\n<ol>\n<li>想象字符串池没有使字符串不可变，它根本不可能，因为在字符串池的情况下，一个字符串对象/文字，例如 “Test” 已被许多参考变量引用，因此如果其中任何一个更改了值，其他参数将自动受到影响，即假设</li>\n</ol>\n<div><pre><code><span>String</span> <span>A</span><span>=</span><span>\"Test\"</span><span>;</span><span>String</span> <span>B</span><span>=</span><span>\"Test\"</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br></div></div><p>现在字符串 B 调用 &quot;Test&quot;.toUpperCase(), 将同一个对象改为“TEST”，所以 A 也是 “TEST”，这不是期望的结果。</p>\n<ol start=\"2\">\n<li>字符串已被广泛用作许多 Java 类的参数，例如，为了打开网络连接，你可以将主机名和端口号作为字符串传递，你可以将数据库 URL 作为字符串传递, 以打开数据库连接，你可以通过将文件名作为参数传递给 File I/O 类来打开 Java 中的任何文件。</li>\n</ol>\n<p>如果 String 不是不可变的，这将导致严重的安全威胁，我的意思是有人可以访问他有权授权的任何文件，然后可以故意或意外地更改文件名并获得对该文件的访问权限。</p>\n<p>由于不变性，你无需担心这种威胁。这个原因也说明了，为什么 String 在 Java 中是最终的，通过使<code>java.lang.String</code>final，Java设计者确保没有人覆盖 String 类的任何行为。</p>\n<ol start=\"3\">\n<li>\n<p>由于 String 是不可变的，它可以安全地共享许多线程，这对于多线程编程非常重要. 并且避免了 Java 中的同步问题，不变性也使得String 实例在 Java 中是线程安全的，这意味着你不需要从外部同步 String 操作。</p>\n</li>\n<li>\n<p>为什么<code>String</code>在Java中是不可变的另一个原因是允许String缓存其哈希码，Java中的不可变String缓存其哈希码，并且不会在每次调用String的<code>hashcode</code>方法时重新计算，这使得它在Java中的HashMap中使用的HashMap键非常快。</p>\n</li>\n</ol>\n<p>简而言之，因为String是不可变的，所以没有人可以在创建后更改其内容，这保证了String的hashCode在多次调用时是相同的。</p>\n<ol start=\"5\">\n<li>String不可变的绝对最重要的原因是它被类加载机制使用，因此具有深刻和基本的安全考虑。如果String是可变的，<code>java.io.Writer</code>的请求可能已被更改为加载“<code>mil.vogoon.DiskErasingWriter</code>”.</li>\n</ol>\n<p>譬如你想加载<code>java.sql.Connection</code>类，而这个值被改成了<code>myhacked.Connection</code>，那么会对你的数据库造成不可知的破坏。</p>\n<p>安全性和字符串池是使字符串不可变的主要原因。</p>\n<p>p：顺便说一句，上面的理由很好回答另一个Java面试问题: “为什么String在Java中是最终的”。要想是不可变的，你必须是最终的，这样你的子类不会破坏不变性。你怎么看？</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>String</span> a <span>=</span> <span>\"111\"</span><span>;</span>\n        a <span>=</span> <span>\"222\"</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>有的人会认为上面这段代码应该输出：111，但输出的值是222</p>\n<p>这不对呀，不是不变吗？怎么变了呢？ 其实在JVM的运行中，会单独给一块地分给String。</p>\n<p>上面的：</p>\n<div><pre><code><span>Stirng</span> a<span>=</span><span>\"111\"</span>；\n</code></pre><div aria-hidden=\"true\"><span>1</span><br></div></div><p>我们知道字符串的分配和其他对象分配一样，是需要消耗高昂的时间和空间的，而且字符串我们使用的非常多。JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：</p>\n<p>使用字符串常量池。每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性我们可以十分肯定常量池中一定不存在两个相同的字符串。</p>\n<p>这里先去JVM给常量池里找，找到了就不用创建对象了，直接把对象的引用地址赋给a。找不到会重新创建一个对象，然后把对象的引用地址赋给a。同理a=&quot;222&quot;;也是先找，找不到就重新创建一个对象，然后把对象的引用地址赋给a。</p>\n<p>大家有没有发现我上面的描述中“引用地址”。比如说<code>Object obj = new Object();</code>很多人喜欢成obj为对象，其实obj不是对象，他只是一个变量，然后这个变量里保存一个Object对象的引用地址罢了。</p>\n<p>引用类型声明的变量是指该变量在内存中实际存储的是一个引用地址，实体在堆中。</p>\n<h2 id=\"字符串常量池详解\" tabindex=\"-1\"> 字符串常量池详解</h2>\n<p>在JVM中，为了减少字符串对象的重复创建，维护了一块特殊的内存空间，这块内存空间就被称为字符串常量池。</p>\n<p>在JDK1.6及之前，字符串常量池存放在方法区中。到JDK1.7之后，就从方法区中移除了，而存放在堆中。一下是《深入理解虚Java虚拟机》第二版原文：</p>\n<p>对于HotSpot 虚拟机，根据官方发布的路线图信息，现在也有放弃永久代并逐步改为采用Native Memory来实现方法区的规划了，在目前已经发布的JDK1.7 的HotSpot中，已经把原本放在永久代的字符串常量池移出。</p>\n<p>根据查阅的资料显示在JDK1.7以后的版本中字符串常量池移到堆内存区域；同时在jdk1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域</p>\n<p>创建字符串对象的两种方法</p>\n<ol>\n<li>直接使用双引号声明出来的String对象会直接储存在常量池中。</li>\n<li>使用new方法创建出来的String对象，可以使用String提供的intern方法。<code>intern</code>方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。</li>\n</ol>\n<div><pre><code><span>class</span> <span>Test</span><span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>{</span>\n        <span>String</span> s1 <span>=</span> <span>\"abc\"</span><span>;</span>\n        <span>String</span> s2 <span>=</span> <span>\"abc\"</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1<span>)</span><span>;</span><span>//abc</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1 <span>==</span> s2<span>)</span><span>;</span><span>//true</span>\n\n        <span>char</span><span>[</span><span>]</span> charArray <span>=</span> <span>{</span><span>'a'</span><span>,</span><span>'b'</span><span>,</span><span>'c'</span><span>}</span><span>;</span>\n        <span>String</span> s3 <span>=</span> <span>new</span> <span>String</span><span>(</span>charArray<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s3<span>)</span><span>;</span><span>//abc</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s1 <span>==</span> s3<span>)</span><span>;</span><span>//false</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>从结果看，两个布尔值的结果不相同，虽然两个输出两个字符串的结果相同，都为abc，但比较两者时则不同，这是因为引用类型比较时，比较的是其地址值；不同于基本数据类型比较的是其数据值。</p>\n<p>双引号声明的方法创建字符串对象，JVM首先会去字符串常量池中查找是否存在&quot;abc&quot;这个对象，如果存在，直接将存在的“abc”的地址返回给对象s2，如果不存在，则在字符串常量池中创建”abc“这个对象并返回其引用地址返回给对象s1。</p>\n<p>而通过new方法创建的String对象，其创建的字符串是放在堆当中的，将堆当中的字符串地址返回赋值给s3，s1和s3的存放位置不同，一个在字符串常量池中，一个在堆中，因此返回的值是false。</p>\n<p>由于String字符串的不可变性我们可以十分肯定常量池中一定不存在两个相同的字符串。</p>\n<div><pre><code><span>User</span> user <span>=</span> <span>new</span> <span>User</span><span>(</span><span>)</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br></div></div><p>创建了一个user对象，老喜欢把user称之为对象。这里不接受反驳。</p>\n<p>所以上面<code>String a = &quot;111&quot;;</code>表达的是变量a里保存了“111”，这个对象的引用地址。变量是可以变的，不能变的是“111”。</p>\n<h2 id=\"string-为什么是不可变的\" tabindex=\"-1\"> String 为什么是不可变的？</h2>\n<p>String对象还有一个方法<code>intern</code>（可惜是个本地方法，不能看到内部如何实现的），这个方法可以动态的扩展运行时常量池。</p>\n<p>当调用 intern 方法时，如果池已经包含一个等于此 String 对象的字符串（用 equals(Object) 方法确定），则返回池中的字符串。否则，将此 String 对象添加到池中，并返回此 String 对象的引用。</p>\n",
      "date_published": "2022-04-14T15:42:00.000Z",
      "date_modified": "2022-04-16T14:05:13.000Z",
      "authors": [],
      "tags": [
        "java基础"
      ]
    },
    {
      "title": "spring中涉及到九种设计模式",
      "url": "http://www.zhangsj.xyz/blog/java/design-patterns/let-me-tell-you-what-design-patterns-are-used-in-spring.html",
      "id": "http://www.zhangsj.xyz/blog/java/design-patterns/let-me-tell-you-what-design-patterns-are-used-in-spring.html",
      "content_html": "<h1 id=\"spring中常用的设计模式达到九种-我们举例说明\" tabindex=\"-1\"> spring中常用的设计模式达到九种，我们举例说明</h1>\n<h2 id=\"_1、简单工厂模式\" tabindex=\"-1\"> 1、简单工厂模式</h2>\n<p>又叫做静态工厂方法（StaticFactory Method）模式，但不属于23种GOF设计模式之一。</p>\n<p>GoF（Gang of Four），中文名——四人组。 《Design Patterns: Elements of Reusable Object-Oriented Software》（即后述《设计模式》一书）</p>\n<p>简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。</p>\n<p>spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。如下配置，就是在 HelloItxx 类中创建一个 itxxBean。</p>\n<div><pre><code><span><span><span>&lt;</span>beans</span><span>></span></span>\n  <span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>\"</span>singletonBean<span>\"</span></span> <span>class</span><span><span>=</span><span>\"</span>com.itxxz.HelloItxxz<span>\"</span></span><span>></span></span>\n     <span><span><span>&lt;</span>constructor-arg</span><span>></span></span>\n       <span><span><span>&lt;</span>value</span><span>></span></span>Hello ! 这是singletonBean!<span><span><span>&lt;</span>value</span><span>></span></span>\n     <span><span><span>&lt;/</span>constructor-arg</span><span>></span></span>\n &lt;/ bean>\n <span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>\"</span>itxxzBean<span>\"</span></span> <span>class</span><span><span>=</span><span>\"</span>com.itxxz.HelloItxxz<span>\"</span></span>  <span>singleton</span><span><span>=</span><span>\"</span>false<span>\"</span></span><span>></span></span>\n   <span><span><span>&lt;</span>constructor-arg</span><span>></span></span>\n       <span><span><span>&lt;</span>value</span><span>></span></span>Hello! 这是itxxzBean! value>\n   <span><span><span>&lt;/</span>constructor-arg</span><span>></span></span>\n <span><span><span>&lt;/</span>bean</span><span>></span></span>\n<span><span><span>&lt;/</span>beans</span><span>></span></span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id=\"_2、工厂方法模式\" tabindex=\"-1\"> 2、工厂方法模式</h2>\n<p>通常由应用程序直接使用new创建新的对象，为了将对象的创建和使用相分离，采用工厂模式,即应用程序将对象的创建及初始化职责交给工厂对象。</p>\n<p>一般情况下,应用程序有自己的工厂对象来创建bean.如果将应用程序自己的工厂对象交给Spring管理,那么Spring管理的就不是普通的bean,而是工厂Bean。</p>\n<p>就以工厂方法中的静态方法为例讲解一下：</p>\n<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Random</span><span>;</span>\n<span>public</span> <span>class</span> <span>StaticFactoryBean</span> <span>{</span>\n <span>public</span> <span>static</span> <span>Integer</span> <span>createRandom</span><span>(</span><span>)</span> <span>{</span>\n      <span>return</span> <span>new</span> <span>Integer</span><span>(</span><span>new</span> <span>Random</span><span>(</span><span>)</span><span>.</span><span>nextInt</span><span>(</span><span>)</span><span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>建一个config.xm配置文件，将其纳入Spring容器来管理,需要通过factory-method指定静态方法名称：</p>\n<div><pre><code><span><span><span>&lt;</span>bean</span> <span>id</span><span><span>=</span><span>\"</span>random<span>\"</span></span>\n<span>class</span><span><span>=</span><span>\"</span>example.chapter3.StaticFactoryBean<span>\"</span></span> <span>factory-method</span><span><span>=</span><span>\"</span>createRandom<span>\"</span></span>\n<span>scope</span><span><span>=</span><span>\"</span>prototype<span>\"</span></span>\n<span>/></span></span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>测试：</p>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>//调用getBean()时,返回随机数.如果没有指定factory-method,会返回StaticFactoryBean的实例,即返回工厂Bean的实例      </span>\n    <span>XmlBeanFactory</span> factory <span>=</span> <span>new</span> <span>XmlBeanFactory</span><span>(</span><span>new</span> <span>ClassPathResource</span><span>(</span><span>\"config.xml\"</span><span>)</span><span>)</span><span>;</span>      \n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"我是IT学习者创建的实例:\"</span><span>+</span>factory<span>.</span><span>getBean</span><span>(</span><span>\"random\"</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"_3、单例模式\" tabindex=\"-1\"> 3、单例模式</h2>\n<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>\n<p>spring中的单例模式完成了后半句话，即提供了全局的访问点<code>BeanFactory</code>。但没有从构造器级别去控制单例，这是因为spring管理的是是任意的java对象。</p>\n<p>核心提示点：Spring下默认的bean均为singleton，可以通过singleton=“true|false” 或者 scope=&quot;?&quot;来指定。</p>\n<h2 id=\"_4、适配器模式\" tabindex=\"-1\"> 4、适配器模式</h2>\n<p>在Spring的Aop（Aspect Oriented Program）中，使用的<code>Advice </code>（通知）来增强被代理类的功能。Spring 实现这一AOP功能的原理就使用代理模式（1、JDK动态代理。2、CGLib字节码生成技术代理。）对类进行方法级别的切面增强，即，生成被代理类的代理类， 并在代理类的方法前，设置拦截器，通过执行拦截器中的内容增强了代理方法的功能，实现的面向切面编程。</p>\n<p><code>Adapter</code>类接口：<code>Target</code></p>\n<div><pre><code><span>public</span> <span>interface</span> <span>AdvisorAdapter</span> <span>{</span>\n\n    <span>boolean</span> <span>supportsAdvice</span><span>(</span><span>Advice</span> advice<span>)</span><span>;</span>\n\n    <span>MethodInterceptor</span> <span>getInterceptor</span><span>(</span><span>Advisor</span> advisor<span>)</span><span>;</span>\n\n<span>}</span> \n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><code>MethodBeforeAdviceAdapter</code>类，Adapter</p>\n<div><pre><code><span>class</span> <span>MethodBeforeAdviceAdapter</span> <span>implements</span> <span>AdvisorAdapter</span><span>,</span> <span>Serializable</span> <span>{</span>\n\n     <span>public</span> <span>boolean</span> <span>supportsAdvice</span><span>(</span><span>Advice</span> advice<span>)</span> <span>{</span>\n           <span>return</span> <span>(</span>advice <span>instanceof</span> <span>MethodBeforeAdvice</span><span>)</span><span>;</span>\n     <span>}</span>\n\n     <span>public</span> <span>MethodInterceptor</span> <span>getInterceptor</span><span>(</span><span>Advisor</span> advisor<span>)</span> <span>{</span>\n        <span>MethodBeforeAdvice</span> advice <span>=</span> <span>(</span><span>MethodBeforeAdvice</span><span>)</span> advisor<span>.</span><span>getAdvice</span><span>(</span><span>)</span><span>;</span>\n        <span>return</span> <span>new</span> <span>MethodBeforeAdviceInterceptor</span><span>(</span>advice<span>)</span><span>;</span>\n     <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"_5、包装器模式\" tabindex=\"-1\"> 5、包装器模式</h2>\n<p>在我们的项目中遇到这样一个问题：我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。我们以往在spring和hibernate框架中总是配置一个数据源，因而<code>sessionFactory</code>的<code>dataSource</code>属性总是指向这个数据源并且恒定不变，所有DAO在使用<code>sessionFactory</code>的时候都是通过这个数据源访问数据库。</p>\n<p>但是现在，由于项目的需要，我们的DAO在访问<code>sessionFactory</code>的时候都不得不在多个数据源中不断切换，问题就出现了：如何让<code>sessionFactory</code>在执行数据持久化的时候，根据客户的需求能够动态切换不同的数据源？我们能不能在spring的框架下通过少量修改得到解决？是否有什么设计模式可以利用呢？</p>\n<p>首先想到在spring的<code>applicationContext</code>中配置所有的<code>dataSource</code>。这些dataSource可能是各种不同类型的，比如不同的数据库：Oracle、SQL Server、MySQL等，也可能是不同的数据源：比如<code>apache</code> 提供的<code>org.apache.commons.dbcp.BasicDataSource</code>、<code>spring</code>提供的<code>org.springframework.jndi.JndiObjectFactoryBean</code>等。然后<code>sessionFactory</code>根据客户的每次请求，将<code>dataSource</code>属性设置成不同的数据源，以到达切换数据源的目的。</p>\n<p>spring中用到的包装器模式在类名上有两种表现：一种是类名中含有<code>Wrapper</code>，另一种是类名中含有Decorator。基本上都是动态地给一个对象添加一些额外的职责。</p>\n<p>decorator 英[ˈdekəreɪtə(r)] 美[ˈdekəreɪtər] n. 室内装修设计师; (房屋的)油漆匠，裱糊匠;</p>\n<h2 id=\"_6、代理模式\" tabindex=\"-1\"> 6、代理模式</h2>\n<p>为其他对象提供一种代理以控制对这个对象的访问。  从结构上来看和<code>Decorator</code>模式类似，但<code>Proxy</code>是控制，更像是一种对功能的限制，而Decorator是增加职责。</p>\n<p>spring的<code>Proxy</code>模式在aop中有体现，比如JdkDynamicAopProxy和Cglib2AopProxy。</p>\n<p>proxy 英[ˈprɒksi] 美[ˈprɑːksi] n. 代理; 代理人; 代表; 代理权; 代表权; 受托人; (测算用的)代替物; 指标;</p>\n<h2 id=\"_7、观察者模式\" tabindex=\"-1\"> 7、观察者模式</h2>\n<p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>\n<p>spring中<code>Observer</code>模式常用的地方是<code>listener</code>的实现。如<code>ApplicationListener</code>。</p>\n<p>observer 英[əbˈzɜːvə(r)] 美[əbˈzɜːrvər] n. 观察者; 观察员; 观察家; 观测者; 目击者; 旁听者; 评论员;</p>\n<h2 id=\"_8、策略模式\" tabindex=\"-1\"> 8、策略模式</h2>\n<p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</p>\n<p>spring中在实例化对象的时候用到Strategy模式</p>\n<p>在<code>SimpleInstantiationStrategy</code>中有如下代码说明了策略模式的使用情况：</p>\n<p>strategy 英[ˈstrætədʒi] 美[ˈstrætədʒi] n. 策略; 计策; 行动计划; 策划; 规划; 部署; 统筹安排; 战略; 战略部署;</p>\n<h2 id=\"_9、模板方法模式\" tabindex=\"-1\"> 9、模板方法模式</h2>\n<p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。<code>Template Method</code>使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>\n<p><code>Template Method</code>模式一般是需要继承的。这里想要探讨另一种对<code>Template Method</code>的理解。spring中的<code>JdbcTemplate</code>，在用这个类时并不想去继承这个类，因为这个类的方法太多，但是我们还是想用到<code>JdbcTemplate</code>已有的稳定的、公用的数据库连接，那么我们怎么办呢？我们可以把变化的东西抽出来作为一个参数传入<code>JdbcTemplate</code>的方法中。但是变化的东西是一段代码，而且这段代码会用到<code>JdbcTemplate</code>中的变量。怎么办？那我们就用回调对象吧。</p>\n<p>在这个回调对象中定义一个操纵<code>JdbcTemplate</code>中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到JdbcTemplate，从而完成了调用。这可能是<code>Template Method</code>不需要继承的另一种实现方式。</p>\n<p>一个具体的例子： JdbcTemplate中的<code>execute</code>方法</p>\n",
      "date_published": "2022-04-14T15:42:00.000Z",
      "date_modified": "2022-04-14T15:42:00.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Java设计模式--单例模式！",
      "url": "http://www.zhangsj.xyz/blog/java/design-patterns/singleton-design.html",
      "id": "http://www.zhangsj.xyz/blog/java/design-patterns/singleton-design.html",
      "content_html": "<p>在介绍单例模式之前，我们先了解一下，什么是设计模式？</p>\n<h2 id=\"一、设计模式-design-pattern\" tabindex=\"-1\"> 一、设计模式（Design Pattern）</h2>\n<p>是一套被反复使用，多数人知晓的，经过分类编目的，代码设计经验的总结。</p>\n<p>目的：使用设计模式是为了可重用性代码，让代码更容易被他人理解，保证代码可靠性。</p>\n<p>本文将会用到的关键词：</p>\n<ul>\n<li>单例：Singleton</li>\n<li>实例：instance</li>\n<li>同步：synchronized</li>\n<li>类装载器：ClassLoader</li>\n</ul>\n<h2 id=\"单例模式\" tabindex=\"-1\"> 单例模式：</h2>\n<p>单例，顾名思义就是只能有一个、不能再出现第二个。就如同地球上没有两片一模一样的树叶一样。</p>\n<p>在这里就是说：一个类只能有一个实例，并且整个项目系统都能访问该实例。</p>\n<p>单例模式共分为两大类：</p>\n<ul>\n<li>懒汉模式：实例在第一次使用时创建</li>\n<li>饿汉模式：实例在类装载时创建</li>\n</ul>\n<p>单例模式UML图：</p>\n<p><img src=\"@source/java/design-patterns/assets/20220414/singleton-design-1649949735164.png\" alt=\"单例模式UML图：\" loading=\"lazy\"></p>\n<h2 id=\"饿汉模式\" tabindex=\"-1\"> 饿汉模式：</h2>\n<p>按照定义我们可以写出一个基本代码：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>\n    <span>private</span> <span>Singleton</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n    <span>// 由于不能使用构造方法创建实力，所以需要在类的内部创建该类的唯一实力，使用STATIC修饰singleton，在外界可以通过类名调用该实例子， 类名.成员变量</span>\n    <span>private</span> <span>static</span> <span>Singleton</span> singleton <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span> <span>// 1</span>\n    \n    <span>// 如果使用private修饰，则不能在外部访问，只能在类内部访问</span>\n    <span>private</span> <span>static</span> <span>Singleton</span> instance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span> <span>// 2</span>\n    <span>public</span> <span>static</span> <span>Singleton</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> instance<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>对于饿汉模式来说，这种写法已经很‘perfect’了，唯一的缺点就是，由于instance的初始化是在类加载时进行的，类加载是由ClassLoader来实现的，如果初始化太早，就会造成资源浪费。</p>\n<p>当然，如果所需的单例占用的资源很少，并且也不依赖于其他数据，那么这种实现方式也是很好的。</p>\n<p>类装载的时机：</p>\n<ul>\n<li>new一个对象时</li>\n<li>使用反射创建它的实例时</li>\n<li>子类被加载时，如果父类还没有加载，就先加载父类</li>\n<li>JVM启动时执行主类 会先被加载</li>\n</ul>\n<h2 id=\"懒汉模式\" tabindex=\"-1\"> 懒汉模式：</h2>\n<p>懒汉模式的代码如下：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>LazySingleton</span><span>{</span>\n    <span>private</span> <span>static</span> <span>LazySingleton</span> singleton<span>;</span>\n    \n    <span>public</span> <span>static</span> <span>String</span> VARIABLE <span>=</span> <span>\"hello world\"</span><span>;</span> \n    \n    <span>private</span> <span>LazySingleton</span><span>(</span><span>)</span><span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"LazySingleton is created\"</span><span>)</span><span>;</span>\n    <span>}</span>\n    \n    <span>public</span> <span>static</span> <span>LazySingleton</span> <span>getInstance</span><span>(</span><span>)</span><span>{</span>\n        <span>if</span><span>(</span>singleton <span>==</span> <span>null</span><span>)</span><span>{</span>\n            singleton <span>=</span> <span>new</span> <span>LazySingleton</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> singleton<span>;</span>\n    <span>}</span>\n    \n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>{</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>printf</span><span>(</span><span>LazySingleton</span><span>.</span>VARIABLE<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>可以看出，只要我们不调用getInstance()方法，就不会常见instance，就可以很好的保证了第一次调用的时候创建对象。</p>\n<h2 id=\"双重检查-double-check\" tabindex=\"-1\"> 双重检查（Double-Check）</h2>\n<div><pre><code><span>class</span> <span>Singleton</span> <span>{</span>\n    <span>private</span> <span>volatile</span> <span>Singleton</span> singleton<span>;</span>\n    \n    <span>private</span> <span>Singleton</span><span>(</span><span>)</span><span>{</span><span>}</span>\n\n    <span>public</span> <span>Singleton</span> <span>getSingleton</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>singleton <span>=</span> <span>null</span><span>)</span><span>{</span>\n            <span>synchronized</span> <span>(</span>singleton<span>.</span><span>class</span><span>)</span><span>{</span>\n                <span>if</span> <span>(</span>singleton <span>=</span> <span>null</span><span>)</span><span>{</span>\n                    singleton <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> singleton<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>怎么说哪？代码量确实比较多，并且难以理解，为什么使用<code>volatile</code> ，以及为什么是两次判空，这些都很难理解，并且在一些低版本的JDK还不能够保证执行的正确性，所以代码中也不推荐大家用，但作为一种思想还是有必要研究一下！</p>\n<p>这段代码看起来已经完美无瑕了。当然，只是『看起来』，还是有小概率出现问题的。想要充分理解需要先弄清楚以下几个概念：原子操作、指令重排。</p>\n<p>原子操作：</p>\n<p>简单来说，原子操作（atomic）就是不可分割的操作，在计算机中，就是指不会因为线程调度被打断的操作。比如，简单的赋值是一个原子操作：</p>\n<p>了解了原子操作和指令重排的概念之后，我们再继续看代码三的问题。</p>\n<p>主要在于singleton = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。</p>\n<ol>\n<li>给 singleton 分配内存</li>\n<li>调用 Singleton 的构造函数来初始化成员变量，形成实例</li>\n<li>将singleton对象指向分配的内存空间（执行完这步 singleton才是非 null了）</li>\n</ol>\n<p>在JVM的即时编译器中存在指令重排序的优化</p>\n<p>volatile关键字的一个作用是禁止指令重排，把instance声明为volatile之后，对它的写操作就会有一个内存屏障，这样，在它的赋值完成之前，就不用会调用读操作。</p>\n<p>注意：volatile阻止的不是singleton = new Singleton()这句话内部[1-2-3]的指令重排，而是保证了在一个写操作（[1-2-3]）完成之前，不会调用读操作（if (instance == null)）。</p>\n<p>其它方法</p>\n<h2 id=\"静态内部类\" tabindex=\"-1\"> 静态内部类</h2>\n<div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>\n    <span>private</span> <span>static</span> <span>class</span> <span>SingletonHolder</span> <span>{</span>\n        <span>private</span> <span>static</span> <span>final</span> <span>Singleton</span> INSTANCE <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>Singleton</span><span>(</span><span>)</span> <span>{</span><span>}</span>\n\n    <span>public</span> <span>static</span> <span>final</span> <span>Singleton</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>SingletonHolder</span><span>.</span>INSTANCE<span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>这种写法的巧妙之处在于：对于内部类SingletonHolder，它是一个饿汉式的单例实现，在SingletonHolder初始化的时候会由ClassLoader来保证同步，使INSTANCE是一个真单例。</p>\n<p>同时，由于SingletonHolder是一个内部类，只在外部类的Singleton的getInstance()中被使用，所以它被加载的时机也就是在getInstance()方法第一次被调用的时候。</p>\n<p>它利用了ClassLoader来保证了同步，同时又能让开发者控制类加载的时机。从内部看是一个饿汉式的单例，但是从外部看来，又的确是懒汉式的实现</p>\n<h2 id=\"枚举\" tabindex=\"-1\"> 枚举：</h2>\n<div><pre><code><span>public</span> <span>enum</span> <span>Singleton</span> <span>{</span>\n    INSTANCE<span>;</span>\n    <span>public</span> <span>void</span> <span>whateverMethod</span><span>(</span><span>)</span> <span>{</span>\n        <span>// ...</span>\n    <span>}</span>\n<span>}</span> <span>// 使用Singleton.INSTANCE.whateverMethod()调用方法</span>\n\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>是不是很简单？而且因为自动序列化机制，保证了线程的绝对安全。三个词概括该方式：简单、高效、安全</p>\n<p>这种写法在功能上与共有域方法相近，但是它更简洁，无偿地提供了序列化机制，绝对防止对此实例化，即使是在面对复杂的序列化或者反射攻击的时候。虽然这中方法还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。</p>\n",
      "date_published": "2022-04-14T15:42:00.000Z",
      "date_modified": "2022-04-16T14:05:13.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "思维方式训练",
      "url": "http://www.zhangsj.xyz/blog/exam/capability/introduce-a-way-of-thinking.html",
      "id": "http://www.zhangsj.xyz/blog/exam/capability/introduce-a-way-of-thinking.html",
      "content_html": "<p><a href=\"https://www.bilibili.com/video/BV1cZ4y1M7t8/?spm_id_from=333.788.recommend_more_video.0\" target=\"_blank\" rel=\"noopener noreferrer\">思维方式</a></p>\n<p>多刷知乎，回答问题，</p>\n<p>考虑你的答案，让他们更有逻辑，更有价值，别人能够听懂，废话很多不重要，80%的废话+20%的核心内容会让你的回答更有说服力，让人更愿意读下去，干巴巴的教条是大家都不愿意读的；</p>\n",
      "date_published": "2022-04-14T03:34:13.000Z",
      "date_modified": "2022-04-14T05:48:05.000Z",
      "authors": [],
      "tags": [
        "expression"
      ]
    },
    {
      "title": "java8新特性",
      "url": "http://www.zhangsj.xyz/blog/java/basic/jdk-8-new-features.html",
      "id": "http://www.zhangsj.xyz/blog/java/basic/jdk-8-new-features.html",
      "content_html": "<h2 id=\"java-8特性-collectors-tomap\" tabindex=\"-1\"> Java 8特性 - Collectors toMap</h2>\n<p>tomap</p>\n",
      "date_published": "2022-04-14T03:34:13.000Z",
      "date_modified": "2022-04-14T05:48:05.000Z",
      "authors": [],
      "tags": [
        "jdk8"
      ]
    },
    {
      "title": "JDK8并发包下的通用并发类",
      "url": "http://www.zhangsj.xyz/blog/java/concurrent/common-concurrency-classes-under-java-8-concurrent-packages.html",
      "id": "http://www.zhangsj.xyz/blog/java/concurrent/common-concurrency-classes-under-java-8-concurrent-packages.html",
      "content_html": "<h1 id=\"java-8并发包下常见的并发类\" tabindex=\"-1\"> Java 8并发包下常见的并发类</h1>\n<h2 id=\"阻塞队列\" tabindex=\"-1\"> 阻塞队列</h2>\n<ul>\n<li><code>LinkedBlockingDeque</code>：底层是单向链表实现，阻塞双端队列，有两把锁，一把用于对头移除元素，一把用于添加元素，添加移除可以并发执行，两把锁比一把锁并发度高；注意：迭代整个队列或查找中间元素时需要同时拿到两把锁，尽量减少这些操作。</li>\n<li><code>BlockingQueue</code>：阻塞队列接口</li>\n<li><code>BlockingDeque</code>：双端阻塞队列接口</li>\n<li><code>ArrayBlockingQueue</code>：阻塞队列，数组实现</li>\n<li><code>LinkedBlockingQueue</code>：阻塞队列，链表实现</li>\n<li><code>DelayQueue</code>：阻塞队列，并且元素是 Delay 的子类，保证元素在达到一定时间后才可以取得到</li>\n<li><code>PriorityBlockingQueue</code>：优先级阻塞队列</li>\n<li><code>SynchronousQueue</code>：同步队列，但是队列长度为 0，生产者放入队列的操作会被阻塞，直到消费者过来取，所以这个队列根本不需要空间存放元素；有点像一个独木桥，一次只能一人通过，还不能在桥上停留</li>\n</ul>\n<h2 id=\"非阻塞队列\" tabindex=\"-1\"> 非阻塞队列</h2>\n<ul>\n<li><code>ConcurrentLinkedDeque</code>：非阻塞双端队列，链表实现，通过<code>volatile</code>关键字和CAS操作实现的。吞吐量会高，并发时通过自旋保证安全；</li>\n<li><code>ConcurrentLinkedQueue</code>：非阻塞队列，链表实现</li>\n</ul>\n<h2 id=\"转移队列\" tabindex=\"-1\"> 转移队列</h2>\n<ul>\n<li><code>TransferQueue</code>：转移队列接口，生产者要等消费者消费的队列，生产者尝试把元素直接转移给消费者</li>\n<li><code>LinkedTransferQueue</code>：转移队列的链表实现，它比 SynchronousQueue 更快</li>\n</ul>\n<h2 id=\"其它容器\" tabindex=\"-1\"> 其它容器</h2>\n<ul>\n<li><code>ConcurrentHashMap</code>：并发 HashMap</li>\n<li><code>ConcurrentMap</code>：并发 Map 的接口，定义了 <code>putIfAbsent(k,v)</code>、remove(k,v)、replace(k,oldV,newV)、replace(k,v) 这四个并发场景下特定的方法</li>\n<li><code>ConcurrentNavigableMap</code>：NavigableMap 的实现类，返回最接近的一个元素</li>\n<li><code>ConcurrentSkipListMap</code>：它也是 <code>NavigableMap</code> 的实现类(要求元素之间可以比较)，同时它比 <code>ConcurrentHashMap</code> 更加 <code>scalable——ConcurrentHashMap</code> 并不保证它的操作时间，并且你可以自己来调整它的 <code>load factor</code>；但是 <code>ConcurrentSkipListMap</code> 可以保证 <code>O(log n)</code> 的性能，同时不能自己来调整它的并发参数，只有你确实需要快速的遍历操作，并且可以承受额外的插入开销的时候，才去使用它</li>\n<li><code>ConcurrentSkipListSet</code>：和上面类似，只不过 map 变成了 set</li>\n<li><code>CopyOnWriteArrayList</code>：<code>copy-on-write</code>模式的 array list，每当需要插入元素，而是会<strong>复制</strong>一个 list进行写操作，适合读远大于写的场景，读写分离的思想，覆盖原来的volatile引用。</li>\n<li><code>CopyOnWriteArraySet</code>：和上面类似，list 变成 set 而已</li>\n</ul>\n<h2 id=\"同步设备\" tabindex=\"-1\"> 同步设备</h2>\n<p>这些类大部分都是帮助做线程之间同步的，简单描述，就像是提供了一个篱笆，线程执行到这个篱笆的时候都得等一等，等到条件满足以后再往后走。</p>\n<p><code>CountDownLatch</code>：一个线程调用 await 方法以后，会阻塞地等待计数器被调用 countDown 直到变成 0，功能上和下面的 CyclicBarrier 有点像</p>\n<p><code>CyclicBarrier</code>：也是计数等待，只不过它是利用 await 方法本身来实现计数器“+1” 的操作，一旦计数器上显示的数字达到 Barrier 可以打破的界限，就会抛出 BrokenBarrierException，线程就可以继续往下执行；请参见我写过的这篇文章 《同步、异步转化和任务执行》中的 Barrier 模式</p>\n<p><code>Semaphore</code>：功能上很简单，acquire() 和 release() 两个方法，一个尝试获取许可，一个释放许可，Semaphore 构造方法提供了传入一个表示该信号量所具备的许可数量。</p>\n<p><code>Exchanger</code>：这个类的实例就像是两列飞驰的火车(线程)之间开了一个神奇的小窗口，通过小窗口(exchange 方法)可以让两列火车安全地交换数据。</p>\n<p><code>Phaser</code>：功能上和第 1、2 个差不多，但是可以重用，且更加灵活，稍微有点复杂(CountDownLatch 是不断-1，CyclicBarrier 是不断+1，而 Phaser 定义了两个概念，phase 和 party)，我在下面画了张图，希望能够帮助理解：</p>\n<p>一个是 phase，表示当前在哪一个阶段，每碰到一次 barrier 就会触发 advance 操作(触发前调用 onAdvance 方法)，一旦越过这道 barrier 就会触发 phase+1，这很容易理解； 另一个是 party，很多文章说它就是线程数，但是其实这并不准确，它更像一个用于判断 advance 是否被允许发生的计数器： 任何时候都有一个 party 的总数，即注册(registered)的 party 数，它可以在 Phaser 构造器里指定，也可以任意时刻调用方法动态增减； 每一个 party 都有 unarrived 和 arrived 两种状态，可以通过调用 arriveXXX 方法使得它从 unarrived 变成 arrived； 每一个线程到达 barrier 后会等待(调用 arriveAndAwaitAdvance 方法)，一旦所有 party 都到达(即 arrived 的 party 数量等于 registered 的数量)，就会触发 advance 操作，同时 barrier 被打破，线程继续向下执行，party 重新变为 unarrived 状态，重新等待所有 party 的到达； 在绝大多数情况下一个线程就只负责操控一个 party 的到达，因此很多文章说 party 指的就是线程，但是这是不准确的，因为一个线程完全可以操控多个 party，只要它执行多次的 arrive 方法。</p>\n<h2 id=\"原子对象\" tabindex=\"-1\"> 原子对象</h2>\n<p>这些对象都的行为在不使用同步的情况下保证了原子性。值得一提的有两点：</p>\n<p>weakCompareAndSet 方法：compareAndSet 方法很明确，但是这个是啥？根据 JSR 规范，调用 weakCompareAndSet 时并不能保证 happen-before 的一致性，因此允许存在重排序指令等等虚拟机优化导致这个操作失败(较弱的原子更新操作)，但是从 Java 源代码看，它的实现其实和 compareAndSet 是一模一样的；</p>\n<p>lazySet 方法：延时设置变量值，这个等价于 set 方法，但是由于字段是 volatile 类型的，因此次字段的修改会比普通字段(非 volatile 字段)有稍微的性能损耗，所以如果不需要立即读取设置的新值，那么此方法就很有用。</p>\n<ul>\n<li><code>AtomicBoolean</code></li>\n<li><code>AtomicInteger</code></li>\n<li><code>AtomicIntegerArray</code></li>\n<li><code>AtomicIntegerFieldUpdater</code></li>\n<li><code>AtomicLong</code></li>\n<li><code>AtomicLongArray</code></li>\n<li><code>AtomicLongFieldUpdater</code></li>\n<li><code>AtomicMarkableReference</code>，它是用来高效表述 Object-boolean 这样的对象标志位数据结构的，一个对象引用+一个 bit 标志位</li>\n<li><code>AtomicReference</code></li>\n<li><code>AtomicReferenceArray</code></li>\n<li><code>AtomicReferenceFieldUpdater</code></li>\n<li><code>AtomicStampedReference</code>，它和前面的 AtomicMarkableReference 类似，但是它是用来高效表述 Object-int 这样的“ 对象+版本号” 数据结构，特别用于解决 ABA 问题(ABA 问题这篇文章里面也有介绍)</li>\n</ul>\n<h2 id=\"锁\" tabindex=\"-1\"> 锁</h2>\n<p>AbstractOwnableSynchronizer，这三个 AbstractXXXSynchronizer 都是为了创建锁和相关的同步器而提供的基础，锁，还有前面提到的同步设备都借用了它们的实现逻辑</p>\n<p>AbstractQueuedLongSynchronizer，AbstractOwnableSynchronizer 的子类，所有的同步状态都是用 long 变量来维护的，而不是 int，在需要 64 位的属性来表示状态的时候会很有用</p>\n<p>AbstractQueuedSynchronizer，为实现依赖于先进先出队列的阻塞锁和相关同步器(信号量、事件等等)提供的一个框架，它依靠 int 值来表示状态</p>\n<p>Lock，Lock 比 synchronized 关键字更灵活，而且在吞吐量大的时候效率更高，根据 JSR-133 的定义，它 happens-before 的语义和 synchronized 关键字效果是一模一样的，它唯一的缺点似乎是缺乏了从 lock 到 finally 块中 unlock 这样容易遗漏的固定使用搭配的约束，除了 lock 和 unlock 方法以外，还有这样两个值得注意的方法：</p>\n<p>lockInterruptibly：如果当前线程没有被中断，就获取锁；否则抛出 InterruptedException，并且清除中断</p>\n<p>tryLock，只在锁空闲的时候才获取这个锁，否则返回 false，所以它不会 block 代码的执行</p>\n<p>ReadWriteLock，读写锁，读写分开，读锁是共享锁，写锁是独占锁；对于读-写都要保证严格的实时性和同步性的情况，并且读频率远远大过写，使用读写锁会比普通互斥锁有更好的性能。</p>\n<p>ReentrantLock，可重入锁(lock 行为可以嵌套，但是需要和 unlock 行为一一对应)，有几点需要注意：</p>\n<p>构造器支持传入一个表示是否是公平锁的 boolean 参数，公平锁保证一个阻塞的线程最终能够获得锁，因为是有序的，所以总是可以按照请求的顺序获得锁；不公平锁意味着后请求锁的线程可能在其前面排列的休眠线程恢复前拿到锁，这样就有可能提高并发的性能</p>\n<p>还提供了一些监视锁状态的方法，比如 <code>isFair</code>、<code>isLocked</code>、<code>hasWaiters</code>、<code>getQueueLength</code> 等等</p>\n<p><code>ReentrantReadWriteLock</code>，可重入读写锁</p>\n<p><code>Condition</code>，使用锁的 newCondition 方法可以返回一个该锁的 Condition 对象，如果说锁对象是取代和增强了 synchronized 关键字的功能的话，那么 Condition 则是对象 wait/notify/notifyAll 方法的替代。在下面这个例子中，lock 生成了两个 condition，一个表示不满，一个表示不空：</p>\n",
      "date_published": "2022-04-14T03:34:13.000Z",
      "date_modified": "2022-05-19T10:22:17.000Z",
      "authors": [],
      "tags": [
        "锁机制"
      ]
    },
    {
      "title": "死锁概念",
      "url": "http://www.zhangsj.xyz/blog/java/concurrent/implement-a-deadlock-program-using-java.html",
      "id": "http://www.zhangsj.xyz/blog/java/concurrent/implement-a-deadlock-program-using-java.html",
      "content_html": "<p>死锁:在java语言中,死锁是指在两个或者两个以上的线程执行的过程中,因争夺资源而产生的一种互相等待的现象</p>\n<p>产生死锁的四个条件（互斥、请求与保持、不剥夺、循环等待）</p>\n<p>同步锁使用的弊端：当线程任务中出现了多个同步(多个锁)时，如果同步中嵌套了其他的同步。这时容易引发一种现象：程序出现无限等待，这种现象我们称为死锁。这种情况能避免就避免掉。</p>\n<div><pre><code><span>class</span> <span>T</span> <span>{</span>\n    <span>synchronzied</span><span>(</span><span>A</span>锁<span>)</span> <span>{</span>\n        undefined\n        <span>synchronized</span> <span>(</span><span>B</span>锁<span>)</span> <span>{</span>\n            undefined\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>我们进行下死锁情况的代码演示：</p>\n<p>定义锁对象类</p>\n<div><pre><code><span>public</span> <span>class</span> <span>MyLock</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>Object</span> lockA <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>\n    <span>public</span> <span>static</span> <span>final</span> <span>Object</span> lockB <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>线程任务类</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ThreadTask</span> <span>implements</span> <span>Runnable</span> <span>{</span>\n    <span>int</span> x <span>=</span> <span>new</span> <span>Random</span><span>(</span><span>)</span><span>.</span><span>nextInt</span><span>(</span><span>1</span><span>)</span><span>;</span><span>//0,1</span>\n<span>//指定线程要执行的任务代码</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n        <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>x <span>%</span> <span>2</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>\n                <span>//情况一</span>\n                <span>synchronized</span> <span>(</span><span>MyLock</span><span>.</span>lockA<span>)</span> <span>{</span>\n                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"if-LockA\"</span><span>)</span><span>;</span>\n                    <span>synchronized</span> <span>(</span><span>MyLock</span><span>.</span>lockB<span>)</span> <span>{</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"if-LockB\"</span><span>)</span><span>;</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"if大口吃肉\"</span><span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                <span>//情况二</span>\n                <span>synchronized</span> <span>(</span><span>MyLock</span><span>.</span>lockB<span>)</span> <span>{</span>\n                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"else-LockB\"</span><span>)</span><span>;</span>\n                    <span>synchronized</span> <span>(</span><span>MyLock</span><span>.</span>lockA<span>)</span> <span>{</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"else-LockA\"</span><span>)</span><span>;</span>\n                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"else大口吃肉\"</span><span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span>\n            <span>}</span>\n            x<span>++</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>测试类</p>\n<div><pre><code><span>public</span> <span>class</span> <span>ThreadDemo</span> <span>{</span>\n    <span>// undefined</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>// undefined</span>\n        <span>//创建线程任务类对象</span>\n        <span>ThreadTask</span> task <span>=</span> <span>new</span> <span>ThreadTask</span><span>(</span><span>)</span><span>;</span>\n        <span>//创建两个线程</span>\n        <span>Thread</span> t1 <span>=</span> <span>new</span> <span>Thread</span><span>(</span>task<span>)</span><span>;</span>\n        <span>Thread</span> t2 <span>=</span> <span>new</span> <span>Thread</span><span>(</span>task<span>)</span><span>;</span>\n        <span>//启动线程</span>\n        t1<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        t2<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>解决死锁问题的方法是：一种是用<code>synchronized</code>，一种是用<code>Lock</code>显式锁实现。</p>\n<p>而如果不恰当的使用了锁，且出现同时要锁多个对象时，会出现死锁情况</p>\n",
      "date_published": "2022-04-14T03:34:13.000Z",
      "date_modified": "2022-04-14T05:48:05.000Z",
      "authors": [],
      "tags": [
        "锁机制"
      ]
    },
    {
      "title": "Java面试通关秘籍汇总集！",
      "url": "http://www.zhangsj.xyz/blog/java/concurrent/interview-preparation.html",
      "id": "http://www.zhangsj.xyz/blog/java/concurrent/interview-preparation.html",
      "content_html": "<h2 id=\"java基础\" tabindex=\"-1\"> Java基础</h2>\n<h3 id=\"重载和重写的区别\" tabindex=\"-1\"> 重载和重写的区别</h3>\n<p>重载 override</p>\n<h2 id=\"网络-io基础\" tabindex=\"-1\"> 网络/IO基础</h2>\n<h3 id=\"bio、nio、aio的概念\" tabindex=\"-1\"> BIO、NIO、AIO的概念</h3>\n<p>BIO 其实就是IO，文件读写，scoket通信，都是io操作</p>\n<p>BIO又被称为阻塞式I/O模型，那为什么会被叫做这个名字呢，原因就是BIO的特性是同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，处理完成后返回应答给客户端，也就是经典的请求－应答通信模型。但是随着客户端并发量上升，服务端的线程数膨胀，系统性能急剧下降，最终会导致系统不可用。这种模型无法满足高并发，高性能的场景。</p>\n<p>它的具体通信流程为：</p>\n<p>（1）服务器监听</p>\n<p>服务器监听：是服务端scoket并不定位具体的客户端scoket，而是处于等待连接的状态，实时监控网络的状态</p>\n<p>（2）客户端请求服务器</p>\n<p>客户端请求：是指由客户端的scoket提出连接请求，要连接的目标是服务器端的scoket。为此，客户端的scoket必须首先描述它要连接的服务器的scoket，指出服务器scoket的地址和端口号，然后就想服务器端scoket提出连接请求</p>\n<p>说说 SQL 优化之道</p>\n<p>void use select *</p>\n<p>很多时候，我们写sql时，直接使用select * ，一次性查处表中所有列的数据。</p>\n<p>内存或者CPUss</p>\n<p>网络io传输的过程中，也会增加数据传输的时间。</p>\n<p>不会走覆盖索引，会出现大量的回表操作，</p>\n<p>用union all 代替union</p>\n<p>小标驱动大表</p>\n<h2 id=\"缓冲区-buffer\" tabindex=\"-1\"> 缓冲区（buffer）</h2>\n<p>buffer是一个对象，是所有IO的基础，IO讲的无非就是把数据移入和移出缓冲区；进程执行IO操作时，读的时候，往缓冲区放数据，写的时候，让系统去缓冲区里头拿数据，</p>\n<p>进程发起读请求后，内核接收到这个读请求后，会先检查内核空间里是否有存在的进程所有的数据，如果存在，就直接把该数据放入进程的缓冲区里，要是没有，内核让磁盘去读取数据，然后写入到内核读缓冲区，</p>\n<p>要是进程发起写请求，把用户缓冲区里头的数据放到内核socket缓冲区；再通过DMA把数据赋给网卡，发送出去；</p>\n<p>每次咱们都要把内核空间里的数据写到用户空间，</p>\n<h2 id=\"虚拟内存\" tabindex=\"-1\"> 虚拟内存</h2>\n<p>现在的操作系统都用虚拟地址代替物理地址，这样的好处：</p>\n<p>一是一个以上的虚拟地址能指向</p>\n<p>在面向流的IO中，可以将数据直接写入或读取到Stream中。在NIO库中，所有的数据都是用缓冲区处理的（读写）。缓冲区实质上是一个数组，通常它是一个字节数组（ByteBuffer)，这个字节输出同时存储输入及输出数据，当然也可以使用其他类型的数组，这个数组为缓冲区提供了数据的访问读写等操作属性，如位置，容量，上限等概念。</p>\n<p>Buffer类型：我们最常用的ByteBuffer，实际上每一种Java基本类型都对应了一种缓冲区（除了BOOlean类型）</p>\n<h3 id=\"通道-channel\" tabindex=\"-1\"> 通道（Channel）</h3>\n<p>通道（Channel），也被称为管道，它就像自来水管道一样，网络数据通过Channel读取和写入，通道与流不同之处在于通道是双向的，而流只是一个方向上向移动（一个流必须是inputStream或者outputStream的子类），而通道可以用于读，写或者二者同时进行，最关键的是可以与多路复用器结合起来，有多钟的状态位，方便多路复用器去识别，以此执行不同的handler。</p>\n<p>事实上通道分为两大类，一类是网络读写的（SelectableChannel),一类是用于文件操作的（FileChannel），我们通常使用的Socket和ServerSockerChannel都是SelectableChannel的子类。</p>\n<h3 id=\"多路复用器-selector\" tabindex=\"-1\"> 多路复用器（selector）</h3>\n<p>多路复用器，它是NIO编程的基础，非常重要，多路复用器提供选择已经就绪的任务的能力。</p>\n<p>意思就是Selector会不断的轮询注册在其上的通道，如果每个通道发生了读写操作，这个通道就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以取得就绪的Channel集合。从而进行后续的IO操作。</p>\n<p>总结起来，selector线程就类似于一个管理者，管理了成千上万个管道，然后轮询哪个管道的数据已经准备好，通知CPU执行IO的读取或写入操作。</p>\n<p>Selector模式：当IO事件注册到选择器以后，selector会分配给每个通道一个key值，相当于标签。selector选择器是以轮询的方式进行查找注册的所有通道。</p>\n<p>当我们的IO事件（通道）准备就绪后，selector就会识别，会通过Key值来找到相应的管道，进行相关的数据处理操作（从通道读或写数据，写入我们的数据缓冲区中）。</p>\n<p>一个多路复用器（selector）可以负责成千上万个Channel，效率比起BIO大大的提升了，由于JDK使用了epoll代替传统的select实现，所以没有最大连接句柄1024/2048的限制，这也意味着我们只要一个线程负责selector的轮询，就可以接入成千上万个客户端，这是JDK，NIO库的巨大进步。</p>\n<p>但是NIO也有自己的缺点，NIO会等数据准备好后，再交由应用进行处理，数据的读取写入过程依然在应用线程中完成，只是将等待的时间剖离到单独的线程中去，节省了数据准备时间，因为多路复用机制，channel会得到复用，对于那些读写过程时间长的，NIO就不打适合。</p>\n<p>但是，我们需要注意，虽然说NIO是非阻塞的，但是，selector中的selector.select()，是阻塞的，所以，你是不是有什么有趣的想法呢？例如，把selector这个线程，也是用线程池来分配。</p>\n<p>分布式系统消息系统的对比：</p>\n<h2 id=\"二、kafka基本架构\" tabindex=\"-1\"> 二、Kafka基本架构</h2>\n<p>它的架构包括以下组件：</p>\n<p>1、话题（Topic）：是特定类型的消息流。消息是字节的有效负载（Payload），话题是消息的分</p>\n",
      "date_published": "2022-04-14T03:34:13.000Z",
      "date_modified": "2022-05-24T07:41:09.000Z",
      "authors": [],
      "tags": [
        "面经"
      ]
    },
    {
      "title": "乐观锁&悲观锁",
      "url": "http://www.zhangsj.xyz/blog/java/concurrent/optimistic-locking-and-pessimistic-locking.html",
      "id": "http://www.zhangsj.xyz/blog/java/concurrent/optimistic-locking-and-pessimistic-locking.html",
      "content_html": "<h2 id=\"乐观锁\" tabindex=\"-1\"> 乐观锁</h2>\n<p>1、版本号机制</p>\n<p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据只是，在读取数据同时也会读取version值，如果version值不一致，则说明数据被修改过，线程A就不能更新数据。</p>\n<p><code>Update ex_order set status =2 where ID =1 and status = 1</code></p>\n<p>并判断返回影响行数，如果影响行数不符合预期则抛异常让数据库回滚已经执行的 sql 语句。</p>\n<p>举一个简单的例子：</p>\n<p>假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。</p>\n<ol>\n<li>操作员A此时将其读出（version=1），并从其帐户余额中扣除$50（$100-$50）。</li>\n<li>在操作员A操作的过程中，操作员B也读入此用户信息（version=1），并从其帐户余额中扣除$20（$100-$20）。</li>\n<li>操作员A完成了修改工作，将数据版本号加一（version=2），连同帐户扣除后余额（balance=$50），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录version更新为2。</li>\n<li>操作员B完成了操作，也将版本号加一（version=2）试图向数据库提交数据（balance=$80），但此时比对数据库记录版本时发现，操作员B提交的数据版本号为2，数据库记录当前版本也为2，不满足“提交版本必须大于记录当前版本才能执行更新“的乐观锁策略，因此，操作员B的提交被驳回。</li>\n</ol>\n<p>优点：这种方案本质上是乐观锁的处理方案，适合读多写少的场景，可以根据更新语句返回的数据判断，做合适的业务处理，比如重试，抛异常等；</p>\n<p>缺点：如果没有预期状态 status 值则无法完成这种操作，必须新增真正的乐观锁字段 version，如果需要回滚的业务操作太多，则会加大数据库压力。</p>\n<p>2、CAS算法</p>\n<p>即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数</p>\n<ul>\n<li>需要读写的内存值 V</li>\n<li>进行比较的值 A</li>\n<li>拟写入的新值 B</li>\n</ul>\n<p>当且仅当V的值等于A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</p>\n<p>乐观锁的缺点：</p>\n<p>若线程A第一次读取的值为A，线程T1准备对A执行写操作，但这段时间，线程T2完成了A到B到A的更改，当线程A准备写时，A已经不是原来的A了； ABA 问题是乐观锁一个常见的问题</p>\n<p>1、ABA 问题</p>\n<p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 &quot;ABA&quot;问题。</p>\n<p>JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>\n<p>2、循环时间长开销大</p>\n<p>自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p>\n<p>3、只能保证一个共享变量的原子操作</p>\n<p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 <code>CAS</code> 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。</p>\n<h2 id=\"悲观锁方案\" tabindex=\"-1\"> 悲观锁方案</h2>\n<p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。</p>\n<div><pre><code><span>select</span> <span>.</span><span>.</span><span>.</span> <span>for</span> <span>update</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br></div></div><p>悲观锁方案 update</p>\n<p>先根据订单 ID 和预期状态更新订单，再判断影响行数是否等于预期行数，如果符合预期，则根据订单 ID 和登记信息生成异常登记记录并插入记录表 B。</p>\n<p>优点： 这种方案本质上是悲观锁的处理方案，适合读少写多的场景，当一个事务执行update的操作的时候，会在这行记录上加锁，阻塞其他事务的update操作；</p>\n<p>缺点： 如果订单表不止更新状态字段，且其他字段的更新需要额外的计算，且异常登记记录表也需要其他额外字段，这种方案就没法做了。</p>\n<p>一开始就对订单加上锁，查询订单表 A 并加锁，在根据查询返回的字段进行逻辑计算，并生成异常登记记录，然后插入数据，最后更新订单状态。因为这时候不会有别其他事务更新这条商品库存。</p>\n<p>这种本质上也是悲观锁方案，适用于更新操作时需要复杂的逻辑计算。</p>\n<h2 id=\"接口幂等性的解决方案\" tabindex=\"-1\"> 接口幂等性的解决方案</h2>\n<p>当然，在接口设计中我们要考虑很多问题，安全性，格式，设计等等，今天我们先来聊聊，在高并发环境下，接口幂等性的解决方案有哪些。</p>\n<h3 id=\"概念\" tabindex=\"-1\"> 概念</h3>\n<p>就是说在多次相同的操作下保证最终的结果是一致的。</p>\n<p>其实这个概念还是比较简单的，很容易理解，那我们思考一个问题，如果不保证接口幂等性会有什么问题？</p>\n<p>我们简单的举个例子，现在有一个接口，提供了转账的功能，a要给b转账1000元，正常情况下我们接口一次性就调用成功了，但是却因为网络抖动等其它原因没有成功，于是就开始不停的重试，突然网络好了，但是这时却连续发出去了三个请求，但是这个接口没有保证幂等性，于是从结果上来看就是a给b转了3000元，这显然是程序业务逻辑上不能接受的。</p>\n<h3 id=\"_2-1-token机制\" tabindex=\"-1\"> 2.1 token机制</h3>\n<p>首先客户端先请求服务端，服务端生成token，每次请求生成的都是一个新的token(这个token一定要设置超时时间)，将token存入redis当中，然后将token返回给客户端。</p>\n<p>客户端携带刚刚返回的token请求服务端做业务请求。</p>\n<p>服务端收到请求，做判断。</p>\n<ul>\n<li>如果<code>token</code>在<code>redis</code>中，则直接删除该token，然后继续做业务请求。</li>\n<li>如果<code>token</code>不在<code>redis</code>中，代表已经执行过当前业务了，则不执行业务。</li>\n</ul>\n<p>图示如下：</p>\n<p><img src=\"@source/java/concurrent/assets/optimistic-locking-and-pessimistic-locking-1650785569325.png\" alt=\"幂等解决方案-token机制\" loading=\"lazy\"></p>\n<p>token机制实现方式还是比较简单的，但是其实对于我们某些响应速度要求很高的业务不太友好，缺点就是需要多一次请求获取token的过程。\n正常来说是每次请都会生成一个新的token，如果有极限情况下，有两个请求都带着相同的token进来，会存在都走入判断是否存在的过程，可能都会同时查到存在，这样也会有问题，针对这种情况，<strong>我们可以在删除前判断下是否存在，存在就删除，为了保证原子性，这部分逻辑建议使用lua脚本完成</strong>。</p>\n<h3 id=\"_2-2-去重表\" tabindex=\"-1\"> 2.2 去重表</h3>\n<p>去重表的机制是根据mysql唯一索引的特性来的，我们先来说下它的流程：</p>\n<p>首先客户端先请求服务端，服务端先将这次的请求信息存入一张mysql的去重表中，这张表要根据这次请求的其中某个特殊字段建立唯一索引，或者主键索引。</p>\n<p>判断是否插入成功</p>\n<ul>\n<li>如果插入成功，则继续做后续业务请求。</li>\n<li>如果插入失败，则代表已经执行过当前请求。</li>\n</ul>\n<p>图示如下：</p>\n<p><img src=\"@source/java/concurrent/assets/optimistic-locking-and-pessimistic-locking-1650785700785.png\" alt=\"幂等解决方案-去重表机制\" loading=\"lazy\"></p>\n<p>去重表机制的问题有两点：</p>\n<ol>\n<li>mysql容错性，也就是mysql本身如果不是高可用的那么业务可能会受到影响：</li>\n<li>既然是唯一索引，自然在写表的时候就没有办法用到<code>changbuffer</code>，每次都要从磁盘查出来判断再写入，对于一个高并发的接口来说，这些都是需要考虑的因素。</li>\n</ol>\n<h3 id=\"_2-3-redis-的-setnx键值\" tabindex=\"-1\"> 2.3 redis 的 SETNX键值</h3>\n<p>过程如下：</p>\n<ol>\n<li>首先客户端先请求服务端，服务端将能代表这次请求业务的唯一字段以 SETNX 的方式存入redis，并设置超时时间，超时时间可以根据业务权衡。</li>\n<li>判断是否插入成功</li>\n</ol>\n<ul>\n<li>如果插入成功，则继续做后续业务请求。</li>\n<li>如果插入失败，则代表已经执行过当前请求。\n这里我们是利用了redis setnx 的特性来完成的。</li>\n</ul>\n<p>setnx:只在键key不存在的情况下，将键key的值设置为value。若键key已经存在，则SETNX命令不做任何动作。命令在设置成功时返回1，设置失败时返回0。</p>\n<p><img src=\"@source/java/concurrent/assets/optimistic-locking-and-pessimistic-locking-1650785861023.png\" alt=\"幂等解决方案-setnx机制\" loading=\"lazy\"></p>\n<p>这种方案可以说是针对上一个方案改进的，效率也会提高很多。</p>\n<h3 id=\"_2-4-状态机幂\" tabindex=\"-1\"> 2.4 状态机幂</h3>\n<p>这种机制适用于有不同状态的业务，moon的上一家公司就是这样做的。\n我们的订单系统，一条订单会有多个状态，如：待付款，锁定，已付款等状态，而这些状态都是有流程和逻辑的，我们可以根据这个状态判断是否执行后续业务操作。</p>\n<h3 id=\"_2-5-乐观锁-更新操作\" tabindex=\"-1\"> 2.5 乐观锁(更新操作)</h3>\n<p>就是数据库中增加版本号字段，每次更新根据版本号来判断</p>\n<p>过程如下：</p>\n<ol>\n<li>首先客户端先请求服务端，先查询出当前的version版本。 <code>select version from .. where ..</code></li>\n<li>根据version版本来做sql操作 <code>UPDATE .. SET ... version=(version+1) WHERE .. AND version=version;</code></li>\n</ol>\n<p>这个图示我就不再画了，还是比较简单的</p>\n<h3 id=\"_2-6-悲观锁-更新操作\" tabindex=\"-1\"> 2.6 悲观锁(更新操作)</h3>\n<p>假设每一次拿数据，都有认为会被修改，所以给数据库的行上锁，也是基于数据库特性来完成。</p>\n<p>当数据库执行select for update时会获取被select中的数据行的行锁，因此其他并发执行的select for update如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。</p>\n<div><pre><code><span>START</span> <span>TRANSACTION</span><span>;</span> <span># 开启事务</span>\nSELETE <span>*</span> <span>FROM</span> <span>TABLE</span> <span>WHERE</span> <span>.</span><span>.</span> <span>FOR</span> <span>UPDATE</span><span>;</span>\n<span>UPDATE</span> <span>TABLE</span> <span>SET</span> <span>.</span><span>.</span><span>.</span> <span>WHERE</span> <span>.</span><span>.</span><span>;</span>\n<span>COMMIT</span><span>;</span> <span># 提交事务</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>结语</p>\n<p>关于接口幂等性这部分内容，解决方案其实大同小异，很多方式的原理都是一样的，更多的其实都是在<strong>业务链路中去过滤</strong>，也会有很多是有<strong>消息中间件</strong>去解决的，默认在中间件这一层就直接过滤掉了，当然每种方式都有各自的优点和缺点，需要结合当前的业务去选择。</p>\n",
      "date_published": "2022-04-14T03:34:13.000Z",
      "date_modified": "2022-04-24T09:56:06.000Z",
      "authors": [],
      "tags": [
        "锁机制"
      ]
    },
    {
      "title": "数据库索引",
      "url": "http://www.zhangsj.xyz/blog/java/datasource/mysql-index.html",
      "id": "http://www.zhangsj.xyz/blog/java/datasource/mysql-index.html",
      "content_html": "<h2 id=\"sql调优\" tabindex=\"-1\"> sql调优</h2>\n<h3 id=\"使用exists代替in\" tabindex=\"-1\"> 使用exists代替in</h3>\n<div><pre><code>\n<span>select</span> name <span>from</span> a <span>where</span> id <span>in</span><span>(</span><span>select</span> id <span>from</span> b<span>)</span>\n\n<span>-- 如果我们将这条语句换成下面的写法：</span>\n\n<span>select</span> name <span>from</span> a <span>where</span> <span>exists</span><span>(</span><span>select</span> <span>1</span> <span>from</span> b <span>where</span> id <span>=</span> a<span>.</span>id<span>)</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"避免在-where-子句中对字段进行函数操作\" tabindex=\"-1\"> 避免在 where 子句中对字段进行函数操作</h3>\n<div><pre><code><span>select</span> id <span>from</span> <span>table</span> <span>where</span> substring<span>(</span>name<span>,</span><span>1</span><span>,</span><span>2</span><span>)</span> <span>=</span> <span>'zs'</span>\n\n<span>--或</span>\n\n<span>select</span> id <span>from</span> <span>table</span> <span>where</span> datediff<span>(</span><span>day</span><span>,</span>datefield<span>,</span><span>'2022-07-17'</span><span>)</span> <span>>=</span> <span>0</span>    \n\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id=\"like-中通配符的使用\" tabindex=\"-1\"> like 中通配符的使用</h3>\n<p>下面的语句会导致全表扫描，尽量少用。如：</p>\n<div><pre><code><span>select</span> id <span>from</span> tabel <span>where</span> name <span>like</span><span>'%zs%'</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br></div></div><h3 id=\"between-and-代替-in-少用-in-或-not-in\" tabindex=\"-1\"> between and 代替 in 少用 in 或 not in</h3>\n<div><pre><code><span>select</span> name <span>from</span> tabel <span>where</span> id <span>in</span><span>(</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>,</span><span>5</span><span>)</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br></div></div><p>像这种连续的数值，我们可以使用 BETWEEN AND，如：</p>\n<div><pre><code><span>select</span> name <span>from</span> tabel <span>where</span> id <span>between</span> <span>1</span> <span>and</span> <span>5</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br></div></div><h3 id=\"避免在-where-子句中使用-or来链接条件\" tabindex=\"-1\"> 避免在 where 子句中使用 or来链接条件</h3>\n<div><pre><code><span>select</span> id <span>from</span> tabel <span>where</span> name <span>=</span> <span>'zs'</span> <span>or</span> name <span>=</span> <span>'PHP'</span>\n\n<span>-- 这种情况，我们可以这样写：</span>\n\n<span>select</span> id <span>from</span> tabel <span>where</span> name <span>=</span> <span>'zs'</span>\n\n<span>union</span> <span>all</span>\n\n<span>select</span> id <span>from</span> tabel <span>where</span> name <span>=</span> <span>'PHP'</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id=\"避免在-where-子句中使用-或-操作符\" tabindex=\"-1\"> 避免在 where 子句中使用 != 或 &lt;&gt; 操作符</h3>\n<p>避免在where子句中使用 is null 或 is not null 对字段进行判断。</p>\n<p>如：</p>\n<div><pre><code><span>select</span> id <span>from</span> <span>table</span> <span>where</span> name <span>is</span> <span>null</span><span>`</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br></div></div><p>在这个查询中，就算我们为 name 字段设置了索引，查询分析器也不会使用，因此查询效率底下。</p>\n<p>为了避免这样的查询，在数据库设计的时候，尽量将可能会出现 null 值的字段设置默认值，这里如果我们将 name 字段的默认值设置为0，那么我们就可以这样查询：</p>\n<div><pre><code><span>select</span> id <span>from</span> <span>table</span> <span>where</span> name <span>=</span> <span>0</span><span>`</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br></div></div><p>索引不存储空值，如果不限制索引列是not null，数据库会认为索引列有可能存在空值，所以不会按照索引进行计算。</p>\n<h3 id=\"最左原则\" tabindex=\"-1\"> 最左原则</h3>\n<p>复合索引中索引列按顺序查询，如果不是按照索引的最左列开始查找，则无法使用索引</p>\n<h3 id=\"覆盖索引\" tabindex=\"-1\"> 覆盖索引</h3>\n<p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p>\n<p>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，\n而无需回表查询。</p>\n<p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。</p>\n<p>再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。</p>\n<h2 id=\"创建索引的注意事项\" tabindex=\"-1\"> 创建索引的注意事项</h2>\n<p>1、选择合适的字段创建索引：</p>\n<ul>\n<li>不为<code>NULL</code>的字段 ：索引字段的数据应该尽量不为<code>NULL</code>，因为对于数据为 <code>NULL</code> 的字段，数据库较难优化。</li>\n<li>如果字段频繁被查询，但又避免不了为 NULL ，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</li>\n<li>被频繁查询的字段 ：我们创建索引的字段应该是查询操作非常频繁的字段。</li>\n<li>被作为条件查询的字段 ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</li>\n<li>频繁需要排序的字段 ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li>\n<li>被经常频繁用于连接的字段 ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</li>\n</ul>\n<p>2、被频繁更新的字段应该慎重建立索引。</p>\n<p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p>\n<p>3、尽可能的考虑建立联合索引而不是单列索引。</p>\n<p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。</p>\n<p>如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p>\n<p>4、注意避免冗余索引 。</p>\n<p>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p>\n<p>5、考虑在字符串类型的字段上使用前缀索引代替普通索引。</p>\n<p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p>\n<p>1.普通索引 添加INDEX</p>\n<div><pre><code><span>ALTER</span> <span>TABLE</span> <span><span>`</span>table_name<span>`</span></span> <span>ADD</span> <span>INDEX</span> index_name <span>(</span> <span><span>`</span>column<span>`</span></span> <span>)</span>\n\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br></div></div><p>下面演示下给user表的name字段添加一个索引</p>\n<p>2.主键索引 添加PRIMARY KEY</p>\n<div><pre><code><span>ALTER</span> <span>TABLE</span> <span><span>`</span>table_name<span>`</span></span> <span>ADD</span> <span>PRIMARY</span> <span>KEY</span> <span>(</span> <span><span>`</span>column<span>`</span></span> <span>)</span>\n\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br></div></div><p>3.唯一索引 添加UNIQUE</p>\n<div><pre><code><span>ALTER</span> <span>TABLE</span> <span><span>`</span>table_name<span>`</span></span> <span>ADD</span> <span>UNIQUE</span> <span>(</span> <span><span>`</span>column<span>`</span></span> <span>)</span>\n\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br></div></div><p>4.全文索引 添加FULLTEXT</p>\n<div><pre><code><span>ALTER</span> <span>TABLE</span> <span><span>`</span>table_name<span>`</span></span> <span>ADD</span> FULLTEXT <span>(</span> <span><span>`</span>column<span>`</span></span><span>)</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br></div></div><p>5.如何添加多列索引</p>\n<div><pre><code><span>ALTER</span> <span>TABLE</span> <span><span>`</span>table_name<span>`</span></span> <span>ADD</span> <span>INDEX</span> index_name <span>(</span> <span><span>`</span>column1<span>`</span></span><span>,</span> <span><span>`</span>column2<span>`</span></span><span>,</span> <span><span>`</span>column3<span>`</span></span> <span>)</span>\n\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br></div></div>",
      "date_published": "2022-03-18T00:00:00.000Z",
      "date_modified": "2022-04-14T05:48:05.000Z",
      "authors": [],
      "tags": [
        "mysql"
      ]
    },
    {
      "title": "说说分库与分表设计",
      "url": "http://www.zhangsj.xyz/blog/java/datasource/mysql-master-slave-replication.html",
      "id": "http://www.zhangsj.xyz/blog/java/datasource/mysql-master-slave-replication.html",
      "content_html": "<h2 id=\"mysql主从复制\" tabindex=\"-1\"> mysql主从复制</h2>\n<p>MySQL主从复制是一个异步的复制过程，底层是基于数据库自带的二进制日志功能。就是一台或多台MySQL数据库（slave，即从库）从另一台MySQL数据库（</p>\n<ul>\n<li>master将改变纪录到二进制日志（binary log)</li>\n<li>slave将master的binary log拷贝到它的中继日志（relay log）</li>\n<li>slave重做中继日志中的事件，将改变应用到自己的数据库中。</li>\n</ul>\n<p>搭建，实现主从同步。 (两阶段提交)</p>\n<p>配置-前置条件</p>\n<p>提前准备好两台服务器，分别安装MySQL并启动服务成功。</p>\n<ul>\n<li>主库（master） 192.168.138.100</li>\n<li>从库（slave） 192.168.138.101</li>\n</ul>\n",
      "date_published": "2022-04-14T03:34:13.000Z",
      "date_modified": "2022-04-14T05:48:05.000Z",
      "authors": [],
      "tags": [
        "数据库"
      ]
    },
    {
      "title": "二十三种设计模式",
      "url": "http://www.zhangsj.xyz/blog/java/datasource/nine-classic-design-patterns-in-mybatis.html",
      "id": "http://www.zhangsj.xyz/blog/java/datasource/nine-classic-design-patterns-in-mybatis.html",
      "content_html": "<h1 id=\"二十三种设计模式\" tabindex=\"-1\"> 二十三种设计模式</h1>\n<p>虽然我们都知道有二十三种设计模式，但是大多停留在概念层面，真实开发中很少遇到。mybatis源码中使用了大量的设计模式，阅读源码并观察设计模式在其中的应用，能够更深入的理解设计模式。</p>\n<ol>\n<li>Builder模式，例如SqlSessionFactoryBuilder、XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder、CacheBuilder；</li>\n<li>工厂模式，例如SqlSessionFactory、ObjectFactory、MapperProxyFactory；</li>\n<li>单例模式，例如ErrorContext和LogFactory；</li>\n<li>代理模式，Mybatis实现的核心，比如MapperProxy、ConnectionLogger，用的jdk的动态代理；还有executor.loader包使用了cglib或者javassist达到延迟加载的效果；</li>\n<li>组合模式，例如SqlNode和各个子类<code>ChooseSqlNode</code>等；</li>\n<li>模板方法模式，例如BaseExecutor和SimpleExecutor，还有<code>BaseTypeHandler</code>和所有的子类例如<code>IntegerTypeHandler</code>；</li>\n<li>装饰者模式，例如Cache包中的<code>cache.decorators</code>子包中等各个装饰者的实现；</li>\n<li>迭代器模式，例如迭代器模式<code>PropertyTokenizer</code>；</li>\n</ol>\n<p><a href=\"https://blog.csdn.net/androidstarjack/article/details/121133873\" target=\"_blank\" rel=\"noopener noreferrer\">面试必问：Mybatis中9种经典的设计模式！你知道几个？</a></p>\n",
      "date_published": "2022-04-14T03:34:13.000Z",
      "date_modified": "2022-04-14T03:34:13.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "设计模式遵循的一些原则",
      "url": "http://www.zhangsj.xyz/blog/java/design-patterns/six-principles-of-design-patterns.html",
      "id": "http://www.zhangsj.xyz/blog/java/design-patterns/six-principles-of-design-patterns.html",
      "content_html": "<h2 id=\"一、开发原则\" tabindex=\"-1\"> 一、开发原则</h2>\n<ul>\n<li>S：单一职责SRP</li>\n<li>O：开放封闭原则OCP</li>\n<li>L：里氏替换原则LSP</li>\n<li>I：接口隔离法则</li>\n<li>D：依赖倒置原则DIP</li>\n</ul>\n<p>合成/聚合复用原则</p>\n<p>迪米特法则</p>\n<p>在软件开发中，前人对软件系统的设计和开发总结了一些原则和模式，不管用什么语言做开发，都将对我们系统设计和开发提供指导意义。本文主要将总结这些常见的原则和具体阐述意义。</p>\n<p>面向对象的基本原则(solid)是五个，但是在经常被提到的除了这五个之外还有迪米特法则和合成复用原则等，所以在常见的文章中有表示写六大或七大原则的； 除此之外我还将给出一些其它相关书籍和互联网上出现的原则；</p>\n<h2 id=\"二、单一职责原则\" tabindex=\"-1\"> 二、单一职责原则</h2>\n<p>Single-Responsibility Principle，一个类，最好只做一件事，只有一个引起它的变化的原因。单一职责原则可以看做是低耦合、高内聚在面向对象原则的引申，将职责定义为引起变化的原因，以提高内聚性减少引起变化的原因。</p>\n<p>1、定义</p>\n<p>一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。即定义有且仅有一个原因使类变更。</p>\n<p>2、原则分析</p>\n<p>一个类或者大到模块，小到方法，承担的职责越多，它被复用的可能性越小，而且如果一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作。</p>\n<p>类的职责主要包括两个方面：数据职责和行为职责，数据职责通过其属性来体现，而行为职责通过其方法来体现。</p>\n<p>单一职责原则是实现高内聚、低耦合的指导方针，在很多代码重构手法中都能找到它的存在，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。</p>\n<p>3、优点</p>\n<p>降低类的复杂性，类的职责清晰明确。比如数据职责和行为职责清晰明确；</p>\n<p>提高类的可读性和维护性；</p>\n<p>变更引起的风险减低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的类有影响，对其他接口无影响，这对系统的扩展性、维护性都有非常大的帮助。</p>\n<p>注意：单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否合理，但是“职责”和“变化原因”都是没有具体标准的，一个类到底要负责那些职责？这些职责怎么细化？细化后是否都要有一个接口或类？这些都需从实际的情况考虑。因项目而异，因环境而异。</p>\n<p>4、例子</p>\n<p>SpringMVC中Entity、DAO、Service、Controller、Util等的分离。（设计模式的核心原则）</p>\n<h2 id=\"三、开闭原则\" tabindex=\"-1\"> 三、开闭原则</h2>\n<p>定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p>\n<p>1、定义</p>\n<p>一个软件实体(如类、模块和函数)应该对扩展开放，对修改关闭。意思是在一个系统或者模块中，对于扩展是开放的，对于修改是关闭的。一个 好的系统是在不修改源代码的情况下，可以扩展你的功能。而实现开闭原则的关键就是抽象化。</p>\n<p>2、原则分析</p>\n<p>当软件实体因需求要变化时, 尽量通过扩展已有软件实体，可以提供新的行为，以满足对软件的新的需求，而不是修改已有的代码，使变化中的软件有一定的适应性和灵活性 。已有软件模块，特别是最重要的抽象层模块不能再修改，这使变化中的软件系统有一定的稳定性和延续性。</p>\n<p>实现开闭原则的关键就是抽象化，在&quot;开-闭&quot;原则中，不允许修改的是抽象的类或者接口，允许扩展的是具体的实现类，抽象类和接口在&quot;开-闭&quot;原则中扮演着极其重要的角色，即要预知可能变化的需求.又预见所有可能已知的扩展，所以在这里&quot;抽象化&quot;是关键!</p>\n<p>可变性的封闭原则：找到系统的可变因素，将它封装起来。这是对&quot;开-闭&quot;原则最好的实现。不要把你的可变因素放在多个类中，或者散落在程序的各个角落。你应该将可变的因素，封套起来..并且切忌不要把所用的可变因素封套在一起。最好的解决办法是，分块封套你的可变因素！避免超大类、超长类、超长方法的出现!!给你的程序增加艺术气息，将程序艺术化是我们的目标！</p>\n<p>3、例子</p>\n<p>设计模式中模板方法模式和观察者模式都是开闭原则的极好体现。</p>\n<h2 id=\"四、里氏替换原则\" tabindex=\"-1\"> 四、里氏替换原则</h2>\n<p>Liskov Substitution Principle，LSP：任何基类可以出现的地方，子类也可以出现；这一思想表现为对继承机制的约束规范，只有子类能够替换其基类时，才能够保证系统在运行期内识别子类，这是保证继承复用的基础。</p>\n<p>1、定义</p>\n<p>第一种定义方式相对严格：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有变化，那么类型S是类型T的子类型。</p>\n<p>第二种更容易理解的定义方式：所有引用基类（父类）的地方必须能透明地使用其子类的对象。即子类能够必须能够替换基类能够从出现的地方。子类也能在基类 的基础上新增行为。</p>\n<p>里氏代换原则由2008年图灵奖得主、美国第一位计算机科学女博士、麻省理工学院教授BarbaraLiskov和卡内基.梅隆大学Jeannette Wing教授于1994年提出。其原文如下：Let q(x) be a property provableabout objects x of type T. Then q(y) should be true for objects y of type Swhere S is a subtype of T.</p>\n<p>2、原则分析</p>\n<p>讲的是基类和子类的关系，只有这种关系存在时，里氏代换原则才存在。正方形是长方形是理解里氏代换原则的经典例子。</p>\n<p>里氏代换原则可以通俗表述为：在软件中如果能够使用基类对象，那么一定能够使用其子类对象。把基类都替换成它的子类，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类的话，那么它不一定能够使用基类。</p>\n<p>里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p>\n<h2 id=\"五、接口隔离法则\" tabindex=\"-1\"> 五、接口隔离法则</h2>\n<p>(Interface Segregation Principle，ISL）：客户端不应该依赖那些它不需要的接口。（这个法则与迪米特法则是相通的）</p>\n<p>1、定义</p>\n<p>客户端不应该依赖那些它不需要的接口。</p>\n<p>另一种定义方法：一旦一个接口太大，则需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。</p>\n<p>注意，在该定义中的接口指的是所定义的方法。例如外面调用某个类的public方法。这个方法对外就是接口。</p>\n<p>2、原则分析：</p>\n<p>（1）接口隔离原则是指使用多个专门的接口，而不使用单一的总接口。每一个接口应该承担一种相对独立的角色，不多不少，不干不该干的事，该干的事都要干。</p>\n<ul>\n<li>一个接口就只代表一个角色，每个角色都有它特定的一个接口，此时这个原则可以叫做“角色隔离原则”。</li>\n<li>接口仅仅提供客户端需要的行为，即所需的方法，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。</li>\n</ul>\n<p>（2）使用接口隔离原则拆分接口时，首先必须满足单一职责原则，将一组相关的操作定义在一个接口中，且在满足高内聚的前提下，接口中的方法越少越好。</p>\n<p>（3）可以在进行系统设计时采用定制服务的方式，即为不同的客户端提供宽窄不同的接口，只提供用户需要的行为，而隐藏用户不需要的行为。</p>\n<h2 id=\"六、依赖倒置原则dip\" tabindex=\"-1\"> 六、依赖倒置原则DIP</h2>\n<p>Dependency-Inversion Principle 要依赖抽象,而不要依赖具体的实现, 具体而言就是高层模块不依赖于底层模块,二者共同依赖于抽象。抽象不依赖于具体,具体依赖于抽象。</p>\n<p>1、定义</p>\n<p>高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。简单的说，依赖倒置原则要求客户端依赖于抽象耦合。原则表述：</p>\n<ol>\n<li>抽象不应当依赖于细节；细节应当依赖于抽象；</li>\n<li>要针对接口编程，不针对实现编程</li>\n</ol>\n<p>2、原则分析</p>\n<p>（1）如果说开闭原则是面向对象设计的目标,依赖倒转原则是到达面向设计&quot;开闭&quot;原则的手段..如果要达到最好的&quot;开闭&quot;原则,就要尽量的遵守依赖倒转原则. 可以说依赖倒转原则是对&quot;抽象化&quot;的最好规范! 我个人感觉,依赖倒转原则也是里氏代换原则的补充..你理解了里氏代换原则,再来理解依赖倒转原则应该是很容易的。</p>\n<p>（2）依赖倒转原则的常用实现方式之一是在代码中使用抽象类，而将具体类放在配置文件中。</p>\n<p>（3）类之间的耦合：零耦合关系，具体耦合关系，抽象耦合关系。依赖倒转原则要求客户端依赖于抽象耦合，以抽象方式耦合是依赖倒转原则的关键。</p>\n<p>3、例子1</p>\n<p>理解这个依赖倒置，首先我们需要明白依赖在面向对象设计的概念：</p>\n<p>依赖关系(Dependency)：是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。（假设A类的变化引起了B类的变化，则说名B类依赖于A类。）大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。在UML中，依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。</p>\n<p>4、例子2</p>\n<p>某系统提供一个数据转换模块，可以将来自不同数据源的数据转换成多种格式，如可以转换来自数据库的数据(DatabaseSource)、也可以转换来自文本文件的数据(TextSource)，转换后的格式可以是XML文件(XMLTransformer)、也可以是XLS文件(XLSTransformer)等。</p>\n<p><img src=\"@source/java/design-patterns/assets/20220415/six-principles-of-design-patterns-1649988704099.png\" alt=\"依赖倒置原则例子2\" loading=\"lazy\"></p>\n<p>由于需求的变化，该系统可能需要增加新的数据源或者新的文件格式，每增加一个新的类型的数据源或者新的类型的文件格式，客户类MainClass都需要修改源代码，以便使用新的类，但违背了开闭原则。现使用依赖倒转原则对其进行重构。</p>\n<p><img src=\"@source/java/design-patterns/assets/20220415/six-principles-of-design-patterns-1649988740325.png\" alt=\"依赖倒置原则例子3\" loading=\"lazy\"></p>\n<p>当然根据具体的情况，也可以将AbstractSource注入到AbstractStransformer，依赖注入的方式有以下三种：</p>\n<div><pre><code><span>/**\n * 依赖注入是依赖AbstractSource抽象注入的，而不是具体 DatabaseSource\n */</span>\n<span>abstract</span> <span>class</span> <span>AbstractStransformer</span> <span>{</span>\n    <span>private</span> <span>AbstractSource</span> source<span>;</span>\n\n    <span>/**\n     * 构造注入（Constructor Injection）：通过构造函数注入实例变量\n     */</span>\n    <span>public</span> <span>void</span> <span>AbstractStransformer</span><span>(</span><span>AbstractSource</span> source<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>source <span>=</span> source<span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 设值注入（Setter Injection)：通过Setter方法注入实例变量。\n     * <span>@param</span> <span>source</span> : the sourceto set\n     */</span>\n    <span>public</span> <span>void</span> <span>setSource</span><span>(</span><span>AbstractSource</span> source<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>source <span>=</span> source<span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 接口注入（Interface Injection)：通过接口方法注入实例变量。\n     * <span>@param</span> <span>source</span>\n     */</span>\n    <span>public</span> <span>void</span> <span>transform</span><span>(</span><span>AbstractSource</span> source<span>)</span> <span>{</span>\n        source<span>.</span><span>getSource</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Stransforming .….\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h2 id=\"七、合成-聚合复用原则\" tabindex=\"-1\"> 七、合成/聚合复用原则</h2>\n<p>(Composite/Aggregate ReusePrinciple ，CARP)：要尽量使用对象组合，而不是继承关系达到软件复用的目的。</p>\n<p>1、定义</p>\n<p>经常又叫做合成复用原则（Composite ReusePrinciple或CRP），尽量使用对象组合，而不是继承来达到复用的目的。</p>\n<p>就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新对象通过向这些对象的委派达到复用已有功能的目的。简而言之，要尽量使用合成/聚合，尽量不要使用继承。</p>\n<p>2、原则分析</p>\n<p>（1）在面向对象设计中，可以通过两种基本方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或通过继承。\n继承复用：实现简单，易于扩展。破坏系统的封装性；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；只能在有限的环境中使用。（“白箱”复用）\n组合/聚合复用：耦合度相对较低，选择性地调用成员对象的操作；可以在运行时动态进行。（“黑箱”复用）\n（2）组合/聚合可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合/聚合来实现复用；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。\n（3）此原则和里氏代换原则氏相辅相成的,两者都是具体实现&quot;开-闭&quot;原则的规范。违反这一原则，就无法实现&quot;开-闭&quot;原则，首先我们要明白合成和聚合的概念：</p>\n<p>注意：聚合和组合的区别是什么？</p>\n<p>合成（组合）：表示一个整体与部分的关系，指一个依托整体而存在的关系（整体与部分不可以分开）；比如眼睛和嘴对于头来说就是组合关系，没有了头就没有眼睛和嘴，它们是不可分割的。在UML中，组合关系用带实心菱形的直线表示。</p>\n<p>聚合：聚合是比合成关系的一种更强的依赖关系,也表示整体与部分的关系（整体与部分可以分开）；比如螺丝和汽车玩具的关系，螺丝脱离玩具依然可以用在其它设备之上。在UML中，聚合关系用带空心菱形的直线表示。</p>\n<h2 id=\"八、迪米特法则\" tabindex=\"-1\"> 八、迪米特法则</h2>\n<p>(Law of Demeter，LoD：系统中的类,尽量不要与其他类互相作用，减少类之间的耦合度。</p>\n<p>1、定义</p>\n<p>又叫最少知识原则（Least Knowledge Principle或简写为LKP）几种形式定义：</p>\n<p>不要和“陌生人”说话。英文定义为：Don't talk to strangers.</p>\n<p>只与你的直接朋友通信。英文定义为：Talk only to your immediate friends.</p>\n<p>每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。</p>\n<p>简单地说，也就是，一个对象应当对其它对象有尽可能少的了解。一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的public方法，我就调用这么多，其他的一概不关心。</p>\n<p>2、法则分析\n朋友类：在迪米特法则中，对于一个对象，其朋友包括以下几类：</p>\n<ol>\n<li>当前对象本身(this)；</li>\n<li>以参数形式传入到当前对象方法中的对象；</li>\n<li>当前对象的成员对象；</li>\n<li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；</li>\n<li>当前对象所创建的对象。</li>\n</ol>\n<p>任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。</p>\n<p>3、狭义法则和广义法则：</p>\n<p>在狭义的迪米特法则中，如果两个类之间不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，如果其中的一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p>\n<p>狭义的迪米特法则：可以降低类之间的耦合，但是会在系统中增加大量的小方法并散落在系统的各个角落，它可以使一个系统的局部设计简化，因为每一个局部都不会和远距离的对象有直接的关联，但是也会造成系统的不同模块之间的通信效率降低，使得系统的不同模块之间不容易协调。</p>\n<p>广义的迪米特法则：指对对象之间的信息流量、流向以及信息的影响的控制，主要是对信息隐藏的控制。信息的隐藏可以使各个子系统之间脱耦，从而允许它们独立地被开发、优化、使用和修改，同时可以促进软件的复用，由于每一个模块都不依赖于其他模块而存在，因此每一个模块都可以独立地在其他的地方使用。一个系统的规模越大，信息的隐藏就越重要，而信息隐藏的重要性也就越明显。</p>\n<p>4、迪米特法则的主要用途：在于控制信息的过载。</p>\n<ul>\n<li>在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；</li>\n<li>在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；</li>\n<li>在类的设计上，只要有可能，一个类型应当设计成不变类；</li>\n<li>在对其他类的引用上，一个对象对其他对象的引用应当降到最低。</li>\n</ul>\n<p>5、例子</p>\n<p>外观模式Facade（结构型）</p>\n<p>迪米特法则与设计模式Facade模式、Mediator模式</p>\n<p>系统中的类,尽量不要与其他类互相作用,减少类之间的耦合度,因为在你的系统中,扩展的时候,你可能需要修改这些类,而类与类之间的关系,决定了修改的复杂度,相互作用越多,则修改难度就越大,反之,如果相互作用的越小,则修改起来的难度就越小..例如A类依赖B类,则B类依赖C类,当你在修改A类的时候,你要考虑B类是否会受到影响,而B类的影响是否又会影响到C类. 如果此时C类再依赖D类的话,呵呵,我想这样的修改有的受了。</p>\n<h2 id=\"九、q-a\" tabindex=\"-1\"> 九、Q&amp;A</h2>\n<p>1、面向对象设计其他原则？</p>\n<ul>\n<li>封装变化；</li>\n<li>少用继承多用组合；</li>\n<li>针对接口编程、不针对实现编程；</li>\n<li>为交互对象之间的松耦合设计而努力；</li>\n<li>类应该对扩展开发、对修改封闭（开闭OCP原则）；</li>\n<li>依赖抽象，不要依赖于具体类（依赖倒置DIP原则）；</li>\n<li>密友原则：只和朋友交谈（最少知识原则，迪米特法则）；\n(说明：一个对象应当对其他对象有尽可能少的了解，将方法调用保持在界限内，只调用属于以下范围的方法：该对象本身（本地方法）对象的组件 被当作方法参数传进来的对象 此方法创建或实例化的任何对象；)</li>\n<li>别找我（调用我） 我会找你（调用你）（好莱坞原则）；</li>\n<li>一个类只有一个引起它变化的原因（单一职责SRP原则）；</li>\n</ul>\n<p>2、你能解释一下里氏替换原则吗?</p>\n<p>严格定义：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象用o1替换o2时，程序P的行为没有变化，那么类型S是类型T的子类型。</p>\n<p>通俗表述：所有引用基类（父类）的地方必须能透明地使用其子类的对象。也就是说子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：</p>\n<ul>\n<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li>\n<li>子类中可以增加自己特有的方法。</li>\n<li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li>\n<li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li>\n</ul>\n<p>3、什么情况下会违反迪米特法则？为什么会有这个问题？</p>\n<p>迪米特法则建议“只和朋友说话，不要陌生人说话”，以此来减少类之间的耦合。</p>\n<p>4、给我一个符合开闭原则的设计模式的例子？</p>\n<p>开闭原则要求你的代码对扩展开放，对修改关闭。这个意思就是说，如果你想增加一个新的功能，你可以很容易的在不改变已测试过的代码的前提下增加新的代码。有好几个设计模式是基于开闭原则的，如策略模式，如果你需要一个新的策略，只需要实现接口，增加配置，不需要改变核心逻辑。一个正在工作的例子是<code>Collections.sort()</code>方法，这就是基于策略模式，遵循开闭原则的，你不需为新的对象修改 sort() 方法，你需要做的仅仅是实现你自己的 Comparator 接口。</p>\n<p>5、什么时候使用享元模式（蝇量模式）？</p>\n<p>享元模式通过共享对象来避免创建太多的对象。为了使用享元模式，你需要确保你的对象是不可变的，这样你才能安全的共享。JDK中<code>String池</code>、<code>Integer池</code>以及<code>Long池</code>都是很好的使用了享元模式的例子。</p>\n<p><a href=\"https://www.cnblogs.com/pengdai\" target=\"_blank\" rel=\"noopener noreferrer\">原文</a></p>\n",
      "date_published": "2022-04-14T03:34:13.000Z",
      "date_modified": "2022-04-16T23:42:59.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "类加载机制",
      "url": "http://www.zhangsj.xyz/blog/java/jvm/class-loader.html",
      "id": "http://www.zhangsj.xyz/blog/java/jvm/class-loader.html",
      "content_html": "<h1 id=\"类加载机制\" tabindex=\"-1\"> 类加载机制</h1>\n<h2 id=\"parent-delegation-model\" tabindex=\"-1\"> parent-delegation-model</h2>\n<p>避免用户自己编写的类动态替换JAVA的一些核心类，比如String。同时也避免了类的重复加载，因为JVM中区分不同类，不仅仅根据类名，相同的class文件被不同ClassLoader加载就是不同的两个类。</p>\n<p>双亲委派模型的好处：</p>\n<p>主要是为了安全性，便面用户自己编写的类动态替换JAVA的一些核心类，比如String。</p>\n",
      "date_published": "2022-04-14T03:34:13.000Z",
      "date_modified": "2022-04-16T14:05:13.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Shallow&Deep copy",
      "url": "http://www.zhangsj.xyz/blog/java/jvm/deep-copy-and-shallow-copy.html",
      "id": "http://www.zhangsj.xyz/blog/java/jvm/deep-copy-and-shallow-copy.html",
      "content_html": "<h2 id=\"基本类型和引用类型\" tabindex=\"-1\"> 基本类型和引用类型</h2>\n<h3 id=\"在java中数据类型可以分为两大类-基本类型和引用类型\" tabindex=\"-1\"> 在Java中数据类型可以分为两大类：基本类型和引用类型</h3>\n<p>基本类型也称为值类型，分别是字符型char，布尔型boolean以及数值型 byte、short、int、long、float、double。</p>\n<p>引用类型则包括类、接口、数组、枚举等。</p>\n<h3 id=\"内存空间分为堆和栈\" tabindex=\"-1\"> 内存空间分为堆和栈</h3>\n<p>基本类型直接在栈中存储数值，而引用类型是将引用放在栈中，实际存储的值是放在堆中，通过栈中的引用指向堆中存放的数据。</p>\n<p>开发过程中，有时会遇到把现有的一个对象的所有成员属性拷贝给另一个对象的需求。</p>\n<h2 id=\"创建对象的5种方式\" tabindex=\"-1\"> 创建对象的5种方式</h2>\n<p>①、通过 new 关键字</p>\n<p>这是最常用的一种方式，通过 new 关键字调用类的有参或无参构造方法来创建对象。比如 Object obj = new Object();</p>\n<p>②、通过 Class 类的 newInstance() 方法</p>\n<p>这种默认是调用类的无参构造方法创建对象。</p>\n<p>比如 <code>Person p2 = (Person) Class.forName(&quot;com.ys.test.Person&quot;).newInstance();</code></p>\n<p>③、通过 Constructor 类的 newInstance 方法</p>\n<p>这和第二种方法类时，都是通过反射来实现。通过 java.lang.relect.Constructor 类的 newInstance() 方法指定某个构造器来创建对象。</p>\n<p><code>Person p3 = (Person) Person.class.getConstructors()[0].newInstance();</code></p>\n<p>实际上第二种方法利用 Class 的 <code>newInstance()</code>方法创建对象，其内部调用还是 Constructor 的 newInstance() 方法。</p>\n<p>④、利用 Clone 方法</p>\n<p><code>Clone</code> 是 <code>Object</code> 类中的一个方法，通过 对象<code>A.clone()</code>方法会创建一个内容和对象 A 一模一样的对象 B，clone 克隆，顾名思义就是创建一个一模一样的对象出来。</p>\n<p><code>Person p4 = (Person) p3.clone();</code></p>\n<p>⑤、反序列化</p>\n<p>序列化是把堆内存中的 Java 对象数据，通过某种方式把对象存储到磁盘文件中或者传递给其他网络节点（在网络上传输）。而反序列化则是把磁盘文件中的对象数据或者把网络节点上的对象数据，恢复成Java对象模型的过程。</p>\n<h2 id=\"clone-方法\" tabindex=\"-1\"> Clone 方法</h2>\n<p>本篇博客我们讲解的是 Java 的深拷贝和浅拷贝，其实现方式正是通过调用 Object 类的 clone() 方法来完成。在 Object.class 类中，源码为：</p>\n<p><code>protected native Object clone() throws CloneNotSupportedException;</code></p>\n<p>ative 修饰的方法就是告诉操作系统，这个方法我不实现了，让操作系统去实现。具体怎么实现我们不需要了解，只需要知道 clone方法的作用就是复制对象，产生一个新的对象。</p>\n<h2 id=\"深拷贝\" tabindex=\"-1\"> 深拷贝</h2>\n<p>深拷贝：创建一个新对象，然后将当前对象的非静态字段复制到该新对象，无论该字段是值类型的还是引用类型，都复制独立的一份。</p>\n<p>当你修改其中一个对象的任何内容时，都不会影响另一个对象的内容。</p>\n<p>①、让每个引用类型属性内部都重写clone() 方法</p>\n<p>既然引用类型不能实现深拷贝，那么我们将每个引用类型都拆分为基本类型，分别进行浅拷贝。比如上面的例子，Person 类有一个引用类型 Address(其实String 也是引用类型，但是String类型有点特殊，后面会详细讲解)，我们在 Address 类内部也重写 clone 方法。如下：</p>\n<p>测试还是和上面一样，我们会发现更改了p2对象的Address属性，p1 对象的 Address 属性并没有变化。</p>\n<p>但是这种做法有个弊端，这里我们 Person 类只有一个 Address 引用类型，而 Address 类没有，所以我们只用重写 Address 类的clone 方法，但是如果 Address 类也存在一个引用类型，那么我们也要重写其clone 方法，这样下去，有多少个引用类型，我们就要重写多少次，如果存在很多引用类型，那么代码量显然会很大，所以这种方法不太合适。</p>\n<p>②、利用序列化</p>\n<p>序列化是将对象写到流中便于传输，而反序列化则是把对象从流中读取出来。这里写到流中的对象则是原始对象的一个拷贝，因为原始对象还存在 JVM 中，所以我们可以利用对象的序列化产生克隆对象，然后通过反序列化获取这个对象。</p>\n<p>注意每个需要序列化的类都要实现 Serializable 接口，如果有某个属性不需要序列化，可以将其声明为 transient，即将其排除在克隆属性之外。</p>\n<p>因为序列化产生的是两个完全独立的对象，所有无论嵌套多少个引用类型，序列化都是能实现深拷贝的。</p>\n",
      "date_published": "2022-04-14T03:34:13.000Z",
      "date_modified": "2022-04-14T03:34:13.000Z",
      "authors": [],
      "tags": [
        "jvm"
      ]
    },
    {
      "title": "JVM类加载与字节码技术&内存模型",
      "url": "http://www.zhangsj.xyz/blog/java/jvm/jvm-class-loading&bytecode-technology.html",
      "id": "http://www.zhangsj.xyz/blog/java/jvm/jvm-class-loading&bytecode-technology.html",
      "content_html": "<h2 id=\"jvm类加载与字节码技术-内存模型\" tabindex=\"-1\"> JVM类加载与字节码技术&amp;内存模型</h2>\n<h2 id=\"class-load\" tabindex=\"-1\"> class load</h2>\n<p>类加载与字节码技术</p>\n<p><img src=\"@source/java/jvm/img/3-1.png\" alt=\"类加载与字节码技术\" loading=\"lazy\"></p>\n<p>1、类文件结构</p>\n<p>通过 javac 类名.java 编译 java 文件后，会生成一个 .class 的文件！下图是字节码文件：</p>\n<p><img src=\"@source/java/jvm/assets/20220414/jvm-class-loading&amp;bytecode-technology-1649901838160.png\" alt=\"字节码文件\" loading=\"lazy\"></p>\n<p>据 JVM 规范，类文件结构如下：</p>\n<div><pre><code>u4       magic\nu2             minor_version;\nu2             major_version;\nu2             constant_pool_count;\ncp_info        constant_pool[constant_pool_count-1];\nu2             access_flags;\nu2             this_class;\nu2             super_class;\nu2             interfaces_count;\nu2             interfaces[interfaces_count];\nu2             fields_count;\nfield_info     fields[fields_count];\nu2             methods_count;\nmethod_info    methods[methods_count];\nu2             attributes_count;\nattribute_info attributes[attributes_count];\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>1）魔数</p>\n<p>U4 magic\n对应字节码文件的 0~3 个字节\n0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09\nca fe ba be：意思是 .class文件，不同的东西有不同的魔数，比如jpg、PNG 图片等！</p>\n<p>2）版本</p>\n<p>U2 minor_version;\nu2 major_version;\n0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09\n00 00 00 34：34H(16 进制) = 52(10 进制)，代表 JDK8</p>\n<p>3）常量池</p>\n<p>常量池在java用于保存在编译期已确定的，已编译的class文件中的一份数据。它包括了关于类，方法，接口等中的常量，也包括字符串常量，如String s = &quot;java&quot;这种申明方式；当然也可扩充，执行器产生的常量也会放入常量池，故认为常量池是JVM的一块特殊的内存空间。</p>\n<p><a href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.5\" target=\"_blank\" rel=\"noopener noreferrer\">参考文档</a></p>\n<h2 id=\"_2、字节码指令\" tabindex=\"-1\"> 2、字节码指令</h2>\n<p>可参考：</p>\n<p><a href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5\" target=\"_blank\" rel=\"noopener noreferrer\">字节码指令</a></p>\n<h3 id=\"_1、javap-工具\" tabindex=\"-1\"> 1、javap 工具</h3>\n<p>Java中提供了<code>javap</code>工具来反编译 class 文件</p>\n<h3 id=\"_2-图解方法执行流程\" tabindex=\"-1\"> 2）图解方法执行流程</h3>\n<p>代码</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Demo3_1</span> <span>{</span>\n <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n  <span>int</span> a <span>=</span> <span>10</span><span>;</span>\n  <span>int</span> b <span>=</span> <span>Short</span><span>.</span>MAX_VALUE <span>+</span> <span>1</span><span>;</span>\n  <span>int</span> c <span>=</span> a <span>+</span> b<span>;</span>\n  <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>c<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>常量池载入运行时常量池</p>\n<p>常量池也属于方法区，只不过这里单独提出来了</p>\n<p><img src=\"@source/java/jvm/img/3-2.png\" alt=\"\" loading=\"lazy\"></p>\n<p>方法字节码载入方法区</p>\n<p>(stack=2，locals=4) 对应操作数栈有 2 个空间(每个空间 4 个字节)，局部变量表中有 4 个槽位。</p>\n<p><img src=\"@source/java/jvm/img/3-3.png\" alt=\"\" loading=\"lazy\"></p>\n<p>执行引擎开始执行字节码</p>\n<p>Bipush 10</p>\n<ul>\n<li>将一个 byte 压入操作数栈(其长度会补齐 4 个字节)，类似的指令还有\n<ul>\n<li>sipush 将一个 short 压入操作数栈(其长度会补齐 4 个字节)</li>\n<li>ldc 将一个 int 压入操作数栈</li>\n<li>ldc2_w 将一个 long 压入操作数栈（<strong>分两次压入</strong>，因为 long 是 8 个字节）</li>\n<li>这里小的数字都是和字节码指令存在一起，<strong>超过 short 范围的数字存入了常量池</strong></li>\n</ul>\n</li>\n</ul>\n<p>Istore 1</p>\n<p>将操作数栈栈顶元素弹出，放入局部变量表的 slot 1 中</p>\n<p>对应代码中的 <code>a = 10</code></p>\n<p>3）通过字节码指令分析问题</p>\n<p>代码</p>\n<p><a href=\"https://blog.csdn.net/weixin_50280576/article/details/113784268\" target=\"_blank\" rel=\"noopener noreferrer\">csdn</a></p>\n",
      "date_published": "2022-04-14T03:34:13.000Z",
      "date_modified": "2022-04-14T06:39:11.000Z",
      "authors": [],
      "tags": [
        "jvm"
      ]
    },
    {
      "title": "类的生命周期",
      "url": "http://www.zhangsj.xyz/blog/java/jvm/life-cycle-of-a-class.html",
      "id": "http://www.zhangsj.xyz/blog/java/jvm/life-cycle-of-a-class.html",
      "content_html": "<h2 id=\"类的生命周期\" tabindex=\"-1\"> 类的生命周期</h2>\n<p>类从被加载到虚拟机内存中开始，到卸载出内存为止，加载、验证、准备、解析、初始化、使用、卸载七个阶段。其实验证、准备、解析三个部分统称为连接。</p>\n<p>加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、 初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3个部分统称为连接（Linking）</p>\n<FlowChart id=\"flowchart-1a962853\" code=\"%E5%8A%A0%E8%BD%BD%3D%3Eoperation%3A%20%E5%8A%A0%E8%BD%BD%0A%E9%AA%8C%E8%AF%81%3D%3Eoperation%3A%20%E9%AA%8C%E8%AF%81%0A%E5%87%86%E5%A4%87%3D%3Eoperation%3A%20%E5%87%86%E5%A4%87%0A%E8%A7%A3%E6%9E%90%3D%3Eoperation%3A%20%E8%A7%A3%E6%9E%90%0A%E5%88%9D%E5%A7%8B%E5%8C%96%3D%3Eoperation%3A%20%E5%88%9D%E5%A7%8B%E5%8C%96%0A%E4%BD%BF%E7%94%A8%3D%3Eoperation%3A%20%E4%BD%BF%E7%94%A8%0A%E5%8D%B8%E8%BD%BD%3D%3Eoperation%3A%20%E5%8D%B8%E8%BD%BD%0A%0A%E5%8A%A0%E8%BD%BD(right)-%3E%E9%AA%8C%E8%AF%81(right)-%3E%E5%87%86%E5%A4%87(right)-%3E%E8%A7%A3%E6%9E%90(right)-%3E%E5%88%9D%E5%A7%8B%E5%8C%96(right)-%3E%E4%BD%BF%E7%94%A8(right)-%3E%E5%8D%B8%E8%BD%BD%0A\" preset=\"vue\"></FlowChart><h2 id=\"七大阶段\" tabindex=\"-1\"> 七大阶段</h2>\n<p>阶段顺序</p>\n<p>加载、校验、准备、初始化和卸载这五个阶段的顺序是确定的，但是对于“解析”阶段则不一定，它在某些情况下可以在初始化之后再开始，这样做是 为了支持 java 的运行时绑定特征（也称为动态绑定或晚期绑定）。</p>\n<h3 id=\"_1、加载\" tabindex=\"-1\"> 1、加载</h3>\n<p>什么是需要开始类第一个阶段“加载”，虚拟机规范没有强制约束，这点交给虚拟机的具体实现来自由把控。 “加载 loading”阶段是整个类加载（class loading）过程的一个阶段。</p>\n<p>加载阶段虚拟机需要完成以下3件事情：</p>\n<ul>\n<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>\n<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>\n<li>在内存中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区这个类的各种数据的访问入口。</li>\n</ul>\n<p>注意：比如“通过一个类的全限定名来获取定义此类的二进制字节流”没有指定一定得从某个class文件中获取，所以我们可以从zip压缩包、从网络中获取、运行时计算生成、数据库中读取、或者从加密文件中获取等等。</p>\n<p>我们也可以通过前面的工具JHSD可以看到，JVM 启动后，相关的类已经加载进入了方法区，成为了方法区的运行时结构。</p>\n<p>Attarch上JVM启动的进程</p>\n<h3 id=\"_2-验证\" tabindex=\"-1\"> 2.验证</h3>\n<p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。但从整体 上看，验证阶段大致上会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证.</p>\n<p>1、文件格式验证</p>\n<p>第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点:</p>\n<ul>\n<li>是否以魔数OxCAFEBABE开头。</li>\n<li>主、次版本号是否在当前Java虚拟机接受范围之内。</li>\n<li>常量池的常量中是否有不被支持的常量类型(检查常量tag标志)。</li>\n<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li>\n<li>CONSTANT Utf8 info型的常量中是否有不符合UTF-8编码的数据。</li>\n<li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。</li>\n</ul>\n<p>以上的部分还只是一小部分，没必要进行深入的研究</p>\n<p>这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进人Java虚拟机内存的方法区中进行存储，所以后面 的三个验证阶段全部是基于方法区的存储结构（内存）上进行的，不会再直接读取、操作字节流了</p>\n<p>2、 元数据验证</p>\n<p>第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java 语言规范》的要求，这个阶段可能包括的验证点如下:</p>\n<ul>\n<li>这个类是否有父类(除了<code>java.lang.Object</code>之外，所有的类都应当有父类)。</li>\n<li>这个类的父类是否继承了不允许被继承的类(被<code>final</code>修饰的类)。</li>\n<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li>\n<li>类中的字段、方法是否与父类产生矛盾(例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都-致，但返回值类型却不同等)。\n…\n以上的部分还只是一小部分，没必要进行深入的研究。\n元数据验证是验证的第二阶段，主要目的是对类的元数据信息进行语义校验，保证不存在与《Java语言规范》定义相悖的元数据信息。</li>\n</ul>\n<p>3、 字节码验证</p>\n<p>字节码验证第三阶段是整个验证过程中最复杂的一一个阶段， 主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。在第二 阶段对元数据信息中的数据类型校验完毕以后，这阶段就要对类的方法体(Class文件中的Code属性)进行校验分析，保证被校验类的方法在运行时不会做 出危害虚拟机安全的行为，例如:</p>\n<ul>\n<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作栈放置了一个int类型的数据，使用时却按long类型 来加载入本地变量表中”这样的情况。</li>\n<li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上。</li>\n<li>保证方法体中的类型转换总是有效的，例如可以把-个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。…</li>\n</ul>\n<p>以上的部分还只是一小部分，没必要进行深入的研究。\n如果一个类型中有方法体的字节码没有通过字节码验证，那它肯定是有问题的</p>\n<p>4、符号引用验证</p>\n<p>最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段一解析阶段中发生。符号引用验证可以看作是对类自身以外(常量池中的各种符号引用)的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问其依赖的某些外部类、方法、字段等资源。</p>\n<p>本阶段通常需要校验下列内容:</p>\n<ul>\n<li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li>\n<li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</li>\n<li>符号引用中的类、字段、方法的可访问性( private、 protected. public、 )</li>\n<li>是否可被当前类访问。…</li>\n</ul>\n<p>符号引用验证的主要目的是确保解析行为能正常执行，如果无法通过符号引用验证，将会抛出异常</p>\n<p>5、验证（总结）</p>\n<p>验证阶段对于虚拟机的类加载机制来说，是一个非常重要的、 但却不是必须要执行的阶段，因为验证阶段只有通过或者不通过的差别，只要通过了验证， 其后就对程序运行期没有任何影响了。如果程序运行的全部代码(包括自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码)都已经被反复 使用和验证过，在生产环境的实施阶段就可以考虑使用-Xverify:none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>\n<h3 id=\"_3、准备\" tabindex=\"-1\"> 3、准备</h3>\n<p>准备阶段是为静态变量分配内存并赋初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。</p>\n<p>这个阶段中有两个容易产生混淆的概念需要强调一下：</p>\n<p>首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p>\n<p>其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：</p>\n<p><code>public static int value=123;</code></p>\n<p>那变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123是后续的初始化环节.</p>\n<h3 id=\"_4、解析\" tabindex=\"-1\"> 4、解析</h3>\n<p>解析阶段是JVM将常量池内的符号引用替换为直接引用的过程。</p>\n<p>符号引用是一种定义，可以是任何字面上的含义，而直接引用就是直接指向目标的指针、相对偏移量。</p>\n<p>直接引用的对象都存在于内存中，你可以把通讯录里的女友手机号码，类比为符号引用，把面对面和你吃饭的女朋友，类比为直接引用。 解析大体可以分为：</p>\n<p>-类或接口的解析\n-字段解析\n-类方法解析\n-接口方法解析</p>\n<p>我们了解几个经常发生的异常，就与这个阶段有关。</p>\n<ul>\n<li><code>java.lang.NoSuchFieldError</code>根据继承关系从下往上，找不到相关字段时的报错。（字段解析异常）</li>\n<li><code>java.lang.IllegalAccessError</code>字段或者方法，访问权限不具备时的错误。（类或接口的解析异常）</li>\n<li><code>java.lang.NoSuchMethodError</code>找不到相关方法时的错误。（类方法解析、接口方法解析时发生的异常）</li>\n</ul>\n<h3 id=\"_5、初始化\" tabindex=\"-1\"> 5、初始化</h3>\n<p>初始化主要是对一个<code>class</code>中的<code>static{}</code>语句进行操作（对应字节码就是<code>clinit</code>方法）。</p>\n<p>如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法。</p>\n<p>有且只有6种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p>\n<ol>\n<li>遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>或<code>invokestatic</code>这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的<code>Java</code>代码场景是：\n使用<code>new</code>关键字实例化对象的时候。\n读取或设置一个类的静态字段（被<code>final</code>修饰、已在编译期把结果放入常量池的静态字段除外）的时候\n调用一个类的静态方法的时候。</li>\n<li>使用<code>java.lang.reflect</code>包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li>\n<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>\n<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含<code>main()</code>方法的那个类），虚拟机会先初始化这个主类。</li>\n<li>当使用JDK1.7的动态语言支持时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果<code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code>的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>\n<li>当一个接口中定义了<code>JDK1.8</code>新加入的默认方法（被<code>default</code>关键字修饰的接口方法）时，如果这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>\n</ol>\n",
      "date_published": "2022-04-14T03:34:13.000Z",
      "date_modified": "2022-04-16T23:42:59.000Z",
      "authors": [],
      "tags": [
        "jvm"
      ]
    },
    {
      "title": "分布式消息中间件",
      "url": "http://www.zhangsj.xyz/blog/java/message-queue/kafka-supplement.html",
      "id": "http://www.zhangsj.xyz/blog/java/message-queue/kafka-supplement.html",
      "content_html": "<h2 id=\"kafka\" tabindex=\"-1\"> kafka</h2>\n<p>Kafka 是一个分布式流式处理平台。</p>\n<p>流平台具有三个关键功能：</p>\n<ol>\n<li>消息队列：发布和订阅消息流，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。</li>\n<li>容错的持久方式存储记录消息流： Kafka 会把消息持久化到磁盘，有效避免了消息丢失的风险。</li>\n<li>流式处理平台: 在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。</li>\n</ol>\n<p>Kafka 主要有两大应用场景：</p>\n<ol>\n<li>消息队列 ：建立实时流数据管道，以可靠地在系统或应用程序之间获取数据。</li>\n<li>数据处理： 构建实时的流数据处理程序来转换或处理数据流。</li>\n</ol>\n<h3 id=\"和其他消息队列相比-kafka-的优势在哪里\" tabindex=\"-1\"> 和其他消息队列相比,Kafka 的优势在哪里？</h3>\n<p>Kafka 相比其他消息队列主要的优势如下：</p>\n<ol>\n<li>极致的性能 ：设计中大量使用了批量处理和异步的思想，最高可以每秒处理千万级别的消息。</li>\n<li>生态系统兼容性好 ：Kafka 与周边生态系统的兼容性是最好的，在大数据和流计算领域。</li>\n</ol>\n<h3 id=\"队列模型了解吗-kafka的消息模型知道吗\" tabindex=\"-1\"> 队列模型了解吗？Kafka的消息模型知道吗？</h3>\n<p>使用队列(Queue)作为消息通信载体，满足生产者与消费者模式，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。 比如：我们生产者发送 100 条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半(也就是你一个我一个的消费。)</p>\n<p>队列模型存在的问题：</p>\n<p>假如我们存在这样一种情况：我们需要将生产者产生的消息分发给多个消费者，并且每个消费者都能接收到完整的消息内容。</p>\n<p>这种情况，队列模型就不好解决了。很多比较杠精的人就说：我们可以为每个消费者创建一个单独的队列，让生产者发送多份。这是一种非常愚蠢的做法，浪费资源不说，还违背了使用消息队列的目的。</p>\n<h4 id=\"发布-订阅模型-kafka-消息模型\" tabindex=\"-1\"> 发布-订阅模型:Kafka 消息模型</h4>\n<p>发布-订阅模型主要是为了解决队列模型存在的问题。</p>\n<p><img src=\"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/发布订阅模型.png\" alt=\"发布订阅模型\" loading=\"lazy\"></p>\n<p>发布订阅模型(Pub-Sub) 使用主题(Topic) 作为消息通信载体，类似于广播模式；发布者发布一条消息，该消息通过主题传递给所有的订阅者，在一条消息广播之后才订阅的用户则是收不到该条消息的。</p>\n<p>在发布 - 订阅模型中，如果只有一个订阅者，那它和队列模型就基本是一样的了。所以说，发布 - 订阅模型在功能层面上是可以兼容队列模型的。</p>\n<p>Kafka 采用的就是发布 - 订阅模型。</p>\n<blockquote>\n<p>RocketMQ 的消息模型和 Kafka 基本是完全一样的。唯一的区别是 Kafka 中没有队列这个概念，与之对应的是 Partition(分区)。</p>\n</blockquote>\n<h3 id=\"基本概念\" tabindex=\"-1\"> 基本概念</h3>\n<p>Kafka 将生产者发布的消息发送到 Topic(主题) 中，需要这些消息的消费者可以订阅这些 Topic(主题)，如下图所示：</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/KafkaTopicPartitioning.png\" alt=\"Kafka Topic Partition\" loading=\"lazy\"></p>\n<h2 id=\"二、kafka基本架构\" tabindex=\"-1\"> 二、Kafka基本架构</h2>\n<p>Producer(生产者) 产生消息的一方。</p>\n<p>Consumer(消费者) 消费消息的一方。</p>\n<p>Broker(代理)</p>\n<p>可以看作是一个独立的 Kafka 实例。多个 Kafka Broker 组成一个 Kafka Cluster。</p>\n<p>同时，你一定也注意到每个 Broker 中又包含了 Topic 以及 Partition 这两个重要的概念：</p>\n<ul>\n<li>主题（Topic）： Producer将消息发送到特定的主题，Consumer通过订阅特定的Topic（主题）来消费消息。</li>\n<li>分区（Partition）: <code>Partition</code>属于<code>Topic</code>的一部分。一个Topic可以有多个Partition ，并且同一 Topic 下的 Partition 可以分布在不同的 Broker 上，这也就表明一个 Topic 可以横跨多个 Broker 。这正如我上面所画的图一样。</li>\n</ul>\n<blockquote>\n<p>划重点：Kafka 中的 Partition(分区) 实际上可以对应成为消息队列中的队列。这样是不是更好理解一点？</p>\n</blockquote>\n<h3 id=\"kafka-的多副本机制\" tabindex=\"-1\"> Kafka 的多副本机制</h3>\n<p>还有一点我觉得比较重要的是 Kafka 为分区(Partition)引入了多副本(Replica)机制。分区(Partition)中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。</p>\n<blockquote>\n<p>生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。当 leader 副本发生故障时会从 follower 中选举出一个 leader,但是 follower 中如果有和 leader 同步程度达不到要求的参加不了 leader 的竞选。</p>\n</blockquote>\n<h4 id=\"好处\" tabindex=\"-1\"> 好处</h4>\n<p>Kafka 的多分区(Partition)以及多副本(Replica)机制有什么好处呢？</p>\n<ol>\n<li>Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力(负载均衡)。</li>\n<li>Partition 可以指定对应的 Replica 数, 这也极大地提高了消息存储的安全性, 提高了容灾能力，不过也相应的增加了所需要的存储空间。</li>\n</ol>\n<h3 id=\"zookeeper-在-kafka-中的作用\" tabindex=\"-1\"> Zookeeper 在 Kafka 中的作用</h3>\n<p>下图就是我的本地 Zookeeper ，它成功和我本地的 Kafka 关联上(以下文件夹结构借助 idea 插件 Zookeeper tool 实现)。</p>\n<p>ZooKeeper 主要为 Kafka 提供元数据的管理的功能。</p>\n<p>从图中我们可以看出，Zookeeper 主要为 Kafka 做了下面这些事情：</p>\n<ol>\n<li>Broker 注册 ：</li>\n</ol>\n<p>在 Zookeeper 上会有一个专门用来进行 Broker 服务器列表记录的节点。每个 Broker 在启动时，都会到 Zookeeper 上进行注册，即到 <code>/brokers/ids</code> 下创建属于自己的节点。每个 Broker 就会将自己的 IP 地址和端口等信息记录到该节点中去</p>\n<ol start=\"2\">\n<li>Topic 注册 ：</li>\n</ol>\n<p>在 Kafka 中，同一个 Topic 的消息会被分成多个分区并将其分布在多个 Broker 上，这些分区信息及与 Broker 的对应关系也都是由 Zookeeper 在维护。比如我创建了一个名字为 my-topic 的主题并且它有两个分区，对应到 zookeeper 中会创建这些文件夹：<code>/brokers/topics/my-topic/Partitions/0</code>、<code>/brokers/topics/my-topic/Partitions/1</code></p>\n<ol start=\"3\">\n<li>负载均衡 ：</li>\n</ol>\n<p>上面也说过了 Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力。 对于同一个 Topic 的不同 Partition，Kafka 会尽力将这些 Partition 分布到不同的 Broker 服务器上。当生产者产生消息后也会尽量投递到不同 Broker 的 Partition 里面。当 Consumer 消费的时候，Zookeeper 可以根据当前的 Partition 数量以及 Consumer 数量来实现动态负载均衡。</p>\n<h3 id=\"kafka-如何保证消息的消费顺序\" tabindex=\"-1\"> Kafka 如何保证消息的消费顺序？</h3>\n<p>我们在使用消息队列的过程中经常有业务场景需要严格保证消息的消费顺序，比如我们同时发了 2 个消息，这 2 个消息对应的操作分别对应的数据库操作是：</p>\n<ol>\n<li>更改用户会员等级。</li>\n<li>根据会员等级计算订单价格。</li>\n</ol>\n<p>假如这两条消息的消费顺序不一样造成的最终结果就会截然不同。</p>\n<p>我们知道 Kafka 中 Partition(分区)是真正保存消息的地方，我们发送的消息都被放在了这里。而我们的 Partition(分区) 又存在于 Topic(主题) 这个概念中，并且我们可以给特定 Topic 指定多个 Partition。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/KafkaTopicPartionsLayout.png\" alt=\"\" loading=\"lazy\"></p>\n<p>每次添加消息到 Partition(分区) 的时候都会采用尾加法，如上图所示。 Kafka 只能为我们保证 Partition(分区) 中的消息有序。</p>\n<blockquote>\n<p>消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量(offset)。Kafka 通过偏移量(offset)来保证消息在分区内的顺序性。</p>\n</blockquote>\n<p>所以，我们就有一种很简单的保证消息消费顺序的方法：</p>\n<p>1 个 Topic 只对应一个 Partition。</p>\n<p>这样当然可以解决问题，但是破坏了 Kafka 的设计初衷。</p>\n<p>Kafka 中发送 1 条消息的时候，可以指定 topic, partition, key, data(数据) 4 个参数。如果你发送消息的时候指定了 Partition 的话，所有消息都会被发送到指定的 Partition。并且，同一个 key 的消息可以保证只发送到同一个 partition，这个我们可以采用表/对象的 ID 来作为 key 。</p>\n<div><p>总结</p>\n<p>对于如何保证 Kafka 中消息消费的顺序，有了下面两种方法：</p>\n<ol>\n<li>\n<p>1 个 Topic 只对应一个 Partition。</p>\n</li>\n<li>\n<p>(推荐)发送消息的时候指定 key/Partition。</p>\n</li>\n</ol>\n</div>\n<p>当然不仅仅只有上面两种方法，上面两种方法是我觉得比较好理解的，</p>\n<h3 id=\"kafka-如何保证消息不丢失\" tabindex=\"-1\"> Kafka 如何保证消息不丢失</h3>\n<h4 id=\"生产者丢失消息的情况\" tabindex=\"-1\"> 生产者丢失消息的情况</h4>\n<p>生产者(Producer) 调用<code>send</code>方法发送消息之后，消息可能因为网络问题并没有发送过去。</p>\n<p>所以，我们不能默认在调用<code>send</code>方法发送消息之后消息发送成功了。为了确定消息是发送成功，我们要判断消息发送的结果。但是要注意的是 Kafka 生产者(Producer) 使用 <code>send</code> 方法发送消息实际上是异步的操作，我们可以通过 <code>get()</code>方法获取调用结果，但是这样也让它变为了同步操作，示例代码如下：</p>\n<div><pre><code><span>SendResult</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> sendResult <span>=</span> kafkaTemplate<span>.</span><span>send</span><span>(</span>topic<span>,</span> o<span>)</span><span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>\n<span>if</span> <span>(</span>sendResult<span>.</span><span>getRecordMetadata</span><span>(</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n  logger<span>.</span><span>info</span><span>(</span><span>\"生产者成功发送消息到\"</span> <span>+</span> sendResult<span>.</span><span>getProducerRecord</span><span>(</span><span>)</span><span>.</span><span>topic</span><span>(</span><span>)</span> <span>+</span> <span>\"-> \"</span> <span>+</span> sendRe\n              sult<span>.</span><span>getProducerRecord</span><span>(</span><span>)</span><span>.</span><span>value</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>但是一般不推荐这么做！可以采用为其添加回调函数的形式，示例代码如下：</p>\n<div><pre><code><span>class</span> <span>T</span><span>{</span>\n        <span>private</span> <span>void</span> <span>m</span><span>(</span><span>)</span><span>{</span>\n            <span>ListenableFuture</span><span><span>&lt;</span><span>SendResult</span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span><span>></span></span> future <span>=</span> kafkaTemplate<span>.</span><span>send</span><span>(</span>topic<span>,</span> o<span>)</span><span>;</span>\n                    future<span>.</span><span>addCallback</span><span>(</span>result <span>-></span> logger<span>.</span><span>info</span><span>(</span><span>\"生产者成功发送消息到topic:{} partition:{}的消息\"</span><span>,</span> result<span>.</span><span>getRecordMetadata</span><span>(</span><span>)</span><span>.</span><span>topic</span><span>(</span><span>)</span><span>,</span> result<span>.</span><span>getRecordMetadata</span><span>(</span><span>)</span><span>.</span><span>partition</span><span>(</span><span>)</span><span>)</span><span>,</span>\n                    ex <span>-></span> logger<span>.</span><span>error</span><span>(</span><span>\"生产者发送消失败，原因：{}\"</span><span>,</span> ex<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>如果消息发送失败的话，我们检查失败的原因之后重新发送即可！</p>\n<p>另外这里推荐为 Producer 的<code>retries</code>(重试次数)设置一个比较合理的值，一般是 3 ，</p>\n<p>但是为了保证消息不丢失的话一般会设置比较大一点。</p>\n<p>设置完成之后，当出现网络问题之后能够自动重试消息发送，避免消息丢失。另外，建议还要设置重试间隔，因为间隔太小的话重试的效果就不明显了，网络波动一次你 3 次一下子就重试完了</p>\n<h4 id=\"消费者丢失消息的情况\" tabindex=\"-1\"> 消费者丢失消息的情况</h4>\n<p>我们知道消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量(offset)。</p>\n<p>偏移量(offset)表示 Consumer 当前消费到的 Partition(分区)的所在的位置。Kafka 通过偏移量（offset)可以保证消息在分区内的顺序性。</p>\n<p><img src=\"https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/kafka-offset.jpg\" alt=\"kafka offset\" loading=\"lazy\"></p>\n<p>当消费者拉取到了分区的某个消息之后，消费者会自动提交了 offset。自动提交的话会有一个问题，试想一下，当消费者刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了。</p>\n<p>解决办法也比较粗暴，我们手动关闭自动提交 offset，每次在真正消费完消息之后再自己手动提交 offset 。 但是，细心的朋友一定会发现，这样会带来消息被重新消费的问题。比如你刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。</p>\n<h4 id=\"kafka-弄丢了消息\" tabindex=\"-1\"> Kafka 弄丢了消息</h4>\n<p>我们知道 Kafka 为分区(Partition)引入了多副本(Replica)机制。</p>\n<p>分区(Partition)中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。</p>\n<p>我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。</p>\n<p>生产者和消费者只与 leader 副本交互。</p>\n<p>你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。</p>\n<p>试想一种情况：假如 leader 副本所在的 broker 突然挂掉，那么就要从 follower 副本重新选出一个 leader ，但是 leader 的数据还有一些没有被 follower 副本的同步的话，就会造成消息丢失。</p>\n<p>设置 <code>acks = all</code></p>\n<p>解决办法就是我们设置 acks = all。</p>\n<p>acks 是 Kafka 生产者(Producer) 很重要的一个参数。</p>\n<p>acks 的默认值即为 1，代表我们的消息被 leader 副本接收之后就算被成功发送。当我们配置 acks = all 代表则所有副本都要接收到该消息之后该消息才算真正成功被发送。</p>\n<p>设置 replication.factor &gt;= 3</p>\n<p>为了保证 leader 副本能有 follower 副本能同步消息，我们一般会为 topic 设置 replication.factor &gt;= 3。这样就可以保证每个 分区(partition) 至少有 3 个副本。虽然造成了数据冗余，但是带来了数据的安全性。</p>\n<p>设置 min.insync.replicas &gt; 1</p>\n<p>一般情况下我们还需要设置 min.insync.replicas&gt; 1 ，这样配置代表消息至少要被写入到 2 个副本才算是被成功发送。Min.insync.replicas 的默认值为 1 ，在实际生产中应尽量避免默认值 1。</p>\n<p>但是，为了保证整个 Kafka 服务的高可用性，你需要确保 replication.factor &gt; min.insync.replicas 。为什么呢？设想一下假如两者相等的话，只要是有一个副本挂掉，整个分区就无法正常工作了。这明显违反高可用性！一般推荐设置成 replication.factor = min.insync.replicas + 1。</p>\n<p>设置 unclean.leader.election.enable = false</p>\n<blockquote>\n<p>Kafka 0.11.0.0 版本开始 unclean.leader.election.enable 参数的默认值由原来的 true 改为 false</p>\n</blockquote>\n<p>我们最开始也说了我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。多个 follower 副本之间的消息同步情况不一样，当我们配置了 unclean.leader.election.enable = false 的话，当 leader 副本发生故障时就不会从 follower 副本中和 leader 同步程度达不到要求的副本中选择出 leader ，这样降低了消息丢失的可能性。</p>\n<h3 id=\"kafka-如何保证消息不重复消费\" tabindex=\"-1\"> Kafka 如何保证消息不重复消费</h3>\n<p>kafka 出现消息重复消费的原因：</p>\n<ul>\n<li>服务端侧已经消费的数据没有成功提交 offset(根本原因)。</li>\n<li>Kafka 侧 由于服务端处理业务时间长或者网络链接等等原因让 Kafka 认为服务假死，触发了分区 rebalance。</li>\n</ul>\n<p>解决方案：</p>\n<ul>\n<li>消费消息服务做幂等校验，比如 Redis 的 set、MySQL 的主键等天然的幂等功能。这种方法最有效。</li>\n<li>将 <code>enable.auto.commit</code> 参数设置为 false，关闭自动提交，开发者在代码中手动提交 offset。那么这里会有个问题：什么时候提交 offset 合适？\n<ul>\n<li>处理完消息再提交：依旧有消息重复消费的风险，和自动提交一样</li>\n<li>拉取到消息即提交：会有消息丢失的风险。允许消息延时的场景，一般会采用这种方式。然后，通过定时任务在业务不繁忙(比如凌晨)的时候做数据兜底。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"reference\" tabindex=\"-1\"> Reference</h3>\n<ul>\n<li><a href=\"https://kafka.apache.org/documentation\" target=\"_blank\" rel=\"noopener noreferrer\">Kafka 官方文档</a></li>\n<li>极客时间—《Kafka 核心技术与实战》第 11 节：无消息丢失配置怎么实现？</li>\n</ul>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486269&amp;idx=2&amp;sn=ec00417ad641dd8c3d145d74cafa09ce&amp;chksm=cea244f6f9d5cde0c8eb233fcc4cf82e11acd06446719a7af55230649863a3ddd95f78d111de&amp;token=1633957262&amp;lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener noreferrer\">Kafka 系列第三篇！10 分钟学会如何在 Spring Boot 程序中使用 Kafka 作为消息队列?</a></p>\n<h2 id=\"三、基本原理\" tabindex=\"-1\"> 三、基本原理</h2>\n<p>我们将消息的发布者称作producer，将消息的订阅表述为consumer，将中间的存储阵列称作broker，这样就可以大致描绘出一个场面：</p>\n<p>生产者将数据生产出来，交给broker进行存储，，消费者需要消费数据了，就从broker中区拿出数据来，然后完成一系列对数据的处理操作。</p>\n<p>咋一看范爷太简单了，不是说了它是分布式吗？难道把producer、broker、和consumer放在三台不同的机器上就算是分布式了吗？</p>\n<p>多个broker协同合作，producer和consumer部署在各个分布式消息发布订阅系统就完成了。</p>\n<p>图上有个细节需要注意，producer到broker的过程是push，也就是有数据就推送到borker，而consumer到borker的过程就是pull，是通过consumer主动去拉数据的，而不是broker把数据主动发送到consumer端的。</p>\n<h2 id=\"_4、zookeeper在kafka的作用\" tabindex=\"-1\"> 4、Zookeeper在kafka的作用</h2>\n<p>上述，提到了Zookeeper，那么Zookeeper在kafka的作用是什么？</p>\n<p>（1）、无论是kafka集群，还是producer和consumer都依赖于zookeeper来保证系统可用性集群保存一些Meta信息。</p>\n<p>（2）、kafka使用zookeeper作为其分布式协调框架，很好地将消息生产、存储、消费的过程结合在一起。</p>\n<p>(3)、同时借助Z</p>\n<h2 id=\"执行流程\" tabindex=\"-1\"> 执行流程</h2>\n<p>我们看上面的图：我们把broker的数量减少，另有一台。现在假设我们安装上图进行部署:</p>\n<h2 id=\"特性\" tabindex=\"-1\"> 特性</h2>\n<p>高吞吐量、低延迟：</p>\n<p>可扩展性：</p>\n<p>持久性：</p>\n<p>容错性：</p>\n<p>高并发：</p>\n<p>支持实时在线处理和离线处理：可以用时storm这种实时流处理系统对消息进行实时处理，同时还可以使用Hadoop这种批处理系统进行离线处理；</p>\n<h2 id=\"使用场景\" tabindex=\"-1\"> 使用场景</h2>\n<ol>\n<li>日志收集</li>\n<li>消息系统</li>\n<li>运营管理</li>\n<li>用户活动跟踪</li>\n<li>流失处理</li>\n<li>事件源</li>\n</ol>\n",
      "image": "https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B.png",
      "date_published": "2022-04-14T03:34:13.000Z",
      "date_modified": "2022-04-16T14:05:13.000Z",
      "authors": [],
      "tags": [
        "消息队列"
      ]
    },
    {
      "title": "为什么分布式要有分布式锁",
      "url": "http://www.zhangsj.xyz/blog/java/soa/distributed-lock.html",
      "id": "http://www.zhangsj.xyz/blog/java/soa/distributed-lock.html",
      "content_html": "<h1 id=\"为什么分布式要有分布式锁\" tabindex=\"-1\"> 为什么分布式要有分布式锁</h1>\n<p>目前网上大部分的基于<code>ZOOKEEPER</code>，和<code>REDIS</code>的分布式锁的文章都不够全面。要么就是特意避开集群的情况，要么就是考虑不全，堵着看着还是一脸迷茫。坦白说，这种老题材，很难写出新创意，博主内心战战兢兢，如履薄冰，文中有什么不严谨之处，欢迎批评。</p>\n<p>博主的这篇文章，不上代码，只讲分析。</p>\n<p>1、在REDIS方面，有开源<code>REDISSION</code>的JAR包供你使用。\n2、在ZOOKEEPER方面，有开源的<code>CURATOR</code>的JAR包供你使用。</p>\n<p>因为已经有开源JAR供你使用，没有必要去自己封装一个，大家出门百度一个API即可，不需要再罗列一堆实现代码。</p>\n<p>需要说明的是，Google有一个名为<code>CHUBBY</code>的粗粒度分布式锁的服务，然而，Google chubb并不是开源的，我们只能通过其论文和其他相关的文档中了解具体的细节。值得庆幸的是，YAHOO！借鉴CHUBBY的设计思想开发了ZOOKEEPER，并将其开源，因此本文不讨论CHUBBY。至于TAIR，是阿里开源的一个分布式KV存储方案。我们在工作中基本上REDIS是用的比较多，讨论TAIR所实现的分布式锁，不具有代表性。</p>\n<p>因此，主要分析的还是<code>REDIS</code>和<code>ZOOKEEPER</code>所实现的分布式锁。</p>\n<p>文档的目录结构如下：</p>\n<ol>\n<li>为什么使用分布式锁</li>\n<li>单机情形比较。</li>\n<li>集群情形比较；</li>\n<li>锁的其它特性比较；</li>\n</ol>\n<p>为什么使用分布式锁？</p>\n<p>使用分布式锁的目的，无外乎就是保证同一时间只有一个客户端可以对共享资源进行操作。</p>\n<p>但是MARTIN指出，根据锁的用途还可以细分为以下两类：</p>\n<p>1、允许多个客户端操作共享资源</p>\n<p>这种情况下，对共享资源的操作一定是幂等性操作，无论你操作多少次都不会出现不同结果。在这里使用锁，无外乎就是避免重复操作共享资源从而提高效率。</p>\n<p>2、 只允许一个客户端操作共享资源</p>\n<p>这种情况下，对共享资源的操作一般是非幂等性操作。在这种情况下，如果出现多个客户端操作共享资源，就可能意味着数据不一致，数据丢失。</p>\n<h2 id=\"第一回合-单机情形比较\" tabindex=\"-1\"> 第一回合，单机情形比较</h2>\n<p>1、redis</p>\n<p>先说加锁，根据REDIS官网文档的描述，是所有下面的命令加锁：</p>\n<div><pre><code><span>set</span> resource_name my_random_value NX PX <span>30000</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br></div></div><ul>\n<li>my_random_value是由客户端生成的一个随机字符串，相当于客户端持有锁的标志</li>\n<li>NX表示只有当resource_name对应的KEY值不存在的时候才能SET成功，相当于只有第一个请求的客户端才能获得锁</li>\n<li>PX 30000表示这个锁有一个三十秒的自动过期时间。</li>\n</ul>\n<p>至于解锁，为了防止客户端A获得的锁被客户端B释放，采用下面的LUA脚本来释放锁</p>\n<div><pre><code><span>if</span> redis<span>.</span><span>call</span><span>(</span><span>\"get\"</span><span>,</span>KEY<span>[</span><span>1</span><span>]</span> <span>==</span> ARGV<span>[</span><span>1</span><span>]</span> then\n        <span>return</span> redis<span>.</span><span>call</span><span>(</span><span>\"del\"</span><span>,</span>KEYS<span>[</span><span>1</span><span>]</span><span>)</span>\n    <span>)</span>\n<span>else</span>\n    <span>return</span> <span>0</span>\nend\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>在执行这段LUA脚本的时候，KEYS[1]的值为resource_name，ARGV[1]的值为my_random_value。原理就是先获取所对应的VALUE值，保证和客户端穿进去的my_random_value值相等，这样就能避免自己的所被其他人释放。另外，采取LUA脚本操作保证了原子性。</p>\n<p>过期时间如果设置。如果客户端在操作共享资源的过程中，因为长期阻塞的原因，导致锁过期，那么接下来访问共享资源就不安全。</p>\n<p>可是，有的人会说</p>\n<blockquote>\n<p>那可以在客户端操作完共享资源后，判断锁是否依然归该客户端所有，如果依然归客户端所有，则提交资源，释放锁。若不归客户端所有，则不提交资源。</p>\n</blockquote>\n<p>这么做，只能降低多个客户端操作共享资源发生的概率，并不能解决问题</p>\n<h2 id=\"第二回合-集群情形比较\" tabindex=\"-1\"> 第二回合，集群情形比较</h2>\n<p>我们在生产中，一般都是用集群情形，所以第一回合讨论的单机情形。算是给大家热热身。</p>\n<p>1、Redis</p>\n<p>为了Redis的高可用，一般都会给REDIS的节点挂一个SLAVE，然后采用哨兵模式进行主备切换。但由于REDIS的主从复制是异步的，这可能会出现在数据同步过程中，master宕机，slave来不及同步数据就被选为MASTER，从而数据丢失。具体流程如下所示：</p>\n<ol>\n<li>客户端A从MASTER获取了锁。</li>\n<li>MASTER宕机了，存储锁的KEY还没有来得及同步到SLAVE上。</li>\n<li>SLAVE升级为MASTER。</li>\n<li>客户端B从新的MASTER获取到了对应的同一个资源的锁</li>\n</ol>\n<p>为了应对这个情形，REDIS的作者antirez提出了REDLOCK算法，步骤如下：</p>\n<p>假设我们有N个MASTER节点</p>\n<ol>\n<li>获取当前时间（单位是毫秒）。</li>\n<li>轮流用相同的KEY和随机值在N个节点上清求索，在这一步里，客户端在每个master上请求锁时，会有一个和总得锁释放时间相比小得多的超时时间。比如如果锁自动释放时间是十秒钟，那每个节点所请求的超时时间可能是5~50毫秒的范围，这个可以防止一个客户端在某个宕掉的MASTER节点上阻塞过长时间，如果一个MASTER节点不可用了，我们应该尽快尝试下一个MASTER节点。</li>\n<li>客户端计算第二步中获取锁所花的时间，只有当客户端在大多数MASTER节点上成功获取了锁（在这里是三个），而且总共消耗的时间不超过锁释放时间，这个锁就认为是获取成功了。</li>\n</ol>\n<h2 id=\"redis-实现分布式锁\" tabindex=\"-1\"> Redis 实现分布式锁</h2>\n<p>分布式锁要满足的条件：</p>\n<ul>\n<li>多进程互斥：同一时刻，只有一个进程可以获取锁</li>\n<li>保证锁可以释放：任务结束或出现异常，锁一定要释放，避免死锁</li>\n<li>阻塞锁(可选)：获取锁失败时可否重试</li>\n<li>重入锁(可选)：获取锁的代码递归调用时，依然可以获取锁</li>\n</ul>\n<h3 id=\"最基本的分布式锁\" tabindex=\"-1\"> 最基本的分布式锁</h3>\n<p>利用 Redis 的 setnx 命令，这个命令的特征时如果多次执行，只有第一次执行会成功，可以实现<code>互斥</code>的效果。为了保证服务宕机时也可以释放锁，同时需要利用 expire 命令给锁设置一个有效期</p>\n<div><pre><code>setnx lock thread-01 # 尝试获取锁\nexpire lock 10 # 设置有效期\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br></div></div><h3 id=\"释放锁的时候-保证持有锁的线程释放锁\" tabindex=\"-1\"> 释放锁的时候，保证持有锁的线程释放锁</h3>\n<p>在锁中存储当前进程和线程标识，释放锁时对锁的标识判断，如果是自己的则删除，不是则放弃操作。</p>\n<p>但是这两步操作要保证原子性，需要通过 Lua 脚本来实现。</p>\n<div><pre><code>if redis.call(\"get\",KEYS[1]) == ARGV[1] then\n    redis.call(\"del\",KEYS[1])\nend\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"可重入分布式锁\" tabindex=\"-1\"> 可重入分布式锁</h3>\n<p>如果有重入的需求，则除了在锁中记录进程标识，还要记录重试次数，流程如下：</p>\n<p>下面我们假设锁的 key 为“<code>lock</code>”，hashKey 是当前线程的 id：“<code>threadId</code>”，锁自动释放时间假设为 20</p>\n<p>获取锁的步骤：</p>\n<ul>\n<li>1、判断 lock 是否存在 <code>EXISTS lock</code>\n<ul>\n<li>存在，说明有人获取锁了，下面判断是不是自己的锁</li>\n<li>判断当前线程 ID 作为 hashKey 是否存在：<code>HEXISTS lock threadId</code></li>\n<li>不存在，说明锁已经有了，且不是自己获取的，锁获取失败，end</li>\n<li>存在，说明是自己获取的锁，重入次数+1：<code>HINCRBY lock threadId 1</code>，去到步骤 3</li>\n</ul>\n</li>\n<li>2、不存在，说明可以获取锁，<code>HSET key threadId 1</code></li>\n<li>3、设置锁自动释放时间，<code>EXPIRE lock 20</code></li>\n</ul>\n<p>释放锁的步骤：</p>\n<ul>\n<li>1、判断当前线程 ID 作为 hashKey 是否存在：<code>HEXISTS lock threadId</code>\n<ul>\n<li>不存在，说明锁已经失效，不用管了</li>\n<li>存在，说明锁还在，重入次数减 1：<code>HINCRBY lock threadId -1</code>，获取新的重入次数</li>\n</ul>\n</li>\n<li>2、判断重入次数是否为 0：\n<ul>\n<li>为 0，说明锁全部释放，删除 key：<code>DEL lock</code></li>\n<li>大于 0，说明锁还在使用，重置有效时间：<code>EXPIRE lock 20</code></li>\n</ul>\n</li>\n</ul>\n<p>对应的 Lua 脚本如下：</p>\n<p>首先是获取锁：</p>\n<div><pre><code><span>local</span> key <span>=</span> KEYS<span>[</span><span>1</span><span>]</span><span>;</span> <span>-- 锁的key</span>\n<span>local</span> threadId <span>=</span> ARGV<span>[</span><span>1</span><span>]</span><span>;</span> <span>-- 线程唯一标识</span>\n<span>local</span> releaseTime <span>=</span> ARGV<span>[</span><span>2</span><span>]</span><span>;</span> <span>-- 锁的自动释放时间</span>\n\n<span>if</span><span>(</span>redis<span>.</span><span>call</span><span>(</span><span>'exists'</span><span>,</span> key<span>)</span> <span>==</span> <span>0</span><span>)</span> <span>then</span> <span>-- 判断是否存在</span>\n redis<span>.</span><span>call</span><span>(</span><span>'hset'</span><span>,</span> key<span>,</span> threadId<span>,</span> <span>'1'</span><span>)</span><span>;</span> <span>-- 不存在, 获取锁</span>\n redis<span>.</span><span>call</span><span>(</span><span>'expire'</span><span>,</span> key<span>,</span> releaseTime<span>)</span><span>;</span> <span>-- 设置有效期</span>\n <span>return</span> <span>1</span><span>;</span> <span>-- 返回结果</span>\n<span>end</span><span>;</span>\n\n<span>if</span><span>(</span>redis<span>.</span><span>call</span><span>(</span><span>'hexists'</span><span>,</span> key<span>,</span> threadId<span>)</span> <span>==</span> <span>1</span><span>)</span> <span>then</span> <span>-- 锁已经存在，判断threadId是否是自己</span>\n redis<span>.</span><span>call</span><span>(</span><span>'hincrby'</span><span>,</span> key<span>,</span> threadId<span>,</span> <span>'1'</span><span>)</span><span>;</span> <span>-- 不存在, 获取锁，重入次数+1</span>\n redis<span>.</span><span>call</span><span>(</span><span>'expire'</span><span>,</span> key<span>,</span> releaseTime<span>)</span><span>;</span> <span>-- 设置有效期</span>\n <span>return</span> <span>1</span><span>;</span> <span>-- 返回结果</span>\n<span>end</span><span>;</span>\n<span>return</span> <span>0</span><span>;</span> <span>-- 代码走到这里,说明获取锁的不是自己，获取锁失败</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>然后是释放锁：</p>\n<div><pre><code><span>local</span> key <span>=</span> KEYS<span>[</span><span>1</span><span>]</span><span>;</span> <span>-- 锁的key</span>\n<span>local</span> threadId <span>=</span> ARGV<span>[</span><span>1</span><span>]</span><span>;</span> <span>-- 线程唯一标识</span>\n<span>local</span> releaseTime <span>=</span> ARGV<span>[</span><span>2</span><span>]</span><span>;</span> <span>-- 锁的自动释放时间</span>\n\n<span>if</span> <span>(</span>redis<span>.</span><span>call</span><span>(</span><span>'HEXISTS'</span><span>,</span> key<span>,</span> threadId<span>)</span> <span>==</span> <span>0</span><span>)</span> <span>then</span> <span>-- 判断当前锁是否还是被自己持有</span>\n    <span>return</span> <span>nil</span><span>;</span> <span>-- 如果已经不是自己，则直接返回</span>\n<span>end</span><span>;</span>\n<span>local</span> count <span>=</span> redis<span>.</span><span>call</span><span>(</span><span>'HINCRBY'</span><span>,</span> key<span>,</span> threadId<span>,</span> <span>-</span><span>1</span><span>)</span><span>;</span> <span>-- 是自己的锁，则重入次数-1</span>\n\n<span>if</span> <span>(</span>count <span>></span> <span>0</span><span>)</span> <span>then</span> <span>-- 判断是否重入次数是否已经为0</span>\n    redis<span>.</span><span>call</span><span>(</span><span>'EXPIRE'</span><span>,</span> key<span>,</span> releaseTime<span>)</span><span>;</span> <span>-- 大于0说明不能释放锁，重置有效期然后返回</span>\n    <span>return</span> <span>nil</span><span>;</span>\n<span>else</span>\n    redis<span>.</span><span>call</span><span>(</span><span>'DEL'</span><span>,</span> key<span>)</span><span>;</span> <span>-- 等于0说明可以释放锁，直接删除</span>\n    <span>return</span> <span>nil</span><span>;</span>\n<span>end</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div>",
      "date_published": "2022-04-14T03:34:13.000Z",
      "date_modified": "2022-05-24T08:00:53.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "dubbo面试18个问题你知道所有这些吗?",
      "url": "http://www.zhangsj.xyz/blog/java/soa/dubbo-interview-18-questions!-do-you-know-all-these.html",
      "id": "http://www.zhangsj.xyz/blog/java/soa/dubbo-interview-18-questions!-do-you-know-all-these.html",
      "content_html": "<h2 id=\"dubbo是什么\" tabindex=\"-1\"> dubbo是什么</h2>\n<p>dubbo是一个分布式框架，远程服务调用的分布式框架，其核心部分包含：</p>\n<ul>\n<li>集群容错：提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</li>\n<li>远程通讯：提供对多种基于长连接的NIO 框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。</li>\n<li>自动发现：基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</li>\n</ul>\n<h2 id=\"dubbo能做什么\" tabindex=\"-1\"> dubbo能做什么</h2>\n<p>透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</p>\n<h2 id=\"_1、默认使用的是什么通信框架-还有别的选择吗\" tabindex=\"-1\"> 1、默认使用的是什么通信框架，还有别的选择吗?</h2>\n<p>答：默认也推荐使用<code>netty</code> 框架，还有 <code>mina</code>。</p>\n<h2 id=\"_2、服务调用是阻塞的吗\" tabindex=\"-1\"> 2、服务调用是阻塞的吗？</h2>\n<p>答：默认是阻塞的，可以异步调用，没有返回值的可以这么做。</p>\n<h2 id=\"_3、一般使用什么注册中心-还有别的选择吗\" tabindex=\"-1\"> 3、一般使用什么注册中心？还有别的选择吗？</h2>\n<p>答：推荐使用 <code>zookeeper</code> 注册中心，还有 <code>Multicast</code> 注册中心, <code>Redis</code> 注册中心, <code>Simple</code> 注册中心.</p>\n<p><code>ZooKeeper</code>的节点是通过像树一样的结构来进行维护的，并且每一个节点通过路径来标示以及访问。除此之外，每一个节点还拥有自身的一些信息，包括：数据、数据长度、创建时间、修改时间等等。</p>\n<h2 id=\"_4、默认使用什么序列化框架-你知道的还有哪些\" tabindex=\"-1\"> 4、默认使用什么序列化框架，你知道的还有哪些？</h2>\n<p>答：默认使用 Hessian 序列化，还有 Duddo 、FastJson、Java 自带序列化。 <code>hessian</code>是一个采用二进制格式传输的服务框架，相对传统 soap web service，更轻量，更快速。</p>\n<p>Hessian原理与协议简析：</p>\n<p>http的协议约定了数据传输的方式，<code>hessian</code>也无法改变太多：</p>\n<ol>\n<li>\n<p>hessian中client与server的交互，基于<code>http-post</code>方式。</p>\n</li>\n<li>\n<p>hessian将辅助信息，封装在<code>http header</code>中，比如“<code>授权token</code>”等，我们可以基于<code>http-header</code>来封装关于“安全校验”，“meta数据”等。hessian提供了简单的”校验”机制。</p>\n</li>\n<li>\n<p>对于<code>hessian</code>的交互核心数据，比如“调用的方法”和参数列表信息，将通过post请求的body体直接发送，格式为字节流。</p>\n</li>\n<li>\n<p>对于<code>hessian</code>的server端响应数据，将在<code>response</code>中通过字节流的方式直接输出。</p>\n</li>\n</ol>\n<p>hessian 的协议本身并不复杂，在此不再赘言；所谓协议(<code>protocol</code>)就是约束数据的格式，client按照协议将请求信息序列化成字节序列发送给server端，server端根据协议，将数据反序列化成“对象”，然后执行指定的方法，并将方法的返回值再次按照协议序列化成字节流，响应给client，client按照协议将字节流反序列化成”对象”。</p>\n<h2 id=\"_5、服务提供者能实现失效踢出是什么原理\" tabindex=\"-1\"> 5、服务提供者能实现失效踢出是什么原理？</h2>\n<p>答：服务失效踢出基于 <code>zookeeper</code> 的临时节点原理。</p>\n<h2 id=\"_6、服务上线怎么不影响旧版本\" tabindex=\"-1\"> 6、服务上线怎么不影响旧版本？</h2>\n<p>答：采用多版本开发，不影响旧版本。在配置中添加<code>version</code>来作为版本区分</p>\n<h2 id=\"_7、如何解决服务调用链过长的问题\" tabindex=\"-1\"> 7、如何解决服务调用链过长的问题？</h2>\n<p>答：可以结合 <code>zipkin</code> 实现分布式服务追踪。</p>\n<h2 id=\"_8、说说核心的配置有哪些\" tabindex=\"-1\"> 8、说说核心的配置有哪些？</h2>\n<p>核心配置有： `org.apache.dubbo.config</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>dubbo:service</td>\n<td>服务提供者暴露服务配置</td>\n</tr>\n<tr>\n<td>dubbo:reference</td>\n<td>服务消费者引用服务配置</td>\n</tr>\n<tr>\n<td>dubbo:protocol</td>\n<td>服务提供者协议配置，同时，如果需要支持多协议，可以声明多个 <a href=\"dubbo:protocol\">dubbo:protocol</a> 标签，并在 &lt;&gt; 中通过 protocol 属性指定使用的协议。</td>\n</tr>\n<tr>\n<td>dubbo:registry</td>\n<td>注册中心配置。 同时如果有多个不同的注册中心，可以声明多个 <code>&lt;dubbo:registry&gt;</code> 标签，并在 <code>&lt;&gt;</code> 或 <code>&lt;dubbo:reference&gt;</code> 的 registry 属性指定使用的注册中心</td>\n</tr>\n<tr>\n<td>dubbo:application</td>\n<td>应用信息配置。</td>\n</tr>\n<tr>\n<td>dubbo:provider</td>\n<td>服务提供者缺省值配置。同时该标签为 <a href=\"dubbo:service\">dubbo:service</a> 和 <a href=\"dubbo:protocol\">dubbo:protocol</a> 标签的缺省值设置。</td>\n</tr>\n<tr>\n<td>dubbo:consumer</td>\n<td>服务消费者缺省值配置。同时该标签为 <a href=\"dubbo:reference\">dubbo:reference</a> 标签的缺省值设置。</td>\n</tr>\n<tr>\n<td>dubbo:method</td>\n<td>方法级配置。同时该标签为 <a href=\"dubbo:service\">dubbo:service</a> 或 <a href=\"dubbo:reference\">dubbo:reference</a> 的子标签，用于控制到方法级。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"_9、dubbo-支持哪些协议-每种协议的应用场景-优缺点\" tabindex=\"-1\"> 9、Dubbo 支持哪些协议，每种协议的应用场景，优缺点？</h2>\n<ul>\n<li>dubbo：单一长连接和NIO异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提</li>\n<li>供者。传输协议TCP，异步，Hessian序列化；</li>\n<li>rmi：采用JDK标准的rmi协议实现，传输参数和返回参数对象需要实现<code>Serializable</code>接口，使用java标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议TCP。多个短连接，TCP协议传输，同步传输，适用常规的远程服务调用和rmi互操作。在依赖低版本的Common-Collections包，java序列化存在安全漏洞；<code>webservice</code>:基于WebService的远程调用协议，集成CXF实现，提供和原生WebService\n的互操作。多个短连接，基于HTTP传输，同步传输，适用系统集成和跨语言调用；</li>\n<li>http：基于Http表单提交的远程调用协议，使用Spring的HttpInvoke实现。多个短连接，传输协议HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器JS调用；</li>\n<li>hessian：集成Hessian服务，基于HTTP通讯，采用Servlet暴露服务，Dubbo内嵌Jetty作为服务器时默认实现，提供与Hession服务互操作。多个短连接，同步HTTP传输，Hessian序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件；</li>\n<li><code>memcache</code>：基于memcached实现的RPC协议</li>\n<li>redis：基于redis实现的RPC协议</li>\n</ul>\n<p>dubbo 推荐用什么协议？ 默认使用<code>dubbo</code>协议。</p>\n<h2 id=\"_11、同一个服务多个注册的情况下可以直连某一个服务吗\" tabindex=\"-1\"> 11、同一个服务多个注册的情况下可以直连某一个服务吗？</h2>\n<p>答：可以直连，修改配置即可，也可以通过 <code>telnet</code> 直接某个服务。</p>\n<h2 id=\"_11、dubbo-在安全机制方面如何解决的\" tabindex=\"-1\"> 11、dubbo 在安全机制方面如何解决的？</h2>\n<p>dubbo 通过 token 令牌防止用户绕过注册中心直连，然后在注册中心管理授权，dubbo 提供了黑白名单，控制服务所允许的调用方。</p>\n<h2 id=\"_12、集群容错怎么做\" tabindex=\"-1\"> 12、集群容错怎么做？</h2>\n<p>答：读操作建议使用 <code>Failover</code> 失败自动切换，默认重试两次其他服务器。写操作建议使用 <code>Failfast</code> 快速失败，发一次调用失败就立即报错。</p>\n<h2 id=\"_13、在使用过程中都遇到了些什么问题-如何解决的\" tabindex=\"-1\"> 13、在使用过程中都遇到了些什么问题？ 如何解决的？</h2>\n<ol>\n<li>同时配置了<code>XML</code>和<code>properties</code>文件，则 properties 中的配置无效 只有 XML 没有配置时，properties 才生效。</li>\n<li>dubbo 缺省会在启动时检查依赖是否可用，不可用就抛出异常，阻止 spring 初始化完成，check 属性默认为 true。 测试时有些服务不关心或者出现了循环依赖，将 check 设置为 false</li>\n<li>为了方便开发测试，线下有一个所有服务可用的注册中心，这时，如果有一个正在开发中的服务提供者注册，可能会影响消费者不能正常运行。\n解决：让服务提供者开发方，只订阅服务，而不注册正在开发的服务，通过直连测试正在开发的服务。设置 dubbo:registry 标签的 register 属性为 false。</li>\n<li>spring 2.x 初始化死锁问题。 在 spring 解析到 dubbo:service 时，就已经向外暴露了服务，而 spring 还在接着初始化其他 bean，如果这时有请求进来，并且服务的实现类里有调用 <code>applicationContext.getBean()</code> 的用法。getBean 线程和 spring 初始化线程的锁的顺序不一样，导致了线程死锁，不能提供服务，启动不了。\n解决：不要在服务的实现类中使用 applicationContext.getBean(); 如果不想依赖配置顺序，可以将 dubbo:provider 的 deplay 属性设置为 - 1，使 dubbo 在容器初始化完成后再暴露服务。</li>\n<li>服务注册不上 检查 <code>dubbo</code> 的 jar 包有没有在 <code>classpath</code> 中，以及有没有重复的 jar 包 检查暴露服务的 <code>spring</code> 配置有没有加载，在服务提供者机器上测试与注册中心的网络是否通</li>\n<li>出现 RpcException：<code>No provider available for remote service</code>异常，表示没有可用的服务提供者，\n<ul>\n<li>检查连接的注册中心是否正确</li>\n<li>到注册中心查看相应的服务提供者是否存在</li>\n<li>检查服务提供者是否正常运行</li>\n</ul>\n</li>\n<li>出现” 消息发送失败” 异常，通常是接口方法的传入传出参数未实现 Serializable 接口。</li>\n</ol>\n<h2 id=\"_14、dubbo-和-dubbox-之间的区别\" tabindex=\"-1\"> 14、dubbo 和 dubbox 之间的区别？</h2>\n<p>答：dubbox 是当当网基于 dubbo 上做了一些扩展，如加了服务可 restful 调用，更新了开源组件等。</p>\n<h2 id=\"_15、你还了解别的分布式框架吗\" tabindex=\"-1\"> 15、你还了解别的分布式框架吗？</h2>\n<p>答：别的还有 spring 的 spring cloud，facebook 的 <code>thrift</code>，twitter 的 <code>finagle</code> 等。</p>\n<h2 id=\"_17、dubbo-集群的负载均衡有哪些策略\" tabindex=\"-1\"> 17、Dubbo 集群的负载均衡有哪些策略</h2>\n<p>并预设扩展点予以自行实现。</p>\n<ul>\n<li>Random LoadBalance : 随机选取提供者策略，有利于动态调整提供者权重。截面碰撞率高，调用次数越多，分布越均匀；</li>\n<li>RoundRobin LoadBalance : 轮循选取提供者策略，平均分布，但是存在请求累积的问题；</li>\n<li>LeastActive LoadBalance : 最少活跃调用策略，解决慢提供者接收更少的请求；</li>\n<li>ConstantHash LoadBalance : 一致性 Hash 策略，使相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者，避免引起提供者的剧烈变动；</li>\n</ul>\n<h2 id=\"_18、服务调用超时问题怎么解决\" tabindex=\"-1\"> 18、服务调用超时问题怎么解决</h2>\n<p>dubbo在调用服务不成功时，默认是会重试两次的。这样在服务端的处理时间超过了设定的超时时间时，就会有重复请求，比如在发邮件时，可能就会发出多份重复邮件，执行注册请求时，就会插入多条重复的注册数据，那么怎么解决超时问题呢？如下对于核心的服务中心，去除dubbo超时重试机制，并重新评估设置超时时间。 业务处理代码必须放在服务端，客户端只做参数验证和服务调用，不涉及业务流程处理 全局配置实例</p>\n<div><pre><code><span><span><span>&lt;</span><span>dubbo:</span>provider</span> <span>delay</span><span><span>=</span><span>\"</span>1<span>\"</span></span> <span>timeout</span><span><span>=</span><span>\"</span>6000<span>\"</span></span> <span>retries</span><span><span>=</span><span>\"</span>0<span>\"</span></span><span>/></span></span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br></div></div><p>当然Dubbo的重试机制其实是非常好的QOS保证，它的路由机制，是会帮你把超时的请求路由到其他机器上，而不是本机尝试，所以 dubbo的重试机器也能一定程度的保证服务的质量。但是请一定要综合线上的访问情况，给出综合的评估。</p>\n<p><img src=\"https://deanwang1943.github.io/bugs/\" alt=\"原文链接：\" loading=\"lazy\"></p>\n",
      "image": "https://deanwang1943.github.io/bugs/",
      "date_published": "2022-04-14T03:34:13.000Z",
      "date_modified": "2022-04-16T14:05:13.000Z",
      "authors": [
        {
          "name": "Dean Wang"
        }
      ],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "spring-cloud生产者集群版构建",
      "url": "http://www.zhangsj.xyz/blog/java/soa/spring-cloud-producer-cluster-edition-construction.html",
      "id": "http://www.zhangsj.xyz/blog/java/soa/spring-cloud-producer-cluster-edition-construction.html",
      "content_html": "<p>需要换成生产者的服务名称就行了，如下图：</p>\n<p>你看得见爱在满红殆尽的燃烧着吗</p>\n<ol>\n<li>注册中心：<code>eureka</code>(属于Netflix,2.x版本不在开源，1.x版本让在更新)</li>\n<li>服务调用：<code>ribbon</code>(属于Netflix,停止更新，已经彻底被移除）、spring <code>Loadbalancer</code>(属于Spring Cloud官方,目前的默认方案)</li>\n<li>服务降级：<code>hystrix</code>(属于Netflix,停止更新，已经彻底被移除）</li>\n<li>路由网关：<code>zuul</code>(属于Netflix,停止更新，已经彻底被移除）、gateway(属于spring Cloud官方, 推荐方案)</li>\n</ol>\n<p>找一套更好的解决方案势在必行，也就引出了我们本章的主角：spring cloud alibaba</p>\n<blockquote>\n<p>阿里巴巴作为业界的互联网大厂，给出了一套微服务开发的一站式解决方案。此项目包含开发分布式应用服务的必需组件，方便开发者通过spring cloud编程模型轻松使用这些组件来开发分布式应用服务。\n依托spring cloud alibaba,您只需要添加一些注解和少量配置，就可以将spring cloud 应用接入阿里分布式应用解决方案，通过阿里中渐渐迅速搭建分布式应用系统。</p>\n</blockquote>\n<p>目前spring cloud alibaba提供了如下功能：</p>\n<ol>\n<li>服务限流降级：支持WebServlet、WebFlux、OpenFeign、RestTemplate、dubbo限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降低Metrics监控。</li>\n<li>服务注册与发现：适配spring cloud服务注册与发现标准，默认集成了Ribbon的支持；</li>\n<li>分布式配置管理：支持分布式系统中的外部化配置，配置更改时自动刷新。</li>\n<li>RPC服务：扩展RestTemplate、OpenFeign、dubbo等RPC客户端</li>\n<li>消息驱动能力：基于RabbitMQ、RocketMQ、Kafka等消息驱动能力，支持消息队列、消息事件、消息订阅等能力。</li>\n<li>分布式事务：使用了@GlobalTransactional注解，高效并且对业务零侵入地解决了分布式事务的问题。</li>\n<li>阿里云对象存储：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li>\n<li>分布式任务调度：提供秒级、精准、高可靠、高可用的定时（基于CRON表达式）任务调度服务。同时提供分布式的任务执行模型，如网络任务。网络任务支持海量子任务均匀分配到所有worker（shceduler-client)上执行。</li>\n<li>阿里云短信服务：覆盖全球的短信服务，友好、搞笑、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li>\n</ol>\n",
      "date_published": "2022-04-14T03:34:13.000Z",
      "date_modified": "2022-05-19T10:22:17.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "前后端分离利器之JWT",
      "url": "http://www.zhangsj.xyz/blog/java/soa/take-you-step-by-step-to-understand-the-jwt.html",
      "id": "http://www.zhangsj.xyz/blog/java/soa/take-you-step-by-step-to-understand-the-jwt.html",
      "content_html": "<h1 id=\"一步步带你了解前后端分离利器之jwt\" tabindex=\"-1\"> 一步步带你了解前后端分离利器之JWT</h1>\n<h2 id=\"一、http的无状态性\" tabindex=\"-1\"> 一、HTTP的无状态性</h2>\n<p>HTTP 是无状态协议，它不对之前发送过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。假设要求登录认证的 Web 页面本身无法进行状态的管理（不记录已登录的状态），那么每次跳转新页面不是要再次登录，就是要在每次请求报文中附加参数来管理登录状态。</p>\n<p>不可否认，无状态协议当然也有它的优点。由于不必保存状态，自然可减少服务器的CPU及内存资源的消耗。从另一侧面来说，也正是因为 <code>HTTP</code> 协议本身是非常简单的，所以才会被应用在各种场景里。</p>\n<h2 id=\"二、cookie-技术的引入\" tabindex=\"-1\"> 二、Cookie 技术的引入</h2>\n<p>如果让服务器管理全部客户端状态则会成为负担，保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入了 Cookie 技术。Cookie 技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。</p>\n<p>Cookie 会根据从服务器端发送的响应报文内的一个叫做<code>Set-Cookie</code> 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。</p>\n<p>1、没有 Cookie 信息状态下的请求（来源《图解HTTP》）</p>\n<p>客户端 保存 Cookie</p>\n<p>请求 -&gt; ①保存请求</p>\n<p>响应 &lt;- ②在响应中添加Cookie后返回</p>\n<p>服务器 生成Cookie记住是向谁发送到</p>\n<p>2、第 2 次以后（存有 Cookie 信息状态） 的请求（来源《图解HTTP》）</p>\n<p>Client</p>\n<p>request -&gt; ③请求中添加Cookie后send</p>\n<p>response &lt;-</p>\n<p>server ④检查Cookie （是刚才生成的Cookie）</p>\n<p>3、详细介绍Cookie 传输过程</p>\n<p>server发现client发送过来的Cookie后，回去check 是从哪一个client发来的request，然后对比server上的记录，最后得到之前的状态信息。</p>\n<h2 id=\"三、基于表单的认证\" tabindex=\"-1\"> 三、基于表单的认证</h2>\n<p>目前用户的认证多半是基于表单的认证，基于表单的认证一般会使用 Cookie 来管理Session（Session会话，Session代表着服务器和客户端一次会话的过程，直到Session失效（服务端关闭）或者客户端关闭时结束）。基于表单认证本身是通过服务器端的 Web应用，将客户端发送过来的用户ID和密码与之前登录过的信息做匹配来进行认证的。</p>\n<p>但鉴于 HTTP 是无状态协议，之前已认证成功的用户状态无法通过协议层面保存下来。即无法实现状态管理，因此即使当该用户下一次继续访问，也无法区分它与其他的用户。于是我们会使用Cookie来管理Session，以弥补HTTP协议中不存在状态管理功能。</p>\n<h2 id=\"四、session存储位置以及集群情况下的问题\" tabindex=\"-1\"> 四、Session存储位置以及集群情况下的问题</h2>\n<p>Session 是存储在Web服务器（例如：Tomcat）中的，并针对每个客户端（客户），通过SessionID来区别不同用户的。Session是以Cookie技术或URL重写实现，默认以Cookie技术实现，服务端会给这次会话创造一个JSESSIONID的Cookie值。</p>\n<p>但是一个显著的问题就是，在集群模式下如果通过Nginx负载均衡的时候，如果有一个用户登录的时候请求被分配到服务器A上，登录成功后设置的Session就会存放在服务器A上了，但是在服务器B上却没有该用户的Session数据，当用户再次发起一个请求的时候，此时请求如果被分配到服务器B上，则就不会查询到该用户的登录状态，就会出现登录失败的情况！</p>\n<p>一种可以想到的方式就是将多个Web服务器上存储的Session统一存储到某一存储介质中，保证进集群中的每一台机器都可以看到所有相同Session数据，这里的同步体现在所有的Session存储在同一的存储介质里边。</p>\n<p>幸运的是我们常用的Tomcat容器已经为我们提供了一个接口，可以让我们实现将Session存储到除当前服务器之外的其他存储介质上，例如Redis等。</p>\n<p>了解Spring Session的小伙伴可能都会知道<code>Spring Session</code>的本质就是通过实现Tomcat提供的该接口将Session存储到Redis中，以此来实现Session的统一存储管理，对Spring Session有兴趣的小伙伴可以参考往期的文章：</p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247483665&amp;idx=1&amp;sn=126be172d9804cdcf75a17b50dcd48fa&amp;chksm=e9c5f8a0deb271b62898af1266da1bde81aed33b231b7c79216dd550d467401728bb6726f5bd&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">使用Redis存储Nginx+Tomcat负载均衡集群的Session</a></p>\n<h2 id=\"五、小结与需求痛点\" tabindex=\"-1\"> 五、小结与需求痛点</h2>\n<p>Session和Cookie的目的相同，都是为了克服HTTP协议无状态的缺陷，但完成的方法不同。Session通过Cookie，在客户端保存SessionID，而将用户的其他会话消息保存在服务端的Session对象中，与此相对的，Cookie需要将所有信息都保存在客户端。因此Cookie存在着一定的安全隐患，例如本地Cookie中保存的用户名密码被破译，或Cookie被其他网站收集，例如：</p>\n<ol>\n<li>\n<p>appA主动设置域B cookie，让域B cookie获取；</p>\n</li>\n<li>\n<p>XSS，在appA上通过JavaScript获取document.cookie，并传递给自己的appB。</p>\n</li>\n</ol>\n<p>上述过程我们简单的描述了Session的演进过程还有使用同步的方式解决Session在集群的时候出现的问题，但是我们意识到了使用Spring Session的方式来实现Session的同步是一件相对比较麻烦的事情，我们虽然使用Redis来进行同步，但是Redis并不是100%可靠的，我们需要对Redis搭建集群、进行主从同步复制、进行持久化等，显然这是一件很复杂的事情，因此有没有一种小而轻便的方式来实现我们的这种<strong>认证需求</strong>！那就是JWT了！</p>\n<p>除了上述我们遇到的问题之外，在目前前后端分离的大环境下经常会遇到需要根据用户来分配权限和显示相对应信息的问题，虽然传统的Cookie和Session机制可以解决这个问题，但就通用性而言，JWT（JSON Web Token）相对来说更好。</p>\n<p>看到这里很多小伙伴都已经按捺不住了！那JWT到底是什么呢？</p>\n<h2 id=\"六、jwt是什么\" tabindex=\"-1\"> 六、JWT是什么</h2>\n<p>Json web token (JWT)，是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519)。该标准被设计为紧凑且安全的，一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息。当然该标准也可直接被用于认证，也可被加密。</p>\n<p><strong>JWT的几个特点：</strong></p>\n<p>1、由于它们的尺寸较小，JWT可以通过URL，POST参数或HTTP头部发送。 另外，尺寸越小意味着传输速度越快。</p>\n<p>2、有效载荷包含有关用户的所有必需信息，避免了多次查询数据库的需要。</p>\n<p><strong>JWT的使用场景：</strong></p>\n<p>1.验证 这是使用JWT 最常见的情况。 一旦用户登录，每个后续请求将包括JWT。它将允许用户访问该令牌允许的路由，服务和资源。 单点登录是当今广泛使用JWT的一项功能，因为它的开销很小，而且能够轻松地跨不同域使用。\n2.信息交换 JWT 是在各方之间安全传输信息的好方法， 因为JWT可以被签名（例如使用公钥/私钥对进行签名）。所以你可以确定发件人是他们说的那个人。 此外，由于使用头部（header）和有效载荷（payload）计算签名，因此您还可以验证内容是否未被篡改。</p>\n<h2 id=\"七、jwt的结构说明\" tabindex=\"-1\"> 七、JWT的结构说明</h2>\n<p>JWT包含三个由点（.）分隔的部分，它们是：</p>\n<ul>\n<li>头部（header）</li>\n<li>有效负载（payload）</li>\n<li>签名（signature）</li>\n</ul>\n<p>因此，JWT通常看起来如下所示:</p>\n<p>xxxxx.yyyyy.zzzzz</p>\n<p>1、头部（header）</p>\n<p>头部（header）通常由两部分组成：令牌的类型（即JWT）和正在使用的散列算法（如HMAC SHA256或RSA）。如下所示：</p>\n<div><pre><code><span>{</span>\n  <span>\"alg\"</span><span>:</span> <span>\"HS256\"</span><span>,</span>\n  <span>\"typ\"</span><span>:</span> <span>\"JWT\"</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>然后，将这个JSON用Base64编码，形成JWT的第一部分。</p>\n<p>2、有效负载（payload）</p>\n<p>令牌的第二部分是包含声明的有效载荷。 声明是关于实体（通常是用户）和附加元数据的声明。 有三种类型的声明：</p>\n<p>标准中注册的声明；</p>\n<p>公开声明；</p>\n<p>私人声明；</p>\n<p>（1）标准中注册的声明：这是一组预先定义的声明，这些声明不是强制性的，但建议提供一套有用的，可互操作的声明。 如下：</p>\n<div><pre><code>iss: jwt签发者\n\nsub: jwt所面向的用户\n\naud: 接收jwt的一方\n\nexp: jwt的过期时间，这个过期时间必须要大于签发时间\n\nnbf: 定义在什么时间之前，该jwt都是不可用的.\n\niat: jwt的签发时间\n\njti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>注意：声明名称只有三个字符长，因为JWT是紧凑的。</p>\n<p>（2）公开声明：这些可以由使用JWT的人员随意定义。 但为避免冲突，应在IANA JSON Web令牌注册表中定义它们，或者将其定义为包含防冲突命名空间的URI。</p>\n<p>（3）私人声明：这是为了共享使用它们的当事方之间共享信息而创建的声明，既不是登记声明，也不是公开声明。</p>\n<p>示例如下：</p>\n<div><pre><code><span>{</span>\n <span>\"sub\"</span><span>:</span> <span>\"1234567890\"</span><span>,</span>\n <span>\"name\"</span><span>:</span> <span>\"john\"</span><span>,</span>\n<span>\"admin\"</span><span>:</span> <span>true</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>然后将有效载荷进行Base64编码，以形成JSON Web令牌的第二部分。</p>\n<p>3、签名（signature）</p>\n<p>要创建签名部分，您必须采用头部（header），有效载荷（payload），密钥（secret），以及头部中指定的算法。例如，如果你想使用HMACSHA256算法，签名将按以下方式创建：</p>\n<div><pre><code>HMACSHA256<span>{</span>\nbase64UrlEncoded(header)+<span>\".\"</span>+base64UrlEncoded(payload)<span>,</span>\nsecret\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>签名通常用于验证JWT的发件人是谁，并JWT在传送的过程中不被篡改。</p>\n<p>注意：上图红框中的secret是保存在服务器端的，JWT的签发生成也是在服务器端的，secret就是用来进行JWT的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret，那就意味着客户端是可以自我签发jwt了。</p>\n<p>4、案例演示</p>\n<p>显示了一个登录请求成功之后服务端返回的Token，它由编码头部（header）、编码有效载荷（payload）和签名（signature）通过（.）拼接而成：</p>\n<p>如果需要，你可以使用jwt.io的Debugger工具，来编码、验证和生成JWT。操作界面如下：</p>\n<h2 id=\"八、jwt的工作原理\" tabindex=\"-1\"> 八、JWT的工作原理</h2>\n<p>在身份验证中，当用户使用他们的凭证（如用户名、密码）成功登录时，后台服务器将返回一个token，前端接收到这个token将其保存在本地（通常在本地存储中，也可以使用Cookie，但不是传统方法中创建会话，服务器并返回一个cookie）。下次用户想要访问受保护的路由或资源时，就将本地保存的token放在头部Header中发送到后台服务器。服务器接收到请求，检查头部中token的存在，如果存在就允许访问受保护的路由或资源，否则就不允许。如下所示：</p>\n<p>一般默认的Value是以“<code>Bearer</code> ”开始，注意这里的<code>Bearer</code>之后有一个空格，以便后端进行分割。</p>\n<p>这是一种无状态身份验证机制，因为用户状态永远不会保存在服务器内存中。由于JWT是独立的，所有必要的信息都在那里，所以减少了多次查询数据库的需求。</p>\n<h2 id=\"九、总结\" tabindex=\"-1\"> 九、总结</h2>\n<p>1、优点</p>\n<ul>\n<li>（1）因为Json的通用性，所以JWT 是可以进行跨语言支持的，像Java、JavaScript、NodeJS、PHP等很多语言都可以使用。</li>\n<li>（2）因为有了payload部分，所以JWT 可以在自身存储一些其他业务逻辑所必要的非敏感信息。</li>\n<li>（3）便于传输，JWT 的构成非常简单，字节占用很小，所以它是非常便于传输的。</li>\n<li>（4）它不需要在服务端保存会话信息, 所以它易于应用的扩展</li>\n</ul>\n<p>2、安全相关</p>\n<ul>\n<li>（1）不应该在JWT的payload 部分存放敏感信息，因为该部分是客户端可解密的部分。</li>\n<li>（2）保护好secret私钥，该私钥非常重要。</li>\n<li>（3）如果可以，请使用HTTPS 协议，不！是务必使用HTTPS!</li>\n</ul>\n",
      "date_published": "2018-02-01T00:00:00.000Z",
      "date_modified": "2022-04-16T23:42:59.000Z",
      "authors": [
        {
          "name": "徐刘根"
        }
      ],
      "tags": []
    },
    {
      "title": "请求正文&响应正文",
      "url": "http://www.zhangsj.xyz/blog/java/spring/@RequestBody&ResponseBody.html",
      "id": "http://www.zhangsj.xyz/blog/java/spring/@RequestBody&ResponseBody.html",
      "content_html": "<h2 id=\"content-type\" tabindex=\"-1\"> Content-Type</h2>\n<h3 id=\"application-x-www-form-urlencoded\" tabindex=\"-1\"> application/x-www-form-urlencoded</h3>\n<p>application/x-www-form-urlencoded主要用于表单形式的POST请求中，如普通的表单提交，或者js发包，默认都是通过这种方式，可以使用Postman来发一个这种类型请求：</p>\n<p>用get提交，和post提交是一样的，数据格式都是这样，get和post的区别是，get显示地址栏中，post提交是不显示的，相对于get来说，post这种提交方式更加安全</p>\n<h3 id=\"multipart-form-data\" tabindex=\"-1\"> multipart/form-data</h3>\n<p>multipart/form-data是使用POST请求上传文件，如果上传照片，文件等，由于很多情况下都会有批量上传，为了区分不同的数据，multipart/form-data的类型有boundary参数进行分割，对上传文件请求抓包，request头部信息如下：</p>\n<p>此时的数据格式是json格式：</p>\n<p>a=123&amp;b=123&amp;c=123</p>\n<p>用get提交，和post提交是一样的，数据格式都是这样，get和post的区别是，get显示地址栏中，post提交是不显示的，相对于get来说，post这种提交方式更加安全</p>\n<p>如果说是 a=123&amp;b=123&amp;c=123这种格式的话。，spring会自动的去转成对象的格式</p>\n<h3 id=\"application-json\" tabindex=\"-1\"> application/json</h3>\n<p>application/json是POST请求以JSON的格式向服务请求发起请求或者请求返回JSON格式的响应内容，服务端接受到数据后对JSON进行解析拿到所需要的参数，同样适用Postman模拟一个请求：</p>\n<p>此时的数据格式是json格式：</p>\n<p>{“a”，“b”，“c”，“d”}。</p>\n<p>那么这种格式的话，Spring就无法自动转化为对象，那么如何解决呢？ 就会自动将json数据转化为对象（实体类）</p>\n<h2 id=\"requestbody\" tabindex=\"-1\"> @RequestBody</h2>\n<p>@RequestBody的作用是将前端传来的json格式的数据转为自己定义好的javabean对象</p>\n<p>@RequestBody要写在方法的参数前</p>\n<p>如图以微信小程序为例，前端向后端传入如下json格式的</p>\n<p>传入数据的属性名称要和后端javabean中定义的一致</p>\n<h2 id=\"responsebody\" tabindex=\"-1\"> @ResponseBody</h2>\n<p>@ResponseBody的作用是将后端以return返回的javabean类型数据转为json格式数据输出到HTTP响应中</p>\n",
      "date_published": "2019-06-23T00:00:00.000Z",
      "date_modified": "2022-04-14T05:48:05.000Z",
      "authors": [],
      "tags": [
        "spring"
      ]
    },
    {
      "title": "动态规划理念",
      "url": "http://www.zhangsj.xyz/blog/algo/dynamic-programming-idea.html",
      "id": "http://www.zhangsj.xyz/blog/algo/dynamic-programming-idea.html",
      "content_html": "<p>动态规划，无非就是利用历史纪录，以便我们的重复计算。而这些历史纪录，我们得需要一些变量来保存，一般就是用一维数组或者二维数组来保存。</p>\n",
      "date_published": "2022-04-14T00:58:56.000Z",
      "date_modified": "2022-04-14T05:48:05.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "链表算法",
      "url": "http://www.zhangsj.xyz/blog/algo/linked-list-determines-that-there-is-a-cycle-recursive-inversion.html",
      "id": "http://www.zhangsj.xyz/blog/algo/linked-list-determines-that-there-is-a-cycle-recursive-inversion.html",
      "content_html": "<h2 id=\"链表算法\" tabindex=\"-1\"> 链表算法</h2>\n<p>判断链表是否有环</p>\n<p>定义一个临时变量引用指向当前的节点</p>\n<p>定义一个 hashmap。Key 与 value 当时当前的节点。</p>\n<p>该节点存在于 hashmap 中，node.get(tmp) ，则确定有环， 没有就存放该的节点。</p>\n<h2 id=\"单链表反转\" tabindex=\"-1\"> 单链表反转</h2>\n<p>从当前链表的首节点开始循环遍历，一直到链表的最后一个节点，会逐个改变所遍历的节点的指针域，另其指向前一个节点。</p>\n<p>具体的实现方法也很简单，借助三个指针即可。首先我们定义 3 个指针并分别命名为 begn，mid，end。他们的初始指向如图 3 所示：</p>\n<p><a href=\"docs/algo/img/1-1.png\"></a></p>\n<h2 id=\"递归反转\" tabindex=\"-1\"> 递归反转</h2>\n<p>链表的尾节点开始，依次向前遍历，遍历过程一次改变各节点的指向，即另其指向前一个节点。</p>\n<div><pre><code><span>class</span> <span>Node</span> <span>{</span>\n <span>private</span> <span>int</span> <span>Data</span><span>;</span><span>// 数据域</span>\n <span>private</span> <span>Node</span> <span>Next</span><span>;</span><span>// 指针域</span>\n <span>public</span> <span>Node</span><span>(</span><span>int</span> <span>Data</span><span>)</span> <span>{</span>\n  <span>// super();</span>\n  <span><span>this<span>.</span></span>Data</span> <span>=</span> <span>Data</span><span>;</span>\n <span>}</span>\n<span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><pre><code><span>public</span> <span>class</span> javatest1 <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>Node</span> head <span>=</span> <span>new</span> <span>Node</span><span>(</span><span>0</span><span>)</span><span>;</span>\n        <span>Node</span> node1 <span>=</span> <span>new</span> <span>Node</span><span>(</span><span>1</span><span>)</span><span>;</span>\n        <span>Node</span> node2 <span>=</span> <span>new</span> <span>Node</span><span>(</span><span>2</span><span>)</span><span>;</span>\n        <span>Node</span> node3 <span>=</span> <span>new</span> <span>Node</span><span>(</span><span>3</span><span>)</span><span>;</span>\n        head<span>.</span><span>setNext</span><span>(</span>node1<span>)</span><span>;</span>\n        node1<span>.</span><span>setNext</span><span>(</span>node2<span>)</span><span>;</span>\n        node2<span>.</span><span>setNext</span><span>(</span>node3<span>)</span><span>;</span>\n\n        <span>// 调用反转方法</span>\n        head <span>=</span> <span>Reverse1</span><span>(</span>head<span>)</span><span>;</span>\n         <span>while</span> <span>(</span><span>null</span> <span>!=</span> head<span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>head<span>.</span><span>getData</span><span>(</span><span>)</span> <span>+</span> <span>\" \"</span><span>)</span><span>;</span>\n            head <span>=</span> head<span>.</span><span>getNext</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>/**\n     * 递归，在反转当前节点之前先反转后续节点\n     */</span>\n    <span>public</span> <span>static</span> <span>Node</span> <span>Reverse1</span><span>(</span><span>Node</span> head<span>)</span> <span>{</span>\n        <span>// head看作是前一结点，head.getNext()是当前结点，reHead是反转后新链表的头结点</span>\n        <span>if</span> <span>(</span>head <span>==</span> <span>null</span> <span>||</span> head<span>.</span><span>getNext</span><span>(</span><span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            <span>return</span> head<span>;</span><span>// 若为空链或者当前结点的下一个节点在尾结点，则直接还回</span>\n        <span>}</span>\n        <span>Node</span> reHead <span>=</span> <span>Reverse1</span><span>(</span>head<span>.</span><span>getNext</span><span>(</span><span>)</span><span>)</span><span>;</span><span>// 先反转后续节点head.getNext()</span>\n        head<span>.</span><span>getNext</span><span>(</span><span>)</span><span>.</span><span>setNext</span><span>(</span>head<span>)</span><span>;</span><span>// 将当前结点的指针域指向前一结点</span>\n        head<span>.</span><span>setNext</span><span>(</span><span>null</span><span>)</span><span>;</span><span>// 前一结点的指针域令为null;</span>\n        <span>return</span> reHead<span>;</span><span>// 反转后新链表的头结点</span>\n    <span>}</span>\n<span>}</span>\n\n\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div>",
      "date_published": "2022-04-14T00:58:56.000Z",
      "date_modified": "2022-04-14T05:48:05.000Z",
      "authors": [],
      "tags": [
        "算法"
      ]
    },
    {
      "title": "幽默笑话",
      "url": "http://www.zhangsj.xyz/blog/note/humorous-jokes.html",
      "id": "http://www.zhangsj.xyz/blog/note/humorous-jokes.html",
      "content_html": "<p>搞学术的为什么都睡得那么晚，难道只有到晚上才有灵感？不是，姑娘，搞学术不靠灵感，靠的是碌碌无为的白天引发的愧疚心。</p>\n<p>单身程序狗解决了一个技术难题后没有妹子可以炫耀或夸一下自己怎么办？</p>\n<p>现在你明白了吧，为什么那么多程序员要写技术博客。</p>\n<p>“玩算法的码农，打拼靠蓝条，像是法师。数学就等于蓝条最大值，数学差，魔法值不高，很快就到瓶颈了。外语影响回蓝速度。经验和智力加急速和穿透的。不玩算法的码农，像是战士，打拼靠血条，体质加生命，精神加生命回复，经验和敏捷加急速和破甲。</p>\n",
      "date_published": "2022-04-14T00:58:56.000Z",
      "date_modified": "2022-04-14T05:48:05.000Z",
      "authors": [],
      "tags": [
        "摘录"
      ]
    },
    {
      "title": "说说你对技术与业务的理解",
      "url": "http://www.zhangsj.xyz/blog/exam/yewu/medical-insurance.html",
      "id": "http://www.zhangsj.xyz/blog/exam/yewu/medical-insurance.html",
      "content_html": "<h2 id=\"医保核心业务\" tabindex=\"-1\"> 医保核心业务</h2>\n<p>北京新医保核心业务的开发(08.03~04.15)，</p>\n<ol>\n<li>手工报销结算模块：</li>\n<li>票据扫描，票据文件报盘导入，提供两定接口，院端自费信息上传接口，</li>\n<li>院端上传的自费信息进行预结算，结算；添加相应的规则校验；</li>\n<li>手工报销结算模块(医照人员)模块：单位报盘自费信息导入，数据审核，补支、追回及其审核模块；对明细进行分割，各个分笔的费用进行金额的分割；\n<ul>\n<li>预结算，将个人信息，就诊的信息，明细信息调支付方式，得出最后可以结算信息，(报销的金额，各项医保基金支出的金额)，如统筹基金，大额基金，军残基金；</li>\n<li>结算，将预结算算出的结算信息保存，同时保存参保人的待遇累计信息；</li>\n</ul>\n</li>\n<li>手工报销费用补支、追回及其审核发财务；</li>\n</ol>\n<p>单位将单位参保人自费的信息进行汇总，通过报盘导入，</p>\n<p>金额是单位将明细的金额进行分类，保存的是分类项金额，不是具体的明细金额</p>\n<p>灵活就业，纯手工录入七大项金额；就诊，明细信息需要机构传入，然后，再经办模块直接结算；模式增加了单位和机构的工作量；</p>\n<p>补充校验规则，重复校验、转归死亡、跨年校验、是否已报销、定点校验、特病校验、门诊住院交叉校验</p>\n<p>上传模块还可以进行批量结算，初审时，多次门诊交易可以结成一笔结算信息；</p>\n<h2 id=\"大数据批量导入\" tabindex=\"-1\"> 大数据批量导入</h2>\n<p>项目前期给监管平台做的大数据批量导出的功能，前端查询模块查询业务数据，有导出功能，选择条件，将数据导出 excel 文件，每天业务量数据很大，每天都好几千万的数据。还要实现进度条的功能</p>\n<ol>\n<li>使用 easyexcel 框架，分批次导出，50 万作为一个 excel 的导出文件，假如有 1000 万条数据，需要 for 循环 20 次，每次循环，去用 limit 分批次查询，当所有 excel 文件生成，将 20 个 excel 文件打包，给前端提供压缩文件的地址</li>\n<li>使用流式查询，防止内存的溢出</li>\n<li>使用 redis 保存该用户各个导出文件的进度，前端专门画了一个页面去查看用户所有导出事件文件生成的进度，<code>redis</code> 结构使用 <code>hash</code> 结构，key 使用用户的 id，<code>value</code> 中的 <code>hash</code> 的 <code>key</code>，导出文件的文件名，value 是导出文件的生成的进度，当压缩文件生成完，<code>value</code> 为压缩文件的地址，前端使用定时器，不停的调查询接口，查询缓存中保存的进度</li>\n</ol>\n<p>用户正在导出的数据过多，可以添加限制次数，前端可以判断 value 值是文件地址时，显示可导出，导出按钮将文件下载。</p>\n<p>每次向文件里面追加数据，类似与 <code>aof</code></p>\n<p>调用 <code>ArrayList.clear()</code>，或者把对象置空,使用 <code>JProfile</code> 进行内存检测</p>\n<p>通过 <code>JProfile</code> 内存分析.最终问题定位完毕.</p>\n<p>原因如下：100W 数据  生成一个文件的过程中，等文件生成完毕之后才能把数据库中的数据备份到历史表中，这个时候才能进行事务的提交，也就是执行 commit()， 并且删除原表数据，100W 数据按照 3000 一批写入文件，每批次只是通过 <code>PreparedStatement.addBatch()</code>;加入到批次里面去,并没有执行 <code>PreparedStatement.executeBatch()</code>,而是在 <code>commit()</code> 之前统一调用的 <code>PreparedStatement.executeBatch()</code>，这样的话 <code>PreparedStatement</code> 就会缓存 100W 条数据信息，造成了内存溢出.</p>\n<h3 id=\"改进\" tabindex=\"-1\"> 改进</h3>\n<p><code>Spring Batch</code> 做批量。根据数据库的时间或者 ID 来进行批量处理后生成文件。然后将生成的文件放到某一个存储位置</p>\n",
      "date_published": "2022-04-14T00:58:56.000Z",
      "date_modified": "2022-04-16T23:42:59.000Z",
      "authors": [],
      "tags": [
        "其他"
      ]
    },
    {
      "title": "explain执行计划",
      "url": "http://www.zhangsj.xyz/blog/java/datasource/explain-execution-plan.html",
      "id": "http://www.zhangsj.xyz/blog/java/datasource/explain-execution-plan.html",
      "content_html": "<h2 id=\"explain-执行计划\" tabindex=\"-1\"> explain 执行计划</h2>\n<p>合理设计并利用索引</p>\n<p>使用EXPLAIN关键字，可以模拟Mysql优化器执行SQL语句，分析查询语句的性能。</p>\n<p>在select语句之前加上explain关键字，mysql会在查询上设置一个标记，执行查询的时候并不是真正的执行sql语句，而是返回该语句的<code>执行计划</code>。</p>\n<p>注意：如果from钟包含子查询，任然会执行该子查询，将结果放入临时表。</p>\n<h2 id=\"explain中\" tabindex=\"-1\"> explain中</h2>\n<ol>\n<li><code>id</code>列的编号是select的序列号，有几个select就有几个id，并且id的大小是根据select出现的先后顺序增长的。id数值越大越先执行，id相同则从上往下执行，id为null的最后执行。</li>\n<li><code>select_type</code></li>\n</ol>\n<ul>\n<li>①simple：简单查询，不包含子查询和union的查询</li>\n<li>②primary：复杂查询中最外层的select。</li>\n<li>③subquery：包含在select中的子查询（不在from字句中）。</li>\n<li>④derived：包含在from子句中的子查询。mysql会将结果放在一个临时表中，也叫派生表。</li>\n<li>⑤union：在union中的第二个和随后的select。\n3、table 这一列表示explain的一行正在访问哪个表。</li>\n<li>当from子句中有子查询的时候，table列是的格式，表示当前查询依赖id=N的查询。</li>\n<li>当有union的时候，table列的值为&lt;union1,2&gt;的格式，1和2表示参与union的select行id。</li>\n</ul>\n<ol start=\"4\">\n<li>type<i>Content not supported</i></li>\n</ol>\n<p>这一列表示关联类型或者访问类型，也可以理解成mysql是如何决定查找表中的行，查找数据行的大概范围。性能从优到差分别为：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL，一般来说需要保证查询达到range级别，最好达到ref。</p>\n<p>①null：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：再索引列中取最小值可以单独查找索引来完成，不需要在执行时访问表。</p>\n<p>②：const，system：mysql能对查询的某部分进行优化并将其转化成一个常量（可以看showwarnings的结果）。用于primarykey或uniquekey的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。system是const的特例，表里只有一条元组匹配时为system。</p>\n<p>③eq_ref:primarykey或uniquekey索引的所有部分被连接使用，最多只会返回一条符合条件的记录。这可能是在const之外最好的联接类型了，简单的select查询不会出现这种type。</p>\n<p>④ref：相比eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。</p>\n<p>简单select查询，name是普通索引（非唯一索引）</p>\n<p>⑤range：范围扫描通常出现在in(),between,&gt;,&lt;,&gt;=等操作中。使用一个索引来检索给定范围的行。</p>\n<p>⑥index：扫描全索引就能拿到结果，一般是扫描某个二级索引，这种扫描不会从索引树根节点开始快速查找，而是直接对二级索引的叶子节点遍历和扫描，速度还是比较慢的，这种查询一般为使用覆盖索引，二级索引一般比较小，所以这种通常比ALL快一些。</p>\n<p>⑦ALL:即全表扫描，扫描你的聚簇索引的所有叶子节点。通常情况下这需要增加索引来进行优化了。</p>\n<p>5、possible_keys</p>\n<p>这一列显示查询可能使用哪些索引来查找。 explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引 对此查询帮助不大，选择了全表查询。 如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提 高查询性能，然后用 explain 查看效果。</p>\n<p>6、key</p>\n<p>这一列显示mysql实际采用哪个索引来优化对该表的访问。 如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，在查询中使用 force index、ignore index。</p>\n<p>7、key_len</p>\n<p>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。 举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成，并且每个int是4字节。通 过结果中的key_len=4可推断出查询使用了第一个列：film_id列来执行索引查找。</p>\n<p>key_len计算规则如下：</p>\n<p>字符串</p>\n<p><code>char(n)</code> 和varchar(n)，5.0.3 以后版本中，n均代表字符数，而不是字节数，如果是utf-8，一个数字或字母占1个字节，一个汉字占3个字节\n<code>char(n)</code>：如果存汉字长度就是 3n 字节\n<code>varchar(n)</code>：如果存汉字则长度是<code>3n+2</code>字节，加的2字节用来存储字符串长度，因为<code>varchar</code>是变长字符串</p>\n<p>数值类型：tinyint：1字节,smallint：2字节,int：4字节,bigint：8字节</p>\n<p>时间类型：date：3字节,timestamp：4字节,datetime：8字节</p>\n<p>如果字段允许为 NULL，需要1字节记录是否为 NULL\n索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索 引。</p>\n<p>8、ref：这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id）</p>\n<p>9、rows：这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。</p>\n<h3 id=\"extra\" tabindex=\"-1\"> extra</h3>\n<ul>\n<li><code>Using filesort</code>：MySQL 需要额外的一次传递，以找出如何按排序顺序检索行。通过根据联接类型浏览所有行并为所有匹配WHERE子句的行保存排序关键字和行的指针完成排序。然后关键字被排序，并按排序顺序检索行</li>\n<li><code>Using temporary</code>：使用了临时表保存中间结果，性能特别查，需要重点优化;</li>\n<li><code>Using index</code>： 使用覆盖索引，不需要通过辅助索引树找到主键，再通过主键去主键索引树里获取其它字段值。</li>\n<li><code>Using index</code> condition：MySQL5.6之后新增的ICP，<code>using index condtion</code>就是使用了ICP（索引下推），在存储引擎层进行数据过滤，而不是在服务层过滤，利用索引现有的数据减少回表的数据。</li>\n<li><code>Select tables optimized away</code>：使用某些聚合函数（比如 max、min）来访问存在索引的某个字段</li>\n<li><code>Using where</code>： 使用 <code>where</code>语句来处理结果，并且查询的列未被索引覆盖</li>\n</ul>\n<p>5、确定问题并采用相应的措施</p>\n<ul>\n<li>优化索引；</li>\n<li>优化SQL语句：修改SQL、IN 查询分段、时间查询分段、基于上一次数据过滤；</li>\n<li>改用其他实现方式：ES、数仓等；</li>\n<li>数据碎片处理。</li>\n</ul>\n",
      "date_published": "2020-09-01T00:00:00.000Z",
      "date_modified": "2022-04-14T05:48:05.000Z",
      "authors": [],
      "tags": [
        "mysql"
      ]
    },
    {
      "title": "MySQL事务",
      "url": "http://www.zhangsj.xyz/blog/java/datasource/mysql-transaction.html",
      "id": "http://www.zhangsj.xyz/blog/java/datasource/mysql-transaction.html",
      "summary": "MySQL事务",
      "content_html": "<h2 id=\"mysql特性\" tabindex=\"-1\"> mysql特性</h2>\n<p>原子性：事务是一个不可分割的工作单位，事务中的操作要么都成功（commit），要么都失败（rollback）。</p>\n<p>一致性：事务前后数据的完整性必须保持一致。 事务执行的结果必须使数据库从一个一致性状态变到另一个一致性的状态。在多个事务并行情况下；</p>\n<p>持久性：指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</p>\n<p>隔离性： 事务的隔离性是多个事务并行，每个事务不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。</p>\n<h2 id=\"mysql事务隔离级别\" tabindex=\"-1\"> mysql事务隔离级别</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">事务隔离级别</th>\n<th>概念</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">read uncommitted(未提交读)</td>\n<td>允许当前事务读取到其他事务未提交的数据,会出现脏读、不可重复读、幻读</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">read committed(读已提交)</td>\n<td>对事务已经提交的数据进行读取，解决了脏读。会出现幻读和不可重复读</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">repeatable read(可重复读)</td>\n<td>在同一个事务中，对相同查询条件，读取数据都是一致的。该级别会出现幻读</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">serializable(串行化)</td>\n<td>完全服从数据库的ACID，读写数据都会锁住在事务中涉及到的数据库表，并发性能极低</td>\n</tr>\n</tbody>\n</table>\n<p>MySQL 默认使用 RR 的事务隔离级别。</p>\n<ul>\n<li>脏读：没有提交就可以读取到数据；</li>\n<li>不可重复读：再重复读一次，数据与上次读到的数据不一样；</li>\n<li>幻读：在查询某一条件的数据，开始查询后，别人又加入或删除某些数据，再读取时与原来的数据不一样了。</li>\n</ul>\n<p>不可重复读形成原因在于数据的修改：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）。</p>\n<p>幻读形成原因主要在于数据的新增或删除：在同一事务中，同样的条件，第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）。</p>\n<h3 id=\"redo-log\" tabindex=\"-1\"> redo log</h3>\n<p>redo log是重做日志，提供前滚操作，</p>\n<p>记录的是数据修改之后的值，不管事务是否提交都会记录下来。在mysql服务器宕机时，InnoDB存储引擎会使用redo log恢复到掉电前的时刻，以此来保证数据的完整性。</p>\n<h3 id=\"undo-log\" tabindex=\"-1\"> undo log</h3>\n<p>undo log是回滚日志，提供回滚操作。</p>\n<p>保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读</p>\n<h3 id=\"binlog\" tabindex=\"-1\"> binlog</h3>\n<p>binlog是追加日志,又称为归档日志，属于逻辑日志，</p>\n<p>binlog是属于MySQL Server层面的，又称为归档日志，属于逻辑日志，是记录原始的sql语句，逻辑</p>\n<p>不支持高并发，以读为主</p>\n<p>共享锁，排它锁，意向锁</p>\n<h2 id=\"mvvc实现原理\" tabindex=\"-1\"> mvvc实现原理</h2>\n<p>MVCC (<code>Multi-Version Concurrency Control</code>) (注：与MVCC相对的，是基于锁的并发控制，<code>Lock-Based Concurrency Control</code>)是一种基于多版本的并发控制协议，只有在<code>InnoDB</code>引擎下存在。 <code>MVCC</code>是为了实现事务的隔离性，通过版本号，避免同一数据在不同事务间的竞争，你可以把它当成基于多版本号的一种乐观锁。 当然，这种乐观锁只在事务级别提交读和可重复读有效。<code>MVCC</code>最大的好处，相信也是耳熟能详：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大地增加了系统的并发性能。</p>\n<div><p>OLTP</p>\n<p><code>On-Line Transaction Processing</code>联机事务处理过程(OLTP)，也称为面向交易的处理过程，其基本特征是前台接收的用户数据可以立即传送到计算中心进行处理，并在很短的时间内给出处理结果，是对用户操作快速响应的方式之一。</p>\n</div>\n<p>你可以简单的理解为MVCC为每一行增加了两个隐藏字段，两个字段分别保存了这个行的当前事务ID跟行的删除事务ID。</p>\n<p><strong>1、insert时：</strong></p>\n<p><code>InnoDB</code>为新插入的每一行保存当前系统版本号作为版本号。</p>\n<p><strong>2、select时：</strong></p>\n<ol>\n<li><code>InnoDB</code>只会查找版本早于当前事务版本的数据行(也就是行的系统版本号&lt;=事务的系统版本号)，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</li>\n<li>行的删除版本要么未定义，要么大于当前事务版本号，这可以确保事务读取到的行在事务开始之前未被删除。</li>\n<li>只有1，2 同时满足的记录，才能返回作为查询结果。</li>\n</ol>\n<p><strong>3、delete时：</strong></p>\n<p>InnoDB会为删除的每一行保存当前系统的版本号(事务的ID)作为删除标识.</p>\n<p><strong>4、<code>update</code>时：</strong></p>\n<p><code>InnoDB</code>执行<code>update</code>，实际上是新插入了一行记录，并保存其创建时间为当前事务的ID，同时保存当前事务ID到要update的行的删除时间。</p>\n<p>上面只是一个浅显地讲解<code>MVCC</code>选择标准流程，源码层面应该是根据低水位跟高水位来截取的。具体实现可自行百度。</p>\n<p>重点：</p>\n<ol>\n<li>事务中快照读的结果是非常依赖该事务首次出现快照读的地方，即某个事务中首次出现快照读的地方非常关键，它有决定该事务后续快照读结果的能力。</li>\n<li>在<code>RC</code>隔离级别下，是每个快照读都会生成并获取最新的<code>ReadView</code>；而在<code>RR</code>隔离级别下，则是同一个事务中的第一个快照读才会创建<code>ReadView</code>, 之后的快照读获取的都是同一个<code>ReadView</code>。</li>\n</ol>\n<p>四个隐式字段：</p>\n<ol>\n<li><code>DB_TRX_ID</code>：6byte，最近修改(修改/插入)事务ID，记录创建这条记录/最后一次修改该记录的事务ID；</li>\n<li><code>DB_ROLL_PTR</code>：7byte，回滚指针，指向这条记录的上一个版本（存储于<code>rollback segment</code>里）；</li>\n<li><code>DB_ROW_ID</code>：6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以<code>DB_ROW_ID</code>产生一个聚簇索引；</li>\n<li><code>FLAG</code>：一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了；</li>\n</ol>\n<p>事务对一条记录的修改，会导致该记录的undo log成为一条记录版本线性表(链表)，undo log的链首就是最新的旧记录，链尾就是最早的旧记录。</p>\n<p>undo日志：此知识点上文已经说过了，对MVCC有帮助的实质是<code>update undo log</code>，<code>undo log</code>实际上就是存在<code>rollback segment</code>中旧记录链。</p>\n<p>一致读视图 <code>Consistent Read View</code>：<code>Read View</code>是事务进行快照读操作的时候生产的读视图(<code>Read View</code>)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(InnoDB里面每个事务有一个唯一的事务ID，叫作transaction id。它是在事务开始的时候向InnoDB的事务系统申请的，是按申请顺序严格递增的)。拿着这个ID跟记录中ID对比进行选择性展示，这里说下大致的思维。</p>\n<h2 id=\"当前读\" tabindex=\"-1\"> 当前读</h2>\n<ol>\n<li>像<code>select lock in share mode</code>(共享锁)、<code>select for update</code> 、<code>update</code>、<code>insert</code>、<code>delete</code>(排他锁)这些操作都是一种当前读，就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会<strong>对读取的记录进行加锁</strong>。</li>\n<li>当前读可以认为是悲观锁的具体功能实现</li>\n</ol>\n<h3 id=\"快照读\" tabindex=\"-1\"> 快照读</h3>\n<ol>\n<li>不加锁的<code>select</code>就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC，可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。</li>\n<li>快照读就是<code>MVCC</code>思想在MySQL的具体非阻塞读功能实现，<code>MVCC</code>的目的就是为了实现读-写冲突不加锁，提高并发读写性能，而这个读指的就是快照读。</li>\n</ol>\n",
      "date_published": "2022-02-28T00:00:00.000Z",
      "date_modified": "2022-05-24T07:41:43.000Z",
      "authors": [],
      "tags": [
        "mysql"
      ]
    },
    {
      "title": "sql优化",
      "url": "http://www.zhangsj.xyz/blog/java/datasource/mysql-tuning.html",
      "id": "http://www.zhangsj.xyz/blog/java/datasource/mysql-tuning.html",
      "content_html": "<h2 id=\"一、前言\" tabindex=\"-1\"> 一、前言</h2>\n<p>在应用开发的早期，数据量少，开发人员开发功能时更重视功能上的实现，随着生产数据的增长，很多SQL语句开始暴露出性能问题，对生产的影响也越来越大，有时可能这些有问题的SQL就是整个系统性能的瓶颈。</p>\n<h2 id=\"二、sql优化一般步骤\" tabindex=\"-1\"> 二、SQL优化一般步骤</h2>\n<p>1、通过慢查日志等定位那些执行效率较低的SQL语句\n2、explain 分析SQL的执行计划需要重点关注 type、rows、filtered 、extra。\ntype由上至下，效率越来越高。</p>\n<ul>\n<li>ALL 全表扫描；</li>\n<li>index 索引全扫描；</li>\n<li>range 索引范围扫描，常用语&lt;,&lt;=,&gt;=,between,in等操作；</li>\n<li>ref 使用非唯一索引扫描或唯一索引前缀扫描，返回单条记录，常出现在关联查询中；</li>\n<li>eq_ref 类似ref，区别在于使用的是唯一索引，使用主键的关联查询；</li>\n<li>const/system 单条记录，系统会把匹配行中的其他列作为常数处理，如主键或唯一索引查询；</li>\n<li>null MySQL不访问任何表或索引，直接返回结果；\n虽然上至下，效率越来越高，但是根据cost模型，假设有两个索引idx1(a, b, c),idx2(a, c)，SQL为\nExtra</li>\n<li>Using filesort：MySQL 需要额外的一次传递，以找出如何按排序顺序检索行。通过根据联接类型浏览所有行并为所有匹配WHERE子句的行保存排序关键字和行的指针来完成排序。然后关键字被排序，并按排序顺序检索行；</li>\n<li>Using temporary ：使用了临时表保存中间结果，性能特别差，需要重点优化；</li>\n<li>Using index：表示相应的 select 操作中使用了覆盖索引（Coveing Index）,避免访问了表的数据行，效率不错！如果同时出现 using where，意味着无法直接通过索引查找来查询到符合条件的数据；</li>\n<li>Using index condition ：MySQL5.6之后新增的ICP，using index condtion就是使用了ICP（索引下推），在存储引擎层进行数据过滤，而不是在服务层过滤，利用索引现有的数据减少回表的数据。</li>\n</ul>\n<p>3、show profile分析</p>\n<p>了解SQL执行的线程的状态及消耗的时间。</p>\n<p>默认是关闭的，开启语句“set profiling = 1;”</p>\n<div><pre><code>SHOW PROFILES ;\nSHOW PROFILE FOR QUERY  #{id};\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br></div></div><p>4、trace</p>\n<p>trace分析优化器如何选择执行计划，通过trace文件能够进一步了解为什么优惠券选择A执行计划而不选择B执行计划。</p>\n<div><pre><code>set optimizer_trace=\"enabled=on\";\nset optimizer_trace_max_mem_size=1000000;\nselect * from information_schema.optimizer_trace;\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>5、确定问题并采用相应的措施</p>\n<p>优化索引；</p>\n<p>优化SQL语句：修改SQL、IN 查询分段、时间查询分段、基于上一次数据过滤；</p>\n<p>改用其他实现方式：ES、数仓等；</p>\n<p>数据碎片处理。</p>\n<h2 id=\"三、场景分析\" tabindex=\"-1\"> 三、场景分析</h2>\n<h3 id=\"_1、最左匹配\" tabindex=\"-1\"> 1、最左匹配</h3>\n<p>1）索引</p>\n<p>KEY <code>idx_shopid_orderno</code> (<code>shop_id</code>,<code>order_no</code>)</p>\n<p>2）SQL语句</p>\n<p>select * from _t where orderno=''</p>\n<p>查询匹配从左往右匹配，要使用order_no走索引，必须查询条件携带shop_id或者索引(shop_id,order_no)调换前后顺序。</p>\n<h3 id=\"_2、隐式转换\" tabindex=\"-1\"> 2、隐式转换</h3>\n<p>1）索引</p>\n<div><pre><code><span>KEY</span> <span><span>`</span>idx_mobile<span>`</span></span> <span>(</span><span><span>`</span>mobile<span>`</span></span><span>)</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br></div></div><p>2）SQL语句</p>\n<div><pre><code><span>select</span> <span>*</span> <span>from</span> _user <span>where</span> mobile<span>=</span><span>12345678901</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br></div></div><p>隐式转换相当于在索引上做运算，会让索引失效。mobile是字符类型，使用了数字，应该使用字符串匹配，否则MySQL会用到隐式替换，导致索引失效。</p>\n<h3 id=\"_3、大分页\" tabindex=\"-1\"> 3、大分页</h3>\n<p>1）索引</p>\n<div><pre><code><span>KEY</span> <span><span>`</span>idx_a_b_c<span>`</span></span> <span>(</span><span><span>`</span>a<span>`</span></span><span>,</span> <span><span>`</span>b<span>`</span></span><span>,</span> <span><span>`</span>c<span>`</span></span><span>)</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br></div></div><p>2）SQL语句</p>\n<div><pre><code><span>select</span> <span>*</span> <span>from</span> _t <span>where</span> a <span>=</span> <span>1</span> <span>and</span> b <span>=</span> <span>2</span> <span>order</span> <span>by</span> c <span>desc</span> <span>limit</span> <span>10000</span><span>,</span> <span>10</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br></div></div><p>对于大分页的场景，可以优先让产品优化需求，如果没有优化的，有如下两种优化方式：</p>\n<p>一种是把上一次的最后一条数据，也即上面的c传过来，然后做“c &lt; xxx”处理，但是这种一般需要改接口协议，并不一定可行；‘</p>\n<p>另一种是采用延迟关联的方式进行处理，减少SQL回表，但是要记得索引需要完全覆盖才有效果，SQL改动如下：</p>\n<div><pre><code><span>select</span> t1<span>.</span><span>*</span> <span>from</span> _t t1<span>,</span> <span>(</span><span>select</span> id <span>from</span> _t <span>where</span> a <span>=</span> <span>1</span> <span>and</span> b <span>=</span> <span>2</span> <span>order</span> <span>by</span> c <span>desc</span> <span>limit</span> <span>10000</span><span>,</span> <span>10</span><span>)</span> t2 <span>where</span> t1<span>.</span>id <span>=</span> t2<span>.</span>id<span>;</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br></div></div><h3 id=\"_4、in-order-by\" tabindex=\"-1\"> 4、in + order by</h3>\n<p>1）索引</p>\n<div><pre><code><span>KEY</span> <span><span>`</span>idx_shopid_status_created<span>`</span></span> <span>(</span><span><span>`</span>shop_id<span>`</span></span><span>,</span> <span><span>`</span>order_status<span>`</span></span><span>,</span> <span><span>`</span>created_at<span>`</span></span><span>)</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br></div></div><p>2）SQL语句</p>\n<div><pre><code><span>select</span> <span>*</span> <span>from</span> _order <span>where</span> shop_id <span>=</span> <span>1</span> <span>and</span> order_status <span>in</span> <span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span> <span>order</span> <span>by</span> created_at <span>desc</span> <span>limit</span> <span>10</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br></div></div><p>in查询在MySQL底层是通过n*m的方式去搜索，类似union，但是效率比union高。</p>\n<p>in查询在进行cost代价计算时（代价 = 元组数 * IO平均值），是通过将in包含的数值，一条条去查询获取元组数的，因此这个计算过程会比较的慢，所以MySQL设置了个临界值(eq_range_index_dive_limit)，5.6之后超过这个临界值后该列的cost就不参与计算了。因此会导致执行计划选择不准确。默认是200，即in条件超过了200个数据，会导致in的代价计算存在问题，可能会导致Mysql选择的索引不准确。</p>\n<p>3）处理方式</p>\n<p>可以(order_status, created_at)互换前后顺序，并且调整SQL为延迟关联。</p>\n<h3 id=\"_5、范围查询阻断-后续字段不能走索引\" tabindex=\"-1\"> 5、范围查询阻断，后续字段不能走索引</h3>\n<p>1）索引</p>\n<div><pre><code><span>KEY</span> <span><span>`</span>idx_shopid_created_status<span>`</span></span> <span>(</span><span><span>`</span>shop_id<span>`</span></span><span>,</span> <span><span>`</span>created_at<span>`</span></span><span>,</span> <span><span>`</span>order_status<span>`</span></span><span>)</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br></div></div><p>2）SQL语句</p>\n<div><pre><code><span>select</span> <span>*</span> <span>from</span> _order <span>where</span> shop_id <span>=</span> <span>1</span> <span>and</span> created_at <span>></span> <span>'2021-01-01 00:00:00'</span> <span>and</span> order_status <span>=</span> <span>10</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br></div></div><p>范围查询还有“IN、between”。</p>\n<h3 id=\"_6、不等于、不包含不能用到索引的快速搜索\" tabindex=\"-1\"> 6、不等于、不包含不能用到索引的快速搜索</h3>\n<p>可以用到ICP</p>\n<div><pre><code><span>select</span> <span>*</span> <span>from</span> _order <span>where</span> shop_id<span>=</span><span>1</span> <span>and</span> order_status <span>not</span> <span>in</span> <span>(</span><span>1</span><span>,</span><span>2</span><span>)</span>\n<span>select</span> <span>*</span> <span>from</span> _order <span>where</span> shop_id<span>=</span><span>1</span> <span>and</span> order_status <span>!=</span> <span>1</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br></div></div><p>在索引上，避免使用NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT EXISTS、NOT IN、NOT LIKE等。</p>\n<h3 id=\"_7、优化器选择不使用索引的情况\" tabindex=\"-1\"> 7、优化器选择不使用索引的情况</h3>\n<p>如果要求访问的数据量很小，则优化器还是会选择辅助索引，但是当访问的数据占整个表中数据的蛮大一部分时（一般是20%左右），优化器会选择通过聚集索引来查找数据。</p>\n<div><pre><code><span>select</span> <span>*</span> <span>from</span> _order <span>where</span>  order_status <span>=</span> <span>1</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br></div></div><p>查询出所有未支付的订单，一般这种订单是很少的，即使建了索引，也没法使用索引。</p>\n<h3 id=\"_8、复杂查询\" tabindex=\"-1\"> 8、复杂查询</h3>\n<div><pre><code><span>select</span> <span>sum</span><span>(</span>amt<span>)</span> <span>from</span> _t <span>where</span> a <span>=</span> <span>1</span> <span>and</span> b <span>in</span> <span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span> <span>and</span> c <span>></span> <span>'2020-01-01'</span><span>;</span>\n<span>select</span> <span>*</span> <span>from</span> _t <span>where</span> a <span>=</span> <span>1</span> <span>and</span> b <span>in</span> <span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span> <span>and</span> c <span>></span> <span>'2020-01-01'</span> <span>limit</span> <span>10</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br></div></div><p>如果是统计某些数据，可能改用数仓进行解决；</p>\n<p>如果是业务上就有那么复杂的查询，可能就不建议继续走SQL了，而是采用其他的方式进行解决，比如使用ES等进行解决。</p>\n<h3 id=\"_9、asc和desc混用\" tabindex=\"-1\"> 9、asc和desc混用</h3>\n<p><code>sql select * from _t where a=1 order by b desc, c asc </code></p>\n<h3 id=\"_10、大数据\" tabindex=\"-1\"> 10、大数据</h3>\n<p>对于推送业务的数据存储，可能数据量会很大，如果在方案的选择上，最终选择存储在MySQL上，并且做7天等有效期的保存。</p>\n<p>那么需要注意，频繁的清理数据，会照成数据碎片，需要联系DBA进行数据碎片处理。</p>\n<h2 id=\"tiaoyou\" tabindex=\"-1\"> tiaoyou</h2>\n<p>MyCat分库分表</p>\n<p>对于一个千万级别的结算，订单表，我们可以用人员编号作为分库分表键，分散8个库，根据最后一位的值或者不同的分库分表健的策略定位到具体的表。</p>\n<p>排查所有的SQL语句，把用到表关联的SQL语句，多表关联和groupby的语句修改，或者添加冗余字段，或者分组，关联的逻辑在java业务写，或者优化将复杂的操作或者计算操作、一些分组计算写入缓存</p>\n<p>Mycat只能支持一些简单的join，如果你的表都在同一个实例的话join是不影响的，跟mysql本身join一样，如果不在一个实例的表进行join貌似只支持两张表join，并且还不能做太大数据量的join</p>\n<p>数据库调优方面解决过的问题，比如索引对应的字段重复率太高，所以索引没用到，解决方法是建复合索引，或 redis 缓存信息没设超时时间，导致内存爆掉，解决方法是设下限。</p>\n<h2 id=\"mycat\" tabindex=\"-1\"> mycat</h2>\n<p>水平切分，一个实体库切分成多个库</p>\n<p>不可能！因为只有大数据量的用户相关业务才会用到水平切割！</p>\n<p>数据库集群对外的统一访问入口</p>\n<p>核心文件：</p>\n<ul>\n<li>schem.xml 配置参数：逻辑库，逻辑表，数据节点。节点主机</li>\n<li>rule.xml：分片规则</li>\n<li>server.xml：连接 mycat 的用户信息(账号和密码)</li>\n</ul>\n<p><code>Order by</code> 字段必须出现在 select 中(MyCat 先将结果取出，然后排序)</p>\n<p><code>Group by</code> 务必使用标准语法 select count(1),type from tab_a group by type;</p>\n<p>MyCat 的一些自带函数 sum，min，max 等可以正确使用，但多分片执行的 avg 有 bug，执行的结果是错误的谨慎使用子查询，外层查询没有分片查询条件，则会在所有分片上执行(子查询内外层的表一样较为特殊)</p>\n<h3 id=\"场景分析\" tabindex=\"-1\"> 场景分析</h3>\n<p>sql优化</p>\n<p>财务流水表 1000w 分页查询 limit</p>\n<p>优化前 17s\n优化后 300ms</p>\n<p>阿里巴巴Java开发手册 第五章-MySQL数据库 （二）索引规约、第7条：</p>\n<p>【推荐】利用延迟关联或者子查询优化超多分页场景</p>\n<p>说明：MySQL并不是挑过offset 行，而是去offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的底下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。</p>\n<p>正例：先快速定位需要获取的id段，然后再关联：</p>\n<p>索引</p>\n<p>KEY <code>idx_a_b_c</code> (<code>a</code>, <code>b</code>, <code>c</code>)</p>\n<div><pre><code><span>select</span> <span>*</span> <span>from</span> _t <span>where</span> a <span>=</span> <span>1</span> <span>and</span> b <span>=</span> <span>2</span> <span>order</span> <span>by</span> c <span>desc</span> <span>limit</span> <span>10000</span><span>,</span> <span>10</span><span>;</span>\n\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br></div></div><p>对于大分页的场景，可以优先让产品优化需求，如果没有优化的，有如下两种优化方式：</p>\n<ul>\n<li>\n<p>一种是把上一次的最后一条数据，也即上面的c 传过来，然后做“c &lt; xxx”处理，但是这种一般需要改接口协议，并不一定可行；‘</p>\n</li>\n<li>\n<p>另一种是采用延迟关联的方式进行处理，减少SQL回表，但是要记得索引需要完全覆盖才有效果，SQL改动如下：</p>\n</li>\n</ul>\n<div><pre><code><span>select</span> t1<span>.</span><span>*</span> <span>from</span> _t t1<span>,</span> <span>(</span><span>select</span> id <span>from</span> _t <span>where</span> a <span>=</span> <span>1</span> <span>and</span> b <span>=</span> <span>2</span> <span>order</span> <span>by</span> c <span>desc</span> <span>limit</span> <span>10000</span><span>,</span> <span>10</span><span>)</span> t2 <span>where</span> t1<span>.</span>id <span>=</span> t2<span>.</span>id<span>;</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br></div></div><p>灌入大量数据，共500万</p>\n",
      "date_published": "2020-08-01T00:00:00.000Z",
      "date_modified": "2022-04-14T06:39:11.000Z",
      "authors": [
        {
          "name": "狼爷、zsj"
        }
      ],
      "tags": [
        "mysql"
      ]
    },
    {
      "title": "jvm-gc",
      "url": "http://www.zhangsj.xyz/blog/java/jvm/jvm-garbage-collection.html",
      "id": "http://www.zhangsj.xyz/blog/java/jvm/jvm-garbage-collection.html",
      "content_html": "<h2 id=\"关于java垃圾回收的简介\" tabindex=\"-1\"> 关于Java垃圾回收的简介</h2>\n<ol>\n<li>Java内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊的执行着出栈和入栈操作。</li>\n<li>每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存和回收都具确定性，如果垃圾不被回收，内存迟早会被消耗空，因为我们在不断的分配内存空间而不进行回收，除非内存无限大，我们可以任性的分配儿不回收。在这几个区域内不需要过多考虑回收的问题，因为方法结束或线程结束时，内存自然就跟随着回收了。</li>\n<li>而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。</li>\n</ol>\n<h3 id=\"minor-gc-young-gc\" tabindex=\"-1\"> Minor GC(young GC)</h3>\n<p>一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Minor GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。</p>\n<p>这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。</p>\n<p>因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。</p>\n<h3 id=\"full-gc\" tabindex=\"-1\"> Full GC</h3>\n<p>对整个堆进行整理，包括 <code>Young</code>、<code>Tenured</code> 和 <code>Perm</code>。Full GC 因为需要对整个堆进行回收，所以比Minor GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：</p>\n<ol>\n<li>年老代（<code>Tenured</code>）被写满</li>\n<li>持久代（<code>Perm</code>）被写满</li>\n<li><code>System.gc()</code>被显示调用</li>\n<li>上一次GC之后Heap的各域分配策略动态变化</li>\n</ol>\n<h2 id=\"判断哪些对象可以回收\" tabindex=\"-1\"> 判断哪些对象可以回收</h2>\n<p>所谓“要回收的垃圾”无非就是那些不可能再被任何途径使用的对象。那么如何找到这些对象？</p>\n<h3 id=\"引用计数法\" tabindex=\"-1\"> 引用计数法</h3>\n<p>当一个对象被引用时，就当引用对象的值加一，当值为0时，就表示该对象不被引用，可以被垃圾收集器回收。</p>\n<p>这个引用计数法听起来不错，但是有一个弊端，循环引用时，两个对象的计数都为1，导致两个对象都无法被释放。</p>\n<h3 id=\"可达性分析算法\" tabindex=\"-1\"> 可达性分析算法</h3>\n<p>这个算法的基本思想是通过一系列称为“GCRoots”的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链，当一个对象到GCRoots没有任何引用链(即GCRoots到对象不可达)时，则证明此对象是不可用的。</p>\n<p>那么问题又来了，如何选取GCRoots对象呢？在Java语言中，可以作为GCRoots的对象包括下面几种：</p>\n<ul>\n<li>虚拟机栈(栈帧中的本地变量表)中引用的对象。</li>\n<li>方法区中类静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n<li>本地方法栈中JNI(即一般说的Native方法)引用的对象，JNI是Java Native Interface的缩写</li>\n</ul>\n<div><pre><code><span>class</span> <span>T</span><span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>\n        <span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        list<span>.</span><span>add</span><span>(</span><span>\"a\"</span><span>)</span><span>;</span>\n        list<span>.</span><span>add</span><span>(</span><span>\"b\"</span><span>)</span><span>;</span>\n        list<span>.</span><span>add</span><span>(</span><span>1</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>1</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>in<span>.</span><span>read</span><span>(</span><span>)</span><span>;</span>\n        list <span>=</span> <span>null</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>2</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>in<span>.</span><span>read</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"end\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>对于以上代码，可以使用如下命令将堆内存信息转储成一个文件，然后使用 idea Memory Analyzer 工具进行分析。</p>\n<p>使用步骤：</p>\n<ol>\n<li>使用 jps 命令，查看程序的进程\n使用 jmap -dump:format=b,live,file=1.bin 16104 命令转储文件</li>\n</ol>\n<ul>\n<li><code>dump</code>：转储文件</li>\n<li><code>format</code> =b：二进制文件</li>\n<li><code>file</code>：文件名</li>\n<li><code>16104</code>：进程的 ID</li>\n</ul>\n<ol start=\"3\">\n<li>打开 Eclipse Memory Analyzer 对 1.bin 文件进行分析。</li>\n</ol>\n<p>分析的 gc root，找到了 ArrayList 对象，然后将 list 置为 null，再次转储，那么 list 对象就会被回收。</p>\n<h3 id=\"四种引用\" tabindex=\"-1\"> 四种引用</h3>\n<ol>\n<li>强引用: 只有所有<code>GC Roots</code>对象都不通过【强引用】引用该对象，该对象才能被垃圾回收；</li>\n<li>软引用(<code>SoftReference</code>): 仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用对象，可以配合引用队列来释放软引用自身；</li>\n<li>弱引用(<code>WeakReference</code>): 仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象,可以配合引用队列来释放弱引用自身；</li>\n<li>虚引用(<code>PhantomReference</code>): 必须配合引用队列使用，主要配合<code>ByteBuffer</code>使用，被引用对象回收时，会将虚引用入队，由<code>Reference Handler</code>线程调用虚引用相关方法释放直接内存</li>\n<li>终结器引用(<code>FinalReference</code>)： 无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队(被引用对象暂时没有被回收)，再由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize方法，第二次GC时才能回收被引用对象。</li>\n</ol>\n<h2 id=\"垃圾回收算法\" tabindex=\"-1\"> 垃圾回收算法</h2>\n<h3 id=\"标记清除算法-引用计数算法\" tabindex=\"-1\"> 标记清除算法（引用计数算法）</h3>\n<p>它很难解决对象之间的相互循环引用的问题。</p>\n<p>例如：对象objA和ObjB都有字段instance，赋值令标记-清除算法分为两个阶段：标记阶段和清除阶段。</p>\n<p>标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。</p>\n<p><a href=\"./img/2-1.png\">标记清除算法</a></p>\n<p>这种回收算法会产生大量不连续的内存碎片，当要频繁分配一个大对象时，jvm在新生代中找不到足够大的连续的内存块，会导致jvm频繁进行内存回收(目前有机制，对大对象，直接分配到老年代中)</p>\n<p>优点：利用率百分之百</p>\n<p>缺点：标记和清除的效率都不高（比对复制算法），会产生大量的不连续的内存碎片；</p>\n<h3 id=\"复制算法\" tabindex=\"-1\"> 复制算法</h3>\n<p>复制算法将可用内存按容量划分为两个大小相等的块，每次只使用其中的一块。</p>\n<p>当这一块的内存用完了，就将还存活着的对象复制到另外一块内存中，然后把这块内存一次清理掉。这样做的效率比较高，也避免了内存碎片。但是这样内存的可使用空间减半，内存利用率低。内存空间的浪费</p>\n<p><a href=\"./img/2-2.png\">复制算法</a></p>\n<p>这种算法虽然实现简单，运行高效且不容易产生内存碎片，但是却对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。很显然，Copying 算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，那么 Copying 算法的效率将会大大降低。</p>\n<h3 id=\"标记-整理算法-压缩法\" tabindex=\"-1\"> 标记-整理算法(压缩法)</h3>\n<p>为了解决 <code>Copying</code> 算法的缺陷，充分利用内存空间，提出了 <code>Mark-Compact</code> 算法。该算法标记阶段和 <code>Mark-Sweep</code> 一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。具体过程如下图所示：</p>\n<p><a href=\"./img/2-3.png\">压缩法</a></p>\n<h3 id=\"分代收集算法\" tabindex=\"-1\"> 分代收集算法</h3>\n<p>当前商业虚拟机都采用这种算法。首先根据对象存活周期的不同将内存分为几块即新生代、老年代，然后根据不同年代的特点，采用不同的收集算法。</p>\n<p>新生代: 每次垃圾收集都能发现大批对象已死, 只有少量存活。因此选用复制算法, 只需要付出少量存活对象的复制成本就可以完成。但是实际中并不是按照 1：1 的比例来划分新生代的空间的，一般来说是将新生代划分为一块较大的 <code>Eden</code> 空间和两块较小的 <code>Survivor</code> 空间，每次使用 <code>Eden</code> 空间和其中的一块 <code>Survivor</code> 空间，当进行回收时，将 <code>Eden</code> 和 <code>Survivor</code> 中还存活的对象复制到另一块 <code>Survivor</code> 空间中，然后清理掉 <code>Eden</code> 和刚才使用过的 <code>Survivor</code> 空间。</p>\n<p>老年代: 是每次垃圾收集时只有少量对象需要被回收，一般使用的是标记-整理算法(压缩法)。</p>\n<h2 id=\"典型的垃圾收集器\" tabindex=\"-1\"> 典型的垃圾收集器</h2>\n<h2 id=\"serial-收集器\" tabindex=\"-1\"> Serial 收集器</h2>\n<p>Serial 收集器是最基本的、发展历史最悠久的收集器</p>\n<p>特点：单线程、简单高效（与其他收集器的单线程相比），采用复制算法。对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）！</p>\n<h3 id=\"parnew-收集器\" tabindex=\"-1\"> ParNew 收集器</h3>\n<p>ParNew 收集器其实就是 Serial 收集器的多线程版本</p>\n<p>特点：多线程、ParNew 收集器默认开启的收集线程数与CPU的数量相同，在 CPU 非常多的环境中，可以使用 -XX:ParallelGCThreads 参数来限制垃圾收集的线程数。和 Serial 收集器一样存在 Stop The World 问题</p>\n<h3 id=\"cms-收集器\" tabindex=\"-1\"> CMS 收集器</h3>\n<p><code>Concurrent Mark Sweep</code>，一种以获取最短回收停顿时间为目标的老年代收集器</p>\n<p>特点：基于标记-清除算法实现。并发收集、低停顿，但是会产生内存碎片。</p>\n<p>应用场景：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。</p>\n<p>如 web 程序、b/s 服务</p>\n<p>CMS 收集器的运行过程分为下列4步：</p>\n<ul>\n<li>初始标记：标记GC-Roots能直接到的对象。速度很快但是仍存在STW问题。</li>\n<li>并发标记：进行GC-Roots-Tracing的过程，找出存活对象且用户线程可并发执行。</li>\n<li>重新标记：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在STW问题</li>\n<li>并发清除：对标记的对象进行清除回收，清除的过程中，可能任然会有新的垃圾产生，这些垃圾就叫浮动垃圾，如果当用户需要存入一个很大的对象时，新生代放不下去，老年代由于浮动垃圾过多，就会退化为serialOld收集器，将老年代垃圾进行标记-整理，当然这也是很耗费时间的！</li>\n</ul>\n<p>CMS 收集器的内存回收过程是与用户线程一起并发执行的，可以搭配 ParNew 收集器（多线程，新生代，复制算法）与 Serial Old 收集器（单线程，老年代，标记-整理算法）使用。</p>\n<h2 id=\"g1-收集器\" tabindex=\"-1\"> G1 收集器</h2>\n<p>适用场景：</p>\n<ul>\n<li>同时注重吞吐量和低延迟（响应时间）</li>\n<li>超大堆内存（内存大的），会将堆内存划分为多个大小相等的区域，区域可能是Eden，也有可能是Survivor，也有可能是Old，另外Region中还有一类特殊的Humongous区域，专门用来存储大对象。</li>\n<li>整体上是标记-整理算法，两个区域之间是复制算法</li>\n</ul>\n<p>G1的运行过程与CMS大体一致，分为以下四个步骤：</p>\n<ul>\n<li>初始标记(Initial Marking)：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</li>\n<li>并发标记( Concurrent Marking)：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫\n描完成以后，并发时有引用变动的对象会产生漏标问题，G1中会使用SATB(snapshot-at-the-beginning)算法来解决，后面会详细介绍。</li>\n<li>最终标记(Final Marking)：对用户线程做一个短暂的暂停，用于处理并发标记阶段仍遗留下来的最后那少量的SATB记录(漏标对象)。</li>\n<li>筛选回收(Live Data Counting and Evacuation)：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多个收集器线程并行完成的。</li>\n</ul>\n<p>TAMS是什么？</p>\n<p>要达到GC与用户线程并发运行，必须要解决回收过程中新对象的分配，所以G1为每一个Region区域设计了两个名为TAMS（Top at Mark Start）的指针，从Region区域划出一部分空间用于记录并发回收过程中的新对象。这样的对象认为它们是存活的，不纳入垃圾回收范围。</p>\n<div><pre><code>-XX:+UseG1GC\n-XX:G1HeapRegionSize<span>=</span>size\n-XX:MaxGCPauseMillis<span>=</span>time\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>Young Collection：对新生代垃圾收集</p>\n<p>Young Collection + Concurrent Mark：如果老年代内存到达一定的阈值了，新生代垃圾收集同时会执行一些并发的标记。</p>\n<p>Mixed Collection：会对新生代 + 老年代 + 幸存区等进行混合收集，然后收集结束，会重新进入新生代收集。</p>\n<p>Young Collection</p>\n<p>新生代存在 STW：</p>\n<p>分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间！</p>\n<p>E：eden，S：幸存区，O：老年代</p>\n<p>新生代收集会产生STW！</p>\n<p><a href=\"./img/20210210122339138.gif\"></a></p>\n<p>Young Collection + CM</p>\n<p>在 Young GC 时会进行 GC Root 的初始化标记</p>\n<p>老年代占用堆空间比例达到阈值时，进行并发标记（不会STW），由下面的 JVM 参数决定 -XX:InitiatingHeapOccupancyPercent=percent （默认45%）</p>\n<p><a href=\"./img/20210210122601873.png\"></a></p>\n<p>Mixed Collection</p>\n<p>会对 E S O 进行全面的回收</p>\n<p>最终标记会STW</p>\n<p>拷贝存活会STW</p>\n<p>-XX:MaxGCPauseMills=xxms 用于指定最长的停顿时间！</p>\n<p>问：为什么有的老年代被拷贝了，有的没拷贝？</p>\n<p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会回收最有价值的老年代（回收后，能够得到更多内存）</p>\n<p><a href=\"./img/20210210144216170.png\"></a></p>\n<p>Full GC</p>\n<p>G1 在老年代内存不足时（老年代所占内存超过阈值）</p>\n<p>如果垃圾产生速度慢于垃圾回收速度，不会触发 Full GC，还是并发地进行清理</p>\n<p>如果垃圾产生速度快于垃圾回收速度，便会触发 Full GC，然后退化成 serial Old 收集器串行的收集，就会导致停顿的时候长。</p>\n<h2 id=\"新生代调优\" tabindex=\"-1\"> 新生代调优</h2>\n<p>新生代的特点所有的new操作分配内存都是非常廉价的</p>\n<p>TLAB thread-local allocation buffer</p>\n<p>死亡对象回收零代价</p>\n<p>大部分对象用过即死（朝生夕死）</p>\n<p>MinorGC所用时间远小于FullGC</p>\n<p>新生代内存越大越好么？不是</p>\n<p>新生代内存太小：频繁触发MinorGC，会<code>STW</code>，会使得吞吐量下降</p>\n<p>新生代内存太大：老年代内存占比有所降低，会更频繁地触发FullGC。而且触发MinorGC时，清理新生代所花费的时间会更长</p>\n<p>新生代内存设置为内容纳[并发量*(请求-响应)]的数据为宜</p>\n<p>幸存区需要能够保存，当前活跃对象+需要晋升的对象</p>\n<p>晋升阈值配置得当，让长时间存活的对象尽快晋升</p>\n<div><pre><code>-XX:MaxTenuringThreshold<span>=</span>threshold\n-XX:+PrintTenuringDistrubution\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br></div></div><h2 id=\"老年代调优\" tabindex=\"-1\"> 老年代调优</h2>\n<p>以CMS为例：CMS的老年代内存越大越好</p>\n<p>先尝试不做调优，如果没有FullGC，否者先尝试调优新生代。</p>\n<p>观察发现FullGC时老年代内存占用，将老年代内存预设调大1/4~1/3</p>\n<p><code>-XX:CMSInitiatingOccupancyFraction=percent</code></p>\n<p><a href=\"https://blog.csdn.net/weixin_50280576/article/details/113775575\" target=\"_blank\" rel=\"noopener noreferrer\">JVM 学习笔记（二）垃圾回收</a></p>\n<ul>\n<li><code>GC</code>：表示进行了一次Minor GC，即从年轻代空间(包括 Eden 和 Survivor 区域)回收内存</li>\n<li>Allocation Failure：在年轻代中没有足够的空间能够存储新的数据</li>\n<li><code>Full GC</code> (Ergonomics)：表示进行了一次Full GC，即清理整个堆空间(包含年轻代和老年代)</li>\n<li><code>PSYoungGen</code>: 1024K-&gt;1024K(1536K)：垃圾回收器是Paralle Scavenge，年轻代区GC前-&gt;GC后该区域已使用量，后面的1536表示该区域总量</li>\n<li><code>ParOldGen</code>: 4032K-&gt;4032K(4096K)：老年代区，GC前-&gt;GC后该区域已使用量，后面的4096表示该区域总量\n5056K-&gt;5056K(5632K)：GC前 -&gt; GC后Java堆的使用量，后面的5632表示Java堆总量</li>\n<li><code>Metaspace</code>: 3117K-&gt;3117K(1056768K)：JDK8中取消了永久代，新增了一个叫元空间(Metaspace)的区域，对应的还是JVM规范中的方法区(主要存放一些<code>class</code>和元数据的信息)，该数据表示该区GC前后使用量</li>\n</ul>\n",
      "date_published": "2021-02-01T00:00:00.000Z",
      "date_modified": "2022-05-19T10:22:17.000Z",
      "authors": [],
      "tags": [
        "jvm"
      ]
    },
    {
      "title": "JVM内存结构",
      "url": "http://www.zhangsj.xyz/blog/java/jvm/jvm-memory-structure.html",
      "id": "http://www.zhangsj.xyz/blog/java/jvm/jvm-memory-structure.html",
      "content_html": "<p>想走的长远，就需要懂原理，比如：自动装箱、自动拆箱是怎么实现的，反射是怎么实现的，垃圾回收机制是怎么回事等待，JVM 是必须掌握的。</p>\n<h2 id=\"一、jvm内存结构简介\" tabindex=\"-1\"> 一、JVM内存结构简介</h2>\n<p>Java Virtual Machine ，Java 程序的运行环境(Java 二进制字节码的运行环境)。</p>\n<ul>\n<li>一次编译，处处执行</li>\n<li>自动的内存管理，垃圾回收机制</li>\n<li>数组下标越界检查</li>\n</ul>\n<p>3）比较</p>\n<p>JVM、JRE、JDK 的关系如下图所示</p>\n<p>操作系统(Windows+Linux)</p>\n<ul>\n<li>jre(jvm+基本类库)</li>\n<li>Jvm</li>\n<li>jdk(jvm+基本类库+编译工具)</li>\n<li>开发 javaSE 程序(JDK+IDE 工具)</li>\n<li>开发 JavaEE 程序(JDK+应用服务器+IDE 工具)</li>\n</ul>\n<p>下图是JVM：</p>\n<p><a href=\"./img/1-1.png\"></a></p>\n<p>4、学习路线</p>\n<p><a href=\"./img/1-2.png\"></a></p>\n<p>ClassLoader：Java 代码编译成二进制后，会经过类加载器，这样才能加载到 JVM 中运行。</p>\n<p>Method Area：类是放在方法区中</p>\n<p>Heap：类的实例对象。</p>\n<p>当类调用方法时，会用到 JVM Stack、PC Register、本地方法栈。</p>\n<p>方法执行时的每行代码是有执行引擎中的解释器逐行执行，方法中的热点代码频繁调用的方法，由 JIT 编译器优化后执行，GC 会对堆中不用的对象进行回收。需要和操作系统打交道就需要使用到本地方法接口。</p>\n<h2 id=\"二、程序计数器\" tabindex=\"-1\"> 二、程序计数器</h2>\n<p>1）定义</p>\n<p>Program Counter Register 程序计数器(寄存器)</p>\n<p>作用：是记录下一条 jvm 指令的执行地址行号。</p>\n<p>特点：</p>\n<p>是线程私有的</p>\n<p>不会存在内存溢出</p>\n<p>2）作用</p>\n<div><pre><code><span>0</span><span>:</span> getstatic #<span>20</span> <span>// PrintStream out = System.out;</span>\n<span>3</span><span>:</span> astore_1 <span>// --</span>\n<span>4</span><span>:</span> aload_1 <span>// out.println(1);</span>\n<span>5</span><span>:</span> iconst_1 <span>// --</span>\n<span>6</span><span>:</span> invokevirtual #<span>26</span> <span>// --</span>\n<span>9</span><span>:</span> aload_1 <span>// out.println(2);</span>\n<span>10</span><span>:</span> iconst_2 <span>// --</span>\n<span>11</span><span>:</span> invokevirtual #<span>26</span> <span>// --</span>\n<span>14</span><span>:</span> aload_1 <span>// out.println(3);</span>\n<span>15</span><span>:</span> iconst_3 <span>// --</span>\n<span>16</span><span>:</span> invokevirtual #<span>26</span> <span>// --</span>\n<span>19</span><span>:</span> aload_1 <span>// out.println(4);</span>\n<span>20</span><span>:</span> iconst_4 <span>// --</span>\n<span>21</span><span>:</span> invokevirtual #<span>26</span> <span>// --</span>\n<span>24</span><span>:</span> aload_1 <span>// out.println(5);</span>\n<span>25</span><span>:</span> iconst_5 <span>// --</span>\n<span>26</span><span>:</span> invokevirtual #<span>26</span> <span>// --</span>\n<span>29</span><span>:</span> <span>return</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>解释器会解释指令为机器码交给 cpu 执行，程序计数器会记录下一条指令的地址行号，这样下一次解释器会从程序计数器拿到指令然后进行解释执行。</p>\n<p>多线程的环境下，如果两个线程发生了上下文切换，那么程序计数器会记录线程下一行指令的地址行号，以便于接着往下执行。</p>\n<h2 id=\"三、虚拟机栈\" tabindex=\"-1\"> 三、虚拟机栈</h2>\n<p>每个线程运行需要的内存空间，称为虚拟机栈 每个栈由多个栈帧(Frame)组成，对应着每次调用方法时所占用的内存 每个线程只能有一个活动栈帧，对应着当前正在执行的方法</p>\n<p>Q&amp;A</p>\n<p>1、垃圾回收是否涉及栈内存？</p>\n<p>不会。栈内存是方法调用产生的，方法调用结束后会出栈。</p>\n<p>2、栈内存分配越大越好吗？</p>\n<p>不是。因为物理内存是一定的，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</p>\n<p>3、方法内的局部变量是否线程安全？</p>\n<p>如果方法内部的变量没有逃离方法的作用访问，它是线程安全的；如果是局部变量引用了对象，并逃离了方法的访问，那就要考虑线程安全问题。</p>\n<p>4、栈内存溢出？</p>\n<p>栈帧过大、过多、或者第三方类库操作，都有可能造成栈内存溢出 <code>java.lang.stackOverflowError</code> ，使用 <code>-Xss256k</code> 指定栈内存大小！</p>\n<p>5、cpu 占用过多？</p>\n<p>解决方法：Linux 环境下运行某些程序的时候，可能导致 CPU 的占用过高，这时需要定位占用 CPU 过高的线程</p>\n<p>Top 命令，查看是哪个进程占用 CPU 过高</p>\n<p><code>ps H </code>-eo<code> pid, tid（线程id）</code>, %cpu | grep</p>\n<p>刚才通过 top 查到的进程号 通过 ps 命令进一步查看是哪个线程占用 CPU 过高</p>\n<h2 id=\"四、本地方法栈\" tabindex=\"-1\"> 四、本地方法栈</h2>\n<p>一些带有<code>native</code>关键字的方法就是需要<code>JAVA</code>去调用本地的C或者C++方法，因为<code>JAVA</code>有时候没法直接和操作系统底层交互，所以需要用到本地方法栈，服务于带 native 关键字(unsafe)的方法</p>\n<h2 id=\"五、堆\" tabindex=\"-1\"> 五、堆</h2>\n<p>1）定义</p>\n<p><code>Heap</code> 堆</p>\n<p>通过 <code>new</code> 关键字创建的对象都会被放在堆内存</p>\n<p>特点</p>\n<p>它是线程共享，堆内存中的对象都需要考虑线程安全问题</p>\n<p>有垃圾回收机制</p>\n<p>2）堆内存溢出</p>\n<p>Java.<code>lang.OutofMemory</code>Error ：java heap space. 堆内存溢出 可以使用 -Xmx8m 来指定堆内存大小。</p>\n<p>3）堆内存诊断</p>\n<ul>\n<li>Jps 工具：查看当前系统中有哪些 java 进程</li>\n<li>Jmap 工具：查看堆内存占用情况 <code>jmap -heap</code> 进程 ID</li>\n<li>Jconsole 工具：图形界面的，多功能的监测工具，可以连续监测</li>\n<li>Jvisualvm 工具：可视化工具，可以监测堆内存占用情况</li>\n</ul>\n<p>在jvm的堆内存中有三个区域：</p>\n<ol>\n<li>年轻代：用于存放新产生的对象。</li>\n<li>老年代：用于存放被长期引用的对象。</li>\n<li>持久代：用于存放Class，method 元信息（1 .8之后改为元空间）。</li>\n</ol>\n<h3 id=\"年轻代\" tabindex=\"-1\"> 年轻代</h3>\n<p>年轻代中包含两个区：Eden 和survivor，并且用于存储新产生的对象，其中有两个survivor区</p>\n<h3 id=\"老年代\" tabindex=\"-1\"> 老年代</h3>\n<p>年轻代在垃圾回收多次都没有被GC回收的时候就会被放到老年代，以及一些大的对象（比如缓存，这里的缓存是弱引用），这些大对象可以不进入年轻代就直接进入老年代</p>\n<h3 id=\"持久代\" tabindex=\"-1\"> 持久代</h3>\n<p>持久代用来存储class，method元信息，大小配置和项目规模，类和方法的数量有关。</p>\n<h3 id=\"元空间\" tabindex=\"-1\"> 元空间</h3>\n<p>JDK1.8之后，取消perm永久代，转而用元空间代替</p>\n<p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。</p>\n<p>不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。并且可以动态扩容。那么使用元空间会有哪些问题呢？同学们可以思考下。</p>\n<h3 id=\"为什么分代\" tabindex=\"-1\"> 为什么分代？</h3>\n<p>因为不同对象的生命周期是不一样的。80%-98%的对象都是“朝生夕死”，生命周期很短，大部分新对象都在年轻代，可以很高效地进行回收，不用遍历所有对象。而老年代对象生命周期一般很长，每次可能只回收一小部分内存，回收效率很低。</p>\n<p>年轻代和老年代的内存回收算法完全不同，因为年轻代存活的对象很少，标记清楚再压缩的效率很低，所以采用复制算法将存活对象移到survivor区，更高效。而老年代则相反，存活对象的变动很少，所以采用标记清除压缩算法更合适。</p>\n<h2 id=\"六、方法区\" tabindex=\"-1\"> 六、方法区</h2>\n<p>1）定义</p>\n<p>Java 虚拟机有一个在所有 Java 虚拟机线程之间共享的方法区域。方法区域类似于用于传统语言的编译代码的存储区域，或者类似于操作系统进程中的“文本”段。</p>\n<p>它存储每个类的结构，例如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括特殊方法，用于类和实例初始化以及接口初始化方法区域是在虚拟机启动时创建的。</p>\n<p>尽管方法区域在逻辑上是堆的一部分，但简单的实现可能不会选择垃圾收集或压缩它。</p>\n<p>此规范不强制指定方法区的位置或用于管理已编译代码的策略。</p>\n<p>方法区域可以具有固定的大小，或者可以根据计算的需要进行扩展，并且如果不需要更大的方法区域，则可以收缩。方法区域的内存不需要是连续的！</p>\n<p>2）组成</p>\n<p>Hotspot 虚拟机 jdk1.6 1.7 1.8 内存结构图</p>\n<p><img src=\"@source/java/jvm/img/1-3.png\" alt=\"\" loading=\"lazy\"></p>\n<p><img src=\"@source/java/jvm/img/1-4.png\" alt=\"\" loading=\"lazy\"></p>\n<p>3）方法区内存溢出</p>\n<p>1.8 之前会导致永久代内存溢出</p>\n<p>使用 -XX:MaxPermSize=8m 指定永久代内存大小</p>\n<p>1.8 之后会导致元空间内存溢出</p>\n<p>使用 -XX:MaxMetaspaceSize=8m 指定元空间大小</p>\n<p>4）运行时常量池</p>\n<p>二进制字节码包含(类的基本信息，常量池，类方法定义，包含了虚拟机的指令)</p>\n<p>首先看看常量池是什么，编译如下代码：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>T</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"Hello World!\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>然后使用 javap -v Test.class 命令反编译查看结果。</p>\n<p>每条指令都会对应常量池表中一个地址，常量池表中的地址可能对应着一个类名、方法名、参数类型等信息。</p>\n<p><strong>常量池：</strong></p>\n<p>就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息</p>\n<p><strong>运行时常量池：</strong></p>\n<p>常量池是 *.class 文件中的，当该类被加载以后，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</p>\n<p>每条指令都会对应常量池表中一个地址，常量池表中的地址可能对应着一个类名、方法名、参数类型等信息。</p>\n<p>5）<code>StringTable</code></p>\n<p>常量池中的字符串仅是符号，只有在被用到时才会转化为对象,Jdk1.6 StringTable 位置是在永久代中，1.8 StringTable 位置是在堆中。</p>\n<div><pre><code>-Xmx10m 指定堆内存大小\n-XX:+PrintStringTableStatistics 打印字符串常量池信息\n-XX:+PrintGCDetails\n-verbose:gc 打印 gc 的次数，耗费时间等信息\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>利用串池的机制，来避免重复创建字符串对象，字符串变量拼接的原理是 StringBuilder</p>\n<p>字符串常量拼接的原理是编译器优化，可以使用 intern 方法，主动将串池中还没有的字符串对象放入串池中；如果串池中没有该字符串对象，则放入成功，如果有该字符串对象，则放入失败，无论放入是否成功，都会返回串池中的字符串对象</p>\n<p>注意：此时如果调用 <code>intern</code> 方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象，可以通过 <code>intern</code> 方法减少重复入池</p>\n<div><pre><code><span>public</span> <span>class</span> <span>T</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>// \"a\" \"b\" 被放入串池中，str 则存在于堆内存之中</span>\n        <span>String</span> str <span>=</span> <span>new</span> <span>String</span><span>(</span><span>\"a\"</span><span>)</span> <span>+</span> <span>new</span> <span>String</span><span>(</span><span>\"b\"</span><span>)</span><span>;</span>\n        <span>// 调用 str 的 intern 方法，这时串池中没有 \"ab\" ，则会将该字符串对象放入到串池中，此时堆内存与串池中的 \"ab\" 是同一个对象</span>\n        <span>String</span> st2 <span>=</span> str<span>.</span><span>intern</span><span>(</span><span>)</span><span>;</span>\n        <span>// 给 str3 赋值，因为此时串池中已有 \"ab\" ，则直接将串池中的内容返回</span>\n        <span>String</span> str3 <span>=</span> <span>\"ab\"</span><span>;</span>\n        <span>// 因为堆内存与串池中的 \"ab\" 是同一个对象，所以以下两条语句打印的都为 true</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str <span>==</span> st2<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str <span>==</span> str3<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n```java\n<span>public</span> <span>class</span> <span>T</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>// 此处创建字符串对象 \"ab\" ，因为串池中还没有 \"ab\" ，所以将其放入串池中</span>\n        <span>String</span> str3 <span>=</span> <span>\"ab\"</span><span>;</span>\n        <span>// \"a\" \"b\" 被放入串池中，str 则存在于堆内存之中</span>\n        <span>String</span> str <span>=</span> <span>new</span> <span>String</span><span>(</span><span>\"a\"</span><span>)</span> <span>+</span> <span>new</span> <span>String</span><span>(</span><span>\"b\"</span><span>)</span><span>;</span>\n        <span>// 此时因为在创建 str3 时，\"ab\" 已存在与串池中，所以放入失败，但是会返回串池中的 \"ab\"</span>\n        <span>String</span> str2 <span>=</span> str<span>.</span><span>intern</span><span>(</span><span>)</span><span>;</span>\n        <span>// false</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str <span>==</span> str2<span>)</span><span>;</span>\n        <span>// false</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str <span>==</span> str3<span>)</span><span>;</span>\n        <span>// true</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str2 <span>==</span> str3<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>因为 <code>StringTable</code> 是由 HashTable 实现的，所以可以适当增加 HashTable 桶的个数，来减少字符串放入串池所需要的时间</p>\n<p><code>-XX:StringTableSize=桶个数</code>(最少设置为 1009 以上)</p>\n<h2 id=\"七、直接内存\" tabindex=\"-1\"> 七、直接内存</h2>\n<p>直接内存（<code>Direct Memory</code>）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致频繁地使用，而且也可能导致OutOfMemoryError异常出现，常见于NIO操作时，用于数据缓冲区</p>\n<p>在JDK1.4中新加入NIO（New Input、output）</p>\n<p>分配回收成本较高，但读写性能高</p>\n<p>不受 JVM 内存回收管理</p>\n<p>文件读写流程：</p>\n<p><img src=\"@source/java/jvm/img/1-5.png\" alt=\"\" loading=\"lazy\"></p>\n<p>因为 java 不能直接操作文件管理，需要切换到内核态，使用本地方法进行操作，然后读取磁盘文件，会在系统内存中创建一个缓冲区，将数据读到系统缓冲区， 然后在将系统缓冲区数据，复制到 java 堆内存中。缺点是数据存储了两份，在系统内存中有一份，java 堆中有一份，造成了不必要的复制。</p>\n<p>使用了 DirectBuffer 文件读取流程</p>\n<p><img src=\"@source/java/jvm/img/1-6.png\" alt=\"\" loading=\"lazy\"></p>\n<p>直接内存是操作系统和 Java 代码都可以访问的一块区域，无需将代码从系统内存复制到 Java 堆内存，从而提高了效率。</p>\n<h4 id=\"直接内存回收原理\" tabindex=\"-1\"> 直接内存回收原理</h4>\n<div><pre><code><span>public</span> <span>class</span> <span>Code_06_DirectMemoryTest</span> <span>{</span>\n\n    <span>public</span> <span>static</span> <span>int</span> _1GB <span>=</span> <span>1024</span> <span>*</span> <span>1024</span> <span>*</span> <span>1024</span><span>;</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>IOException</span><span>,</span> <span>NoSuchFieldException</span><span>,</span> <span>IllegalAccessException</span> <span>{</span>\n<span>//        method();</span>\n        <span>method1</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>// 演示 直接内存 是被 unsafe 创建与回收</span>\n    <span>private</span> <span>static</span> <span>void</span> <span>method1</span><span>(</span><span>)</span> <span>throws</span> <span>IOException</span><span>,</span> <span>NoSuchFieldException</span><span>,</span> <span>IllegalAccessException</span> <span>{</span>\n        <span>Field</span> field <span>=</span> <span>Unsafe</span><span>.</span><span>class</span><span>.</span><span>getDeclaredField</span><span>(</span><span>\"theUnsafe\"</span><span>)</span><span>;</span>\n        field<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>\n        <span>Unsafe</span> unsafe <span>=</span> <span>(</span><span>Unsafe</span><span>)</span> field<span>.</span><span>get</span><span>(</span><span>Unsafe</span><span>.</span><span>class</span><span>)</span><span>;</span>\n\n        <span>long</span> base <span>=</span> unsafe<span>.</span><span>allocateMemory</span><span>(</span>_1GB<span>)</span><span>;</span>\n        unsafe<span>.</span><span>setMemory</span><span>(</span>base<span>,</span> _1GB<span>,</span> <span>(</span><span>byte</span><span>)</span> <span>0</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>in<span>.</span><span>read</span><span>(</span><span>)</span><span>;</span>\n\n        unsafe<span>.</span><span>freeMemory</span><span>(</span>base<span>)</span><span>;</span>\n        <span>System</span><span>.</span>in<span>.</span><span>read</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>// 演示 直接内存被 释放</span>\n    <span>private</span> <span>static</span> <span>void</span> <span>method</span><span>(</span><span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>\n        <span>ByteBuffer</span> byteBuffer <span>=</span> <span>ByteBuffer</span><span>.</span><span>allocateDirect</span><span>(</span>_1GB<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"分配完毕\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>in<span>.</span><span>read</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"开始释放\"</span><span>)</span><span>;</span>\n        byteBuffer <span>=</span> <span>null</span><span>;</span>\n        <span>System</span><span>.</span><span>gc</span><span>(</span><span>)</span><span>;</span> <span>// 手动 gc</span>\n        <span>System</span><span>.</span>in<span>.</span><span>read</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n<span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><p>直接内存的回收不是通过 JVM 的垃圾回收来释放的，而是通过 unsafe.freeMemory 来手动释放。</p>\n<p>第一步：<code>allocateDirect</code>的实现</p>\n<div><pre><code><span>public</span> <span>static</span> <span>ByteBuffer</span> <span>allocateDirect</span><span>(</span><span>int</span> capacity<span>)</span><span>{</span>\n        <span>return</span> <span>new</span> <span>DirectByteBuffer</span><span>(</span>capacity<span>)</span><span>;</span>\n        <span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>底层是创建了一个<code>DirectByteBuffer</code>对象。</p>\n<p>第二步：<code>DirectByteBuffer</code>类</p>\n<div><pre><code><span>class</span> <span>T</span><span>{</span>\n<span>DirectByteBuffer</span><span>(</span><span>int</span> cap<span>)</span><span>{</span>   <span>// package-private</span>\n\n        <span>super</span><span>(</span><span>-</span><span>1</span><span>,</span><span>0</span><span>,</span>cap<span>,</span>cap<span>)</span><span>;</span>\n        <span>boolean</span> pa<span>=</span>VM<span>.</span><span>isDirectMemoryPageAligned</span><span>(</span><span>)</span><span>;</span>\n        <span>int</span> ps<span>=</span><span>Bits</span><span>.</span><span>pageSize</span><span>(</span><span>)</span><span>;</span>\n        <span>long</span> size<span>=</span><span>Math</span><span>.</span><span>max</span><span>(</span><span>1L</span><span>,</span><span>(</span><span>long</span><span>)</span>cap<span>+</span><span>(</span>pa<span>?</span>ps<span>:</span><span>0</span><span>)</span><span>)</span><span>;</span>\n        <span>Bits</span><span>.</span><span>reserveMemory</span><span>(</span>size<span>,</span>cap<span>)</span><span>;</span>\n\n        <span>long</span> base<span>=</span><span>0</span><span>;</span>\n        <span>try</span><span>{</span>\n        base<span>=</span>unsafe<span>.</span><span>allocateMemory</span><span>(</span>size<span>)</span><span>;</span> <span>// 申请内存</span>\n        <span>}</span><span>catch</span><span>(</span><span>OutOfMemoryError</span> x<span>)</span><span>{</span>\n        <span>Bits</span><span>.</span><span>unreserveMemory</span><span>(</span>size<span>,</span>cap<span>)</span><span>;</span>\n        <span>throw</span> x<span>;</span>\n        <span>}</span>\n        unsafe<span>.</span><span>setMemory</span><span>(</span>base<span>,</span>size<span>,</span><span>(</span><span>byte</span><span>)</span><span>0</span><span>)</span><span>;</span>\n        <span>if</span><span>(</span>pa<span>&amp;&amp;</span><span>(</span>base<span>%</span>ps<span>!=</span><span>0</span><span>)</span><span>)</span><span>{</span>\n        <span>// Round up to page boundary</span>\n        address<span>=</span>base<span>+</span>ps<span>-</span><span>(</span>base<span>&amp;</span><span>(</span>ps<span>-</span><span>1</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span><span>else</span><span>{</span>\n        address<span>=</span>base<span>;</span>\n        <span>}</span>\n        cleaner<span>=</span><span>Cleaner</span><span>.</span><span>create</span><span>(</span><span>this</span><span>,</span><span>new</span> <span>Deallocator</span><span>(</span>base<span>,</span>size<span>,</span>cap<span>)</span><span>)</span><span>;</span> <span>// 通过虚引用，来实现直接内存的释放，this为虚引用的实际对象, 第二个参数是一个回调，实现了 runnable 接口，run 方法中通过 unsafe 释放内存。</span>\n        att<span>=</span><span>null</span><span>;</span>\n        <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>社区报备 这里调用了一个 Cleaner 的 create 方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象(这里是 DirectByteBuffer )被回收以后，就会调用 Cleaner 的 clean 方法，来清除直接内存中占用的内存。</p>\n<div><pre><code><span>class</span> <span>A</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>clean</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>remove</span><span>(</span><span>this</span><span>)</span><span>)</span> <span>{</span>\n            <span>try</span> <span>{</span>\n                <span>// 都用函数的 run 方法, 释放内存</span>\n                <span>this</span><span>.</span>thunk<span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>final</span> <span>Throwable</span> var2<span>)</span> <span>{</span>\n                <span>AccessController</span><span>.</span><span>doPrivileged</span><span>(</span><span>new</span> <span>PrivilegedAction</span><span><span>&lt;</span><span>Void</span><span>></span></span><span>(</span><span>)</span> <span>{</span>\n                    <span>public</span> <span>Void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n                        <span>if</span> <span>(</span><span>System</span><span>.</span>err <span>!=</span> <span>null</span><span>)</span> <span>{</span>\n                            <span>(</span><span>new</span> <span>Error</span><span>(</span><span>\"Cleaner terminated abnormally\"</span><span>,</span> var2<span>)</span><span>)</span><span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n                        <span>}</span>\n                        <span>System</span><span>.</span><span>exit</span><span>(</span><span>1</span><span>)</span><span>;</span>\n                        <span>return</span> <span>null</span><span>;</span>\n                    <span>}</span>\n                <span>}</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>可以看到关键的一行代码， this.thunk.run()，thunk 是 Runnable 对象。Run 方法就是回调 Deallocator 中的 run 方法，</p>\n<div><pre><code> <span>public</span> <span>class</span> <span>T</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>address <span>==</span> <span>0</span><span>)</span> <span>{</span>\n            <span>// Paranoia</span>\n            <span>return</span><span>;</span>\n        <span>}</span>\n        <span>// 释放内存</span>\n        unsafe<span>.</span><span>freeMemory</span><span>(</span>address<span>)</span><span>;</span>\n        address <span>=</span> <span>0</span><span>;</span>\n        <span>Bits</span><span>.</span><span>unreserveMemory</span><span>(</span>size<span>,</span> capacity<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><p>总结直接内存的回收机制</p>\n<p>使用了 Unsafe 类来完成直接内存的分配回收，回收需要主动调用 freeMemory 方法 ByteBuffer 的实现内部使用了 Cleaner(虚引用)来检测 ByteBuffer 。一旦 ByteBuffer 被垃圾回收，那么会由 ReferenceHandler(守护线程) 来调用 Cleaner 的 clean 方法调用 freeMemory 来释放内存</p>\n</div>\n<div><pre><code><span>public</span> <span>class</span> <span>T</span> <span>{</span>\n    <span>/**\n     * -XX:+DisableExplicitGC 显示的\n     */</span>\n    <span>private</span> <span>static</span> <span>void</span> <span>method</span><span>(</span><span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>\n        <span>ByteBuffer</span> byteBuffer <span>=</span> <span>ByteBuffer</span><span>.</span><span>allocateDirect</span><span>(</span>_1GB<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"分配完毕\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>in<span>.</span><span>read</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"开始释放\"</span><span>)</span><span>;</span>\n        byteBuffer <span>=</span> <span>null</span><span>;</span>\n        <span>System</span><span>.</span><span>gc</span><span>(</span><span>)</span><span>;</span> <span>// 手动 gc 失效</span>\n        <span>System</span><span>.</span>in<span>.</span><span>read</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>一般用 jvm 调优时，会加上下面的参数：</p>\n<div><pre><code>-XX:+DisableExplicitGC  // 静止显示的 GC\n</code></pre><div aria-hidden=\"true\"><span>1</span><br></div></div><p>意思就是禁止我们手动的GC，比如手动<code>System.gc()</code>无效，它是一种<code>full gc</code>，会回收新生代、老年代，会造成程序执行的时间比较长。所以我们就通过unsafe对象调用<code>free Memory</code>的方式释放内存。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/weixin_50280576/article/details/113742011\" target=\"_blank\" rel=\"noopener noreferrer\">csdn</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1yE411Z7AP?from=search&amp;seid=14402867104835325411&amp;spm_id_from=333.337.0.0\" target=\"_blank\" rel=\"noopener noreferrer\">bilibili</a></li>\n</ul>\n<h2 id=\"八、内存分配策略\" tabindex=\"-1\"> 八、内存分配策略</h2>\n<h3 id=\"优先在eden区分配\" tabindex=\"-1\"> 优先在Eden区分配</h3>\n<p>在大多数情况下, 对象在新生代Eden区中分配, 当Eden区没有足够空间分配时, VM发起一次Minor GC, 将Eden区和其中一块Survivor区内尚存活的对象放入另一块Survivor区域, 如果在Minor GC期间发现新生代存活对象无法放入空闲的Survivor区, 则会通过空间分配担保机制使对象提前进入老年代(空间分配担保见下).</p>\n<h3 id=\"大对象直接进入老年代\" tabindex=\"-1\"> 大对象直接进入老年代</h3>\n<p><code>Serial</code>和<code>ParNew</code>两款收集器提供了<code>-XX:PretenureSizeThreshold</code>的参数, 令大于该值的大对象直接在老年代分配, 这样做的目的是避免在Eden区和Survivor区之间产生大量的内存复制(大对象一般指 需要大量连续内存的Java对象, 如很长的字符串和数组), 因此大对象容易导致还有不少空闲内存就提前触发GC以获取足够的连续空间</p>\n<h3 id=\"长期存活对象进入老年区\" tabindex=\"-1\"> 长期存活对象进入老年区</h3>\n<p>如果对象在<code>Eden</code>出生并经过第一次 <code>Minor GC</code> 后仍然存活，并且能被<code>Survivor</code>容纳的话，将被移动到<code>Survivor</code>空间中，并将对象年龄设为1，对象在Survivor区中每熬过一次 Minor GC，年龄就增加1，当它的年龄增加到一定程度(默认为15)_时，就会被晋升到老年代中。</p>\n<h3 id=\"对象年龄动态判定\" tabindex=\"-1\"> 对象年龄动态判定</h3>\n<p>如果在 <code>Survivor</code>空间中相同年龄所有对象大小的综合大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代</p>\n<h3 id=\"空间分配担保\" tabindex=\"-1\"> 空间分配担保</h3>\n<p>在发生<code>Minor GC</code>之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看<code>HandlePromotionFailure</code>设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次<code>Minor GC</code>是有风险的，如果担保失败则会进行一次Full GC；如果小于，或者<code>HandlePromotionFailure</code>\n设置不允许冒险，那这时也要改为进行一次<code>Full GC</code>。</p>\n<p>HotSpot默认是开启空间分配担保的。</p>\n",
      "date_published": "2022-04-14T00:58:56.000Z",
      "date_modified": "2022-04-16T23:42:59.000Z",
      "authors": [],
      "tags": [
        "jvm"
      ]
    },
    {
      "title": "jvm调优",
      "url": "http://www.zhangsj.xyz/blog/java/jvm/jvm-tuning.html",
      "id": "http://www.zhangsj.xyz/blog/java/jvm/jvm-tuning.html",
      "content_html": "<h2 id=\"jvm调优\" tabindex=\"-1\"> jvm调优</h2>\n<p>虚拟机和内存调优技能</p>\n<p>第一步，发现系统很卡，或者日志里频繁出现 OOM 异常。</p>\n<p>第二步，用 dump 文件看 OOM 时的内存镜像，看的工具可以是<code>JMAT</code>。这两个步骤是通用的。</p>\n<p>生成dump文件 <code>jmap -dump:live,format=b,file=xxxx.bin 进程ID</code></p>\n<p>第三，通过 dump 文件，jvisualvm 启动可视化工具，再结合日志上下文，</p>\n<p>定位 OOM 的原因，比较简单的原因是 Redis 缓存超时时间过长，或者是 ThreadLocal 里的对象用好没 remove(这块还涉及到弱引用，大家可以自己去查，本文不展开)，或者创建线程池时，等待队列设置成了无界，或者你在 mybatis 里，where 条件都是带 if 的，即如果传入 ID 和 name 再拼装 where ID = xxx 之类的语句，在一种场景里，都没传条件，所以 where 后面不带条件，把数据库里记录全捞出来了，导致 OOM。</p>\n<p>第四是解决，发现问题后，对症下药解决就很容易，比如降低 Redis 超时时间，或者修改好对应的代码。</p>\n",
      "date_published": "2022-04-14T00:58:56.000Z",
      "date_modified": "2022-04-14T05:48:05.000Z",
      "authors": [],
      "tags": [
        "虚拟机"
      ]
    },
    {
      "title": "分布式 id",
      "url": "http://www.zhangsj.xyz/blog/java/soa/distributed-id.html",
      "id": "http://www.zhangsj.xyz/blog/java/soa/distributed-id.html",
      "content_html": "<h2 id=\"分布式-id\" tabindex=\"-1\"> 分布式 id</h2>\n<div><p>Snowflake</p>\n<p>Snowflake 是 Twitter 开源的分布式 ID 生成算法，目的是在分布式系统中生成全局唯一且趋势递增的 long(64bit) 的id数值。\n其特性是各节点无需协调、按时间大致有序、且整个集群各节点单不重复。\n该数值的默认组成如下(符号位之外的三部分允许个性化调整)：\n1bit: 符号位，始终是 0(为了保证主键是正数)。\n41bit: 毫秒数(可用 69 年)；\n10bit: 节点ID(5bit数据中心 + 5bit节点ID，支持 32 * 32 = 1024 个节点)\n12bit: 流水号(每个节点每毫秒内支持 4096 个 ID，相当于 409万的 QPS)\n整个64位数值最大值为2的63次方-1，正好等于Long.MAX_VALUE（9223372036854775807）</p>\n</div>\n<p>Performance</p>\n<p>一、UUID</p>\n<p>UUID是通过唯一识别码，可以生成一个长度32位的全局唯一识别码。\nString uuid = UUID.randomUUID().toString()；\n缺点：UUID虽然能保证全局唯一，但是占用32位有些太长，而且是无序的，入库时性能较差。(由于关系型数据库索引大多都是B+ tree结构，每个索引节点都存储着若干个id，如果无序的插入会导致一些中间节点分裂，造成很多节点不饱和，大大降低了数据库插入性能)</p>\n<p>二、数据库自增主键</p>\n<p>分布式系统中用DB proxy请求不同的分库，每个分库设置不同的初始值，步长和分库数量相等：</p>\n<p>缺点：id的生成严重依赖数据库，不但影响性能，而且一旦数据库宕机，服务将变得不可用。</p>\n<h3 id=\"snowflake算法\" tabindex=\"-1\"> SnowFlake算法</h3>\n<p>雪花算法支持毫秒级的百万id生成操作。</p>\n<p>定义一个初始时间戳startTimestamp(14位)，比如 1483200000000L(2017-01-01)，接着获取相应的机房和机器id码(10位)，我目前做的项目就是12位的机器id码+10位的sequence序列号</p>\n<p>1、同步锁保证线程安全，step1中，我们先比较当前时间戳与上次缓存毫秒时间，如果小于缓存时间(两种原因，一是毫秒级sequence达到了上限，二是时间回调)，则使用上次缓存毫秒时间戳进行缓存计数器计数操作</p>\n<p>2、step2中，我们判断当前时间戳与上次缓存时间是否相等，若相等则进行缓存计数器sequence+1操作，当sequence达到最大值2的10次方1024时，重置为0，且当前时间戳+1；若不等，即当前时间戳大于缓存时间戳，那么sequence从0开始新的计数</p>\n<p>3、step3中将当前时间戳的值缓存到lastTimestamp，进行二进制的位运算获得64位全局唯一的分布式id并转成十进制。</p>\n<p>41位时间戳：(timestamp - startTimestamp) &lt;&lt; TIMESTAMP_OFFSET，左移22位，相当于2的22次方，右边补0 10位机器码：machineId &lt;&lt; MACHINE_OFFSET，左移12位，相当于2的12次方，右边补0 最后将41位时间戳二进制值、10位机器码二进制值与sequence二进制值进行或运算(相当于右边补0的位置进行相应的合并计算)</p>\n<p>优点：ID呈趋势递增，后续插入索引树的时候性能较好。</p>\n<p>缺点：</p>\n<p>依赖于系统时钟的一致性。</p>\n<p>我这边写法仅仅解决了机器系统时钟短时间内的回拨，如果某台机器的系统时钟回拨+服务器重启，缓存时间丢失，那么就有可能造成ID冲突，或者ID乱序。</p>\n<ol>\n<li>生成ID时不依赖于DB，完全在内存生成，高性能高可用。</li>\n</ol>\n<p>一、什么是高并发</p>\n<p>高并发是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。</p>\n<p>高并发相关常用的一些指标有响应时间、吞吐量、每秒查询率QPS、并发用户数等。</p>\n<p>响应时间：系统对请求做出响应的时间。例如系统处理一个HTTP请求需要200ms，这个200ms就是系统的响应时间。</p>\n<p>吞吐量：单位时间内处理的请求数量。</p>\n<p>QPS：每秒响应请求数。在互联网领域，这个指标和吞吐量区分的没有这么明显。</p>\n<p>并发用户数：同时承载正常使用系统功能的用户数量。例如一个即时通讯系统，同时在线量一定程度上代表了系统的并发用户数。</p>\n",
      "date_published": "2022-04-14T00:58:56.000Z",
      "date_modified": "2022-04-24T09:56:06.000Z",
      "authors": [],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "分布式事务",
      "url": "http://www.zhangsj.xyz/blog/java/soa/distributed-transaction.html",
      "id": "http://www.zhangsj.xyz/blog/java/soa/distributed-transaction.html",
      "content_html": "<p>解决跨库操作的数据一致性问题：</p>\n<p>在分布式或者微服务架构中，每个服务都有自己的数据源，使用不同事务管理器，如果A服务去调用B服务，B服务执行失败了，A服务的事务和B服务的事务都会回滚，这时候是不存在事务问题的，但是如果A服务B服务执行成功之后出现异常，A服务的事原子性务会回滚，但是B服务的事务不会回滚，此时就存在分布式事务问题。</p>\n<h2 id=\"使用场景\" tabindex=\"-1\"> 使用场景</h2>\n<ul>\n<li>转账：包含转出和转入操作</li>\n<li>网购：包含下单、扣减库存、支付操</li>\n</ul>\n<h3 id=\"事务的4个特性acid\" tabindex=\"-1\"> 事务的4个特性ACID</h3>\n<p>原子性（Atomicity）：操作这些指令时，要么全部执行成功，要么全部不执行。只要其中一个指令执行失败，所有的指令都执行失败，数据进行回滚，回到执行指令前的数据状态。</p>\n<p>一致性（Consistency）<i>Content not supported</i>：事务的执行使数据从一个状态转换为另一个状态，数据库的完整性约束没有被破坏。</p>\n<blockquote>\n<p>拿转账来说，假设用户A和用户B 两者的钱加起来一共是2000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是2000，这就是事务的一致性。</p>\n</blockquote>\n<p>隔离性（Isolation）<i>Content not supported</i>：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>\n<blockquote>\n<p>即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p>\n</blockquote>\n<p>持久性（Durability）：当事务正确完成后，它对于数据的改变是永久性的。不会轻易丢失</p>\n<div><pre><code><span>begin</span> <span>transaction</span> \n<span>-- 本地数据库操作：张三减少金额 </span>\n<span>-- 本地数据库操作：李四增加金额 </span>\n<span>commit</span> transation\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>随着互联网的快速发展，软件系统由原来的单体应用转变为分布式应用，下图描述了单体应用向微服务的演变：分布式系统会把一个应用系统拆分为可独立部署的多个服务，因此需要服务与服务之间远程协作才能完成事务操 作，这种分布式系统环境下由不同的服务之间通过网络远程协作完成事务称之为分布式事务，例如用户注册送积分 事务、创建订单减库存事务，银行转账事务等都是分布式事务。</p>\n<p>典型的场景就是微服务架构 微服务之间通过远程调用完成事务操作。 比如：订单微服务和库存微服务，下单的 同时订单微服务请求库存微服务减库存。 简言之：跨JVM进程产生分布式事务。</p>\n<div><pre><code><span>begin</span> <span>transaction</span>；\n<span>//1.本地数据库操作：张三减少金额</span>\n<span>//2.远程调用：让李四增加金额 </span>\n<span>commit</span> transation<span>;</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id=\"cap定理\" tabindex=\"-1\"> CAP定理</h3>\n<p>CAP原则指的是在一个分布式系统中，不可能同时满足以下三点。</p>\n<p>一致性（Consistency）<i>Content not supported</i></p>\n<p>指强一致性，在写操作完成后开始的任何读操作都必须返回该值，或者后续写操作的结果。</p>\n<p>可用性（Availability）<i>Content not supported</i>：</p>\n<p>可用性是指，每次向未崩溃的节点发送请求，总能保证收到响应数据（允许不是最新数据）</p>\n<p>分区容忍性（Partition tolerance）<i>Content not supported</i>：分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务,，也就是说，服务器A和B发送给对方的任何消息都是可以放弃的，也就是说A和B可能因为各种意外情况，导致无法成功进行同步，分布式系统要能容忍这种情况。除非整个网络环境都发生了故障。</p>\n<ol>\n<li>使用MQ</li>\n<li>使用Seata</li>\n</ol>\n<p>CP  满足原子和分区容错，也就是说，要放弃可用。当系统被分区，为了保证原子性，必须放弃可用性，让服务停用。\nAP 满足可用性和分区容错，当出现分区，同时为了保证可用性，必须让节点继续对外服务，这样必然导致失去原子性。</p>\n<h3 id=\"一致性\" tabindex=\"-1\"> 一致性 <i>Content not supported</i></h3>\n<p>一致性可以分为强一致性与弱一致性。所谓强一致性，即复制是同步的，弱一致性，即复制是异步的。</p>\n<p>ap 不是完全放弃数据一致性，而是牺牲强一致性换取弱一致性。</p>\n<h2 id=\"seata\" tabindex=\"-1\"> seata</h2>\n<ul>\n<li>TC (Transaction Coordinator) - 事务协调者\n维护全局和分支事务的状态，驱动全局事务提交或回滚；</li>\n<li>TM (Transaction Manager) - 事务管理器\n定义全局事务的范围：开始全局事务、提交或回滚全局事务；</li>\n<li>RM (Resource Manager) - 资源管理器\n管理分支事务处理的资源，与TC交互以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚；</li>\n</ul>\n<p>Seata是阿里巴巴退出的一款用来解决分布式事务问题的框架，他经过天猫双十一的考验，很有可能成为解决分布式事务问题的主流框架</p>\n<p>4、Seata分布式事务框架实现原理？</p>\n<p>Seata有三个组成部分：事务协调器TC：协调者、事务管理器TM：发起方、资源管理器RM：参与方</p>\n<ol>\n<li>发起方会向协调者申请一个全局事务id ，并保存到ThreadLocal中（为什么要保存到ThreadLocal中？弱引用，线程之间不会发生数据冲突）</li>\n<li>Seata 数据源代理发起方和参与方的数据源，将前置镜像和后置镜像写入到undo_log表中，方便后期回滚使用</li>\n<li>发起方获取全局事务id，通过改写Feign客户端请求头传入全局事务id。</li>\n<li>参与方从请求头中获取全局事务id保存到ThreadLocal中，并把该分支注册到SeataServer中。</li>\n<li>如果没有出现异常，发起方会通知协调者，协调者通知所有分支，通过全局事务id和本地事务id删除undo_log数据，如果出现异常，通过undo_log逆向生成sql语句并执行，然后删除undo_log语句。如果处理业务逻辑代码超时，也会回滚</li>\n</ol>\n<h2 id=\"at事务模式\" tabindex=\"-1\"> AT事务模式</h2>\n<p>分布式事务工作机制</p>\n<p>前提： 基于支持本地 ACID 事务的关系型数据库；（mysql、oracle）</p>\n<p>Java 应用，通过JDBC访问数据库；</p>\n<p>整体机制就是两阶段提交协议的演变：</p>\n<p>一阶段： “业务数据“和“回滚日志记录“在同一个本地事务中提交，释放本地锁和连接资源；</p>\n<p>二阶段： 如果没有异常异步化提交，非常快速地完成； 如果有异常回滚通过一阶段的回滚日志进行反向补偿；</p>\n\n<p>具体举例说明整个AT分支的工作过程：</p>\n<h2 id=\"saga事务模式\" tabindex=\"-1\"> saga事务模式</h2>\n<p>又称为Long-running-transaction(长事务)，核心思想是把一个长事务分为多个本地事务来完成，由一个<code>Process Manager</code> 统一协调。如果成功，则继续往下执行，如果失败，则调用补偿操作。</p>\n<p>每个业务都至少需要实现正向、反向两个接口。</p>\n<p>我们看如下一个业务场景。在购买旅游套餐业务操作涉及到三个操作，他们分别是预定车辆，预定宾馆，预定机票，他们分别属于三个不同的远程接口。可能从我们程序的角度来说他们不属于一个事务，但是从业务角度来说是属于同一个事务的。</p>\n<p><img src=\"@source/java/soa/assets/20220413/分布式事务-1649804696250.png\" alt=\"saga案例\" loading=\"lazy\"></p>\n<p>他们的执行顺序如上图所示，所以当发生失败时，会依次进行取消的补偿操作。</p>\n<p>因为长事务被拆分了很多个业务流，所以 Saga 事务模型最重要的一个部件就是流程管理器(Process Manager)。</p>\n<p>在执行到第3步时，发生了失败，回退的过程也比较复杂，特别是子业务比较多的场景。</p>\n<p>如何实现数据的一致性呢？如下罗列了一些方案。</p>\n<ol>\n<li>如果失败，可以发生消息到MQ，消费者根据状态，去重试，或者执行回退操作。同时，也可以进一步检查数据的一致性。</li>\n<li>建立一个定时任务去检查数据的完整性，如果第3步失败了，定时任务会检测到并修复数据。</li>\n<li>本地操作日志或DB日志。</li>\n</ol>\n<h2 id=\"tcc事务模型\" tabindex=\"-1\"> TCC事务模型</h2>\n<p>TCC(Try Confirm Cancel)事务模型的思想和2PC提交有点类似。下图是TCC和2PC(XA)的对比。</p>\n<p><img src=\"@source/java/soa/assets/20220413/分布式事务-1649805216922.png\" alt=\"TCC实物模型的思想和2PC提交比较\" loading=\"lazy\"></p>\n<ol>\n<li>在阶段一：XA模型中，各个RM准备提交各自的事务分支，事实上就是准备提交资源的更新操作（insert、delete、update等），而在TCC中，是主业务活动请求(try)各个从业务服务检查和预留资源。</li>\n<li>阶段二：2PC（XA）根据第一阶段每个RM是否都prepare成功，判断是要提交还是回滚。如果都prepare成功，那么就commit每个事务分支，反之则rollback每个事务分支。</li>\n<li>TCC中，如果在第一阶段所有业务资源都预留成功，那么confirm各个从业务服务，否则取消(cancel)所有从业务服务的资源预留请求。</li>\n</ol>\n<p>TCC两阶段提交与2PC/XA两阶段提交的区别是：</p>\n<ul>\n<li>2PC是资源层面的分布式事务，强一致性，在两阶段提交的整个过程中，一直会持有资源的锁。</li>\n<li>TCC是业务层面的分布式事务，最终一致性，不会一直持有资源的锁。</li>\n</ul>\n<p>是目前最火的一种柔性事务方案，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作</p>\n<p>所谓的 TCC 编程模式，也是两阶段提交的一个变种，不同的是 TCC 为在业务层编写代码实现的两阶段提交。</p>\n<h3 id=\"注意事项\" tabindex=\"-1\"> 注意事项</h3>\n<p>最常见的主要是这三种异常，分别是空回滚、幂等、悬挂。</p>\n<p>1、允许空回滚：</p>\n<p>事务协调器在调用TCC服务的一阶段TRY操作时，可能会出现因为丢包而导致的网络超时，此时事务协调器会触发二阶段回滚，调用TCC服务的CANCEL操作；</p>\n<p>TCC服务在未收到TRY请求的情况下受到CANCEL请求，这种场景被称为空回滚；TCC服务在实现时应当允许空回滚的执行。</p>\n<p>那怎么解决空回滚呢？前面提到，Cancel 要识别出空回滚，直接返回成功。那关键就是要识别出这个空回滚。**思路很简单就是需要知道一阶段是否执行，如果执行了，那就是正常回滚；**如果没执行，那就是空回滚。因此，需要一张额外的事务控制表，其中有分布式事务 ID 和分支事务 ID，第一阶段 Try 方法里会插入一条记录，表示一阶段执行了。Cancel 接口里读取该记录，如果该记录存在，则正常回滚；如果该记录不存在，则是空回滚。</p>\n<p>3、防悬挂控制</p>\n<p>事务协调器在调用TCC服务的一阶段TRY操作时，可能会出现网络拥堵而导致的超时，此时事务协调器会触发二阶段回滚，调用TCC服务的CANCEL操作；在此之后，拥堵在网络上的一阶段TRY数据包被TCC服务收到，出现了二阶段CanCEL请求比一阶段TRY请求先执行的情况。</p>\n<p>用户在实现TCC服务时，应该允许空回滚，但是要拒绝执行空回滚之后到来的一阶段TRY请求；</p>\n<p>大家是否想到了刚才解决空回滚和幂等时用到的事务控制表，可以在二阶段执行时插入一条事务控制记录，状态为已回滚，这样当一阶段执行时，先读取该记录，如果记录存在，就认为二阶段已经执行；否则二阶段没执行。</p>\n<p>4、幂等控制</p>\n<p>无论是网络数据包重传，还是异常事务的补偿执行；用户在实现TCC，需要考虑幂等控制，即TRY、CONFIRM、CANCEL执行一次和执行多次的业务结果是一样的；</p>\n<p>接下来是幂等。幂等就是对于同一个分布式事务的同一个分支事务，重复去调用该分支事务的第二阶段接口，因此，要求 TCC 的二阶段 Confirm 和 Cancel 接口保证幂等，不会重复使用或者释放资源。如果幂等控制没有做好，很有可能导致资损等严重问题。</p>\n<p>什么样的情形会造成重复提交或回滚？从图中可以看到，提交或回滚是一次 TC 到参与者的网络调用。因此，网络故障、参与者宕机等都有可能造成参与者 TCC 资源实际执行了二阶段防范，但是 TC 没有收到返回结果的情况，这时，TC 就会重复调用，直至调用成功，整个分布式事务结束。</p>\n<p>TCC 分别指 Try、Confirm、Cancel ，一个业务操作要对应的写这三个方法。</p>\n<p>第一阶段</p>\n<p>Try（尝试）：</p>\n<p>完成所有业务检查(一致性)\n预留必须业务资源(准隔离性)</p>\n<p>第二阶段</p>\n<p>本阶段根据第一阶段的结果，决定是执行confirm还是cancel</p>\n<p>Confirm（确认）：</p>\n<ul>\n<li>执行真正的业务执行业务</li>\n<li>不做任何业务检查</li>\n<li>只使用Try阶段预留的业务资源</li>\n<li>释放Try阶段预留的业务资源</li>\n</ul>\n<p>Cancle（取消）</p>\n<ul>\n<li>释放Try阶段预留的业务资源</li>\n</ul>\n<p>以下单扣库存为例，</p>\n<ul>\n<li>Try 阶段去占库存（资源的检测与预留）；</li>\n<li>Confirm 阶段则实际扣库存（执行的业务操作提交）；</li>\n<li>如果库存扣减失败 Cancel 阶段进行回滚，释放库存（预留资源释放）；</li>\n</ul>\n<h3 id=\"一个完整的tcc事务参与方包括三部分\" tabindex=\"-1\"> 一个完整的TCC事务参与方包括三部分</h3>\n<ul>\n<li>发起方</li>\n<li>参与方：服务必须实现Try、Confirm 和Cancel三个接口，供发起方服务调用，由于Confirm和Cancel操作可能被重复调用，故要求Confirm和Cancel两个接口必须是幂等的。</li>\n<li>tc：记录维护TCC全局事务的事务状态和每个从业务服务的子事务状态，并在业务活动提交时确认所有的TCC型操作的confirm操作，在业务活动取消时调用所有TCC型操作的cancel操作。</li>\n</ul>\n<p>并发控制 ➢允许空回滚 ➢防悬挂控制 ➢幂等控制</p>\n<p>TCC 不存在资源阻塞的问题，因为每个方法都直接进行事务的提交，一旦出现异常通过则 Cancel 来进行回滚补偿，这也就是常说的补偿性事务。</p>\n<p>原本一个方法，现在却需要三个方法来支持，可以看到 TCC 对业务的侵入性很强，而且这种模式并不能很好地被复用，会导致开发量激增。还要考虑到网络波动等原因，</p>\n<p>为保证请求一定送达都会有重试机制，所以考虑到接口的幂等性。</p>\n<h3 id=\"tcc-案例\" tabindex=\"-1\"> tcc 案例</h3>\n<p>账务拆分的业务场景如下，分别位于三个不同分库的帐户A、B、C，A和B一起向C转帐共80元：</p>\n<p>1、Try：尝试执行业务。</p>\n<p>完成所有业务检查(一致性)：检查A、B、C的帐户状态是否正常，帐户A的余额是否不少于30元，帐户B的余额是否不少于50元。</p>\n<p>预留必须业务资源(准隔离性)：帐户A的冻结金额增加30元，帐户B的冻结金额增加50元，这样就保证不会出现其他并发进程扣减了这两个帐户的余额而导致在后续的真正转帐操作过程中，帐户A和B的可用余额不够的情况。</p>\n<p>2、Confirm：确认执行业务。</p>\n<p>真正执行业务：如果Try阶段帐户A、B、C状态正常，且帐户A、B余额够用，则执行帐户A给账户C转账30元、帐户B给账户C转账50元的转帐操作。</p>\n<p>不做任何业务检查：这时已经不需要做业务检查，Try阶段已经完成了业务检查。</p>\n<p>只使用Try阶段预留的业务资源：只需要使用Try阶段帐户A和帐户B冻结的金额即可。</p>\n<p>3、Cancel：取消执行业务</p>\n<p>释放Try阶段预留的业务资源：如果Try阶段部分成功，比如帐户A的余额够用，且冻结相应金额成功，帐户B的余额不够而冻结失败，则需要对帐户A做Cancel操作，将帐户A被冻结的金额解冻掉。</p>\n<p><a href=\"https://gitee.com/SHIJINGSPACE/seata-tcc-main\" target=\"_blank\" rel=\"noopener noreferrer\">实例代码</a></p>\n<h3 id=\"一个稳定的、高可用的、扩展性强的tcc事务管理器-seata\" tabindex=\"-1\"> 一个稳定的、高可用的、扩展性强的TCC事务管理器（seata）</h3>\n<h3 id=\"tcc事务的优点和限制\" tabindex=\"-1\"> TCC事务的优点和限制</h3>\n<p>解决了跨应用业务操作的原子性问题，在诸如组合支付、账务拆分场景非常实用。</p>\n<p>TCC实际上把数据库层的二阶段提交上提到了应用层来实现，对于数据库来说是一阶段提交，规避了数据库层的2PC性能低下问题。</p>\n<p>TCC事务的缺点，主要就一个：</p>\n<p>TCC的Try、Confirm和Cancel操作功能需业务提供，开发成本高。</p>\n<p>当然，对TCC事务的这个缺点是否是缺点，是一个见仁见智的事情。</p>\n<h2 id=\"基于消息的分布式事务\" tabindex=\"-1\"> 基于消息的分布式事务</h2>\n<p>基于消息的分布式事务与上面的方案很不同，适合执行周期长且实时性要求不高的场景。</p>\n<p>基于消息的分布式事务是指当发起方执行完本地事务后并发出一条消息，参与方一定能够接收消息并处理事务成功，此方案强调的是只要消息发给参与方最终事务要达到一致。</p>\n<p>一般使用消息中间件完成。</p>\n<p>事务发起方（消息生产方）将消息发给消息中间件，事务参与方从消息中间件接收消息，事务发起方和消息中间件之间，事务参与方（消息消费方）和消息中间件之间都是通过网络通信。</p>\n<p>发起方将消息发给消息中间件，参与方从消息中间件接收消息，发起方和消息中间件之间，参与方和消息中间件之间都是通过网络通信。</p>\n<p>本地事务与消息发送的原子性问题</p>\n<ul>\n<li>保证数据库操作与发送消息的一致性，不会出现只有一个成功，另一个不成功的情况</li>\n<li>事务参与方接收消息的可靠性</li>\n<li>事务参与方必须能够从消息队列接收到消息，如果接收消息失败可以重复接收消息</li>\n<li>消息重复消费的问题</li>\n</ul>\n<p>由于网络的存在，若某一个消费节点超时但是消费成功，此时消息中间件会重复投递此消息，就导致了消息的重复消费</p>\n<p>RocketMQ 事务消息设计则主要是为了解决发起方的消息发送与本地事务执行的原子性问题，</p>\n<p>RocketMQ 的设计中 broker 与提供者的双向通信能力，使得 broker 天生可以作为一个事务协调者存在；而 RocketMQ 本身提供的存储机制为事务消息提供了持久化能力；</p>\n<p>RocketMQ 的高可用机制以及可靠消息设计则为事务消息在系统发生异常时依然能够保证达成事务的最终一致性。</p>\n<p>发起方发消息到mq，mq 将消息状态标记为prepared，这条消息消费者无法消费到。</p>\n<p>mq接受到发起方发送的消息回应发送成功</p>\n<p>发起方执行本地业务代码； 本地事务执行成功，向mq发送commit消息，mq 接受到commit 消息把状态置为可消费，此时消费者（参与方）正常消费消息 参与方本地事务执行失败，向mq发送rollback 消息，mq接收到rollback 消息删除消息 参与方消费消息成功向mq回应ack 确认消费消息成功，否则重复接收，这里ack默认自动回应。 如果参与者执行本地事务时，宕机或超时，mq 会不停询问同组的其他消费者来获取事务执行状态。mq 会根据会回查结构来确定是否投递消息；</p>\n",
      "date_published": "2021-10-21T00:00:00.000Z",
      "date_modified": "2022-04-16T14:05:13.000Z",
      "authors": [],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "spring事务",
      "url": "http://www.zhangsj.xyz/blog/java/spring/spring-transaction.html",
      "id": "http://www.zhangsj.xyz/blog/java/spring/spring-transaction.html",
      "content_html": "<h2 id=\"spring-事务\" tabindex=\"-1\"> spring 事务</h2>\n<p>Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring 是无法提供事务功能的。对于纯 JDBC 操作数据库，想要用到事务，可以按照以下步骤进行：</p>\n<h3 id=\"事务传播行为\" tabindex=\"-1\"> 事务传播行为</h3>\n<p>spring特有的事务传播行为，spring支持7种事务传播行为，确定客户端和被调用端的事务边界 （说得通俗一点就是多个具有事务控制的service的相互调用时所形成的复杂的事务边界控制）下图所示为7钟事务传播机制</p>\n<ol>\n<li>获取连接<code>Connection con = DriverManager.getConnection()</code></li>\n<li>开启事务<code>con.setAutoCommit(true/false);</code></li>\n<li>执行<code>CRUD</code></li>\n<li>提交事务/回滚事务<code>con.commit()</code>/<code>con.rollback()</code>;</li>\n<li>关闭连接<code>conn.close()</code>;</li>\n</ol>\n<p>使用<code>Spring</code>的事务管理功能后，我们可以不再写步骤2、4的代码，而是由Spring自动完成。那么Spring是如何在我们书写的CRUD之前和之后开启事务和关闭事务的呢？解决这个问题，也就可以从整体上理解Spring的事务管理实现原理了。</p>\n<p>注解方式开启事务的步骤：</p>\n<ol>\n<li>配置文件开启注解驱动，在相关的类和方法上通过注解@Transactional标识。</li>\n<li>spring在启动的时候会去解析生成相关的bean，这时候会查看拥有相关注解的类和方法，并且为这些类和方法生成代理，并根据@Transaction的相关参数进行相关配置注入，这样就在代理中为我们把相关的事务处理掉了(开启正常提交事务，异常回滚事务)。</li>\n<li>真正的数据库层的事务提交和回滚是通过binlog或者redolog实现的。</li>\n</ol>\n<h2 id=\"spring-的事务机制\" tabindex=\"-1\"> Spring 的事务机制</h2>\n<p>而 Spring 的事务机制是用统一的机制来处理不同数据访问技术的事务处理。</p>\n<p>Spring 的事务机制提供了一个<code>PlatformTransactionManager</code>接口，不同的数据访问技术的事务使用不同的接口实现；</p>\n<h3 id=\"aop代理的两种实现\" tabindex=\"-1\"> AOP代理的两种实现</h3>\n<p><code>Jdk</code>是代理接口，私有方法必然不会存在在接口里，所以就不会被拦截到；</p>\n<p><code>Cglib</code>是子类，<code>private</code>的方法照样不会出现在子类里，也不能被拦截。</p>\n<h2 id=\"spring事务的传播属性\" tabindex=\"-1\"> Spring事务的传播属性</h2>\n<p>所谓<code>spring</code>事务的传播属性，就是定义在存在多个事务同时存在的时候，<code>spring</code>应该如何处理这些事务的行为。这些属性在 <code>TransactionDefinition</code>中定义，具体常量的解释见下表：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">传播行为</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">PROPAGATION_REQUIRED（XML文件中为REQUIRED)</td>\n<td>表示当前方法必须在一个具有事务的上下文中运行，如有客户端有事务在进行，那么被调用端将在该事务中运行，否则的话重新开启一个事务。（如果被调用端发生异常，那么调用端和被调用端事务都将回滚）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PROPAGATION_SUPPORTS(XML文件中为SUPPORTS）</td>\n<td>表示当前方法不必需要具有一个事务上下文，但是如果有一个事务的话，它也可以在这个事务中运行</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PROPAGATION_MANDATORY(XML文件中为MANDATORY）</td>\n<td>表示当前方法必须在一个事务中运行，如果没有事务，将抛出异常</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PROPAGATION_NESTED(XML文件中为NESTED)</td>\n<td>表示如果当前方法正有一个事务在运行中，则该方法应该运行在一个嵌套事务中，被嵌套的事务可以独立于被封装的事务中进行提交或者回滚。如果封装事务存在，并且外层事务抛出异常回滚，那么内层事务必须回滚，反之，内层事务并不影响外层事务。如果封装事务不存在，则同PROPAGATION_REQUIRED的一样</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PROPAGATION_NEVER（XML文件中为NEVER)</td>\n<td>表示当方法务不应该在一个事务中运行，如果存在一个事务，则抛出异常</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PROPAGATION_REQUIRES_NEW(XML文件中为REQUIRES_NEW）</td>\n<td>表示当前方法必须运行在它自己的事务中。一个新的事务将启动，而且如果有一个现有的事务在运行的话，则这个方法将在运行期被挂起，直到新的事务提交或者回滚才恢复执行。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PROPAGATION_NOT_SUPPORTED（XML文件中为NOT_SUPPORTED）</td>\n<td>表示该方法不应该在一个事务中运行。如果有一个事务正在运行，他将在运行期被挂起，直到这个事务提交或者回滚才恢复执行</td>\n</tr>\n</tbody>\n</table>\n<p>所有的数据访问技术都有事务处理机制，这些技术提供了API用来开启事务、提交事务来完成数据操作，或者在发生错误的时候回滚数据。</p>\n<h3 id=\"spring-声明式事务\" tabindex=\"-1\"> spring 声明式事务</h3>\n<p><a href=\"/java/basic/java-exception.html\">Java检查型异常和非检查型异常</a></p>\n<p>Spring 声明式事务管理默认对非检查型异常和运行时异常进行事务回滚，而对检查型异常则不进行回滚操作</p>\n<h3 id=\"java-中抛异常后如何使事务回滚\" tabindex=\"-1\"> java 中抛异常后如何使事务回滚</h3>\n<p>代码中 try……catch 抛出的 Exception 异常，属于检查型异常,Spring 的框架默认是不会进行回滚的。所以必须在 service 捕获异常，然后再次手动 throw 一个非检查型异常，这样事务方才起效.</p>\n<p>首先方法名前面有：<code>@Transactional</code>，下面介绍三种使事务回滚的方式</p>\n<ol>\n<li>手动 throw 异常，让 aop 捕获异常再去回滚，并且在 service 上层(webservice 客户端，view 层 action)要继续捕获这个异常并处理</li>\n</ol>\n<div><pre><code><span>Try</span><span>{</span>undefined\n    …………\n<span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>undefined\n    …………\n    <span>Throw</span> <span>new</span> <span>RuntimeException</span><span>(</span>e<span>)</span><span>;</span>\n\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ol start=\"2\">\n<li>通过注解参数改变默认的回滚方式 。</li>\n</ol>\n<p>在<code>@Transaction</code>注解中定义了 <code>noRollbackFor</code> 和 <code>RollbackFor</code> 来指定某种异常是否回滚。</p>\n<p>使用例子：</p>\n<p>@Transaction(noRollbackFor=RuntimeException.class)</p>\n<p>@Transaction(RollbackFor=Exception.class)</p>\n<p>所以上述的问题可以直接将@Transaction</p>\n<p>添加回滚参数@Transaction(RollbackFor=Exception.class) ,这样就改变了默认的事务处理方式。</p>\n<ol start=\"3\">\n<li>在 service 层方法的 catch 语句中增加：TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();语句，手动回滚，这样上层就无需去处理异常(现在项目的做法)</li>\n</ol>\n",
      "date_published": "2021-10-20T00:00:00.000Z",
      "date_modified": "2022-04-14T15:42:00.000Z",
      "authors": [],
      "tags": [
        "spring"
      ]
    },
    {
      "title": "springboot自动装配原理",
      "url": "http://www.zhangsj.xyz/blog/java/spring/springboot-startup-process.html",
      "id": "http://www.zhangsj.xyz/blog/java/spring/springboot-startup-process.html",
      "content_html": "<h1 id=\"自动装配流程\" tabindex=\"-1\"> 自动装配流程</h1>\n<p>里面有一个<code>main</code>方法运行了一个<code>run()</code>方法，在<code>run</code>方法中必须要传入一个被<code>@SpringBootApplication</code>注解的类。</p>\n<p><code>@SpringBootApplication</code>应用标注在某个类上说明这个类是SpringBoot的主配置类，<code>SpringBoot</code>就会运行这个类的<code>main</code>方法来启动 SpringBoot 项目。</p>\n<p>那<code>@SpringBootApplication</code>注解到底是什么呢，点进去看看：</p>\n<p>发现<code>@SpringBootApplication</code>是一个组合注解。</p>\n<h2 id=\"springbootconfiguration\" tabindex=\"-1\"> @SpringBootConfiguration</h2>\n<p>先看看@SpringBootConfiguration注解：</p>\n<h2 id=\"_05、条件注解\" tabindex=\"-1\"> 05、条件注解</h2>\n<p>默认情况，假设没有条件注解，那么发生什么？因为如果bean指定@Configuration和@Bean是必须一定加载ioc容器中去的.</p>\n<p>思考一个问题：springboot的starter机制中提供了100~200个配置类，这么的多配置类，我们不可能全不让ioc容器加载，因为项目可能之用到了redis，mybatis ，那么另外100多个，应该不要加载才行。所以条件注解就专门来做过滤使用。满足配置就加载，不满足的就忽略。</p>\n",
      "date_published": "2021-10-21T00:00:00.000Z",
      "date_modified": "2022-04-14T15:42:00.000Z",
      "authors": [],
      "tags": [
        "spring"
      ]
    },
    {
      "title": "八皇后问题",
      "url": "http://www.zhangsj.xyz/blog/algo/algorithm-eight-queens.html",
      "id": "http://www.zhangsj.xyz/blog/algo/algorithm-eight-queens.html",
      "content_html": "<p>maximum-path-of-binary-tree</p>\n<h1 id=\"八皇后问题\" tabindex=\"-1\"> 八皇后问题</h1>\n<p>回溯算法的典型案例。</p>\n<p>在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法(92)。</p>\n<h2 id=\"八皇后问题算法思路分析\" tabindex=\"-1\"> 八皇后问题算法思路分析</h2>\n<ol>\n<li>第一个皇后先放第一行第一列</li>\n<li>第二个皇后放在第二行第一列、然后判断是否OK，如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适</li>\n<li>继续第三个皇后，还是第一列、第二列…直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解</li>\n<li>当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到</li>\n<li>然后回头继续第一个皇后放第二列，后面继续循环执行1,2,3,4的步骤</li>\n</ol>\n<div><pre><code><span>package</span> <span>interview</span><span>;</span>\n\n<span>public</span> <span>class</span> BHH <span>{</span>\n    <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> board <span>=</span> <span>new</span> <span>int</span><span>[</span><span>8</span><span>]</span><span>[</span><span>8</span><span>]</span><span>;</span>\n\n    <span>boolean</span> <span>check</span><span>(</span><span>int</span> x<span>,</span> <span>int</span> y<span>)</span> <span>{</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> y<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>board<span>[</span>x<span>]</span><span>[</span>i<span>]</span> <span>==</span> <span>1</span><span>)</span> <span>{</span>\n                <span>return</span> <span>false</span><span>;</span>\n            <span>}</span>\n            <span>//检查左侧斜向</span>\n            <span>if</span> <span>(</span>x <span>-</span> <span>1</span> <span>-</span> i <span>>=</span> <span>0</span> <span>&amp;&amp;</span> board<span>[</span>x <span>-</span> <span>1</span> <span>-</span> i<span>]</span><span>[</span>y <span>-</span> <span>1</span> <span>-</span> i<span>]</span> <span>==</span> <span>1</span><span>)</span> <span>{</span>\n                <span>return</span> <span>false</span><span>;</span>\n            <span>}</span>\n            <span>//检查右侧斜向</span>\n            <span>if</span> <span>(</span>x <span>+</span> i <span>+</span> <span>1</span> <span>&lt;</span> <span>8</span> <span>&amp;&amp;</span> board<span>[</span>x <span>+</span> i <span>+</span> <span>1</span><span>]</span><span>[</span>y <span>-</span> <span>1</span> <span>-</span> i<span>]</span> <span>==</span> <span>1</span><span>)</span> <span>{</span>\n                <span>return</span> <span>false</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n\n\n    <span>boolean</span> <span>settleQ</span><span>(</span><span>int</span> y<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>y <span>==</span> <span>8</span><span>)</span> <span>return</span> <span>true</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>8</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> x <span>=</span> <span>8</span><span>;</span> x <span>&lt;</span> <span>8</span><span>;</span> x<span>++</span><span>)</span> <span>{</span>\n                board<span>[</span>x<span>]</span><span>[</span>y<span>]</span> <span>=</span> <span>0</span><span>;</span>\n            <span>}</span>\n\n            <span>if</span> <span>(</span><span>check</span><span>(</span>i<span>,</span> y<span>)</span><span>)</span> <span>{</span>\n                board<span>[</span>i<span>]</span><span>[</span>y<span>]</span> <span>=</span> <span>1</span><span>;</span>\n                <span>if</span> <span>(</span><span>settleQ</span><span>(</span>y <span>+</span> <span>1</span><span>)</span><span>)</span> <span>{</span>\n                    <span>return</span> <span>true</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n\n    <span>void</span> <span>print</span><span>(</span><span>)</span> <span>{</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>8</span><span>;</span> i<span>++</span><span>)</span> <span>{</span><span>//纵坐标</span>\n            <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> <span>8</span><span>;</span> j<span>++</span><span>)</span> <span>{</span><span>//横坐标</span>\n                <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>board<span>[</span>j<span>]</span><span>[</span>i<span>]</span><span>)</span><span>;</span>\n            <span>}</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div>",
      "date_published": "2022-04-13T18:37:08.000Z",
      "date_modified": "2022-04-24T09:56:06.000Z",
      "authors": [],
      "tags": [
        "算法"
      ]
    },
    {
      "title": "二叉树的最大深度",
      "url": "http://www.zhangsj.xyz/blog/algo/maximum-depth-of-a-binary-tree.html",
      "id": "http://www.zhangsj.xyz/blog/algo/maximum-depth-of-a-binary-tree.html",
      "content_html": "<h2 id=\"二叉树的最大深度\" tabindex=\"-1\"> 二叉树的最大深度</h2>\n<p>给定一个二叉树，找出其最大深度。</p>\n<p>二叉树的深度为根节点到最远叶子节点的路径上的节点数。</p>\n<p>说明:</p>\n<p>叶子节点是指没有子节点的节点。</p>\n<p>给定二叉树<code>[3,9,20,null,null,15,7]</code></p>\n<pre><code>3\n</code></pre>\n<p>/ <br>\n9  20\n/  <br>\n15   7</p>\n<p>返回它的最大深度 3 。</p>\n<p>解题思路：</p>\n<p>要求二叉树的最大深度，我们可以先求出左子树和右子树的深度 l 和 r</p>\n<p>那就可以计算出二叉树的最大深度了：max( l,r )+1</p>\n<p>而左子树和右子树的最大深度又可以以同样的方式进行计算。</p>\n<p>因此我们可以用「深度优先搜索」的方法来计算二叉树的最大深度。</p>\n<p>具体而言，在计算当前二叉树的最大深度时，可以先递归计算出其左子树和右子树的最大深度，然后在 O(1) 时间内计算出当前二叉树的最大深度。递归在访问到空节点时退出。</p>\n<p>:::: 递归求最大深度</p>\n<div><pre><code>\n<span>class</span> <span>TreeNode</span> <span>{</span>\n    <span>Node</span> left<span>;</span>\n    <span>Node</span> right<span>;</span>\n<span>}</span>\n\n<span>class</span> <span>Solution</span> <span>{</span>\n    <span>public</span> <span>int</span> <span>maxDepth</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>\n           <span>//递归终止情况：节点为空</span>\n            <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span>\n            <span>{</span>\n                <span>return</span> <span>0</span><span>;</span>\n            <span>}</span>\n            <span>else</span><span>{</span>\n             <span>int</span> ldpeth <span>=</span> <span>maxDepth</span><span>(</span>root<span>.</span>left<span>)</span><span>;</span>\n             <span>int</span> rdpeth <span>=</span> <span>maxDepth</span><span>(</span>root<span>.</span>right<span>)</span><span>;</span>\n              <span>return</span> <span>Math</span><span>.</span><span>max</span><span>(</span>ldpeth <span>,</span> rdpeth <span>)</span> <span>+</span> <span>1</span><span>;</span>\n            <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>通过\n执行用时：100 ms，在所有 C# 提交中击败了 43.46%的用户\n内存消耗：25.7 MB，在所有 C# 提交中击败了 10.73%的用户</p>\n<p>时间复杂度：O(n) O( n )其中 n 为二叉树节点的个数。每个节点在递归中只被遍历一次。\n空间复杂度：O(n) 空间复杂度：O( height ) 其中 height 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。</p>\n<h2 id=\"广度优先搜索\" tabindex=\"-1\"> 广度优先搜索</h2>\n<p>思路：广度优先搜索的队列里存放的是「当前层的所有节点」。</p>\n<p>每次拓展下一层的时候，不同于广度优先搜索的每次只从队列里拿出一个节点，</p>\n<p>我们需要将队列里的所有节点都拿出来进行拓展，这样能保证每次拓展完的时候队列里存放的是当前层的所有节点，即我们是一层一层地进行拓展，最后我们用一个变量<code>ans</code>来维护拓展的次数，该二叉树的最大深度即为<code>ans</code>。</p>\n<div><pre><code>\n<span>class</span> <span>Solution</span> <span>{</span>\n    <span>public</span> <span>void</span> <span>merge</span><span>(</span><span>int</span><span>[</span><span>]</span> nums1<span>,</span> <span>int</span> m<span>,</span> <span>int</span><span>[</span><span>]</span> nums2<span>,</span> <span>int</span> n<span>)</span> <span>{</span>\n        <span>int</span> p1 <span>=</span> <span>0</span><span>,</span> p2 <span>=</span> <span>0</span><span>;</span>\n        <span>int</span><span>[</span><span>]</span> sorted <span>=</span> <span>new</span> <span>int</span><span>[</span>m <span>+</span> n<span>]</span><span>;</span>\n        <span>int</span> cur<span>;</span>\n        <span>while</span> <span>(</span>p1 <span>&lt;</span> m <span>||</span> p2 <span>&lt;</span> n<span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>p1 <span>==</span> m<span>)</span> <span>{</span>\n                cur <span>=</span> nums2<span>[</span>p2<span>++</span><span>]</span><span>;</span>\n            <span>}</span> <span>else</span> <span>if</span> <span>(</span>p2 <span>==</span> n<span>)</span> <span>{</span>\n                cur <span>=</span> nums1<span>[</span>p1<span>++</span><span>]</span><span>;</span>\n            <span>}</span> <span>else</span> <span>if</span> <span>(</span>nums1<span>[</span>p1<span>]</span> <span>&lt;</span> nums2<span>[</span>p2<span>]</span><span>)</span> <span>{</span>\n                cur <span>=</span> nums1<span>[</span>p1<span>++</span><span>]</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                cur <span>=</span> nums2<span>[</span>p2<span>++</span><span>]</span><span>;</span>\n            <span>}</span>\n            sorted<span>[</span>p1 <span>+</span> p2 <span>-</span> <span>1</span><span>]</span> <span>=</span> cur<span>;</span>\n        <span>}</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>!=</span> m <span>+</span> n<span>;</span> <span>++</span>i<span>)</span> <span>{</span>\n            nums1<span>[</span>i<span>]</span> <span>=</span> sorted<span>[</span>i<span>]</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id=\"深度优先遍历\" tabindex=\"-1\"> 深度优先遍历</h2>\n<p>指对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。</p>\n<p>二叉树的深度优先遍历分为：先序遍历，中序遍历和后序遍历</p>\n<ul>\n<li>先序遍历：先访问根，在访问左子树，最后访问右子树，总结就是“根左右”；</li>\n<li>中序遍历：先访问左子树，再访问根，最后访问右子树，总结就是“左根右”；</li>\n<li>后序遍历：先访问左子树，再访问右子树，最后访问根，总结就是“左右根”。</li>\n</ul>\n",
      "date_published": "2022-04-13T18:37:08.000Z",
      "date_modified": "2022-04-14T05:48:05.000Z",
      "authors": [],
      "tags": [
        "算法"
      ]
    },
    {
      "title": "八种排序算法汇总",
      "url": "http://www.zhangsj.xyz/blog/algo/summary-of-eight-sorting-algorithms.html",
      "id": "http://www.zhangsj.xyz/blog/algo/summary-of-eight-sorting-algorithms.html",
      "content_html": "<h2 id=\"八种排序算法汇总\" tabindex=\"-1\"> 八种排序算法汇总</h2>\n<h2 id=\"_8sort-algo\" tabindex=\"-1\"> 8sort-algo</h2>\n<p><img src=\"@source/algo/assets/20220415/summary-of-eight-sorting-algorithms-1650035855056.png\" alt=\"排序算法架构\" loading=\"lazy\"></p>\n<h2 id=\"堆排序\" tabindex=\"-1\"> 堆排序</h2>\n<p>1）数组构建成二叉堆。(小到大排序,则构建最大堆)； 2）循环删除堆顶元素,替换到二叉堆的末尾,调整堆产生新的堆顶。</p>\n<div><pre><code><span>class</span> <span>T</span> <span>{</span>\n    <span>/**\n     * 下沉调整\n     * <span>@param</span> <span>arr</span> 待调整的堆\n     * <span>@param</span> <span>parent</span> 要下沉的父节点\n     */</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>downAdjust</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>,</span> <span>int</span> parent<span>,</span> <span>int</span> length<span>)</span> <span>{</span>\n        <span>//temp保存父节点值,用于最后的赋值</span>\n        <span>int</span> temp <span>=</span> arr<span>[</span>parent<span>]</span><span>;</span>\n        <span>int</span> child <span>=</span> <span>2</span> <span>*</span> parent <span>+</span> <span>1</span><span>;</span>\n        <span>while</span> <span>(</span>child <span>&lt;</span> length<span>)</span> <span>{</span>\n            <span>//如果有右孩子,且右孩子大于左孩子的值,则定位到右孩子</span>\n            <span>if</span> <span>(</span>child <span>+</span> <span>1</span> <span>&lt;</span> length <span>&amp;&amp;</span> arr<span>[</span>child <span>+</span> <span>1</span><span>]</span> <span>></span> arr<span>[</span>child<span>]</span><span>)</span> <span>{</span>\n                childIndex<span>++</span><span>;</span>\n            <span>}</span>\n            <span>//如果父节点小于任何一个孩子的值,则直接跳出</span>\n            <span>if</span> <span>(</span>temp <span>>=</span> arr<span>[</span>child<span>]</span><span>)</span> <span>{</span>\n                <span>break</span><span>;</span>\n            <span>}</span>\n            <span>//无须真正交换,单向赋值即可</span>\n            arr<span>[</span>parent<span>]</span> <span>=</span> array<span>[</span>child<span>]</span><span>;</span>\n            parent <span>=</span> child<span>;</span>\n            child <span>=</span> <span>2</span> <span>*</span> parent <span>+</span> <span>1</span><span>;</span>\n        <span>}</span>\n        arr<span>[</span>parent<span>]</span> <span>=</span> temp<span>;</span>\n\n    <span>}</span>\n\n    <span>/**\n     * 堆排序（升序）\n     * <span>@param</span> <span>arr</span> 待调整的堆\n     */</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>heapSort</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>)</span> <span>{</span>\n        <span>//1. 把无序数组构建成最大堆</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>(</span>arr<span>.</span>length <span>-</span> <span>2</span><span>)</span> <span>/</span> <span>2</span><span>;</span> i <span>>=</span> <span>0</span><span>;</span> i<span>--</span><span>)</span> <span>{</span>\n            <span>downAdjust</span><span>(</span>arr<span>,</span> i<span>,</span> arr<span>.</span>length<span>)</span><span>;</span>\n        <span>}</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Arrays</span><span>.</span><span>toString</span><span>(</span>arr<span>)</span><span>)</span><span>;</span>\n        <span>//2. 循环删除堆顶元素,移到集合尾部,调整堆产生新的堆顶</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> arr<span>.</span>length<span>;</span> i <span>></span> <span>0</span><span>;</span> i<span>--</span><span>)</span> <span>{</span>\n            <span>//最后1个元素和第一个元素进行交换</span>\n            <span>swap</span><span>(</span>arr<span>,</span> <span>0</span><span>,</span> i<span>)</span><span>;</span>\n            <span>//“下沉”调整最大堆</span>\n            <span>downAdjust</span><span>(</span>arr<span>,</span> <span>0</span><span>,</span> i<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>swap</span><span>(</span><span>int</span><span>[</span><span>]</span> a<span>,</span> <span>int</span> i<span>,</span> <span>int</span> j<span>)</span> <span>{</span>\n        <span>int</span> temp <span>=</span> a<span>[</span>i<span>]</span><span>;</span>\n        a<span>[</span>i<span>]</span> <span>=</span> a<span>[</span>j<span>]</span><span>;</span>\n        a<span>[</span>j<span>]</span> <span>=</span> temp<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>new</span> <span>int</span><span>[</span><span>]</span><span>{</span><span>1</span><span>,</span> <span>3</span><span>,</span> <span>2</span><span>,</span> <span>6</span><span>,</span> <span>5</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>,</span> <span>10</span><span>,</span> <span>0</span><span>}</span><span>;</span>\n        <span>heapSort</span><span>(</span>arr<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Arrays</span><span>.</span><span>toString</span><span>(</span>arr<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br></div></div><h2 id=\"快速排序\" tabindex=\"-1\"> 快速排序</h2>\n<p>快速排序是一种原地排序,只需要一个很小的栈作为辅助空间,空间复杂度为 O(log2n),所以适合在数据集比较大的时候使用。</p>\n<h3 id=\"双边循环法\" tabindex=\"-1\"> 双边循环法</h3>\n<p>使用递归方法</p>\n<ol>\n<li>找一个基线条件(递归结束条件)区间不可再分；</li>\n<li>每一轮挑选一个基准元素,比基准元素大的元素移动到数列一边,小的元素移动到数列的另一边；</li>\n<li>然后分别对得到的子数组第二步的操作,直到符合基线条件。</li>\n</ol>\n<div><pre><code><span>class</span> <span>T</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>quickSort</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>,</span> <span>int</span> startIndex<span>,</span> <span>int</span> endIndex<span>)</span> <span>{</span>\n        <span>// 递归结束条件：startIndex大于或等于endIndex时</span>\n        <span>if</span> <span>(</span>startIndex <span>>=</span> endIndex<span>)</span> <span>{</span>\n            <span>return</span><span>;</span>\n        <span>}</span>\n        <span>// 得到基准元素位置</span>\n        <span>int</span> pivotIndex <span>=</span> <span>partition</span><span>(</span>arr<span>,</span> startIndex<span>,</span> endIndex<span>)</span><span>;</span>\n        <span>//根据基准元素,分成两部分进行递归排序</span>\n        <span>quickSort</span><span>(</span>arr<span>,</span> startIndex<span>,</span> pivotIndex <span>-</span> <span>1</span><span>)</span><span>;</span>\n        <span>quickSort</span><span>(</span>arr<span>,</span> pivotIndex <span>+</span> <span>1</span><span>,</span> endIndex<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 分治（双边循环法）\n     * 让数列中的元素依据自身大小,分别交换到基准元素的左右两边。\n     * <span>@param</span> <span>arr</span>         待交换的数组\n     * <span>@param</span> <span>startIndex</span>  起始下标\n     * <span>@param</span> <span>endIndex</span>    结束下标\n     */</span>\n    <span>private</span> <span>static</span> <span>int</span> <span>partition</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>,</span> <span>int</span> startIndex<span>,</span> <span>int</span> endIndex<span>)</span> <span>{</span>\n        <span>// 取第一个位置（也可以选择随机位置）的元素作为基准元素</span>\n        <span>int</span> pivot <span>=</span> arr<span>[</span>startIndex<span>]</span><span>;</span>\n        <span>int</span> left <span>=</span> startIndex<span>;</span>\n        <span>int</span> right <span>=</span> endIndex<span>;</span>\n\n        <span>while</span> <span>(</span>left <span>!=</span> right<span>)</span> <span>{</span>\n            <span>//控制right指针比较并左移</span>\n            <span>while</span> <span>(</span>left <span>&lt;</span> right <span>&amp;&amp;</span> arr<span>[</span>right<span>]</span> <span>>=</span> pivot<span>)</span> <span>{</span>\n                right<span>--</span><span>;</span>\n            <span>}</span>\n            <span>//控制left指针比较并右移</span>\n            <span>while</span> <span>(</span>left <span>&lt;</span> right <span>&amp;&amp;</span> arr<span>[</span>left<span>]</span> <span>&lt;=</span> pivot<span>)</span> <span>{</span>\n                left<span>++</span><span>;</span>\n            <span>}</span>\n            <span>//交换left 和 right指针所指向的元素</span>\n            <span>if</span> <span>(</span>left <span>&lt;</span> right<span>)</span> <span>{</span>\n                <span>int</span> tmp <span>=</span> arr<span>[</span>left<span>]</span><span>;</span>\n                arr<span>[</span>left<span>]</span> <span>=</span> arr<span>[</span>right<span>]</span><span>;</span>\n                arr<span>[</span>right<span>]</span> <span>=</span> tmp<span>;</span>\n            <span>}</span>\n        <span>}</span>\n\n        <span>//pivot和指针重合点交换</span>\n        arr<span>[</span>startIndex<span>]</span> <span>=</span> arr<span>[</span>left<span>]</span><span>;</span>\n        arr<span>[</span>left<span>]</span> <span>=</span> pivot<span>;</span>\n\n        <span>return</span> left<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>int</span><span>[</span><span>]</span> arr<span>;</span>\n        arr <span>=</span> <span>new</span> <span>int</span><span>[</span><span>]</span><span>{</span><span>4</span><span>,</span> <span>4</span><span>,</span> <span>6</span><span>,</span> <span>5</span><span>,</span> <span>3</span><span>,</span> <span>2</span><span>,</span> <span>8</span><span>,</span> <span>1</span><span>}</span><span>;</span>\n        <span>quickSort</span><span>(</span>arr<span>,</span> <span>0</span><span>,</span> arr<span>.</span>length <span>-</span> <span>1</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Arrays</span><span>.</span><span>toString</span><span>(</span>arr<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br></div></div><h3 id=\"单边循环法\" tabindex=\"-1\"> 单边循环法</h3>\n<p>1）设置一个 mark 指针指向数列起始位置,这个 mark 指针代表小于基准元素的<strong>区域边界</strong>。</p>\n<p>2）从基准元素的下一个位置开始遍历数组。</p>\n<p>如果遍历到的元素大于基准元素,就继续往后遍历。</p>\n<p>如果遍历到的元素小于基准元素,则需要做两件事：</p>\n<ul>\n<li>mark 指针右移一位,小于 pivot 的区域边界增大；</li>\n<li>让最新遍历到的元素和 mark 指针所在的元素交互位置。</li>\n</ul>\n<div><pre><code><span>class</span> <span>T</span> <span>{</span>\n    <span>private</span> <span>static</span> <span>int</span> <span>partitionV2</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>,</span> <span>int</span> startIndex<span>,</span> <span>int</span> endIndex<span>)</span> <span>{</span>\n        <span>int</span> pivot <span>=</span> arr<span>[</span>startIndex<span>]</span><span>;</span>\n        <span>int</span> mark <span>=</span> startIndex<span>;</span>\n\n        <span>//从基准元素的下一个位置开始遍历数组</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> endIndex<span>;</span> i <span>></span> startIndex<span>;</span> i<span>--</span><span>)</span> <span>{</span>\n            <span>//遍历到的元素小于基准元素</span>\n            <span>if</span> <span>(</span>arr<span>[</span>i<span>]</span> <span>&lt;</span> pivot<span>)</span> <span>{</span>\n                <span>//mark指针右移1位,小于pivot的区域边界增大了1;</span>\n                mark<span>++</span><span>;</span>\n                <span>//让最新遍历到的元素和mark指针所在位置的元素交换位置</span>\n                <span>int</span> p <span>=</span> arr<span>[</span>mark<span>]</span><span>;</span>\n                arr<span>[</span>mark<span>]</span> <span>=</span> arr<span>[</span>i<span>]</span><span>;</span>\n                arr<span>[</span>i<span>]</span> <span>=</span> p<span>;</span>\n            <span>}</span>\n            <span>//最后把pivot元素交换到mark指针所在位置,该数列的分治就宣告结束了。</span>\n            arr<span>[</span>startIndex<span>]</span> <span>=</span> arr<span>[</span>mark<span>]</span><span>;</span>\n            arr<span>[</span>mark<span>]</span> <span>=</span> pivot<span>;</span>\n            <span>return</span> mark<span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h2 id=\"冒泡排序\" tabindex=\"-1\"> 冒泡排序</h2>\n<ol>\n<li>比较相邻的两个数据,前一个元素比后一个元素大就交换位置</li>\n<li>从前往后,两两比较,得到最大数</li>\n<li>重复操作,直到最后一个值结束,得到的新数组就是有序的了</li>\n</ol>\n<div><pre><code><span>public</span> <span>class</span> <span>BubbleSort</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>sort</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>)</span> <span>{</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length <span>-</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span><span>//表示趟数,一共arr.length-1次。</span>\n            <span>for</span> <span>(</span><span>int</span> j <span>=</span> arr<span>.</span>length <span>-</span> <span>1</span><span>;</span> j <span>></span> i<span>;</span> j<span>--</span><span>)</span> <span>{</span>\n                <span>if</span> <span>(</span>arr<span>[</span>j <span>-</span> <span>1</span><span>]</span> <span>></span> arr<span>[</span>j<span>]</span><span>)</span> <span>{</span>\n                    <span>swap</span><span>(</span>arr<span>,</span> j<span>,</span> j <span>-</span> <span>1</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>//优化后版本</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>sortV2</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>)</span> <span>{</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length <span>-</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span><span>//趟数</span>\n            <span>boolean</span> isSorted <span>=</span> <span>true</span><span>;</span>\n            <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> arr<span>.</span>length <span>-</span> i <span>-</span> <span>1</span><span>;</span> j<span>++</span><span>)</span> <span>{</span>\n                <span>if</span> <span>(</span>arr<span>[</span>j<span>]</span> <span>&lt;</span> arr<span>[</span>j <span>+</span> <span>1</span><span>]</span><span>)</span> <span>{</span>\n                    <span>swap</span><span>(</span>arr<span>,</span> j<span>,</span> j <span>-</span> <span>1</span><span>)</span><span>;</span>\n                    isSorted <span>=</span> <span>false</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n            <span>if</span> <span>(</span>isSorted<span>)</span> <span>break</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>swap</span><span>(</span><span>int</span><span>[</span><span>]</span> a<span>,</span> <span>int</span> i<span>,</span> <span>int</span> j<span>)</span> <span>{</span>\n        <span>int</span> temp <span>=</span> a<span>[</span>i<span>]</span><span>;</span>\n        a<span>[</span>i<span>]</span> <span>=</span> a<span>[</span>j<span>]</span><span>;</span>\n        a<span>[</span>j<span>]</span> <span>=</span> temp<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><h2 id=\"选择排序\" tabindex=\"-1\"> 选择排序</h2>\n<p>假设<strong>最开始的值为最小值</strong>\n遍历数组,与最开始的元素一一比较,得到最小元素的位置然后交换元素。</p>\n<div><pre><code><span>package</span> <span>sort</span><span>;</span>\n\n<span>/*\n * created by sj 2019年8月16日\n */</span>\n<span>public</span> <span>class</span> <span>SelectSort</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>sort</span><span>(</span><span>int</span><span>[</span><span>]</span> a<span>)</span> <span>{</span>\n        <span>int</span> minIndex <span>=</span> <span>0</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> a<span>.</span>length <span>-</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            minIndex <span>=</span> i<span>;</span> <span>//最小元素下标初始值设为最开始的元素</span>\n            <span>for</span> <span>(</span><span>int</span> j <span>=</span> i <span>+</span> <span>1</span><span>;</span> j <span>&lt;</span> a<span>.</span>length<span>;</span> j<span>++</span><span>)</span> <span>{</span><span>//寻到最小的数,保存下标</span>\n                <span>if</span> <span>(</span>a<span>[</span>j<span>]</span> <span>&lt;</span> a<span>[</span>minIndex<span>]</span><span>)</span>\n                    minIndex <span>=</span> j<span>;</span>\n            <span>}</span>\n            <span>swap</span><span>(</span>a<span>,</span> minIndex<span>,</span> i<span>)</span><span>;</span><span>//交换</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>swap</span><span>(</span><span>int</span><span>[</span><span>]</span> a<span>,</span> <span>int</span> i<span>,</span> <span>int</span> j<span>)</span> <span>{</span>\n        <span>int</span> temp <span>=</span> a<span>[</span>i<span>]</span><span>;</span>\n        a<span>[</span>i<span>]</span> <span>=</span> a<span>[</span>j<span>]</span><span>;</span>\n        a<span>[</span>j<span>]</span> <span>=</span> temp<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h2 id=\"插入排序\" tabindex=\"-1\"> 插入排序</h2>\n<p>在要排序的一组数中，假设前面（N-1）[N&gt;=2]个数已经是排好顺序的，现在要把第N个树杈到前面的有序书中，使得这N个数也是排好顺序的。如此反复循环，直到全部排好顺序。</p>\n<div><pre><code><span>package</span> <span>sort</span><span>;</span>\n\n<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Arrays</span><span>;</span>\n\n<span>/*\n * created by sj 2019年8月16日\n */</span>\n<span>public</span> <span>class</span> <span>InsertSort</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>sort</span><span>(</span><span>int</span> a<span>[</span><span>]</span><span>)</span> <span>{</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> a<span>.</span>length <span>-</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> j <span>=</span> i <span>+</span> <span>1</span><span>;</span> j <span>></span> <span>0</span> <span>&amp;&amp;</span> a<span>[</span>j <span>-</span> <span>1</span><span>]</span> <span>></span> a<span>[</span>j<span>]</span><span>;</span> j<span>--</span><span>)</span> <span>{</span>\n                <span>swap</span><span>(</span>a<span>,</span> j <span>-</span> <span>1</span><span>,</span> j<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>swap</span><span>(</span><span>int</span><span>[</span><span>]</span> a<span>,</span> <span>int</span> i<span>,</span> <span>int</span> j<span>)</span> <span>{</span>\n        <span>int</span> temp <span>=</span> a<span>[</span>i<span>]</span><span>;</span>\n        a<span>[</span>i<span>]</span> <span>=</span> a<span>[</span>j<span>]</span><span>;</span>\n        a<span>[</span>j<span>]</span> <span>=</span> temp<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>int</span><span>[</span><span>]</span> a <span>=</span> <span>{</span><span>3</span><span>,</span> <span>5</span><span>,</span> <span>7</span><span>,</span> <span>1</span><span>,</span> <span>8</span><span>,</span> <span>6</span><span>}</span><span>;</span>\n        <span>sort</span><span>(</span>a<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Arrays</span><span>.</span><span>toString</span><span>(</span>a<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h2 id=\"桶排序\" tabindex=\"-1\"> 桶排序</h2>\n<p>桶排序<strong>利用函数的映射关系</strong></p>\n<p>一句话总结：划分多个范围相同的区间,每个子区间自排序,最后合并。</p>\n<p>桶排序是计数排序的扩展版本,计数排序可以看成每个桶只存储相同元素,而桶排序每个桶存储一定范围的元素,通过映射函数,将待排序数组中的元素映射到各个对应的桶中,对每个桶中的元素进行排序,最后将非空桶中的元素逐个放入原序列中。</p>\n<p>桶排序需要尽量保证元素分散均匀,否则当所有数据集中在同一个桶中时,桶排序失效。</p>\n<p><img src=\"@source/algo/img/1-2.png\" alt=\"\" loading=\"lazy\"></p>\n<div><pre><code><span>class</span> <span>T</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>bucketSort</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>)</span> <span>{</span>\n\n        <span>// 计算最大值与最小值</span>\n        <span>int</span> max <span>=</span> <span>Integer</span><span>.</span>MIN_VALUE<span>;</span>\n        <span>int</span> min <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE<span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            max <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>max<span>,</span> arr<span>[</span>i<span>]</span><span>)</span><span>;</span>\n            min <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>min<span>,</span> arr<span>[</span>i<span>]</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>// 计算桶的数量</span>\n        <span>int</span> bucketNum <span>=</span> <span>(</span>max <span>-</span> min<span>)</span> <span>/</span> arr<span>.</span>length <span>+</span> <span>1</span><span>;</span>\n        <span>ArrayList</span><span><span>&lt;</span><span>ArrayList</span><span>&lt;</span><span>Integer</span><span>></span><span>></span></span> bucketArr <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span>bucketNum<span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> bucketNum<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            bucketArr<span>.</span><span>add</span><span>(</span><span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>// 将每个元素放入桶</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>int</span> num <span>=</span> <span>(</span>arr<span>[</span>i<span>]</span> <span>-</span> min<span>)</span> <span>/</span> <span>(</span>arr<span>.</span>length<span>)</span><span>;</span>\n            bucketArr<span>.</span><span>get</span><span>(</span>num<span>)</span><span>.</span><span>add</span><span>(</span>arr<span>[</span>i<span>]</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>// 对每个桶进行排序</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> bucketArr<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>Collections</span><span>.</span><span>sort</span><span>(</span>bucketArr<span>.</span><span>get</span><span>(</span>i<span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>// 将桶中的元素赋值到原序列</span>\n        <span>int</span> index <span>=</span> <span>0</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> bucketArr<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> bucketArr<span>.</span><span>get</span><span>(</span>i<span>)</span><span>.</span><span>size</span><span>(</span><span>)</span><span>;</span> j<span>++</span><span>)</span> <span>{</span>\n                arr<span>[</span>index<span>++</span><span>]</span> <span>=</span> bucketArr<span>.</span><span>get</span><span>(</span>i<span>)</span><span>.</span><span>get</span><span>(</span>j<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><h2 id=\"计数排序\" tabindex=\"-1\"> 计数排序</h2>\n<p>根据原始数列的取值范围,创建一个<code>统计数组</code>,用来统计原始数列中每一个可能的整数值所出现的次数。</p>\n<p>原始数列中的整数值,和统计数组的下标是一一对应的,以数列的最小值作为偏移量。</p>\n<p>比如原始数列的最小值是 90,那么整数 95 对应的统计数组下标就是 95-90=5.</p>\n<p>每一个桶代表一个区间范围,里面可以承载一个或多个元素。</p>\n<p>算出数列最大值和最小值,并算出差值,初始化桶,桶个数有多种方式,<code>区间跨度= 差值 / （桶的数量-1）</code> 最后一个桶只包含数列最大值,其余桶区间跨度按照比例分配。</p>\n<p>将原始数组中的元素放进相应的桶中,桶内部的元素分别排序,输出所有元素。</p>\n<p>时间复杂度：n+m 空间复杂度：m</p>\n<div><pre><code><span>public</span> <span>class</span> <span>T</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>double</span><span>[</span><span>]</span> <span>bucketSort</span><span>(</span><span>double</span><span>[</span><span>]</span> array<span>)</span> <span>{</span>\n        <span>// 1.得到数列的最大值和最小值,并算出差值d</span>\n        <span>double</span> max <span>=</span> array<span>[</span><span>0</span><span>]</span><span>;</span>\n        <span>double</span> min <span>=</span> array<span>[</span><span>0</span><span>]</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> array<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>array<span>[</span>i<span>]</span> <span>></span> max<span>)</span> <span>{</span>\n                max <span>=</span> array<span>[</span>i<span>]</span><span>;</span>\n            <span>}</span>\n            <span>if</span> <span>(</span>array<span>[</span>i<span>]</span> <span>&lt;</span> min<span>)</span> <span>{</span>\n                min <span>=</span> array<span>[</span>i<span>]</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>double</span> d <span>=</span> max <span>-</span> min<span>;</span>\n\n        <span>// 2.初始化桶</span>\n        <span>int</span> bucketNum <span>=</span> array<span>.</span>length<span>;</span> <span>//我们这里创建的桶数等于原始数列的元素数量</span>\n        <span>List</span><span><span>&lt;</span><span>LinkedList</span><span>&lt;</span><span>Double</span><span>></span><span>></span></span> bucketList <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span>bucketNum<span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> bucketNum<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            bucketList<span>.</span><span>add</span><span>(</span><span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>Double</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>// 3.遍历原始数组,将每个元素放入桶中</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> array<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>int</span> num <span>=</span> <span>(</span><span>int</span><span>)</span> <span>(</span><span>(</span>array<span>[</span>i<span>]</span> <span>-</span> min<span>)</span> <span>*</span> <span>(</span>bucketNum <span>-</span> <span>1</span><span>)</span> <span>/</span> d<span>)</span><span>;</span>\n            bucketList<span>.</span><span>get</span><span>(</span>num<span>)</span><span>.</span><span>add</span><span>(</span>array<span>[</span>i<span>]</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>// 4.对每个通内部进行排序</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> bucketList<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>// JDK底层采用了归并排序或归并的优化版本</span>\n            <span>Collections</span><span>.</span><span>sort</span><span>(</span>bucketList<span>.</span><span>get</span><span>(</span>i<span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>// 5.输出全部元素</span>\n        <span>double</span><span>[</span><span>]</span> sortedArray <span>=</span> <span>new</span> <span>double</span><span>[</span>array<span>.</span>length<span>]</span><span>;</span>\n        <span>int</span> index <span>=</span> <span>0</span><span>;</span>\n        <span>for</span> <span>(</span><span>LinkedList</span><span><span>&lt;</span><span>Double</span><span>></span></span> list <span>:</span> bucketList<span>)</span> <span>{</span>\n            <span>for</span> <span>(</span><span>double</span> element <span>:</span> list<span>)</span> <span>{</span>\n                sortedArray<span>[</span>index<span>]</span> <span>=</span> element<span>;</span>\n                index<span>++</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> sortedArray<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>double</span><span>[</span><span>]</span> array <span>=</span> <span>new</span> <span>double</span><span>[</span><span>]</span><span>{</span><span>4.12</span><span>,</span> <span>6.421</span><span>,</span> <span>0.0023</span><span>,</span> <span>3.0</span><span>,</span> <span>2.123</span><span>,</span> <span>8.122</span><span>,</span> <span>4.12</span><span>,</span> <span>10.09</span><span>}</span><span>;</span>\n        <span>double</span><span>[</span><span>]</span> sortedArray <span>=</span> <span>bucketSort</span><span>(</span>array<span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Arrays</span><span>.</span><span>toString</span><span>(</span>sortedArray<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br></div></div><p><img src=\"https://img-blog.csdnimg.cn/20190828222358183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTgzNTI3,size_16,color_FFFFFF,t_70\" alt=\"各个排序的算法复杂度\" loading=\"lazy\"></p>\n<h2 id=\"希尔排序\" tabindex=\"-1\"> 希尔排序</h2>\n<p>算发现将要排序的一组数按某个增量D(n/2，n为要排序数的个数)分为若干组，每组中记录的下标相差D，</p>\n<h2 id=\"原地、稳定\" tabindex=\"-1\"> 原地、稳定</h2>\n<blockquote>\n<p>原地排序：是否使用了利用辅助的空间。\n稳定排序：数列值相等的元素排序后相对顺序不变</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>排序方式</th>\n<th>是否原地</th>\n<th>是否稳定</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>冒泡</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>插入</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>选择</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>归并</td>\n<td>×</td>\n<td>√</td>\n</tr>\n<tr>\n<td>堆</td>\n<td>√</td>\n<td>×</td>\n</tr>\n<tr>\n<td>桶</td>\n<td>×</td>\n<td>×</td>\n</tr>\n</tbody>\n</table>\n",
      "date_published": "2022-04-13T18:37:08.000Z",
      "date_modified": "2022-04-16T14:05:13.000Z",
      "authors": [],
      "tags": [
        "算法"
      ]
    },
    {
      "title": "60个著名的原理和定理",
      "url": "http://www.zhangsj.xyz/blog/note/60-famous-principles-and-theorems.html",
      "id": "http://www.zhangsj.xyz/blog/note/60-famous-principles-and-theorems.html",
      "content_html": "<h2 id=\"_60条有名的原则与定理\" tabindex=\"-1\"> 60条有名的原则与定理</h2>\n<p>1、蓝斯登原则：在你往上爬的时候，一定要保持梯子的整洁，否则你下来时可能会滑倒。</p>\n<p>提出者：美国管理学家蓝斯登。</p>\n<p>点评：进退有度，才不至进退维谷；宠辱皆忘，方可以宠辱不惊。</p>\n<p>2、卢维斯定理：谦虚不是把自己想得很糟，而是完全不想自己。</p>\n<p>提出者：美国心理学家卢维斯</p>\n<p>点评：如果把自己想得太好，就很容易将别人想得很糟。</p>\n<p>3、托利得定理：测验一个人的智力是否属于上乘，只看脑子里能否同时容纳两种相反的思想，而无碍于其处世行事。</p>\n<p>提出者：法国社会心理学家托利得</p>\n<p>点评：思可相反，得须相成。</p>\n<p>4、刺猬理论：刺猬在天冷时彼此靠拢取暖，但保持一定距离，以免互相刺伤。</p>\n<p>点评：保持亲密的重要方法，乃是保持适当的距离。</p>\n<p>5、鲦鱼效应：鲦鱼因个体弱小而常常群居，并以强健者为自然首领。将一只稍强的鲦鱼脑后控制行为的部分割除后，此鱼便失去自制力，行动也发生紊乱，但其他鲦鱼却仍像从前一样盲目追随。</p>\n<p>提出者：德国动物学家霍斯特</p>\n<p>点评：1、下属的悲剧总是领导一手造成的。2、下属觉得最没劲的事，是他们跟着一位最差劲的领导。</p>\n<p>6、雷鲍夫法则：在你着手建立合作和信任时要牢记我们语言中：</p>\n<p>1.最重要的八个字是：我承认我犯过错误 2.最重要的七个字是：你干了一件好事 3.最重要的六个字是：你的看法如何 4.最重要的五个字是：咱们一起干 5.最重要的四个字是：不妨试试 6.最重要的三个字是：谢谢您 7.最重要的两个字是：咱们 8.最重要的一个字是：您</p>\n<p>提出者：美国管理学家雷鲍夫</p>\n<p>点评：1、最重要的四个字是：不妨试试；2、最重要的一个字是：您</p>\n<p>7、洛伯定理：对于一个经理人来说，最要紧的不是你在场时的情况，而是你不在场时发生了什么。</p>\n<p>提出者：美国管理学家洛伯</p>\n<p>点评：如果只想让下属听你的，那么当你不在身边时他们就不知道应该听谁的了。</p>\n<p>8、斯坦纳定理：在哪里说得愈少，在哪里听到的就愈多。</p>\n<p>提出者：美国心理学家斯坦纳</p>\n<p>点评：只有很好听取别人的，才能更好说出自己的。</p>\n<p>9、费斯诺定理：人两只耳朵却只有一张嘴巴，这意味着人应该多听少讲。</p>\n<p>提出者：英国联合航空公司总裁兼总经理费斯诺</p>\n<p>点评：说得过多了，说的就会成为做的障碍。</p>\n<p>10、牢骚效应：凡是公司中有对工作发牢骚的人，那家公司或老板一定比没有这种人或有这种人而把牢骚埋在肚子里公司要成功得多。</p>\n<p>提出者：美国密歇根大学社会研究院</p>\n<p>点评：1、牢骚是改变不合理现状的催化剂。2、牢骚虽不总是正确的，但认真对待牢骚却总是正确的。</p>\n<p>11、避雷针效应：在高大建筑物顶端安装一个金属棒，用金属线与埋在地下的一块金属板连接起来，利用金属棒的尖端放电，使云层所带的电和地上的电逐渐中和，从而保护建筑物等避免雷击。</p>\n<p>点评：善疏则通，能导必安</p>\n<p>12、氨基酸组合效应：组成人体蛋白的八种氨基酸，只要有一种含量不足，其他七种就无法合成蛋白质。</p>\n<p>点评：当缺一不可时，一就是一切。</p>\n<p>13、米格-25 效应：前苏联研制的米格-25 喷气式战斗机的许多零部件与美国的相比都落后，但因设计者考虑了整体性能，故能在升降、速度、应急反应等方面成为当时世界一流。</p>\n<p>点评：所谓最佳整体，乃是个体的最佳组合。</p>\n<p>14、磨合效应：新组装的机器，通过一定时期的使用，把磨擦面上的加工痕迹磨光而变得更加密合。</p>\n<p>点评：要想达到完整的契合，须双方都做出必要的割舍。</p>\n<p>15、波特定理：当遭受许多批评时，下级往往只记住开头的一些，其余就不听了，因为他们忙于思索论据来反驳开头的批评。</p>\n<p>提出者：英国行为学家波特\n点评：总盯着下属的失误，是一个领导者的最大失误。</p>\n<p>16、蓝斯登定律：跟一位朋友一起工作，远较在父亲之下工作有趣得多。</p>\n<p>提出者：美国管理学家蓝斯登</p>\n<p>点评：可敬不可亲，终难敬；有权没有威，常失权。</p>\n<p>17、吉尔伯特法则：工作危机最确凿的信号，是没有人跟你说该怎样作。</p>\n<p>提出者：英国人力培训专家吉尔伯特</p>\n<p>点评：真正危险的事，是没人跟你谈危险。</p>\n<p>18、权威暗示效应：一化学家称，他将测验一瓶臭气的传播速度，他打开瓶盖 15 秒后，前排学生即举手，称自己闻到臭气，而后排的人则陆续举手，纷纷称自己也已闻到，其实瓶中什么也没有。</p>\n<p>点评：迷信则轻信，盲目必盲从。</p>\n<p>19、奥尼尔定理：所有的政治都是地方的。</p>\n<p>提出者：美国前众议院院长奥尼尔</p>\n<p>点评：只有能切身体会到的，群众才认为那是真实的。</p>\n<p>20、定位效应：社会心理学家曾作过一个试验：在召集会议时先让人们自由选择位子，之后到室外休息片刻再进入室内入座，如此五至六次，发现大多数人都选择他们第一次坐过的位子。</p>\n<p>点评：凡是自己认定的，人们大都不想轻易改变它。</p>\n<p>21、艾奇布恩定理：如果你遇见员工而不认得，或忘了他的名字，那你的公司就太大了点。</p>\n<p>提出者：英国史蒂芬约瑟剧院导演亚伦艾奇布恩</p>\n<p>点评：摊子一旦铺得过大，你就很难把它照顾周全。</p>\n<p>22、吉格勒定理：除了生命本身，没有任何才能不需要后天的锻炼。</p>\n<p>提出者：美国培训专家吉格吉格勒</p>\n<p>点评：水无积无辽阔，人不养不成才。</p>\n<p>23、犬獒效应：当年幼的藏犬长出牙齿并能撕咬时，主人就把它们放到一个没有食物和水的封闭环境里让这些幼犬自相撕咬，最后剩下一只活着的犬，这只犬称为獒。据说十只犬才能产生一只獒。</p>\n<p>点评：困境是造就强者的学校。</p>\n<p>24、近因效应：最近或最后的印象对人的认知有强烈的影响。</p>\n<p>提出者：美国社会心理学家洛钦斯。</p>\n<p>点评：结果往往会被视为过程的总结。</p>\n<p>25、洒井法则：在招工时用尽浑身解数，使出各种方法，不如使自身成为一个好公司，这样人才自然而然会汇集而来。</p>\n<p>提出者：日本企业管理顾问酒井正敬。</p>\n<p>点评：不能吸引人才，已有的人才也留不住。</p>\n<p>26、美即好效应：对一个外表英俊漂亮的人，人们很容易误认为他或她的其他方面也很不错。</p>\n<p>提出者：美国心理学家丹尼尔麦克尼尔。</p>\n<p>点评：印象一旦以情绪为基础，这一印象常会偏离事实。</p>\n<p>27、奥格尔维法则：如果我们每个人都雇用比我们自己都更强的人，我们就能成为巨人公司。</p>\n<p>提出者：美国奥格尔维马瑟公司总裁奥格尔维。</p>\n<p>点评：如果你所用的人都比你差，那么他们就只能作出比你更差的事情。</p>\n<p>28、皮尔卡丹定理：用人上一加一不等于二，搞不好等于零。</p>\n<p>提出者：法国著名企业家皮尔卡丹。</p>\n<p>点评：组合失当，常失整体优势，安排得宜，才成最佳配置。</p>\n<p>29、马蝇效应：再懒惰的马，只要身上有马蝇叮咬，它也会精神抖擞，飞快奔跑。</p>\n<p>点评：有正确的刺激，才会有正确的反应。</p>\n<p>30、倒 u 形假说：当一个人处于轻度兴奋时，能把工作作得最好。当一个人一点儿兴奋都没有时，也就没有作好工作的动力了；相应地，当一个人处于极度兴奋时，随之而来的压力可能会使他完不成本该完成的工作。世界网坛名将贝克尔之所以被称为常胜将军，其秘诀之一即是在比赛中自始至终防止过度兴奋，而保持半兴奋状态。所以有人亦将倒 u 形假说称为贝克尔境界。</p>\n<p>提出者：英国心理学家罗伯特耶基斯和多德林。</p>\n<p>点评：1、激情过热，激情就会把理智烧光。2、热情中的冷静让人清醒，冷静中的热情使人执着。</p>\n<p>31、特伯论断：在数字中找不到安全。</p>\n<p>提出者：美国经济学家特伯。</p>\n<p>点评：数字是死的，情况是活的。</p>\n<p>32、摩斯科定理：你得到的第一个回答，不一定是最好的回答。</p>\n<p>提出者：美国管理学家摩斯科。</p>\n<p>点评：刨根得根，问底知底。</p>\n<p>33、罗杰斯论断：成功的公司不会等待外界的影响来决定自己的命运，而是始终向前看。</p>\n<p>提出者：美国 IBM 公司前总裁罗杰斯。</p>\n<p>点评：只想随波逐流，难有理想彼岸。</p>\n<p>34、萨盖定律：戴一块手表的人知道准确的时间，戴两块手表的人便不敢确定几点了。</p>\n<p>提出者：英国心理学家萨盖。</p>\n<p>点评：若选错误参照，必无正确比较。</p>\n<p>35、隧道视野效应：一个人若身处隧道，他看到的就只是前后非常狭窄的视野。</p>\n<p>点评：1、不拓心路，难开视野。2、视野不宽，脚下的路也会愈走愈窄。</p>\n<p>36、巴菲特定律：在其他人都投了资的地方去投资，你是不会发财的。</p>\n<p>提出者：美国股神巴菲特。</p>\n<p>点评：1、善于走自己的路，才可望走别人没走过的路。2、特色不特，优势无优。</p>\n<p>37、古特雷定理：每一处出口都是另一处的入口。</p>\n<p>提出者：美国管理学家古特雷。</p>\n<p>点评：上一个目标是下一个目标的基础，下一个目标是上一个目标的延续。</p>\n<p>38、列文定理：那些犹豫着迟迟不能作出计划的人，通常是因为对自己的能力没有把握。</p>\n<p>提出者：法国管理学家列文。</p>\n<p>点评：如果没有能力去筹划，就只有时间去后悔了。</p>\n<p>39、弗洛斯特法则：在筑墙之前应该知道把什么圈出去，把什么圈进来。</p>\n<p>提出者：美国思想家弗洛斯特。</p>\n<p>点评：开始就明确了界限，最终就不会作出超越界限的事来。</p>\n<p>40、波克定理：只有在争辩中，才可能诞生最好的主意和最好的决定。</p>\n<p>提出者：美国庄臣公司总经理詹姆士波克。</p>\n<p>点评：无磨擦便无磨合，有争论才有高论。</p>\n<p>41、韦奇定理：即使你已有了主见，但如果有十个朋友看法和你相反，你就很难不动摇。</p>\n<p>提出者：美国洛杉矶加州大学经济学家伊渥韦奇。</p>\n<p>点评：1、未听之时不应有成见，既听之后不可无主见。2、不怕开始众说纷纭，只怕最后莫衷一是。</p>\n<p>42、福克兰定律：没有必要作出决定时，就有必要不作决定。</p>\n<p>提出者：法国管理学家福克兰。</p>\n<p>点评：当不知如何行动时，最好的行动就是不采取任何行动。</p>\n<p>43、王安论断：犹豫不决固然可以免去一些作错事的机会，但也失去了成功的机遇。</p>\n<p>提出者：美籍华裔企业家王安博士。</p>\n<p>点评：寡断能使好事由好变坏，果断可将危机转危为安。</p>\n<p>44、格瑞斯特定理：杰出的策略必须加上杰出的执行才能奏效。</p>\n<p>提出者：美国企业家格瑞斯特。</p>\n<p>点评：好事干实更好，实事办好愈实。</p>\n<p>45、吉德林法则：</p>\n<p>把难题清清楚楚地写出来，便已经解决了一半。</p>\n<p>提出者：美国通用汽车公司管理顾问查尔斯吉德林。</p>\n<p>点评：杂乱无章的思维，不可能产生有条有理的行动。</p>\n<p>46、沃尔森法则：把信息和情报放在第一位，金钱就会滚滚而来。</p>\n<p>提出者：美国企业家沃尔森。</p>\n<p>点评：你能得到多少，往往取决于你能知道多少。</p>\n<p>47、塔马拉效应：塔马拉是捷克雷达专家弗佩赫发明的一种雷达，它与其他雷达的最大不同是不发射信号而只接收信号，故不会被敌方反雷达装置发现。</p>\n<p>点评：善藏者人不可知，能知者人无以藏。</p>\n<p>48、小池定理：越是沉醉，就越是抓住眼前的东西不放。</p>\n<p>提出者：日本管理学家小池敬。</p>\n<p>点评：自我陶醉不易清醒，自以为是不喜批评。</p>\n<p>49、赫勒法则：</p>\n<p>当人们知道自己的工作成绩有人检查的时候会加倍努力。</p>\n<p>提出者：英国管理学家赫勒。</p>\n<p>点评：只有在相互信任的情况下，监督才会成为动力。</p>\n<p>50 横山法则：最有效并持续不断的控制不是强制，而是触发个人内在的自发控制。</p>\n<p>提出者：日本社会学家横山宁夫。</p>\n<p>点评：有自觉性才有积极性，无自决权便无主动权</p>\n<p>51、蝴蝶效应：紊乱学研究者称，南半球某地的一只蝴蝶偶尔扇动一下翅膀所引起的微弱气流，几星期后可变成席卷北半球某地的一场龙卷风。他们将这种由一个极小起因，经过一定的时间，在其他因素的参与作用下，发展成极为巨大和复杂后果的现象称为蝴蝶效应。</p>\n<p>点评：善终者慎始，谨小者慎微。</p>\n<p>52、阿什法则：承认问题是解决问题的第一步。</p>\n<p>提出者：美国企业家阿什。</p>\n<p>点评：你愈是躲着问题，问题愈会揪住你不放。</p>\n<p>53、洛克忠告：规定应该少定，一旦定下之后，便得严格遵守。</p>\n<p>提出者：英国教育家洛克。</p>\n<p>点评：简则易循，严则必行。</p>\n<p>54、热炉法则：当人用手去碰烧热的火炉时，就会受到烫的惩罚，其有以下三个特点：即时性、预警性、平等性。</p>\n<p>点评：罪与罚能相符，法与治可相期。</p>\n<p>55、柯美雅定律：世上没有十全十美的东西，所以任何东西都有改革的余地。</p>\n<p>提出者：美国社会心理学家柯美雅。</p>\n<p>点评：不拘于常规，才能激发出创造力。</p>\n<p>56、达维多夫定律：没有创新精神的人永远也只能是一个执行者。</p>\n<p>提出者：前苏联心理学家达维多夫</p>\n<p>点评：只有敢为人先的人，才最有资格成为真正的先驱者。</p>\n<p>57、自吃幼崽效应：美国硅谷企业竞争十分激烈，以至于各公司都积极寻找自己的致命弱点，所有公司共同的生存之道是：拿出更好看产品来击败自己的原有产品。有人将这种行为戏称为自吃幼崽。</p>\n<p>点评：1、自己不逼自己，别人迟早会逼你。2、敢于对过去告一个段落，才有信心掀开新的一章。</p>\n<p>58、舍恩定理：新思想只有落到真正相信它，对它着迷的人手里才能开花结果。</p>\n<p>提出者：美国麻省理工学院教授舍恩。</p>\n<p>点评：只有信之不疑，才能持之以恒。</p>\n<p>59、吉宁定理：真正的错误是害怕犯错误。</p>\n<p>提出者：美国管理学家吉宁。</p>\n<p>点评：不怕错误的人，错误往往也离他最远。</p>\n<p>60、卡贝定理：放弃是创新的钥匙。</p>\n<p>提出者：美国电话电报公司前总经理卡贝。</p>\n<p>点评：在未学会放弃之前，你将很难懂得什么是争取。</p>\n<p><a href=\"https://blog.csdn.net/poem_qianmo/article/details/30025827?spm=1001.2014.3001.5501\" target=\"_blank\" rel=\"noopener noreferrer\">reference</a></p>\n<p>用 ctrl+r 进行内容替换，使用正则表达式，用^\\s*\\n 替换空即可</p>\n<p>\\s 包括空格、制表符、换页符等空白字符的其中任意一个\n\\r,\\n 代表回车和换行符 *表达式不出现或出现任意次，相当于{0,}，</p>\n",
      "date_published": "2022-04-13T18:37:08.000Z",
      "date_modified": "2022-04-14T05:48:05.000Z",
      "authors": [],
      "tags": [
        "摘录"
      ]
    },
    {
      "title": "做一个批判性思维的程序员",
      "url": "http://www.zhangsj.xyz/blog/note/a_little_experience_of_exporting_tens_of_millions_of_data_to_excel.html",
      "id": "http://www.zhangsj.xyz/blog/note/a_little_experience_of_exporting_tens_of_millions_of_data_to_excel.html",
      "content_html": "<h1 id=\"千万级的数据用-excel-导出\" tabindex=\"-1\"> 千万级的数据用 EXCEL 导出</h1>\n<p>最近做了个项目,使用 MYSQL 数据库,要求做到千万级的数据用 EXCEL 导出,试了良久,找出了几个方法.</p>\n<h2 id=\"问题\" tabindex=\"-1\"> 问题</h2>\n<p>JAVA 实现大数据量导出操作时，如果采用 POI 直接导出，会出现内存溢出的情况。再者 EXCEL 的 SHEET 也存在行数的限制，Excel2003 版最大行数是 655536 行、Excel2007 版最大行数是 1048576 行、Excel2010 版最大行数是 1048576 行。</p>\n<h2 id=\"解决方案\" tabindex=\"-1\"> 解决方案</h2>\n<ol>\n<li>先统计总的记录数，如果大于一定数目则采用压缩文件方式导出</li>\n<li>采用分页方式从数据库中获取数据，并生成多个 Excel 临时文件</li>\n<li>将临时文件 Excel 压缩导出</li>\n<li>删除服务器上的临时文件</li>\n</ol>\n<p>注：\n使用流式读取,耗时 3 分钟,速度还可以再优化,就是占用内存太大,1000W 数据占了 3G 运存,关键字为 <code>resultSetType=&quot;FORWARD_ONLY&quot; fetchSize=&quot;-2147483648&quot;</code></p>\n<p>但是这样得话老大非找我麻烦不可.不过百万左右的数据用这个,速度是真快 3.使用两者结合,在 mybatis 里开启流式读取,并且启用分批读取\n这样数据量大的时候分批读取也不会太慢,读取一批数据,处理一批数据并清空,然后读取下一段,这样耗时 10 分钟左右,256M 内存也正常运行,配合 easyexcel</p>\n<div><pre><code><span>class</span> <span>T</span> <span>{</span>\n    <span>@RequestMapping</span><span>(</span>value <span>=</span> <span>\"/exportExcelFile\"</span><span>,</span> produces <span>=</span> <span>{</span><span>\"text/plain;charset=UTF-8\"</span><span>}</span><span>)</span>\n    <span>public</span> <span>void</span> <span>excelDownLoad</span><span>(</span><span>Map</span> params<span>,</span> <span>HttpServletResponse</span> response<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>QueryParam</span> queryParam <span>=</span> <span>new</span> <span>QueryParam</span><span>(</span><span>)</span><span>;</span>\n        <span>Long</span> allRowNumbers <span>=</span> <span>0L</span><span>;</span>\n        <span>Long</span> rowMaxCount <span>=</span> <span>60000L</span><span>;</span>\n        <span>// 查询记录数</span>\n        allRowNumbers <span>=</span> ossFileListBiz<span>.</span><span>totalRecord</span><span>(</span>queryParam<span>.</span><span>getSqlMap</span><span>(</span><span>)</span><span>)</span><span>;</span>\n\n        <span>// 是否大数据量（超过6W）</span>\n        <span>if</span> <span>(</span>allRowNumbers <span>></span> rowMaxCount<span>)</span> <span>{</span>\n            <span>List</span> list <span>=</span> <span>new</span> <span>ArrayList</span><span>(</span><span>)</span><span>;</span>\n            <span>List</span> downList <span>=</span> <span>new</span> <span>ArrayList</span><span>(</span><span>)</span><span>;</span>\n            <span>// 1.设置相应头</span>\n            <span>String</span> filename <span>=</span> <span>\"导出TEST.zip\"</span><span>;</span>\n            filename <span>=</span> <span>new</span> <span>String</span><span>(</span>filename<span>.</span><span>getBytes</span><span>(</span><span>\"GBK\"</span><span>)</span><span>,</span> <span>\"iso-8859-1\"</span><span>)</span><span>;</span>\n            response<span>.</span><span>reset</span><span>(</span><span>)</span><span>;</span>\n            response<span>.</span><span>setContentType</span><span>(</span><span>\"application/octet-stream;charset=UTF-8\"</span><span>)</span><span>;</span>\n            response<span>.</span><span>setHeader</span><span>(</span><span>\"Content-Disposition\"</span><span>,</span> <span>\"attachment;filename=\"</span> <span>+</span> filename<span>)</span><span>;</span>\n            response<span>.</span><span>addHeader</span><span>(</span><span>\"pargam\"</span><span>,</span> <span>\"no-cache\"</span><span>)</span><span>;</span>\n            response<span>.</span><span>addHeader</span><span>(</span><span>\"Cache-Control\"</span><span>,</span> <span>\"no-cache\"</span><span>)</span><span>;</span>\n\n            <span>// 2.设置批次文件名</span>\n            <span>String</span> fileSuff <span>=</span> <span>\"\"</span><span>;</span>\n            <span>SimpleDateFormat</span> sdf <span>=</span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>\"yyyyMMddHHmmss\"</span><span>)</span><span>;</span>\n            fileSuff <span>=</span> sdf<span>.</span><span>format</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>String</span> fileName <span>=</span> <span>\"导出TEST\"</span> <span>+</span> fileSuff<span>;</span>\n            <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> fileNames <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span> <span>// 存放生成的文件名称</span>\n            <span>String</span> filePath <span>=</span> <span>\"D:/excel/\"</span><span>;</span> <span>// 上线后切换成linux服务器地址</span>\n            <span>if</span> <span>(</span><span>!</span><span>new</span> <span>File</span><span>(</span>filePath<span>)</span><span>.</span><span>exists</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                <span>new</span> <span>File</span><span>(</span>filePath<span>)</span><span>.</span><span>mkdirs</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n            <span>File</span> zip <span>=</span> <span>new</span> <span>File</span><span>(</span>filePath <span>+</span> fileName <span>+</span> <span>\".zip\"</span><span>)</span><span>;</span> <span>// 压缩文件路径</span>\n\n            <span>// 3.分批次生成excel</span>\n            <span>Long</span> tempsize <span>=</span> <span>(</span>allRowNumbers <span>%</span> rowMaxCount<span>)</span> <span>==</span> <span>0</span> <span>?</span> allRowNumbers <span>/</span> rowMaxCount\n                    <span>:</span> allRowNumbers <span>/</span> rowMaxCount <span>+</span> <span>1</span><span>;</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> tempsize<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                <span>if</span> <span>(</span>i <span>==</span> <span>(</span>allRowNumbers <span>/</span> rowMaxCount<span>)</span><span>)</span> <span>{</span>\n                    queryParam<span>.</span><span>setPageNow</span><span>(</span><span>(</span>i <span>+</span> <span>1</span><span>)</span><span>)</span><span>;</span>\n                    queryParam<span>.</span><span>setPageSize</span><span>(</span><span>Integer</span><span>.</span><span>valueOf</span><span>(</span><span>String</span><span>.</span><span>valueOf</span><span>(</span>rowMaxCount<span>)</span><span>)</span><span>)</span><span>;</span>\n                    <span>// params.put(\"startNum\", i*rowMaxCount);</span>\n                    <span>// params.put(\"endNum\", allRowNumbers);</span>\n                <span>}</span> <span>else</span> <span>{</span>\n                    <span>// params.put(\"startNum\", i*rowMaxCount);</span>\n                    <span>// params.put(\"endNum\", (i+1)*rowMaxCount);</span>\n                    queryParam<span>.</span><span>setPageNow</span><span>(</span><span>(</span>i <span>+</span> <span>1</span><span>)</span><span>)</span><span>;</span>\n                    queryParam<span>.</span><span>setPageSize</span><span>(</span><span>Integer</span><span>.</span><span>valueOf</span><span>(</span><span>String</span><span>.</span><span>valueOf</span><span>(</span>rowMaxCount<span>)</span><span>)</span><span>)</span><span>;</span>\n                <span>}</span>\n                list <span>=</span> ossFileListBiz<span>.</span><span>findList</span><span>(</span>queryParam<span>)</span><span>;</span>\n\n                <span>// 3.2生成excel</span>\n                <span>String</span> tempExcelFile <span>=</span> filePath <span>+</span> fileName <span>+</span> <span>\"[\"</span> <span>+</span> <span>(</span>i <span>+</span> <span>1</span><span>)</span> <span>+</span> <span>\"-pic].xlsx\"</span><span>;</span>\n                fileNames<span>.</span><span>add</span><span>(</span>tempExcelFile<span>)</span><span>;</span>\n                <span>FileOutputStream</span> fos <span>=</span> <span>new</span> <span>FileOutputStream</span><span>(</span>tempExcelFile<span>)</span><span>;</span>\n                <span>int</span> rowMemory <span>=</span> <span>100</span><span>;</span>\n                <span>SXSSFWorkbook</span> wb <span>=</span> <span>new</span> <span>SXSSFWorkbook</span><span>(</span>rowMemory<span>)</span><span>;</span>\n                <span>try</span> <span>{</span>\n                    wb <span>=</span> <span>exportDataToExcelXLSX</span><span>(</span>wb<span>,</span> list<span>)</span><span>;</span>\n                    wb<span>.</span><span>write</span><span>(</span>fos<span>)</span><span>;</span>\n                    fos<span>.</span><span>flush</span><span>(</span><span>)</span><span>;</span>\n                    fos<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span> <span>catch</span> <span>(</span><span>RuntimeException</span> runMsg<span>)</span> <span>{</span>\n                    <span>throw</span> <span>new</span> <span>Exception</span><span>(</span><span>\"查询数据信息异常 \"</span><span>)</span><span>;</span>\n                <span>}</span> <span>finally</span> <span>{</span>\n                    fos<span>.</span><span>flush</span><span>(</span><span>)</span><span>;</span>\n                    fos<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n                    <span>// 手动清除list</span>\n                    list<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>\n                    downList<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n            <span>// 4.导出zip压缩文件</span>\n            <span>exportZip</span><span>(</span>response<span>,</span> fileNames<span>,</span> zip<span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"导出失败\"</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>/**\n     * 文件压缩并导出到客户端\n     *\n     * <span>@param</span> <span>outPut</span>\n     * <span>@param</span> <span>fileNames</span>\n     * <span>@param</span> <span>zip</span>\n     * <span>@throws</span> <span><span>FileNotFoundException</span></span>\n     * <span>@throws</span> <span><span>IOException</span></span>\n     */</span>\n    <span>private</span> <span>void</span> <span>exportZip</span><span>(</span><span>HttpServletResponse</span> response<span>,</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> fileNames<span>,</span> <span>File</span> zip<span>)</span>\n            <span>throws</span> <span>FileNotFoundException</span><span>,</span> <span>IOException</span> <span>{</span>\n        <span>OutputStream</span> outPut <span>=</span> response<span>.</span><span>getOutputStream</span><span>(</span><span>)</span><span>;</span>\n\n        <span>// 1.压缩文件</span>\n        <span>File</span> srcFile<span>[</span><span>]</span> <span>=</span> <span>new</span> <span>File</span><span>[</span>fileNames<span>.</span><span>size</span><span>(</span><span>)</span><span>]</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> fileNames<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            srcFile<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>File</span><span>(</span>fileNames<span>.</span><span>get</span><span>(</span>i<span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>byte</span><span>[</span><span>]</span> byt <span>=</span> <span>new</span> <span>byte</span><span>[</span><span>1024</span><span>]</span><span>;</span>\n        <span>ZipOutputStream</span> out <span>=</span> <span>new</span> <span>ZipOutputStream</span><span>(</span><span>new</span> <span>FileOutputStream</span><span>(</span>zip<span>)</span><span>)</span><span>;</span>\n        <span>// out.setEncoding(\"UTF-8\");</span>\n        <span>for</span> <span>(</span><span>File</span> file <span>:</span> srcFile<span>)</span> <span>{</span>\n            <span>FileInputStream</span> in <span>=</span> <span>new</span> <span>FileInputStream</span><span>(</span>file<span>)</span><span>;</span>\n            out<span>.</span><span>putNextEntry</span><span>(</span><span>new</span> <span>ZipEntry</span><span>(</span>file<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n            <span>int</span> length<span>;</span>\n            <span>while</span> <span>(</span><span>(</span>length <span>=</span> in<span>.</span><span>read</span><span>(</span>byt<span>)</span><span>)</span> <span>></span> <span>0</span><span>)</span> <span>{</span>\n                out<span>.</span><span>write</span><span>(</span>byt<span>,</span> <span>0</span><span>,</span> length<span>)</span><span>;</span>\n            <span>}</span>\n            out<span>.</span><span>closeEntry</span><span>(</span><span>)</span><span>;</span>\n            in<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        out<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n\n        <span>// 2.删除服务器上的临时文件(excel)</span>\n        <span>for</span> <span>(</span><span>File</span> temFile <span>:</span> srcFile<span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>temFile<span>.</span><span>exists</span><span>(</span><span>)</span> <span>&amp;&amp;</span> temFile<span>.</span><span>isFile</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                temFile<span>.</span><span>delete</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n\n        <span>// 3.返回客户端压缩文件</span>\n        <span>FileInputStream</span> inStream <span>=</span> <span>new</span> <span>FileInputStream</span><span>(</span>zip<span>)</span><span>;</span>\n        <span>byte</span><span>[</span><span>]</span> buf <span>=</span> <span>new</span> <span>byte</span><span>[</span><span>4096</span><span>]</span><span>;</span>\n        <span>int</span> readLenght<span>;</span>\n        <span>while</span> <span>(</span><span>(</span>readLenght <span>=</span> inStream<span>.</span><span>read</span><span>(</span>buf<span>)</span><span>)</span> <span>!=</span> <span>-</span><span>1</span><span>)</span> <span>{</span>\n            outPut<span>.</span><span>write</span><span>(</span>buf<span>,</span> <span>0</span><span>,</span> readLenght<span>)</span><span>;</span>\n        <span>}</span>\n        inStream<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n        outPut<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n\n        <span>// 4.删除压缩文件</span>\n        <span>if</span> <span>(</span>zip<span>.</span><span>exists</span><span>(</span><span>)</span> <span>&amp;&amp;</span> zip<span>.</span><span>isFile</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            zip<span>.</span><span>delete</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>/**\n     * 设置excel样式和数值\n     *\n     * <span>@param</span> <span>wb</span>\n     * <span>@param</span> <span>listMap</span>\n     * <span>@param</span> <span>companyatr</span>\n     * <span>@return</span>\n     * <span>@throws</span> <span><span>Exception</span></span>\n     */</span>\n    <span>private</span> <span>static</span> <span>SXSSFWorkbook</span> <span>exportDataToExcelXLSX</span><span>(</span><span>SXSSFWorkbook</span> wb<span>,</span> <span>List</span><span><span>&lt;</span><span>Object</span><span>></span></span> listMap<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>String</span><span>[</span><span>]</span> assetHeadTemp <span>=</span> <span>{</span><span>\"ID\"</span><span>,</span> <span>\"路径\"</span><span>}</span><span>;</span>\n        <span>String</span><span>[</span><span>]</span> assetNameTemp <span>=</span> <span>{</span><span>\"id\"</span><span>,</span> <span>\"path\"</span><span>}</span><span>;</span>\n        <span>Sheet</span> sheet <span>=</span> <span>null</span><span>;</span>\n        <span>CellStyle</span> columnHeadStyle <span>=</span> wb<span>.</span><span>createCellStyle</span><span>(</span><span>)</span><span>;</span>\n        columnHeadStyle<span>.</span><span>setBorderBottom</span><span>(</span><span>HSSFCellStyle</span><span>.</span>BORDER_THIN<span>)</span><span>;</span><span>// 下边框</span>\n        columnHeadStyle<span>.</span><span>setBorderLeft</span><span>(</span><span>HSSFCellStyle</span><span>.</span>BORDER_THIN<span>)</span><span>;</span><span>// 左边框</span>\n        columnHeadStyle<span>.</span><span>setBorderRight</span><span>(</span><span>HSSFCellStyle</span><span>.</span>BORDER_THIN<span>)</span><span>;</span><span>// 右边框</span>\n        columnHeadStyle<span>.</span><span>setBorderTop</span><span>(</span><span>HSSFCellStyle</span><span>.</span>BORDER_THIN<span>)</span><span>;</span><span>// 上边框</span>\n        columnHeadStyle<span>.</span><span>setAlignment</span><span>(</span><span>HSSFCellStyle</span><span>.</span>ALIGN_CENTER<span>)</span><span>;</span>\n        columnHeadStyle<span>.</span><span>setVerticalAlignment</span><span>(</span><span>HSSFCellStyle</span><span>.</span>VERTICAL_CENTER<span>)</span><span>;</span>\n        columnHeadStyle<span>.</span><span>setWrapText</span><span>(</span><span>true</span><span>)</span><span>;</span>\n        <span>Font</span> f <span>=</span> wb<span>.</span><span>createFont</span><span>(</span><span>)</span><span>;</span><span>// 字体</span>\n        f<span>.</span><span>setFontHeightInPoints</span><span>(</span><span>(</span><span>short</span><span>)</span> <span>9</span><span>)</span><span>;</span><span>// 字号</span>\n        f<span>.</span><span>setBoldweight</span><span>(</span><span>HSSFFont</span><span>.</span>BOLDWEIGHT_BOLD<span>)</span><span>;</span><span>// BOLDWEIGHT_BOLD);// 加粗</span>\n        columnHeadStyle<span>.</span><span>setFont</span><span>(</span>f<span>)</span><span>;</span>\n        <span>Row</span> row<span>;</span>\n        <span>Cell</span> cell<span>;</span>\n        sheet <span>=</span> wb<span>.</span><span>createSheet</span><span>(</span><span>\"sheet\"</span><span>)</span><span>;</span>\n        row <span>=</span> sheet<span>.</span><span>createRow</span><span>(</span><span>0</span><span>)</span><span>;</span>\n        sheet<span>.</span><span>createFreezePane</span><span>(</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>0</span><span>,</span> <span>1</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> assetHeadTemp<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            cell <span>=</span> row<span>.</span><span>createCell</span><span>(</span>i<span>)</span><span>;</span>\n            cell<span>.</span><span>setCellStyle</span><span>(</span>columnHeadStyle<span>)</span><span>;</span>\n            cell<span>.</span><span>setCellValue</span><span>(</span>assetHeadTemp<span>[</span>i<span>]</span><span>)</span><span>;</span>\n            sheet<span>.</span><span>setColumnWidth</span><span>(</span>i<span>,</span> <span>(</span><span>int</span><span>)</span> <span>7000</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>listMap <span>!=</span> <span>null</span> <span>&amp;&amp;</span> listMap<span>.</span><span>size</span><span>(</span><span>)</span> <span>></span> <span>0</span><span>)</span> <span>{</span>\n            <span>int</span> rowIndex <span>=</span> <span>1</span><span>;</span>\n            <span>for</span> <span>(</span><span>Object</span> m <span>:</span> listMap<span>)</span> <span>{</span>\n                <span>Map</span> map <span>=</span> <span>objectToMap</span><span>(</span>m<span>)</span><span>;</span>\n                row <span>=</span> sheet<span>.</span><span>createRow</span><span>(</span>rowIndex<span>++</span><span>)</span><span>;</span>\n                <span>int</span> index <span>=</span> <span>0</span><span>;</span>\n                <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> assetNameTemp<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                    cell <span>=</span> row<span>.</span><span>createCell</span><span>(</span>index<span>++</span><span>)</span><span>;</span>\n                    cell<span>.</span><span>setCellValue</span><span>(</span>map<span>.</span><span>get</span><span>(</span>assetNameTemp<span>[</span>i<span>]</span><span>)</span> <span>!=</span> <span>null</span> <span>?</span> map<span>.</span><span>get</span><span>(</span>assetNameTemp<span>[</span>i<span>]</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span> <span>:</span> <span>\"\"</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> wb<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> <span>objectToMap</span><span>(</span><span>Object</span> obj<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>if</span> <span>(</span>obj <span>==</span> <span>null</span><span>)</span>\n            <span>return</span> <span>null</span><span>;</span>\n        <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        <span>BeanInfo</span> beanInfo <span>=</span> <span>Introspector</span><span>.</span><span>getBeanInfo</span><span>(</span>obj<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>PropertyDescriptor</span><span>[</span><span>]</span> propertyDescriptors <span>=</span> beanInfo<span>.</span><span>getPropertyDescriptors</span><span>(</span><span>)</span><span>;</span>\n        <span>for</span> <span>(</span><span>PropertyDescriptor</span> property <span>:</span> propertyDescriptors<span>)</span> <span>{</span>\n            <span>String</span> key <span>=</span> property<span>.</span><span>getName</span><span>(</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>key<span>.</span><span>compareToIgnoreCase</span><span>(</span><span>\"class\"</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>\n                <span>continue</span><span>;</span>\n            <span>}</span>\n            <span>Method</span> getter <span>=</span> property<span>.</span><span>getReadMethod</span><span>(</span><span>)</span><span>;</span>\n            <span>Object</span> value <span>=</span> getter <span>!=</span> <span>null</span> <span>?</span> getter<span>.</span><span>invoke</span><span>(</span>obj<span>)</span> <span>:</span> <span>null</span><span>;</span>\n            map<span>.</span><span>put</span><span>(</span>key<span>,</span> value<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> map<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br><span>196</span><br><span>197</span><br><span>198</span><br><span>199</span><br><span>200</span><br><span>201</span><br><span>202</span><br><span>203</span><br><span>204</span><br></div></div>",
      "date_published": "2022-04-13T18:37:08.000Z",
      "date_modified": "2022-04-14T05:48:05.000Z",
      "authors": [],
      "tags": [
        "随笔"
      ]
    },
    {
      "title": "空指针异常，诡计多端！",
      "url": "http://www.zhangsj.xyz/blog/note/a_null_pointer_exception-therearesomanytricks.html",
      "id": "http://www.zhangsj.xyz/blog/note/a_null_pointer_exception-therearesomanytricks.html",
      "content_html": "<h1 id=\"一个-nullpointerexception-竟然有这么多花样\" tabindex=\"-1\"> 一个 NullPointerException ，竟然有这么多花样</h1>\n<h2 id=\"问题\" tabindex=\"-1\"> 问题</h2>\n<p>有个问题实在定位不出来（随机出现的一个空指针异常），可否帮忙看看!☺</p>\n<p>敢问各位大佬，在使用spring 的缓存注解@Cacheable 时，缓存配置的时redis，客户端Jedis ,生产时单点，线上是否碰到过随机的空指针异常，有spring的RedisCache在get时抛出的；</p>\n<p>这里就涉及到一个重要的问题，那就是提问的艺术</p>\n<p>比如说：我们常见的错误提问方式是：</p>\n<p>你们有没有遇到过XXX问题？【X】</p>\n<p>看到这样的问题着实让人脑壳疼，其实简单的常见问题网上搜一下都有</p>\n<p>复杂的问题基本和业务相关，别人碰到和你一样的问题的概率很小</p>\n<p>比较正确的提问姿势应该是把问题具体描述出来</p>\n<p>我做了什么事， 我期望的结果是XX，但是目前出现的结果又是XX ，异常栈信息如下XX【v】</p>\n<p>感兴趣的自然会出声，不感兴趣的那也没办法</p>\n<p>等他出来，再做工作交接，但是得把现有的问题处理处理，再交接。</p>\n<p>要写个交接文档，包括流程、操作表之类的，代码实现具体类、方法。</p>\n<p>有还有另一种奇葩问法：</p>\n<p>XX功能怎么做，如何实现？</p>\n<h2 id=\"案发现场\" tabindex=\"-1\"> 案发现场</h2>\n<p>我们先看一下给出的异常栈</p>\n<div><pre><code><span><span>java<span>.</span>lang<span>.</span></span>NullPointerException</span>\n at <span><span>org<span>.</span>springframework<span>.</span>data<span>.</span>redis<span>.</span>cache<span>.</span></span>RedisCache</span><span>.</span><span>get</span><span>(</span><span>RedisCache</span><span>.</span>java<span>:</span><span>180</span><span>)</span>\n at <span><span>org<span>.</span>springframework<span>.</span>data<span>.</span>redis<span>.</span>cache<span>.</span></span>RedisCache</span><span>.</span><span>get</span><span>(</span><span>RedisCache</span><span>.</span>java<span>:</span><span>133</span><span>)</span>\n at <span><span>org<span>.</span>springframework<span>.</span>cache<span>.</span>transaction<span>.</span></span>TransactionAwareCacheDecorator</span><span>.</span><span>get</span><span>(</span><span>TransactionAwareCacheDecorator</span><span>.</span>java<span>:</span><span>69</span><span>)</span>\n at <span><span>org<span>.</span>springframework<span>.</span>cache<span>.</span>interceptor<span>.</span></span>AbstractCacheInvoker</span><span>.</span><span>doGet</span><span>(</span><span>AbstractCacheInvoker</span><span>.</span>java<span>:</span><span>71</span><span>)</span>\n at <span><span>org<span>.</span>springframework<span>.</span>cache<span>.</span>interceptor<span>.</span></span>CacheAspectSupport</span><span>.</span><span>findInCaches</span><span>(</span><span>CacheAspectSupport</span><span>.</span>java<span>:</span><span>537</span><span>)</span>\n at <span><span>org<span>.</span>springframework<span>.</span>cache<span>.</span>interceptor<span>.</span></span>CacheAspectSupport</span><span>.</span><span>findCachedItem</span><span>(</span><span>CacheAspectSupport</span><span>.</span>java<span>:</span><span>503</span><span>)</span>\n at <span><span>org<span>.</span>springframework<span>.</span>cache<span>.</span>interceptor<span>.</span></span>CacheAspectSupport</span><span>.</span><span>execute</span><span>(</span><span>CacheAspectSupport</span><span>.</span>java<span>:</span><span>389</span><span>)</span>\n at <span><span>org<span>.</span>springframework<span>.</span>cache<span>.</span>interceptor<span>.</span></span>CacheAspectSupport</span><span>.</span><span>execute</span><span>(</span><span>CacheAspectSupport</span><span>.</span>java<span>:</span><span>327</span><span>)</span>\n at <span><span>org<span>.</span>springframework<span>.</span>cache<span>.</span>interceptor<span>.</span></span>CacheInterceptor</span><span>.</span><span>invoke</span><span>(</span><span>CacheInterceptor</span><span>.</span>java<span>:</span><span>61</span><span>)</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>根据异常栈我们很轻松就能定位到源码位置</p>\n<p><img src=\"@source/note/assets/20220414/a_null_pointer_exception-therearesomanytricks-1649937430200.png\" alt=\"定位到源码位置\" loading=\"lazy\"></p>\n<p>很明显exists为null，就会出现本篇的NullPointerException。当然如果这样三分钟没到本篇就草率结束，明显有失肥朝的男儿本色！另外若当真如此草率，那么关注肥朝公众号的意义何在？肥朝公众号的老粉丝们都知道，肥朝的海量源码实战类文章，都有三个特点</p>\n<ul>\n<li>从源码原理角度分析，为什么会出现这个问题？</li>\n<li>如何解决掉这个问题？</li>\n<li>我们如何深度思考，不断从这次经历中压榨出最大价值。（非常重点！）</li>\n</ul>\n<p>比如就拿这个问题来说，按照我们正常的思维惯性，我们看到176行有个return，又知道exists是null，那么我们点进connection.exists(cacheKey.getKeyBytes())这个方法一探究竟。</p>\n<p><img src=\"@source/note/assets/20220414/a_null_pointer_exception-therearesomanytricks-1649937510086.png\" alt=\"源码分析\" loading=\"lazy\"></p>\n<p>结果发现果然如我们所料，这里竟然有两个return null的情况,这个时候就有粉丝把持不住，要九浅一深直入源码分析，看这两个条件什么时候满足。但是肥朝想说的是，且慢动手！</p>\n<p>你注意看这段代码</p>\n<div><pre><code><span>class</span> <span>T</span><span>{</span>\n<span>Boolean</span> exists <span>=</span> <span>(</span><span>Boolean</span><span>)</span> redisOperations<span>.</span><span>execute</span><span>(</span><span>new</span> <span>RedisCallback</span><span><span>&lt;</span><span>Boolean</span><span>></span></span><span>(</span><span>)</span> <span>{</span>\n\n        <span>@Override</span>\n        <span>public</span> <span>Boolean</span> <span>doInRedis</span><span>(</span><span>RedisConnection</span> connection<span>)</span> <span>throws</span> <span>DataAccessException</span> <span>{</span>\n            <span>return</span> connection<span>.</span><span>exists</span><span>(</span>cacheKey<span>.</span><span>getKeyBytes</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div>",
      "date_published": "2018-02-04T00:00:00.000Z",
      "date_modified": "2022-04-14T15:42:00.000Z",
      "authors": [
        {
          "name": "Felix zyf"
        }
      ],
      "tags": [
        "note"
      ]
    },
    {
      "title": "2022年在京的第一个元旦",
      "url": "http://www.zhangsj.xyz/blog/note/life-notes.html",
      "id": "http://www.zhangsj.xyz/blog/note/life-notes.html",
      "content_html": "<div>\n<p>2022 年在京的第一个元旦</p>\n<p>深藏金华京府地，</p>\n<p>浅抹银妆天子城。</p>\n<p>缕缕冬阳生暖意，</p>\n<p>片片霓虹庆喜辰。</p>\n<p>挥断愁丝付流年，</p>\n<p>洗净欢颜听钟声。</p>\n<p>新年新境新气象，</p>\n<p>好人好运好前程。</p>\n</div>\n",
      "date_published": "2022-04-13T18:37:08.000Z",
      "date_modified": "2022-04-14T15:42:00.000Z",
      "authors": [],
      "tags": [
        "随笔"
      ]
    },
    {
      "title": "API开发、调试神器apiPost",
      "url": "http://www.zhangsj.xyz/blog/tool/api-development-debugging-artifact-apipost.html",
      "id": "http://www.zhangsj.xyz/blog/tool/api-development-debugging-artifact-apipost.html",
      "content_html": "<p>这几天看到大疆被UI设计工具Figma列入黑名单，再次证明科技无国界什么的都是屁话，国产软件必须在各个领域出击，才能不用看人脸色。</p>\n<p>在API管理领域，大家长期使用的是Postman，但是这终究不保险，万一哪天外国又卡脖子，我们又要手忙脚乱。好在国产Api管理软件这几年进展神速，比如Apipost，不止功能不输国外，而且在体验上，更适合中国程序员。</p>\n<p>而且最近，国产API开发调试神器Api-post又迎来了一波重大更新，Apipost6.0已正式上线！新版Apipost既支持Web版，又支持客户版，还增加了很多独家创新功能，解决了大量用户痛点!</p>\n<p>这件事给我们的启示是：技术是有国界的，我们应该尽量去外国化，能用国产用国产，为了避免以后被制裁时手足无措。在Api管理领域有一款做的比较好的国产软件——ApiPost，完全可以替代Postman，避免类似的事情再次发生，让别人卡脖子。</p>\n<p>国产，全中文界面，全平台支持，太香了！</p>\n<p>你可以将其看作是Swagger、Postman、Mock的集合，一个工具就搞定了过去多个软件才能做的事情，避免了我们在多个软件之间来回切换，帮助咱们节省了不少事。</p>\n<p>不仅可以一键生成API文档，完全中文，界面简洁美观，而且免费使用！很适合国内的开发者和研发团队及企业。</p>\n<p>最近Apipost又迎来了一波重大更新，Apipost6.0已正式公测！新版Apipost既支持Web版，又支持客户端，还增加了很多独家创新功能，解决了大量用户痛点！</p>\n<p>Apipost6.0Web版用户即用即走，方便快捷。</p>\n<p><a href=\"https://console.apipost.cn/project/c7ee27b5-e0f0-4748-a60a-f5342d18dd48/lately\" target=\"_blank\" rel=\"noopener noreferrer\">Web版链接</a>：</p>\n",
      "date_published": "2022-04-13T18:37:08.000Z",
      "date_modified": "2022-04-16T14:05:13.000Z",
      "authors": [],
      "tags": [
        "工具"
      ]
    },
    {
      "title": "IDEA插件和配置",
      "url": "http://www.zhangsj.xyz/blog/tool/idea-plugin.html",
      "id": "http://www.zhangsj.xyz/blog/tool/idea-plugin.html",
      "content_html": "<h2 id=\"idea-2021-激活\" tabindex=\"-1\"> IDEA-2021：激活</h2>\n<p>1、下载idea和破解工具</p>\n<p>(<a href=\"https://www.jetbrains.com/idea/\" target=\"_blank\" rel=\"noopener noreferrer\">idea下载</a>)</p>\n<p><a href=\"https://github.com/ja-netfilter/ja-netfilter/releases\" target=\"_blank\" rel=\"noopener noreferrer\">ja-netfilter【idea破解工具】</a></p>\n<p>2、修改配置</p>\n<p>将<code>ja-netfilter</code>解压后，在<code>config</code>文件夹里打开<code>mymap.conf</code></p>\n<p>在文件末尾加上这几行：</p>\n<div><pre><code>[MyMap]\nEQUAL,licenseeName-&gt;sj\nEQUAL,gracePeriodDays-&gt;30\nEQUAL,paidUpTo-&gt;2200-12-31\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>C:\\Users\\Administrator\\AppData\\Roaming\\JetBrains\\IntelliJIdea2021.3</p>\n<p>在该文件夹目录下找到文件<code>idea64.exe.vmoptions</code>【用于配置IDEA运行时虚拟机参数，并不是项目运行的配置】，用编译器打开</p>\n<p>添加代理插件的本地路径。</p>\n<p>-javaagent:E:\\download\\ja-netfilter-v2.2.2\\ja-netfilter-v2.2.2\\ja-netfilter.jar</p>\n<div><pre><code>-Xmx2032m\n-Djava.net.preferIPv4Stack=true\n-Dfile.encoding=UTF-8\n-javaagent:E:\\download\\ja-netfilter-v2.2.2\\ja-netfilter-v2.2.2\\ja-netfilter.jar\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>3、打开idea：</p>\n<p>初次弹窗：我们选择start trial  - log in to JetBrains Account，弹出界面：</p>\n<p><img src=\"@source/tool/assets/idea-plugin-1650265183670.png\" alt=\"idea初次弹窗\" loading=\"lazy\"></p>\n<p>没有账号的话，自己注册一个账号，免费的。</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/qq_16268979/article/details/118635094\" target=\"_blank\" rel=\"noopener noreferrer\">idea64.exe.vmoptions文件详解</a></li>\n<li><a href=\"https://blog.csdn.net/qq_41973729/article/details/122353737?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-5.pc_relevant_paycolumn_v3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-5.pc_relevant_paycolumn_v3&amp;utm_relevant_index=8\" target=\"_blank\" rel=\"noopener noreferrer\">idea破解教程</a></li>\n</ul>\n<h2 id=\"idea插件\" tabindex=\"-1\"> idea插件</h2>\n<ol>\n<li>Alibaba Java Coding Guidelines</li>\n<li>iBATIS/MyBatis plugin</li>\n<li>GsonFormat</li>\n<li>Stack Overflow</li>\n<li>Background Image Plus</li>\n<li>Lombok</li>\n<li>CodeGlance</li>\n<li>generatAllSetter</li>\n<li>gitee</li>\n<li>copilot（代码补全）</li>\n<li>GrepFormatPlus</li>\n<li>GrepConsole</li>\n<li>JRebel and XRebel</li>\n<li>Markdown Image Support</li>\n<li>MetricsReloaded</li>\n<li>CamelCase</li>\n<li>RestfulTool</li>\n<li>statistic</li>\n<li>Translation</li>\n<li>vue.js</li>\n</ol>\n<p>IDE eval reset\njrebel and xrebel\ncamelcase</p>\n<h2 id=\"idea配置修改\" tabindex=\"-1\"> IDEA配置修改</h2>\n<p>1、自动编译开关（代码完成-&gt; 区分大小写）</p>\n<p>构建、运行、部署 =》编译器（自动构建项目）</p>\n<p>2、忽略大小写开关</p>\n<p><img src=\"@source/tool/assets/idea-plugin-1650114929063.png\" alt=\"忽略大小写开关\" loading=\"lazy\"></p>\n<p>3、取消单行显示tabs的操作（编辑器-&gt;编辑器选项卡-&gt;在单行显示选项卡）</p>\n<p><img src=\"@source/tool/assets/idea-plugin-1650115316460.png\" alt=\"取消单行显示tabs的操作\" loading=\"lazy\"></p>\n<p>4、项目文件编码（编辑器-》文件编码）</p>\n<p>5、滚轴修改字体大小（常规-》鼠标控制）</p>\n",
      "date_published": "2022-04-13T18:37:08.000Z",
      "date_modified": "2022-05-24T09:58:20.000Z",
      "authors": [],
      "tags": [
        "工具"
      ]
    },
    {
      "title": "vue常见问题",
      "url": "http://www.zhangsj.xyz/blog/vue/frequently-asked-questions.html",
      "id": "http://www.zhangsj.xyz/blog/vue/frequently-asked-questions.html",
      "content_html": "<h2 id=\"vue-常见问题\" tabindex=\"-1\"> vue 常见问题</h2>\n<h2 id=\"spa\" tabindex=\"-1\"> SPA</h2>\n<p>单页应用</p>\n<p>仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。</p>\n<p>一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转，利用路由机制实现 HTML 内容的变换来代替，UI 与用户的交互，避免页面的重新加载。</p>\n<p>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；\n基于上面一点，SPA 相对对服务器压力小；\n前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</p>\n<h3 id=\"缺点\" tabindex=\"-1\"> 缺点</h3>\n<p>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</p>\n<p>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</p>\n<h3 id=\"v-show-与-v-if\" tabindex=\"-1\"> v-show 与 v-if</h3>\n<p><code>V-if</code>是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>\n<p>V-show就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于CSS的<code>display</code>属性进行切换。</p>\n<h3 id=\"computed-和-watch\" tabindex=\"-1\"> computed 和 watch</h3>\n<p>Computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；</p>\n<p>Watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p>\n<h2 id=\"vue-生命周期\" tabindex=\"-1\"> Vue 生命周期</h2>\n<p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">生命周期</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">beforeCreate</td>\n<td style=\"text-align:left\">组件实例被创建之初，组件的属性生效之前</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">created</td>\n<td style=\"text-align:left\">组件实例已经完全创建，属性也绑定，但真实dom还没有生成，$el还不可用</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">beforeMount</td>\n<td style=\"text-align:left\">在挂载开始之前被调用：相关的render函数首次被调用</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">mounted</td>\n<td style=\"text-align:left\">el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">beforeUpdate</td>\n<td style=\"text-align:left\">组件数据更新之前调用，发生在虚拟DOM打补丁之前</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">update</td>\n<td style=\"text-align:left\">组件数据更新之后</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">activited</td>\n<td style=\"text-align:left\">keep-alive专属，组件被激活时调用</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">deactivated</td>\n<td style=\"text-align:left\">keep-alive专属，组件被销毁时调用</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">beforeDestory</td>\n<td style=\"text-align:left\">组件销毁前调用</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">destoryed</td>\n<td style=\"text-align:left\">组件销毁后调用</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"哪个生命周期内调用异步请求\" tabindex=\"-1\"> 哪个生命周期内调用异步请求</h2>\n<p>可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点</p>\n<p>能更快获取到服务端数据，减少页面 loading 时间；\n服务端渲染不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</p>\n<h2 id=\"在什么阶段才能访问操作-dom\" tabindex=\"-1\"> 在什么阶段才能访问操作 DOM</h2>\n<p>在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM。V</p>\n<h2 id=\"父子通信\" tabindex=\"-1\"> 父子通信</h2>\n<ol>\n<li>\n<p>$emit props 触发父组件的事件</p>\n</li>\n<li>\n<p>ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</p>\n</li>\n<li>\n<p>EventBus (emit /on) 适用于 父子、隔代、兄弟组件通信</p>\n</li>\n<li>\n<p>Vuex 适用于 父子、隔代、兄弟组件通信</p>\n</li>\n<li>\n<p>provide / inject 适用于 隔代组件通信</p>\n</li>\n</ol>\n<p><a href=\"https://www.jianshu.com/p/9f460e66ce01\" target=\"_blank\" rel=\"noopener noreferrer\">参考</a></p>\n<h2 id=\"keep-alive\" tabindex=\"-1\"> keep-alive</h2>\n<p>Keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p>\n<p>一般结合路由和动态组件一起使用，用于缓存组件；</p>\n<p>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；</p>\n<p>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</p>\n",
      "date_published": "2022-04-13T18:37:08.000Z",
      "date_modified": "2022-04-16T07:11:11.000Z",
      "authors": [],
      "tags": [
        "前端"
      ]
    },
    {
      "title": "vue指令",
      "url": "http://www.zhangsj.xyz/blog/vue/instruction.html",
      "id": "http://www.zhangsj.xyz/blog/vue/instruction.html",
      "content_html": "<h2 id=\"directives\" tabindex=\"-1\"> directives</h2>\n<p>表格临时回车跳转</p>\n<div><pre><code>    <span>nextSelect</span><span>:</span> <span>{</span>\n      <span>bind</span><span>:</span> <span>function</span> <span>(</span><span>el<span>,</span> <span>{</span> value <span>}</span><span>,</span> vnode</span><span>)</span> <span>{</span>\n        el<span>.</span><span>onkeydown</span> <span>=</span> <span>function</span> <span>(</span><span>ev</span><span>)</span> <span>{</span>\n          <span>if</span> <span>(</span>ev<span>.</span>keyCode <span>===</span> <span>13</span><span>)</span> <span>{</span>\n            <span>let</span> nextInput <span>=</span> vnode<span>.</span>context<span>.</span>$refs<span>[</span>value<span>]</span>\n            <span>if</span> <span>(</span>nextInput <span>&amp;&amp;</span> <span>typeof</span> nextInput<span>.</span>focus <span>===</span> <span>'function'</span><span>)</span> <span>{</span>\n              nextInput<span>.</span><span>focus</span><span>(</span><span>)</span>\n            <span>}</span> <span>else</span> <span>{</span>\n            <span>}</span>\n          <span>}</span>\n        <span>}</span>\n      <span>}</span>\n    <span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>浅拷贝：只是将数据中所有的数据引用下来，依旧指向同一个存放地址，拷贝之后的数据修改之后，也会影响到原数据的中的对象数据。例如:Object.assign(),...扩展运算符</p>\n<p>深拷贝：将数据中所有的数据拷贝下来，对拷贝之后的数据进行修改不会影响到原数据。</p>\n<p><code>JSON.parse(JSON.stringify(obj))</code>深拷贝的问题</p>\n<p><code>JSON.parse(JSON.stringify(obj))</code>深拷贝的问题</p>\n<ol>\n<li>如果obj里面存在时间对象,JSON.parse(JSON.stringify(obj))之后，时间对象变成了字符串。</li>\n<li>如果obj里有RegExp、Error对象，则序列化的结果将只得到空对象。</li>\n<li>如果obj里有函数，undefined，则序列化的结果会把函数，undefined丢失。</li>\n<li>如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null。</li>\n<li>JSON.stringify()只能序列化对象的可枚举的自有属性。如果obj中的对象是有构造函数生成的，则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的constructor。</li>\n<li>如果对象中存在循环引用的情况也无法正确实现深拷贝。</li>\n</ol>\n",
      "date_published": "2022-04-13T18:37:08.000Z",
      "date_modified": "2022-04-16T07:11:11.000Z",
      "authors": [],
      "tags": [
        "前端"
      ]
    },
    {
      "title": "es6语法",
      "url": "http://www.zhangsj.xyz/blog/vue/vue-knowledge-points.html",
      "id": "http://www.zhangsj.xyz/blog/vue/vue-knowledge-points.html",
      "content_html": "<h2 id=\"es6\" tabindex=\"-1\"> es6</h2>\n<p>一种通过重用组件构建类的方法。</p>\n<p>不通过类的直接继承来实现，而是将基类作为接口来实现。对于基类实例化部分在子类中实现，基类中原型的部分在子类中进行声明占位，然后通过一个 Minxin 函数将基类上的原型属性拷贝到子类上。</p>\n<h2 id=\"promise\" tabindex=\"-1\"> promise</h2>\n<p>用来处理异步任务的一个对象，一个 Promise 对象有三个状态，resolved 异步任务执行成功，rejected 异步任务执行失败</p>\n<h3 id=\"使用\" tabindex=\"-1\"> 使用</h3>\n<p>初始化一个 Promise 对象\nnew Promise(fn)</p>\n<p>然后调用上一步返回的 promise 对象的 then 方法，注册回调函数。</p>\n<p>Then 中的回调函数可以有一个参数，也可以不带参数。如果 then 中的回调函数依赖上一步的返回结果，那么要带上参数。比如:</p>\n<p>最后注册 catch 异常处理函数，处理前面回调中可能抛出的异常。</p>\n<p>回调地狱带来的负面作用有以下几点：</p>\n<p>处理一个异步网络请求</p>\n<div><pre><code><span>请求1</span><span>(</span><span>function</span> <span>(</span><span>请求结果<span>1</span></span><span>)</span> <span>{</span>\n  <span>请求2</span><span>(</span><span>function</span> <span>(</span><span>请求结果<span>2</span></span><span>)</span> <span>{</span>\n    处理请求结果<span>2</span><span>;</span>\n  <span>}</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>\n<li>代码臃肿。</li>\n<li>可读性差。</li>\n<li>耦合度过高，可维护性差。</li>\n<li>代码复用性差。</li>\n<li>只能在回调里处理异常。</li>\n</ul>\n<p>比传统的异步解决方案【回调函数】和【事件】更合理、更强大。</p>\n<div><pre><code><span>new</span> <span>Promise</span><span>(</span>请求<span>1</span><span>)</span>\n  <span>.</span><span>then</span><span>(</span><span>请求2</span><span>(</span>请求结果<span>1</span><span>)</span><span>)</span>\n  <span>.</span><span>then</span><span>(</span><span>请求3</span><span>(</span>请求结果<span>2</span><span>)</span><span>)</span>\n  <span>.</span><span>then</span><span>(</span><span>请求4</span><span>(</span>请求结果<span>3</span><span>)</span><span>)</span>\n  <span>.</span><span>then</span><span>(</span><span>请求5</span><span>(</span>请求结果<span>4</span><span>)</span><span>)</span>\n  <span>.</span><span>catch</span><span>(</span><span>处理异常</span><span>(</span>异常信息<span>)</span><span>)</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>比较一下这种写法和上面的回调式的写法。我们不难发现，Promise 的写法更为直观，并且能够在外层捕获异步函数的异常信息。</p>\n<h3 id=\"promise-resolve-value\" tabindex=\"-1\"> Promise.resolve(value)</h3>\n<p>类方法，该方法返回一个以value值解析后的Promise对象</p>\n<ol>\n<li>如果这个值是个thenable(即带有then方法)，返回的Promise对象会“跟随”这个thenable的对象，采用它的最终状态(指resolved/rejected/pending/settled)</li>\n<li>如果传入的value本身就是Promise对象，则该对象作为Promise.resolve方法的返回值返回。</li>\n<li>其他情况以该值为成功状态返回一个Promise对象。</li>\n</ol>\n<p>上面是 resolve 方法的解释，传入不同类型的 value 值，返回结果也有区别。这个 API 比较重要，建议大家通过练习一些小例子，并且配合上面的解释来熟悉它。如下几个小例子：</p>\n<div><pre><code><span>//如果传入的 value 本身就是 Promise 对象，则该对象作为 Promise.resolve 方法的返回值返回。</span>\n<span>function</span> <span>fn</span><span>(</span><span>resolve</span><span>)</span> <span>{</span>\n  <span>setTimeout</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>\n    <span>resolve</span><span>(</span><span>123</span><span>)</span><span>;</span>\n  <span>}</span><span>,</span> <span>3000</span><span>)</span><span>;</span>\n<span>}</span>\n<span>let</span> p0 <span>=</span> <span>new</span> <span>Promise</span><span>(</span>fn<span>)</span><span>;</span>\n<span>let</span> p1 <span>=</span> Promise<span>.</span><span>resolve</span><span>(</span>p0<span>)</span><span>;</span>\n<span>// 返回为true，返回的 Promise 即是 入参的 Promise 对象。</span>\nconsole<span>.</span><span>log</span><span>(</span>p0 <span>===</span> p1<span>)</span><span>;</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id=\"promise-prototype-then\" tabindex=\"-1\"> Promise.prototype.then</h3>\n<p>实例方法，为Promise注册回调函数，函数形式：<code>fn(vlaue){}</code>，value是上一个任务的返回结果，<code>then</code>中的函数一定要<code>return</code>一个结果或者一个新的<code>Promise</code>对象，才可以让之后的then回调接收</p>\n<h3 id=\"promise-prototype-catch\" tabindex=\"-1\"> Promise.prototype.catch</h3>\n<p>实例方法，捕获异常，函数形式：fn(err){}, err 是 catch 注册 之前的回调抛出的异常信息。</p>\n<h2 id=\"promise-的升级-async-await\" tabindex=\"-1\"> Promise 的升级 async / await</h2>\n<p>Async/await 也是基于 Promise 实现的，</p>\n<p>Async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。</p>\n",
      "date_published": "2021-09-20T00:00:00.000Z",
      "date_modified": "2022-04-14T05:48:05.000Z",
      "authors": [],
      "tags": [
        "前端"
      ]
    },
    {
      "title": "医保业务",
      "url": "http://www.zhangsj.xyz/blog/exam/med/Summary%20of%20problems%20encountered.html",
      "id": "http://www.zhangsj.xyz/blog/exam/med/Summary%20of%20problems%20encountered.html",
      "content_html": "<h2 id=\"医院上传\" tabindex=\"-1\"> 医院上传</h2>\n<h2 id=\"实时未分解交易\" tabindex=\"-1\"> 实时未分解交易</h2>\n<p>未支付成功的票据 xx</p>\n<h2 id=\"补录\" tabindex=\"-1\"> 补录</h2>\n<p>Xx</p>\n<h2 id=\"比对失败\" tabindex=\"-1\"> 比对失败</h2>\n<p>Xx\n比对失败的票据，怎么处理，</p>\n<p>票据文件上传是只用于上传模块？</p>\n<p>用ctrl+r进行内容替换，使用正则表达式，用<code>^\\s*\\n</code> 替换 空即可</p>\n<p>\\s 包括空格、制表符、换页符等空白字符的其中任意一个\n\\r, \\n 代表回车和换行符</p>\n<ul>\n<li>表达式不出现或出现任意次，相当于 {0,}，</li>\n</ul>\n",
      "date_published": "2022-04-13T18:37:08.000Z",
      "date_modified": "2022-04-14T05:48:05.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "项目启动报错",
      "url": "http://www.zhangsj.xyz/blog/exam/trouble/problem%20log.html",
      "id": "http://www.zhangsj.xyz/blog/exam/trouble/problem%20log.html",
      "content_html": "<h2 id=\"启动项目报错\" tabindex=\"-1\"> 启动项目报错</h2>\n<h2 id=\"error-java-outofmemoryerror-insufficient-memory\" tabindex=\"-1\"> Error:java: OutOfMemoryError: insufficient memory</h2>\n<p>idea</p>\n<p>修改Compiler下面的Compiler Process heap size 参数</p>\n<p>点击file，选择Invalidate Caches 进行清理一下。</p>\n<h2 id=\"command-line-is-too-long的解决方法\" tabindex=\"-1\"> Command line is too long的解决方法</h2>\n<p>首先找到项目里面的idea/workspace.xml文件，然后再找到标签如下所示</p>\n<div><pre><code>`<span><span><span>&lt;</span>component</span> <span>name</span><span><span>=</span><span>\"</span>PropertiesComponent<span>\"</span></span><span>></span></span><span><span><span>&lt;/</span>component</span> <span>></span></span>`\n</code></pre><div aria-hidden=\"true\"><span>1</span><br></div></div><p>然后再在component 标签里加一行<code>&lt;property name=&quot;dynamic.classpath&quot; value=&quot;true&quot;/&gt;</code>，就是变成下面这样</p>\n<p>C:\\WINDOWS\\system32\\drivers\\etc</p>\n",
      "date_published": "2022-04-13T18:37:08.000Z",
      "date_modified": "2022-04-16T14:05:13.000Z",
      "authors": [],
      "tags": [
        "问题"
      ]
    },
    {
      "title": "new-age",
      "url": "http://www.zhangsj.xyz/blog/exam/wcyg/topic-is-new-age.html",
      "id": "http://www.zhangsj.xyz/blog/exam/wcyg/topic-is-new-age.html",
      "content_html": "<h2 id=\"today-s-topic-is-new-age\" tabindex=\"-1\"> &quot;today's topic is 'new age'&quot;</h2>\n<p>------愚人记事.</p>\n<div>\n<p>昨夜无眠。</p>\n<p>和朋友鬼扯到一点。</p>\n<p>找资料间,无意听到背景音乐是enya的。</p>\n<p>一时下不了手关闭.</p>\n<p>听着enya的音乐到凌晨五点才沉沉睡去.</p>\n<p>几年了,</p>\n<p>除却sarah的scabrough fair外,</p>\n<p>我的硬盘再也没存有任何 new age style 的任何曲目,</p>\n<p>特别是enya相关的.</p>\n<p>熟悉的watermark,</p>\n<p>冲破几年的封印,</p>\n<p>随着音乐流淌,</p>\n<p>慢慢地浮现出来.</p>\n<p>不知道那张我跑遍了大半个城市才买到的cd,</p>\n<p>现在怎么样了.</p>\n<p>被珍藏还是被遗弃?</p>\n<p>是否和我的爱一样?</p>\n<p>曾以为</p>\n<p>new age会成为我的topic中的主旋律，</p>\n<p>也曾以为</p>\n<p>new age不会再在我的topic中出现了。</p>\n<p>其实</p>\n<p>我并不排斥那种少有鲜明主题的旋律,</p>\n<p>只是当时我也需要时间,</p>\n<p>一如接受其他的...</p>\n<p>其实</p>\n<p>我也很喜欢enya的那份恬静和随意流淌的自我.</p>\n<p>只是当时我找不到我的的心，</p>\n<p>不懂得我自己。</p>\n<p>&quot;today's topic is 'new age'&quot;</p>\n<p>.....</p>\n<p>&quot;xxxxxxxxx xxxxxxxxx！&quot;。</p>\n<p>如果有一种状况叫迷失的话,</p>\n<p>大抵也是如此吧.</p>\n<p>无论我喜欢或者不喜欢,</p>\n<p>都不是为了自已.</p>\n<p>为博伊一笑.</p>\n<p>即兴挥就洋洋千余言的乐评,被戏为乐贫.</p>\n<p>唯一带点安慰的是还有个年度最佳称号.</p>\n<p>在我还不懂enya时，</p>\n<p>我努力地去欣赏,</p>\n<p>并尝试努力去接受,</p>\n<p>然而始终对不上 channel.</p>\n<p>在我不再去听enya时.</p>\n<p>却渐渐地理解这种style,</p>\n<p>我想我可以对上channel了,</p>\n<p>虽然错过了开播的时间。</p>\n<p>有些心境对某人来说是很轻易就能达到的</p>\n<p>但对另一些人来说</p>\n<p>需要经过一番努力</p>\n<p>在时光交错的现实与过去里</p>\n<p>我遍历过很多次凸点集合</p>\n<p>做了好多次迭代替换</p>\n<p>虽然我知道就算能求出最优解</p>\n<p>也已经没有回去的路了</p>\n<p>但只想找回失落的心</p>\n<p>找回真实的感觉</p>\n<p>重听enya</p>\n<p>重新再欣赏new age</p>\n<p>也重新定义了new age的位置</p>\n<p>它不会成为我的topic的主旋律</p>\n<p>但也是不可或缺的旋律</p>\n<p>也是一种存在的体现。</p>\n<p>因为</p>\n<p>喜欢是一种来自心底深层次的感觉，</p>\n<p>是两个具有共同品质的物件的共鸣形式.</p>\n<p>不管是对音乐还是和人.</p>\n</div>\n",
      "date_published": "2021-08-18T00:00:00.000Z",
      "date_modified": "2022-04-13T18:37:08.000Z",
      "authors": [],
      "tags": [
        "随笔"
      ]
    },
    {
      "title": "新人入职注意事项",
      "url": "http://www.zhangsj.xyz/blog/exam/yanyu/new%20recruit.html",
      "id": "http://www.zhangsj.xyz/blog/exam/yanyu/new%20recruit.html",
      "content_html": "<h1 id=\"新人入职注意事项\" tabindex=\"-1\"> 新人入职注意事项</h1>\n<p>新人java入职新公司一脸懵逼，不知从何下手，不知如何融入项目，也不知道如何看项目问题</p>\n<p>我这几年待过一些公司，最近入职了一下新公司，闲来没事，发现网上有很多小白去新公司，不知从何下手，导致劝退，或者很慌的。</p>\n<p>说说我的一些建议和一些个人经验吧</p>\n<p>项目都不知道是干什么的，千万不要一开始就选择看代码看技术，项目的技术往往是结合业务相关联的</p>\n<ol>\n<li>前天或前一周，正常来说是不会接手开始做项目。环境配启动项目，不要浪费太多时间，最多半天到一天时间，以前有个同事搭个环境要两三天\n首先要体现自己的专业性： 自己常用的开发工具和安装文件要有云存储和备份。自常用工具要快速安装搭建。最重要的云笔记要经常编写。如记录地址，代码 账号等参数。非常重要</li>\n<li>首先认清楚自己待的项目团队的人员大概的分布情况，可以选择吃饭的时候问，或者问hr、老大等人。了解哪些人是搞前端，哪些人搞后台，有些公司会带人去介绍，有些不会。</li>\n<li>再了解目前的项目团队主要负责的项目情况:  项目进度，目前是做到哪一步，</li>\n<li>自己在团队的定位是什么是普通小白还是主力开发。</li>\n<li>了解项目是做什么的，具体的核心业务是什么，主要是要知道这个项目具体是做什么用的。一些公司有些人搞了一个月，还不不知道项目具体是干什么的。</li>\n<li>了解项目产品，有文档看文档，没文档请教产品经理或者懂的人。首先站在用户的角度去使用现有的这个项目流程，让别人演示一遍给你看，每一个模块讲一讲是干什么的，站在用户思维去用，才能发现产品的好不好使用。</li>\n<li>当你大概自己会简单操作和使用现有的产品再去看项目的结构代码；</li>\n<li>项目首先看结构是传统项目，还是多maven，还是微服务，前端有几端如：pc端，微信端，app端什么的。再看看pom.xml用了大概那些等等，模块的划分，工具类目录，项目的核心配置，mybatis写法, 接口风格，等大概的情况了解。</li>\n<li>不要去一开始就去看某个代码的实现技术实现什么的，接口的代码等等，别人写的东西一开始也没必要去看，除非是交接，但是前提还是要清楚业务。一般简单了解一下就可以了。</li>\n<li>这时候差不多对项目的产品和项目的架构情况有一个大致初步的判断和了解。</li>\n<li>打开数据库文档 或者数据表，分模块和业务去看，如：用户主表有哪些，用户扩展的表简单了解。其他模块的主表是什么情况，模块与用户的关联是怎么情况。了解数据库表的基本情况和设计风格，不懂业务也没有关系，只是了解大概的情况，这些业务有哪些表。</li>\n<li>前面这么多步骤，随着项目的复杂度大概2天到一周，完全可以知道这个项目整体情况 。从项目是干什么的，项目后台架构是如何，数据表大概情况。</li>\n<li>知道这些后就完事了。当老大问你看的怎么样了，你就掌握的情况通说出来，那些不对的，项目不懂的也都可以说出来。</li>\n<li>接下来一般会安排小问题 小<code>bug</code>，小业务去让你去改，这个时候就可以随着慢慢地融入去开发。</li>\n</ol>\n<h2 id=\"融入去开发\" tabindex=\"-1\"> 融入去开发</h2>\n<p>融入去开发，最重要的一点不懂就问，不懂的列出来，善于去思考。</p>\n<p>吃饭的时间、抽烟的时间，下班的时间多请教！不要怕别人以为你不行，一个项目不懂的人多了去了，很多人只负责自己的模块，其他的人也不懂。没有谁会拒绝一个虚心请教的人，除非你问增删改查怎么写不要待了几天啥都不知道，往往劝退就是在这个时候，</p>\n<p>我第一天下午没事一般就能知道这个项目大概的一个情况，第二天以用户的使用去操作系统，第三天在去具体了解业务实现过程。后面有任务就做，没任务就看业务。不是看代码。新手去了一个公司，往往一股脑就跑项目，看代码，搞了几天别人都不知道你在搞什么。</p>\n<h2 id=\"最重要的是知道业务\" tabindex=\"-1\"> 最重要的是知道业务</h2>\n<p>最重要的是知道业务，随着业务去看代码的实现。当具备这些的时候去大部分的公司能快速上手是没有问题的，少则2，3天，多则一周。大多公司不会让你熟悉半个月、一个月，除非是交接啊或者是很大的项目。</p>\n",
      "date_published": "2022-04-13T18:37:08.000Z",
      "date_modified": "2022-04-16T14:05:13.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "java异常",
      "url": "http://www.zhangsj.xyz/blog/java/basic/java-exception.html",
      "id": "http://www.zhangsj.xyz/blog/java/basic/java-exception.html",
      "content_html": "<h1 id=\"java异常\" tabindex=\"-1\"> java异常</h1>\n<p>图中红色部分为受检查异常。它们必须被捕获，或者在函数中声明为抛出该异常。</p>\n<p><img src=\"@source/java/basic/assets/20220413/java的异常-1649857259697.png\" alt=\"Java异常类的层次结构\" loading=\"lazy\"></p>\n<h2 id=\"检查型异常-checkedexception\" tabindex=\"-1\"> 检查型异常(CheckedException)</h2>\n<p>在 Java 中所有不是 RuntimeException 派生的 Exception 都是检查型异常。</p>\n<p>当函数中存在抛出检查型异常的操作时该函数的函数声明中必须包含 throws 语句。调用改函数的函数也必须对该异常进行处理，如不进行处理则必须在调用函数上声明 throws 语句。</p>\n<p>检查型异常是 JAVA 独有的，在<code>编译期对异常的处理</code>有强制的要求。</p>\n<p>在 JDK 代码中大量的异常属于检查型异常，包括 IOException，SQLException,ClassNotFoundException,NoSuchMetodException 等等。</p>\n<h2 id=\"非检查型异常-uncheckedexception\" tabindex=\"-1\"> 非检查型异常(UncheckedException)</h2>\n<p>如除数是 0 和数组下标越界等，其产生频繁，处理麻烦，若显示申明或者捕获将会对程序的可读性和运行效率影响很大。所以由系统自动检测并将它们交给缺省的异常处理程序。当然如果你有处理要求也可以显示捕获它们。</p>\n<p>对 Checked 异常处理方法有两种</p>\n<p>1 当前方法知道如何处理该异常，则用 try...catch 块来处理该异常。\n2 当前方法不知道如何处理，则在定义该方法是声明抛出该异常。</p>\n<p>在 Java 中所有 <code>RuntimeException</code> 的派生类都是非检查型异常，与检查型异常对比，非检查型异常可以不在函数声明中添加 throws 语句，调用函数上也不需要强制处理。</p>\n<p>常见的 NullPointException，ClassCastException 是常见的非检查型异常。</p>\n<div><pre><code>Java.lang.NullPointerException\nJava.lang.IndexOutOfBoundsException\nJava.lang.ArithmeticException\nJava.lang.ArrayStoreExcetpion\nJava.lang.ClassCastException\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>非检查型异常可以不使用 try...catch 进行处理，但是如果有异常产生，则异常将由 JVM 进行处理。对于 RuntimeException 的子类最好也使用异常处理机制。虽然 RuntimeException 的异常可以不使用 try...catch 进行处理，但是如果一旦发生异常，则肯定会导致程序中断执行，所以，为了保证程序再出错后依然可以执行，在开发代码时最好使用 <code>try...catch</code>的异常处理机制进行处理。</p>\n<h2 id=\"error\" tabindex=\"-1\"> Error</h2>\n<p>当程序发生不可控的错误时，通常做法是通知用户并中止程序的执行。与异常不同的是Error及其子类的对象不应被抛出。</p>\n<p>Error是throwable的子类，代表编译时间和系统错误，用于指示合理的应用程序不应该试图捕获的严重问题。</p>\n<p>Error由Java虚拟机生成并抛出，包括动态链接失败，虚拟机错误等。程序对其不做处理。</p>\n",
      "date_published": "2022-04-13T18:37:08.000Z",
      "date_modified": "2022-04-14T15:42:00.000Z",
      "authors": [],
      "tags": [
        "java基础"
      ]
    },
    {
      "title": "解释Serializable的作用",
      "url": "http://www.zhangsj.xyz/blog/java/basic/the-difference-between-hashcode-and-equals.html",
      "id": "http://www.zhangsj.xyz/blog/java/basic/the-difference-between-hashcode-and-equals.html",
      "content_html": "<h2 id=\"解释serializable-接口的作用\" tabindex=\"-1\"> 解释Serializable 接口的作用</h2>\n<p>在JAVA中的这个Serializable是给JVM看的，告诉JVM，代码不做这个类的序列化了，JVM给我序列化，序列化就是变成二进制流，例如云计算、HADOOP、特别是Hadoop完全就是分布式环境，那么就是涉及到对象要在网络中传输，里面的全是二进制流，当然你来做着这个序列化操作也可以，但是这个类里面可能还有一个类，如果你把外面的类对象的PERSON变成二进制，那么里面也要序列化（这要用到深度遍历，很麻烦），干脆告诉JVM，让他来帮你做。</p>\n<p>了解ID发号器是什么、为什么、如何做？</p>\n<h2 id=\"数据库集群、分库分表\" tabindex=\"-1\"> 数据库集群、分库分表</h2>\n<p>数据库达到一定规模的时候，主键ID的唯一性，这一点很好理解。这是因为，我们的一张表被分割到不同机器上的数据库中，如果还依靠与数据库自带的自增功能的话很难保证ID唯一性！</p>\n<p>可以看出，USER表中的一百万数据备份到两个数据库中，在每个一个数据库内部主键ID是自增的，</p>\n<p>1、使用UUID</p>\n<p>本地生成的，所以相对性能较高、时延低、扩展性高，完全不受分库分表的影响！</p>\n<p>无法保证趋势递增，</p>\n<p>UUID过长，往往用三十二位字符串表示，占用数据库空间较大，做主键的时候索引中主键ID占据的空间较大；</p>\n<p>UUID作为主键建立索引查询效率低，常见的优化方案转换为64整数存储；</p>\n<p>由于使用实现版本的不一样，在高并发情况下可能会出UUID重复的情况；</p>\n<h2 id=\"vesta框架简介\" tabindex=\"-1\"> VESTA框架简介</h2>\n<p>通用的ID产生器，互联网俗称统一发号器，它具有全局唯一、粗略有序、可反解和可制造等特性，它支持三种发布模式：嵌入发布模式、中心服务器发布模式、REST发布模式，根据业务的性能需求，它可以产生最大峰值型和最小粒度型的两种类型的ID，它的实现架构使其具有高性能，可用和可伸缩等互联网产品需要的质量属性，是一款通用的高性能的发号器产品。</p>\n<h2 id=\"hashmap多线程下发生死循环原因及解决\" tabindex=\"-1\"> HashMap多线程下发生死循环原因及解决</h2>\n<p>HASHMAP在多线程环境下，同时进行PUT操作，并且同时进行扩容时，会出现链表环，导致死循环</p>\n<p>因为JDK8之前采用的是头插法，新加入的冲突元素将会查到原有链表的头部。</p>\n<p>扩容之后，链表的元素顺序会反过来，这也是造成死循环的原因之一</p>\n<p>JDK8解决之前版本出现的死循环：</p>\n<p>JDK8后是直接把节点放到扩容后原有链表的尾部</p>\n<p>链表转换为树，</p>\n<p>对树进行操作时</p>\n<p>面试题 ConcurrentHashMap 的工作原理及代码实现,如何统计所有的元素个数</p>\n",
      "date_published": "2022-04-13T18:37:08.000Z",
      "date_modified": "2022-04-16T14:05:13.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "队列同步器AQS和可重入锁锁原理的简要分析",
      "url": "http://www.zhangsj.xyz/blog/java/concurrent/AQS&ReentrantLock.html",
      "id": "http://www.zhangsj.xyz/blog/java/concurrent/AQS&ReentrantLock.html",
      "content_html": "<h2 id=\"java多线程编程-14-java-中的队列同步器aqs和reentrantlock锁原理简要分析\" tabindex=\"-1\"> Java多线程编程-（14）-Java 中的队列同步器AQS和ReentrantLock锁原理简要分析</h2>\n<h3 id=\"一、lock接口\" tabindex=\"-1\"> 一、Lock接口</h3>\n<p>在上一篇文章中：Java多线程编程-（5 ）-使用Lock对象实现同步以及线程间通信介绍了如何使用Lock实现和synchronized关键字类似的同步功能，只是Lock在使用时需要显式地获取和释放锁，synchronized实现的隐式的获取所和释放锁。</p>\n<p>虽然Lock它缺少了（通过synchronized块或者方法所提供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性，何以见得，举个简单的实例：</p>\n<p>假设我们需要先获得锁A，然后在获取锁B，当锁B获得后，释放锁A同时获取锁C，当锁C获得后，在释放B同时获得锁D。。。是不是已经被绕晕了，很显然如果使用synchronized实现的话，不但其过程复杂难以控制，并且稍微出错可以说是一种灾难性的后果。</p>\n<p>Lock接口提供的 synchronized 关键字不具备的主要特性</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">特性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">``</td>\n<td>尝试非阻塞地获取锁</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">能被中断地获取锁</td>\n<td>与synchronized</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">不同，获取锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>而关于Lock接口的使用，也在上一篇的内容中详细的介绍了关系Lock接口的使用案例。下边几张图显示了Lock相关类在Java 8 concurrent并发包下的大致位置和关系。</p>\n<p>1、Java 8中 <code>locks</code> 包下的类：</p>\n",
      "date_published": "2022-04-13T18:37:08.000Z",
      "date_modified": "2022-04-14T05:48:05.000Z",
      "authors": [],
      "tags": [
        "锁机制"
      ]
    },
    {
      "title": "线程通信的方式",
      "url": "http://www.zhangsj.xyz/blog/java/concurrent/how-to-communicate-between-java-threads.html",
      "id": "http://www.zhangsj.xyz/blog/java/concurrent/how-to-communicate-between-java-threads.html",
      "content_html": "<h2 id=\"java-线程的通信方式\" tabindex=\"-1\"> Java 线程的通信方式</h2>\n<p>通信的目的是为了更好的协作，线程无论是<code>交替</code>式执行，还是<code>接力</code>式执行，都需要进行通信告知。</p>\n<p>代码二相对于代码一的效率问题，其实是为了解决1%几率的问题，而使用了一个100%出现的防护盾。那有一个优化的思路，就是把100%出现的防护盾，也改为1%的几率出现，使之只出现在可能会导致多个实例出现的地方。</p>\n<p>代码如下：</p>\n<div><pre><code><span>class</span> <span>Singleton</span> <span>{</span>\n    <span>private</span> <span>volatile</span> <span>Singleton</span> singleton<span>;</span>\n    \n    <span>private</span> <span>Singleton</span><span>(</span><span>)</span><span>{</span><span>}</span>\n\n    <span>public</span> <span>Singleton</span> <span>getSingleton</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>singleton <span>=</span> <span>null</span><span>)</span><span>{</span>\n            <span>synchronized</span> <span>(</span>singleton<span>.</span><span>class</span><span>)</span><span>{</span>\n                <span>if</span> <span>(</span>singleton <span>=</span> <span>null</span><span>)</span><span>{</span>\n                    singleton <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> singleton<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>这段代码看起来有点复杂，注意其中有两次if(instance==null)的判断，这个叫做『双重检查 Double-Check』。</p>\n<ul>\n<li>第一个 if(instance==null)，其实是为了解决代码二中的效率问题，只有instance为null的时候，才进入synchronized的代码段大大减少了几率。</li>\n<li>第二个if(instance==null)，则是跟代码二一样，是为了防止可能出现多个实例的情况。</li>\n</ul>\n<h2 id=\"使用-volatile-保证可见性-synchronized\" tabindex=\"-1\"> 使用 volatile 保证可见性 synchronized</h2>\n<p>Volatile 有两大特性，一是可见性(让线程之间进行通信)，二是有序性，禁止指令重排序</p>\n<p>所有 volatile 修饰的变量一旦被某个线程更改，必须立即刷新到主内存\n所有 volatile 修饰的变量在使用之前必须重新读取主内存的值</p>\n<h2 id=\"等待-通知机制-是基于-wait-和-notify-方法来实现的\" tabindex=\"-1\"> 等待/通知机制 是基于 wait 和 notify 方法来实现的</h2>\n<p>在一个线程内调用该线程锁对象的 wait 方法，线程将进入等待队列进行等待直到被通知或者被唤醒。</p>\n<p>因为调用 wait 方法时，必须要先释放锁，如果没有持有锁将会抛出异常。</p>\n<h2 id=\"join-方式\" tabindex=\"-1\"> join 方式</h2>\n<p>Join 可以理解成是线程合并，当在一个线程调用另一个线程的 join 方法时，当前线程阻塞等待被调用 join 方法的线程执行完毕才能继续执行，所以 join 的好处能够保证线程的执行顺序，但是如果调用线程的 join 方法其实已经失去了并行的意义，虽然存在多个线程，但是本质上还是串行的，join 实现其实也是基于 wait/notify(等待通知机制)。</p>\n<h2 id=\"threadlocal-方式\" tabindex=\"-1\"> threadLocal 方式</h2>\n<p>ThreadLocal使用场合主要解决多线程中数据因并发产生不一致问题。</p>\n<p>每个线程的中并发访问的数据提供一个副本，通过访问副本来运行业务，这样的结果是耗费了内存，单大大减少了线程同步所带来性能消耗，也减少了线程并发控制的复杂度。</p>\n<p>ThreadLocal不能使用原子类型，只能使用Object类型。ThreadLocal的使用比synchronized要简单得多。</p>\n<p>实现每一个线程都有自己的共享变量,绑定自己的值,cpu 下一次轮询，还能获取自己上次的状态。</p>\n<p>ThreadLocal 方式的线程通信，不像以上三种方式是多个线程之间的通信，它更像是一个线程内部的通信，将当前线程和一个 map 绑定，在当前线程内可以任意存取数据，减省了方法调用间参数的传递。</p>\n",
      "date_published": "2022-04-13T18:37:08.000Z",
      "date_modified": "2022-04-16T14:05:13.000Z",
      "authors": [],
      "tags": [
        "进程与线程"
      ]
    },
    {
      "title": "b-tree和b+tree的详细解释",
      "url": "http://www.zhangsj.xyz/blog/java/datasource/detailed-explanation-of-b-tree-and-b+-tree.html",
      "id": "http://www.zhangsj.xyz/blog/java/datasource/detailed-explanation-of-b-tree-and-b+-tree.html",
      "content_html": "<h2 id=\"b树、b-树详解\" tabindex=\"-1\"> B树、B+树详解</h2>\n<p>B-树是一种多路自平衡的搜索树（B树是一颗多路平衡查找树），它类似普通的平衡二叉树，不同的一点是B-树允许每个节点有更多的子节点。下图是 B-树的简化图.</p>\n<p><a href=\"./img/b%E6%A0%91.png\"></a></p>\n<p>B-树有如下特点:</p>\n<ol>\n<li>所有键值分布在整颗树中（索引值和具体data都在每个节点里）；</li>\n<li>任何一个关键字出现且只出现在一个结点中；</li>\n<li>搜索有可能在非叶子结点结束（最好情况O(1)就能找到数据）；</li>\n<li>在关键字全集内做一次查找,性能逼近二分查找</li>\n</ol>\n<p>B-树是一类树，包括B-树、B+树、B*树等，是一棵自平衡的搜索树，它类似普通的平衡二叉树，不同的一点是B-树允许每个节点有更多的子节点。</p>\n<p>B-树是专门为外部存储器设计的，如磁盘，它对于读取和写入大块数据有良好的性能，所以一般被用在文件系统及数据库中。</p>\n<p>定义只需要知道B-树允许每个节点有更多的子节点即可（多叉树）。子节点数量一般在上千，具体数量依赖外部存储器的特性。</p>\n<h3 id=\"出现背景\" tabindex=\"-1\"> 出现背景</h3>\n<p>先来看看为什么会出现B-树这类数据结构。</p>\n<p>传统用来搜索的平衡二叉树有很多，如 AVL 树，红黑树等。这些树在一般情况下查询性能非常好，但当数据非常大的时候它们就无能为力了。</p>\n<p>原因当数据量非常大时，内存不够用，大部分数据只能存放在磁盘上，只有需要的数据才加载到内存中。一般而言内存访问的时间约为 50 ns，而磁盘在 10 ms 左右。速度相差了近 5 个数量级，磁盘读取时间远远超过了数据在内存中比较的时间。</p>\n<p>这说明程序大部分时间会阻塞在磁盘IO上。那么我们如何提高程序性能？</p>\n<p>减少磁盘 IO 次数，像 AVL 树，红黑树这类平衡二叉树从设计上无法“迎合”磁盘。</p>\n<div><p>相关信息</p>\n<p>在磁盘中组织查找结构，从任何一个结点指向其他结点都有可能读取一次磁盘数据，再将数据写入内存进行比较。频繁的磁盘IO操作，效率是很低下的(机械运动比电子运动要慢不知道多少)。显而易见，所有的二叉树的查找结构在磁盘中都是低效的。</p>\n</div>\n<h2 id=\"b-树\" tabindex=\"-1\"> B+树</h2>\n<p>B+树 是 B-树的一种变体，在 磁盘查找结构中，B + 树更适合文件系统的磁盘存储结构。</p>\n<p>B-树 是 平衡多路查找树，所有结点 中 都 包含了 待查关键字的有效信息 (比如文件磁盘指针)。每 个 结点 若有 n 个关键字，则有n+1个指向其他结点的指针。</p>\n<h3 id=\"b-树特征\" tabindex=\"-1\"> B+树特征</h3>\n<ol>\n<li>有m个子树的中间节点包含有m个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引；</li>\n<li>所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而B 树的叶子节点并没有包括全部需要查找的信息)；</li>\n<li>所有的非叶子结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)；</li>\n</ol>\n<h3 id=\"为什么说b-树比b树更适合数据库索引\" tabindex=\"-1\"> 为什么说B+树比B树更适合数据库索引？</h3>\n<ol>\n<li>磁盘读写代价更低，在相同数量的待查数据下，B+树查找过程中需要调用的磁盘IO操作要少于普通B-树。由于B+树所在的磁盘存储背景下，因此B+树的查找性能要好于B-树。</li>\n<li>B+树的查找效率更加稳定，因为所有叶子结点都处于同一层中，而且查找所有关键字都必须走完从根结点到叶子结点的全部历程。因此同一颗B+树中，任何关键字的查找比较次数都是一样的。而B树就不一定了，可能查找到某一个非终结点就结束了。</li>\n<li>B+树便于范围查询（数据库的常态），B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低；</li>\n</ol>\n<p>插入删除对比：B+树与B-树在插入删除操作中的效率是差不多的。</p>\n<div><p>总体评价</p>\n<p>在应用背景下，特别是文件结构存储中。B+树的应用要更多，其效率也要比B-树好。</p>\n<p>B树的范围查找用的是中序遍历，而B+树用的是在链表上遍历；</p>\n</div>\n<p>参考</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/54102723\" target=\"_blank\" rel=\"noopener noreferrer\">漫画：什么是B+树？</a></p>\n",
      "date_published": "2022-04-13T18:37:08.000Z",
      "date_modified": "2022-04-14T05:48:05.000Z",
      "authors": [],
      "tags": [
        "数据结构 - mysql"
      ]
    },
    {
      "title": "MySQL流失查询",
      "url": "http://www.zhangsj.xyz/blog/java/datasource/mysql-streaming-query.html",
      "id": "http://www.zhangsj.xyz/blog/java/datasource/mysql-streaming-query.html",
      "content_html": "<div><p>前言</p>\n<p>程序访问MySQL数据库时，当查询出来的数据量特别大时，数据库驱动把加载到的数据全部加载到内存里，就有可能会导致内存溢出（OOM）。</p>\n<p>其实在MySQL数据库中提供了流式查询，允许把符合条件的数据分批一部分一部分地加载到内存中，可以有效避免OOM；</p>\n<p>本文主要介绍如何使用流式查询并对比普通查询进行性能测试。</p>\n</div>\n<p>查询成功后不是返回一个集合而是返回一个迭代器，应用每次从迭代器去一条查询结果。流式查询的好处是能够降低内存使用。</p>\n<p>如果没有流式查询，我们想要从数据库取1000W 记录而有没有足够的内存时，就不得不分页查询，而分页查询效率取决于表设计，如果设计的不好，就无法执行高效的分页查询。因此流式查询是一个数据库访问框架必须具备的功能。</p>\n<p>流式查询的过程中，数据库连接是保持打开状态的，因此要注意的是：执行一个流式查询后，数据库访问框架就不负责数据库连接了，需要应用去完数据后自己关闭。</p>\n<h2 id=\"基于mybatis实现流式查询\" tabindex=\"-1\"> 基于mybatis实现流式查询</h2>\n<p>MyBatis提供了一个叫org.apache\n.ibatis.cursor.Cursor\n的接口类用于流式查询，这个接口继承了java.io\n.Closeable和java.lang\n.Iterable接口，由此可知：</p>\n<ol>\n<li>Cursor是可关闭的</li>\n<li>Cursor是可遍历的</li>\n</ol>\n<p>除此之外，Cursor还提供了三个方法：</p>\n<ol>\n<li>isOpen\n(): 用于在取数据之前判断Cursor\n对象是否是打开状态只有当打开时Cursor才能取数据；</li>\n<li>isConsumed():用于判断查询结果是否全部取完</li>\n<li>getCurrentIndex (): 返回已经获取了多少条数据</li>\n</ol>\n<p>talk is cheap, show me the code</p>\n<div><pre><code><span>package</span> <span>com<span>.</span>aeert<span>.</span>streamquery<span>.</span>service<span>.</span>impl</span><span>;</span>\n \n<span>import</span> <span>com<span>.</span>aeert<span>.</span>streamquery<span>.</span>dao<span>.</span></span><span>ArticleDao</span><span>;</span>\n<span>import</span> <span>com<span>.</span>aeert<span>.</span>streamquery<span>.</span>entity<span>.</span></span><span>ArticleEntity</span><span>;</span>\n<span>import</span> <span>com<span>.</span>aeert<span>.</span>streamquery<span>.</span>service<span>.</span></span><span>ArticleService</span><span>;</span>\n<span>import</span> <span>com<span>.</span>baomidou<span>.</span>mybatisplus<span>.</span>extension<span>.</span>service<span>.</span>impl<span>.</span></span><span>ServiceImpl</span><span>;</span>\n<span>import</span> <span>org<span>.</span>apache<span>.</span>ibatis<span>.</span>cursor<span>.</span></span><span>Cursor</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>stereotype<span>.</span></span><span>Service</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>transaction<span>.</span>annotation<span>.</span></span><span>Transactional</span><span>;</span>\n \n<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Iterator</span><span>;</span>\n \n<span>/**\n * @Author l'amour solitaire\n * @Description articleService\n * @Date 2020/12/22 下午7:57\n **/</span>\n<span>@Service</span><span>(</span><span>\"articleService\"</span><span>)</span>\n<span>public</span> <span>class</span> <span>ArticleServiceImpl</span> <span>extends</span> <span>ServiceImpl</span><span><span>&lt;</span><span>ArticleDao</span><span>,</span> <span>ArticleEntity</span><span>></span></span> <span>implements</span> <span>ArticleService</span> <span>{</span>\n \n    <span>@Override</span>\n    <span>@Transactional</span><span>(</span>rollbackFor <span>=</span> <span>Exception</span><span>.</span><span>class</span><span>)</span>\n    <span>public</span> <span>void</span> <span>queryByCursor</span><span>(</span><span>)</span> <span>{</span>\n        <span>try</span> <span>(</span><span>Cursor</span><span><span>&lt;</span><span>ArticleEntity</span><span>></span></span> articleEntityCursor <span>=</span> baseMapper<span>.</span><span>queryByCursor</span><span>(</span><span>)</span><span>;</span><span>)</span> <span>{</span>\n            <span>Iterator</span><span><span>&lt;</span><span>ArticleEntity</span><span>></span></span> articleEntityIterator <span>=</span> articleEntityCursor<span>.</span><span>iterator</span><span>(</span><span>)</span><span>;</span>\n            <span>while</span> <span>(</span>articleEntityIterator<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>articleEntityIterator<span>.</span><span>next</span><span>(</span><span>)</span><span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><blockquote>\n<p>⚠注意这里的@Transactional ，没有这个的话会抛异常<code>java.lang.IllegalStateException</code>: A Cursor is already closed.\n这是因为我们前面说了在取数据的过程中需要保持数据库连接，而<code>Mapper</code>方法通常在执行完后连接就关闭了，因此 Cusor 也一并关闭了。</p>\n</blockquote>\n<p>所以，解决这个问题的思路不复杂，保持数据库连接打开即可。我们至少有三种方案可选。这里我们用的是方案三；</p>\n<h3 id=\"方案一-sqlsessionfactory\" tabindex=\"-1\"> 方案一：SqlSessionFactory</h3>\n<p>我们可以用 SqlSessionFactory 来手工打开数据库连接，将 Controller 方法修改如下：</p>\n<div><pre><code><span>class</span> <span>T</span> <span>{</span>\n    <span>@GetMapping</span><span>(</span><span>\"foo/scan/1/{limit}\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>scanFoo1</span><span>(</span><span>@PathVariable</span><span>(</span><span>\"limit\"</span><span>)</span> <span>int</span> limit<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>try</span> <span>(</span>\n                <span>SqlSession</span> sqlSession <span>=</span> sqlSessionFactory<span>.</span><span>openSession</span><span>(</span><span>)</span><span>;</span>  <span>// 1</span>\n                <span>Cursor</span><span><span>&lt;</span><span>Foo</span><span>></span></span> cursor <span>=</span>\n                        sqlSession<span>.</span><span>getMapper</span><span>(</span><span>FooMapper</span><span>.</span><span>class</span><span>)</span><span>.</span><span>scan</span><span>(</span>limit<span>)</span>   <span>// 2</span>\n        <span>)</span> <span>{</span>\n            cursor<span>.</span><span>forEach</span><span>(</span>foo <span>-></span> <span>{</span>\n            <span>}</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>上面的代码中，</p>\n<ol>\n<li>处我们开启了一个 SqlSession （实际上也代表了一个数据库连接），并保证它最后能关闭；</li>\n<li>处我们使用 SqlSession 来获得 Mapper 对象。这样才能保证得到的 Cursor 对象是打开状态的。</li>\n</ol>\n<h3 id=\"方案二-transactiontemplate\" tabindex=\"-1\"> 方案二：TransactionTemplate</h3>\n<p>在 Spring 中，我们可以用 TransactionTemplate 来执行一个数据库事务，这个过程中数据库连接同样是打开的。代码如下：</p>\n<div><pre><code><span>class</span> <span>T</span> <span>{</span>\n\n    <span>@GetMapping</span><span>(</span><span>\"foo/scan/2/{limit}\"</span><span>)</span>\n    <span>public</span> <span>void</span> <span>scanFoo2</span><span>(</span><span>@PathVariable</span><span>(</span><span>\"limit\"</span><span>)</span> <span>int</span> limit<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>TransactionTemplate</span> transactionTemplate <span>=</span>\n                <span>new</span> <span>TransactionTemplate</span><span>(</span>transactionManager<span>)</span><span>;</span>  <span>// 1</span>\n\n        transactionTemplate<span>.</span><span>execute</span><span>(</span>status <span>-></span> <span>{</span>               <span>// 2</span>\n            <span>try</span> <span>(</span><span>Cursor</span><span><span>&lt;</span><span>Foo</span><span>></span></span> cursor <span>=</span> fooMapper<span>.</span><span>scan</span><span>(</span>limit<span>)</span><span>)</span> <span>{</span>\n                cursor<span>.</span><span>forEach</span><span>(</span>foo <span>-></span> <span>{</span>\n                <span>}</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>IOException</span> e<span>)</span> <span>{</span>\n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n            <span>return</span> <span>null</span><span>;</span>\n        <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>limit分页有一个问题就是当偏移量较大时查询遍历的数据越多，效率会逐渐降低，例如limit 1000,10这样的查询这时MYSQL需要查询出1020条记录然后只返回最后20条，前面的1000条记录都会被抛弃，代价较高。如果每个分页被访问的数据频率都相同要优化这种查询要么是在页面中限制分页的数量要么是优化大偏移量的性能。</p>\n<p>优化此类分页查询的最简单的一个办法就是尽可能地使用<strong>索引覆盖</strong>扫描，而不是查询所有的列。然后根据需要做一次关联操作再返回所需的列，对于偏移量很大的时候，这样做的效率会提升很大。</p>\n<p>上面的代码中，</p>\n<ol>\n<li>处我们创建了一个 TransactionTemplate 对象（此处 transactionManager 是怎么来的不用多解释，本文假设读者对 Spring 数据库事务的使用比较熟悉了），</li>\n<li>处执行数据库事务，而数据库事务的内容则是调用 Mapper 对象的流式查询。注意这里的 Mapper 对象无需通过 SqlSession 创建。</li>\n</ol>\n<h3 id=\"方案三-transactional-注解\" tabindex=\"-1\"> 方案三：@Transactional 注解</h3>\n<p>这个本质上和方案二一样，代码如下：</p>\n<div><pre><code><span>@GetMapping</span><span>(</span><span>\"foo/scan/3/{limit}\"</span><span>)</span>\n<span>@Transactional</span>\n<span>public</span> <span>void</span> <span>scanFoo3</span><span>(</span><span>@PathVariable</span><span>(</span><span>\"limit\"</span><span>)</span> <span>int</span> limit<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n    <span>try</span> <span>(</span><span>Cursor</span><span><span>&lt;</span><span>Foo</span><span>></span></span> cursor <span>=</span> fooMapper<span>.</span><span>scan</span><span>(</span>limit<span>)</span><span>)</span> <span>{</span>\n        cursor<span>.</span><span>forEach</span><span>(</span>foo <span>-></span> <span>{</span> <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>它仅仅是在原来方法上面加了个 <code>@Transactional</code> 注解。这个方案看上去最简洁，但请注意 Spring 框架当中注解使用的坑：只在外部调用时生效。在当前类中调用这个方法，依旧会报错。</p>\n<h2 id=\"jdbc实现流式查询\" tabindex=\"-1\"> JDBC实现流式查询</h2>\n<p>使用JDBC的<code>PreparedStatement/Statement</code>的<code>setFetchSize</code>方法设置为 <code>Integer.MIN_VALUE</code>或使用方法<code>Statement.enableStreamingResults()</code>可以实现流式查询，在执行<code>ResultSet.next()</code>方法时，会通过数据库连接一条一条的返回，这样也不会大量占用客户端的内存。</p>\n<div><pre><code><span>public</span> <span>int</span> <span>execute</span><span>(</span><span>String</span> sql<span>,</span> <span>boolean</span> isStreamQuery<span>)</span> <span>throws</span> <span>SQLException</span> <span>{</span>\n    <span>Connection</span> conn <span>=</span> <span>null</span><span>;</span>\n    <span>PreparedStatement</span> stmt <span>=</span> <span>null</span><span>;</span>\n    <span>ResultSet</span> rs <span>=</span> <span>null</span><span>;</span>\n    <span>int</span> count <span>=</span> <span>0</span><span>;</span>\n    <span>try</span> <span>{</span>\n        <span>//获取数据库连接</span>\n        conn <span>=</span> <span>getConnection</span><span>(</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>isStreamQuery<span>)</span> <span>{</span>\n            <span>//设置流式查询参数</span>\n            stmt <span>=</span> conn<span>.</span><span>prepareStatement</span><span>(</span>sql<span>,</span> <span>ResultSet</span><span>.</span>TYPE_FORWARD_ONLY<span>,</span> <span>ResultSet</span><span>.</span>CONCUR_READ_ONLY<span>)</span><span>;</span>\n            stmt<span>.</span><span>setFetchSize</span><span>(</span><span>Integer</span><span>.</span>MIN_VALUE<span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>//普通查询</span>\n            stmt <span>=</span> conn<span>.</span><span>prepareStatement</span><span>(</span>sql<span>)</span><span>;</span>\n        <span>}</span>\n\n        <span>//执行查询获取结果</span>\n        rs <span>=</span> stmt<span>.</span><span>executeQuery</span><span>(</span><span>)</span><span>;</span>\n        <span>//遍历结果</span>\n        <span>while</span><span>(</span>rs<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span><span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>rs<span>.</span><span>getString</span><span>(</span><span>1</span><span>)</span><span>)</span><span>;</span>\n            count<span>++</span><span>;</span>\n        <span>}</span>\n    <span>}</span> <span>catch</span> <span>(</span><span>SQLException</span> e<span>)</span> <span>{</span>\n        e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span> <span>finally</span> <span>{</span>\n        <span>close</span><span>(</span>stmt<span>,</span> rs<span>,</span> conn<span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> count<span>;</span>\n<span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>MySQL流式查询对于内存占用方面的优化还是比较明显的，但是对于查询速度的影响较小，主要用于解决大数据量查询时的内存占用多的场景。</p>\n<p><a href=\"\"></a></p>\n<div><pre><code><span>SELECT</span> <span>*</span> <span>FROM</span> bj_setl_d <span>WHERE</span> ownpay_setl_flag <span>=</span> <span>'3'</span> <span>AND</span> refd_setl_flag <span>=</span> <span>'0'</span> <span>AND</span> medfee_sumamt <span>></span> <span>'1500'</span> <span>AND</span> med_type <span>IN</span> <span>(</span> <span>11</span><span>,</span><span>12</span><span>,</span><span>13</span><span>,</span><span>14</span><span>,</span><span>19</span><span>,</span><span>51</span><span>,</span><span>53</span><span>,</span><span>91</span><span>,</span><span>1105</span><span>,</span><span>1104</span><span>,</span><span>9901</span><span>,</span><span>9903</span><span>,</span><span>9905</span><span>,</span><span>9906</span><span>,</span><span>9914</span><span>,</span><span>530102</span> <span>)</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br></div></div>",
      "date_published": "2021-08-03T00:00:00.000Z",
      "date_modified": "2022-04-24T09:56:06.000Z",
      "authors": [],
      "tags": [
        "mysql"
      ]
    },
    {
      "title": "dataource",
      "url": "http://www.zhangsj.xyz/blog/java/datasource/storage-engine.html",
      "id": "http://www.zhangsj.xyz/blog/java/datasource/storage-engine.html",
      "content_html": "<h2 id=\"innodb-myisam\" tabindex=\"-1\"> Innodb &amp;Myisam</h2>\n<ol>\n<li>myisam 是不支持支持事务；innodb支持事务。</li>\n<li>myisam支持表级锁；innodb 支持行锁，粒度更小，但是在执行不能确定扫描范围的sql语句时，innodb同样会锁全表。</li>\n<li>数据都是存在磁盘文件，通过磁盘IO 操作读取数据，myisam有三个文件.frm(存储表定义)   .myi（存储表索引） .myd（存储表数据） innodb磁盘上存储的是.frm(存储表定义)，.ibd(该表的索引和数据) 和 redo-log,undo-log日志文件;</li>\n</ol>\n<h3 id=\"主键索引\" tabindex=\"-1\"> 主键索引</h3>\n<p>数据表的主键列使用的就是主键索引。</p>\n<p>一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</p>\n<p>因为InnoDB 的数据文件本身要按主键聚集，所以InnoDB 要求表必须有主键（MyISAM 可以没有），如果没有显式指定，则MySQL 系统会自动选择一个可以唯一标识数据记录的列作为主键，没有空值的唯一索引，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐式字段作为主键，这个字段长度为6个字节，类型为长整形。</p>\n<p>在 Mysql 中，InnoDB 引擎的表的 .ibd文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p>\n<h4 id=\"innodb聚集索引\" tabindex=\"-1\"> InnoDB聚集索引</h4>\n<div><p>优点</p>\n<p>查询速度非常的快，因为整个 B 树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。</p>\n</div>\n<div><p>缺点</p>\n<ol>\n<li>依赖于有序的数据 ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li>\n<li>更新代价大 ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改， 而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的， 所以对于主键索引来说，主键一般都是不可被修改的。</li>\n</ol>\n</div>\n<h4 id=\"myisam非聚集索引\" tabindex=\"-1\"> MYISAM非聚集索引</h4>\n<p>非聚集索引即索引结构和数据分开存放的索引。</p>\n<p>二级索引属于非聚集索引。 MYISAM 引擎的表的.MYI 文件包含了表的索引， 该表的索引(B+树)的每个叶子非叶子节点存储索引， 叶子节点存储索引和索引对应数据的指针，指向.MYD 文件的数据。</p>\n<p>非聚集索引的叶子节点并不一定存放数据的指针， 因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</p>\n<p>非聚集索引的优点 更新代价比聚集索引要小 。</p>\n<p>非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的 # 非聚集索引的缺点 跟聚集索引一样，非聚集索引也依赖于有序的数据 可能会二次查询(回表) :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。 这是 MySQL 的表的文件截图:</p>\n<p>覆盖索引不会回表查询</p>\n<h3 id=\"主键索引-辅助索引区别\" tabindex=\"-1\"> 主键索引&amp;辅助索引区别</h3>\n<ul>\n<li>B+Tree的叶子节点存放的是主键字段值就属于主键索引；</li>\n<li>如果存放的是非主键值 就属于辅助索引（二级索引）；</li>\n</ul>\n<h2 id=\"innodb索引\" tabindex=\"-1\"> Innodb索引</h2>\n<p>InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。</p>\n<h3 id=\"myisam索引\" tabindex=\"-1\"> myisam索引</h3>\n<p>索引由B+树构成，执行查询操作的时候会先搜索B+树，如果找到对应叶子结点，根据叶子节点的值（地址），拿出整行数据。</p>\n<p>辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p>\n",
      "date_published": "2020-08-01T00:00:00.000Z",
      "date_modified": "2022-04-14T00:58:56.000Z",
      "authors": [],
      "tags": [
        "mysql"
      ]
    },
    {
      "title": "ArrayList",
      "url": "http://www.zhangsj.xyz/blog/java/jvm/LinkedList.html",
      "id": "http://www.zhangsj.xyz/blog/java/jvm/LinkedList.html",
      "content_html": "<h1 id=\"数组和链表的区别\" tabindex=\"-1\"> 数组和链表的区别</h1>\n<p>1、数组特点</p>\n<p>存储区间是连续、且占用内存严重，空间复杂也很大，时间复杂O(1)。优点：是随机读取效率很高，原因数组是连续（随机访问性强，查找速度快）。缺点：插入和删除数据效率低，因插入数据，这个位置后面的数据在内存中药网后裔的，且大小固定不易动态扩展。</p>\n<p>2、链表特点</p>\n<p>区间离散，占用内存宽松，空间复杂度小，时间复杂度O(N)。优点：插入删除速度快，内存利用率高，没有大小固定，扩展灵活。缺点：不能随机查找，每次都是从第一个开始遍历（查询效率低）。</p>\n<p>ArrayList，linkedList插入和检索顺序是一样的。</p>\n<p>LinkedHashMap实现顺序性</p>\n<h2 id=\"arraylist\" tabindex=\"-1\"> ArrayList</h2>\n<p>上篇文章我们分析了常见的ArrayList源码，它的内部是由一个数组来实现的。那么今天，我们来分析另一个常见的类LinkedList。本文分析都来自Java8。(ps:这段话写自写完本文记录后添加。个人感想为已经写成了介绍链表)</p>\n<p>一、类说明</p>\n<p>首先我们来看一下这个类。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>LinkedLiist</span>\n\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br></div></div><h2 id=\"总结\" tabindex=\"-1\"> 总结</h2>\n<p>首先linkedlist\n内部是由双向链表来实现的。我们存储的每一个数据都会被封装到一个数据节点之中。包括指向前节点的指针，数据，指向后节点的指针；依靠这些数据结点实现双向链表。</p>\n<p>既然是链表，那么优点就是插入，修改，删除数据效率比数组高很多。因为在插入或者实时某个数据时，只需对要删除节点，前节点，后节点进行操作，无需像数组一样将后续数据全部前移或者后移。但是由此也看出缺点，因为链表并不是连续的空间存储，也没有什么下标进行记录位置，因此要寻找某个数据时只能进行遍历，而不像数组一样可以随机查找。如果在实际开发中，我们需要对某个list进行频繁的插入、删除，而且数据量有特别大的时候。可以考虑使用linkedlist。</p>\n",
      "date_published": "2022-04-13T18:37:08.000Z",
      "date_modified": "2022-04-16T23:42:59.000Z",
      "authors": [],
      "tags": [
        "数据结构"
      ]
    },
    {
      "title": "为什么一定要用消息中间件？",
      "url": "http://www.zhangsj.xyz/blog/java/message-queue/why-must-message-middleware-be-used.html",
      "id": "http://www.zhangsj.xyz/blog/java/message-queue/why-must-message-middleware-be-used.html",
      "content_html": "<h2 id=\"为什么一定要用消息中间件\" tabindex=\"-1\"> 为什么一定要用消息中间件？</h2>\n<p>消息中间件是分布式系统常用的组件，无论是异步化、解耦、削峰等都有广泛的应用价值。我们通常会认为，消息中间件是一个可靠的组--这里所谓的可靠是指：只要我们消息成功投递到了消息中间件，消息就不会丢失，即消息肯定会至少保证消息能被消费者成功消费一次，这是消息中间件最基本的特性之一。</p>\n<p>举个栗子：一个消息M发送到了消息中间件，消息投递到了消费程序A，A接收到了消息，消费程序A消费到一半的时候，程序重启了，这时候，这个消息并没有标记为消费成功，这个消息还会继续投递给这个消费者，直到其消费成功，MQ才会停止投递。</p>\n<p>然而这种可靠的特性导致，消息可能被多次投递。举个栗子：还是刚刚那个例子，程序A接收到这个消息M并完成消费逻辑之后，正想通知消息中间件“我已经消费成功了”的时候，程序就重启了，那么对于消息中间件来说，这个消息并没有成功消费过，所以他还会继续投递。这时候对于应用程序A来说，看起来就是这个消息明明消费成功了，但是消息中间件还在重复投递。</p>\n<p>基于消息的投递可靠（消息不丢）是优先级更高的，所以消息补充的人物就会转移到应用程序自我实现，这也是为什么RocketMQ的文档里强调的，消费逻辑需要自我实现幂等。背后的逻辑其实就是：不丢和补充是矛盾的（在分布式场景下），但消息重复是有解决方案的，而消息丢失是很麻烦的。</p>\n<h2 id=\"exactly-once\" tabindex=\"-1\"> Exactly-Once</h2>\n<p>在消息中间件里，有一个投递语义的概念，而这个语义里有一个叫”Exactly Once”，即消息肯定会被成功消费，并且只会被消费一次。以下是阿里云里对Exactly Once的解释：</p>\n<p>Exactly-Once（确切一次） 是指发送到消息系统的消息只能被消费端处理且仅处理一次，即使生产端重试消息发送导致某消息重复投递，该消息在消费端也只被消费一次。</p>\n<h2 id=\"一、你们用的是什么消息中间件\" tabindex=\"-1\"> 一、你们用的是什么消息中间件？</h2>\n<p>这个首先你可以说下你们公司选用的是什么消息中间件，比如用的是RabbitMQ，然后可以初步给一些你对不同MQ中间件技术的选型分析。</p>\n<p><strong>举个例子</strong>：比如说<code>ActiveMQ</code>是老牌的消息中间件，国内很多公司过去运用的还是非常广泛的，功能很强大。</p>\n<p>但是问题在于没法确认<code>ActiveMQ</code>可以支撑互联网公司的高并发、高负载以及高吞吐的复杂场景，在国内互联网公司落地较少。而且使用较多的是一些传统企业，用ActiveMQ做异步调用和系统解耦。</p>\n<p>然后你可以说说<code>RabbitMQ</code>，他的好处在于可以支撑<code>高并发、高吞吐、性能很高</code>，同时有非常完善便捷的后台管理界面可以使用。</p>\n<p>另外，他还支持集群化、高可用部署架构、消息高可靠支持，功能较为完善。</p>\n<p>而且经过调研，国内各大互联网公司落地大规模RabbitMQ集群支撑自身业务的case较多，国内各种中小型互联网公司使用RabbitMQ的实践也比较多。</p>\n<p>除此之外，<code>RabbitMQ</code>的开源社区很活跃，较高频率的迭代版本，来修复发现的bug以及进行各种优化，因此综合考虑过后，公司采取了<code>RabbitMQ</code>。</p>\n<p>但是<code>RabbitMQ</code>也有一点缺陷，就是他自身是基于erlang语言开发的，所以导致较为难以分析里面的源码，也较难进行深层次的源码定制和改造，毕竟需要较为扎实的erlang语言功底才可以。</p>\n<p>然后可以聊聊<code>RocketMQ</code>，是阿里开源的，经过阿里的生产环境的超高并发、高吞吐的考验，性能卓越，同时还支持分布式事务等特殊场景。</p>\n<p>而且<code>RocketMQ</code>是基于Java语言开发的，适合深入阅读源码，有需要可以站在源码层面解决线上生产问题，包括源码的二次开发和改造。</p>\n<p>另外就是Kafka</p>\n<p>Kafka提供的消息中间件的功能明显较少一些，相对上述几款MQ中间件要少很多。</p>\n<p>但是Kafka的优势在于专为超高吞吐量的实时日志采集、实时数据同步、实时数据计算等场景来设计。</p>\n<p>因此Kafka在大数据领域中配合实时计算技术（比如Spark Streaming、Storm、Flink）使用的较多。但是在传统的MQ中间件使用场景中较少采用。</p>\n<h2 id=\"二、为什么要使用消息中间件\" tabindex=\"-1\"> 二、为什么要使用消息中间件？</h2>\n<p>回答这个问题，其实就是让你先说说消息中间件的常见使用场景，然后结合你们自身系统对应的使用场景，说一下在你们系统中引入消息中间件是解决了什么问题。</p>\n<p>1、系统解耦</p>\n<p>假设你有个系统A，这个系统A会产出一个核心数据，现在下游有系统B和系统C需要这个数据。</p>\n<p>那简单，系统A就是直接调用系统B和系统C的接口发送数据给他们就好了。</p>\n<p>整个过程，如下图所示：</p>\n<p>systemA=发送数据=&gt;systemB、systemc</p>\n<p>但是现在要是来了系统D、系统E、系统F、系统G，等等，十来个其他系统慢慢的都需要这份核心数据呢？</p>\n<p>大家可别以为这是开玩笑，一个大规模系统，往往会拆分为几十个甚至上百个子系统，每个子系统又对应N多个服务，这些系统与系统之间有着错综复杂的关系网络。</p>\n<p>如果某个系统产出一份核心数据，可能下游无数的其他系统都需要这份数据来实现各种业务逻辑。</p>\n<p>此时如果你要是采取上面那种模式来设计系统架构，那么绝对你负责系统A的同学要被烦死了。</p>\n<p>先是来一个人找他要求发送数据给一个新的系统H，系统A的同学要修改代码然后在那个代码里加入调用新系统H的流程。</p>\n<p>一会那个系统B是个陈旧老系统要下线了，告诉系统A的同学：别给我发送数据了，接着系统A再次修改代码不再给这个系统B。</p>\n<p>然后如果要是某个下游系统突然宕机了呢？</p>\n<p>系统A的调用代码里是不是会抛异常？那系统A的同学会收到报警说异常了，结果他还要去care是下游哪个系统宕机了。</p>\n<p>所以在实际的系统架构设计中，如果全部采取这种系统耦合的方式，在某些场景下绝对是不合适的，系统耦合度太严重。</p>\n<p>并且互相耦合起来并不是核心链路的调用，而是一些非核心的场景（比如上述的数据消费）导致了系统耦合，这样会严重的影响上下游系统的开发和维护效率。</p>\n<p>因此在上述系统架构中，就可以采用MQ中间件来实现系统解耦。</p>\n<p>系统A就把自己的一份核心数据发到MQ里，下游哪个系统感兴趣自己去消费即可，不需要了就取消数据的消费，如下图所示：</p>\n<p><img src=\"@source/java/message-queue/img/使用mq实现系统解耦.png\" alt=\"\" loading=\"lazy\"></p>\n<p>2、异步调用</p>\n<p>假设你有一个系统调用链路，是系统A调用系统B，一般耗时20ms；系统B调用系统C，一般耗时200ms；系统C调用系统D，一般耗时2s，如下图所示。</p>\n<p><img src=\"@source/java/message-queue/img/异步调用解决系统调用链路耗时.png\" alt=\"\" loading=\"lazy\"></p>\n<p>现在最大的问题就是：</p>\n<p>用户一个请求过来巨慢无比，因为走完一个链路，需要耗费：</p>\n<p>20ms + 200ms + 2000ms（2s） = 2220ms，</p>\n<p>也就是2秒多的时间。但是实际上，链路中的系统A调用系统B，系统B调用系统C，这两个步骤起来也就220ms。</p>\n<p>就因为引入了系统C调用系统D这个步骤，导致最终链路执行时间是2秒多，直接将链路调用性能降低了10倍，这就是导致链路执行过慢的罪魁祸首。</p>\n<p>那此时我们可以思考一下，是不是可以将系统D从链路中抽离出去做成异步调用呢？</p>\n<p>其实很多的业务场景是可以允许异步调用的。</p>\n<p>举个例子：你平时点个外卖，咔嚓一下子下订单然后付款了，此时账户扣款、创建订单、通知商家给你准备菜品。</p>\n<p>接着，是不是需要找个骑手给你送餐？那这个找骑手的过程，是需要一套复杂算法来实现调度的，比较耗时。</p>\n<p>但是其实稍微晚个几十秒完成骑手的调度都是ok的，因为实际并不需要在你支付的一瞬间立马给你找好骑手，也没那个必要。</p>\n<p>那么我们是不是就可以把找骑手给你送餐的这个步骤从链路中抽离出去，做成异步化的，哪怕延迟个几十秒，但是只要在一定时间范围内给你找到一个骑手去送餐就可以了。</p>\n<p>这样是不是就可以让你下订单点外卖的速度变得超快？支付成功之后，直接创建好订单、账户扣款、通知商家立马给你准备做菜就ok了，这个过程可能就几百毫秒。</p>\n<p>然后后台异步化的耗费可能几十秒通过调度算法给你找到一个骑手去送餐，但是这个步骤不影响我们快速下订单。</p>\n<p>当然我们不是说那些大家熟悉的外卖平台的技术架构就一定是这么实现的，只不过是用一个生活中常见的例子给大家举例说明而已。</p>\n<p>所以上面的链路也是同理，如果业务流程支持异步化的话，是不是就可以考虑把系统C对系统D的调用抽离出去做成异步化的，不要放在链路中同步依次调用。</p>\n<p>这样，实现思路就是系统A -&gt; 系统B -&gt; 系统C，直接就耗费220ms后直接成功了。</p>\n<p>然后系统C就是发送个消息到MQ中间件里，由系统D消费到消息之后慢慢的异步来执行这个耗时2s的业务处理。通过这种方式直接将核心链路的执行性能提升了10倍。</p>\n<p>整个过程，如下图所示：</p>\n<p><img src=\"@source/java/message-queue/img/异步调用解决系统调用链路耗时2.png\" alt=\"\" loading=\"lazy\"></p>\n<p>3、流量削峰</p>\n<p>假设你有一个系统，平时正常的时候每秒可能就几百个请求，系统部署在8核16G的机器的上，正常处理都是ok的，每秒几百请求是可以轻松抗住的</p>\n<p>但是如下图所示，在高峰期一下子来了每秒钟几千请求，瞬时出现了流量高峰，此时你的选择是要搞10台机器，抗住每秒几千请求的瞬时高峰吗？</p>\n<p><img src=\"@source/java/message-queue/img/流量削峰.png\" alt=\"\" loading=\"lazy\"></p>\n<p>那如果瞬时高峰每天就那么半个小时，接着直接就降低为了每秒就几百请求，如果你线上部署了很多台机器，那么每台机器就处理每秒几十个请求就可以了，<strong>这不是有点浪费机器资源吗？</strong></p>\n<p>大部分时候，每秒几百请求，一台机器就足够了，但是为了抗那每天瞬时的高峰，硬是部署了10台机器，每天就那半个小时有用，别的时候都是浪费资源的。</p>\n<p><img src=\"@source/java/message-queue/img/流量削峰2.png\" alt=\"\" loading=\"lazy\"></p>\n<p>但是如果你就部署一台机器，那会导致瞬时高峰时，一下子压垮你的系统，因为绝对无法抗住每秒几千的请求高峰。</p>\n<p>此时我们就可以用MQ中间件来进行流量削峰。所有机器前面部署一层MQ，平时每秒几百请求大家都可以轻松接收消息。</p>\n<p>一旦到了瞬时高峰期，一下涌入每秒几千的请求，就可以积压在MQ里面，然后那一台机器慢慢的处理和消费。</p>\n<p>等高峰期过了，再消费一段时间，MQ里积压的数据就消费完毕了。</p>\n<p><img src=\"@source/java/message-queue/img/流量削峰3.png\" alt=\"\" loading=\"lazy\"></p>\n<p><strong>这个就是很典型的一个MQ的用法</strong>，用有限的机器资源承载高并发请求，如果业务场景允许异步削峰，高峰期积压一些请求在MQ里，然后高峰期过了，后台系统在一定时间内消费完毕不再积压的话，那就很适合用这种技术方案。</p>\n",
      "date_published": "2022-04-13T18:37:08.000Z",
      "date_modified": "2022-04-14T05:48:05.000Z",
      "authors": [],
      "tags": [
        "消息中间件"
      ]
    },
    {
      "title": "redis高可用实现",
      "url": "http://www.zhangsj.xyz/blog/java/redis/analysis-and-construction-of-redis.html",
      "id": "http://www.zhangsj.xyz/blog/java/redis/analysis-and-construction-of-redis.html",
      "content_html": "<h2 id=\"高可用redis服务架构分析与搭建\" tabindex=\"-1\"> 高可用Redis服务架构分析与搭建</h2>\n<p>基于内存的Redis应该是目前各种Web开发业务中最为常用的Key-Value数据库了，我们经常在业务中用其存储用户登陆态（Session存储），加速一些热数据的查询（相比较MySQL而言，速度有数量级的提升），做简单的消息队列（LPUSH和BRPOP）、订阅发布（PUB/SUB）系统等等。规模比较大的互联网公司，一般都会有专门的团队，将Redis存储以基础服务的形式提供给各个业务调用。</p>\n<p>不过任何一个基础服务的提供方，都会被调用方问起的一个问题是：你的服务是否具有高可用性？最好不要因为你的服务经常出问题，导致我这边的业务跟着遭殃。最近我所在的项目中也自己搭了一套小型的“高可用”Redis服务，在此做一下自己的总结和思考。</p>\n<p>首先我们要定义一下对于Redis服务来说怎样才算是高可用，即在各种出现异常的情况下，依然可以正常提供服务。或者宽松一些，出现异常的情况下，只经过很短暂的时间即可恢复正常服务。</p>\n<p>所谓异常，应该至少包含了以下几种可能性：</p>\n<p>【异常1】某个节点服务器的某个进程突然down掉（例如某开发手残，把一台服务器的redis-server进程kill了）；</p>\n<p>【异常2】某台节点服务器down掉，相当于这个节点上所有进程都停了（例如某运维手残，把一个服务器的电源拔了；例如一些老旧机器出现硬件故障）；</p>\n<p>【异常3】任意两个节点服务器之间的通信中断了（例如某临时工手残，把用于两个机房通信的光缆挖断了）；</p>\n<p>其实以上任意一种异常都是小概率事件，而做到高可用性的基本指导思想就是：多个小概率事件同时发生的概率可以忽略不计。只要我们设计的系统可以容忍短时间内的单点故障，即可实现高可用性。</p>\n<p>对于搭建高可用Redis服务，网上已有了很多方案，例如Keepalived，Codis，Twemproxy，Redis Sentinel。其中Codis和Twemproxy主要是用于大规模的Redis集群中，也是在Redis官方发布Redis Sentinel之前twitter和豌豆荚提供的开源解决方案。我的业务中数据量并不大，所以搞集群服务反而是浪费机器了。最终在Keepalived和Redis Sentinel之间做了个选择，选择了官方的解决方案Redis Sentinel。</p>\n<p>Redis Sentinel可以理解为一个监控Redis Server服务是否正常的进程，并且一旦检测到不正常，可以自动地将备份（slave）Redis Server启用，使得外部用户对Redis服务内部出现的异常无感知。我们按照由简至繁的步骤，搭建一个最小型的高可用的Redis服务。</p>\n<p>方案1：单机版Redis Server，无Sentinel</p>\n<p><img src=\"@source/java/redis/img/单机版redis-server，无Sentinel.png\" alt=\"单机版redis-server，无Sentinel\" loading=\"lazy\"></p>\n<p>一般情况下，我们搭的个人网站，或者平时做开发时，会起一个单实例的Redis Server。调用方直接连接Redis服务即可，甚至Client和Redis本身就处于同一台服务器上。这种搭配仅适合个人学习娱乐，毕竟这种配置总会有单点故障的问题无法解决。一旦Redis服务进程挂了，或者服务器1停机了，那么服务就不可用了。并且如果没有配置Redis数据持久化的话，Redis内部已经存储的数据也会丢失。</p>\n<p>方案2：主从同步Redis Server，单实例Sentinel</p>\n<p><img src=\"@source/java/redis/img/主从同步redis-server，单实例Sentinel.png\" alt=\"主从同步redis-server，单实例Sentinel\" loading=\"lazy\"></p>\n<p>为了实现高可用，解决方案1中所述的单点故障问题，我们必须增加一个备份服务，即在两台服务器上分别各启动一个Redis Server进程，一般情况下由master提供服务，slave只负责同步和备份。与此同时，在额外启动一个Sentinel进程，监控两个Redis Server实例的可用性，以便在master挂掉的时候，及时把slave提升到master的角色继续提供服务，这样就实现了Redis Server的高可用。这基于一个高可用服务设计的依据，即单点故障本身就是个小概率事件，而多个单点同时故障（即master和slave同时挂掉），可以认为是（基本）不可能发生的事件。</p>\n<p>对于Redis服务的调用方来说，现在要连接的是Redis Sentinel服务，而不是Redis Server了。常见的调用过程是，client先连接Redis Sentinel并询问目前Redis Server中哪个服务是master，哪些是slave，然后再去连接相应的Redis Server进行操作。当然目前的第三方库一般都已经实现了这一调用过程，不再需要我们手动去实现（例如Nodejs的ioredis，PHP的predis，Golang的go-redis/redis，JAVA的jedis等）。</p>\n<p>然而，我们实现了Redis Server服务的主从切换之后，又引入了一个新的问题，即Redis Sentinel本身也是个单点服务，一旦Sentinel进程挂了，那么客户端就没办法链接Sentinel了。所以说，方案2的配置并无法实现高可用性。</p>\n<p>方案3：主从同步Redis Server，双实例Sentinel</p>\n<p><img src=\"@source/java/redis/img/主从同步redis-server，双实例Sentinel.png\" alt=\"主从同步redis-server，双实例Sentinel\" loading=\"lazy\"></p>\n<p>为了解决方案2的问题，我们把Redis Sentinel进程也额外启动一份，两个Sentinel进程同时为客户端提供服务发现的功能。对于客户端来说，它可以连接任何一个Redis Sentinel服务，来获取当前Redis Server实例的基本信息。通常情况下，我们会在Client端配置多个Redis Sentinel的链接地址，Client一旦发现某个地址连接不上，会去试图连接其他的Sentinel实例，这当然也不需要我们手动实现，各个开发语言中比较热门的redis连接库都帮我们实现了这个功能。我们预期是：即使其中一个Redis Sentinel挂掉了，还有另外一个Sentinel可以提供服务。</p>\n<p>然而，愿景是美好的，现实却是很残酷的。如此架构下，依然无法实现Redis服务的高可用。方案3示意图中，红线部分是两台服务器之间的通信，而我们所设想的异常场景（【异常2】）是，某台服务器整体down机，不妨假设服务器1停机，此时，只剩下服务器2上面的Redis Sentinel和slave Redis Server进程。这时，Sentinel其实是不会将仅剩的slave切换成master继续服务的，也就导致Redis服务不可用，因为Redis的设定是只有当超过50%的Sentinel进程可以连通并投票选取新的master时，才会真正发生主从切换。本例中两个Sentinel只有一个可以连通，等于50%并不在可以主从切换的场景中。</p>\n<p>你可能会问，为什么Redis要有这个50%的设定？假设我们允许小于等于50%的Sentinel连通的场景下也可以进行主从切换。试想一下【异常3】，即服务器1和服务器2之间的网络中断，但是服务器本身是可以运行的。如下图所示：</p>\n<p><img src=\"@source/java/redis/img/主从同步redis-server，双实例Sentinel（2）.png\" alt=\"主从同步redis-server，双实例Sentinel（2）\" loading=\"lazy\"></p>\n<p>实际上对于服务器2来说，服务器1直接down掉和服务器1网络连不通是一样的效果，反正都是突然就无法进行任何通信了。假设网络中断时我们允许服务器2的Sentinel把slave切换为master，结果就是你现在拥有了两个可以对外提供服务的Redis Server。Client做任何的增删改操作，有可能落在服务器1的Redis上，也有可能落在服务器2的Redis上（取决于Client到底连通的是哪个Sentinel），造成数据混乱。即使后面服务器1和服务器2之间的网络又恢复了，那我们也无法把数据统一了（两份不一样的数据，到底该信任谁呢？），数据一致性完全被破坏。</p>\n<h2 id=\"方案4-主从同步redis-server-三实例sentinel\" tabindex=\"-1\"> 方案4：主从同步Redis Server，三实例Sentinel</h2>\n<p><img src=\"@source/java/redis/img/主从同步redis-server，三实例Sentinel.png\" alt=\"主从同步redis-server，三实例Sentinel\" loading=\"lazy\"></p>\n<p>鉴于方案3并没有办法做到高可用，我们最终的版本就是上图所示的方案4了。实际上这就是我们最终搭建的架构。我们引入了服务器3，并且在3上面又搭建起一个Redis Sentinel进程，现在由三个Sentinel进程来管理两个Redis Server实例。这种场景下，不管是单一进程故障、还是单个机器故障、还是某两个机器网络通信故障，都可以继续对外提供Redis服务。</p>\n<p>实际上，如果你的机器比较空闲，当然也可以把服务器3上面也开启一个Redis Server，形成1 master + 2 slave的架构，每个数据都有两个备份，可用性会提升一些。当然也并不是slave越多越好，毕竟主从同步也是需要时间成本的。</p>\n<p>在方案4中，一旦服务器1和其他服务器的通信完全中断，那么服务器2和3会将slave切换为master。对于客户端来说，在这么一瞬间会有2个master提供服务，并且一旦网络恢复了，那么所有在中断期间落在服务器1上的新数据都会丢失。如果想要部分解决这个问题，可以配置Redis Server进程，让其在检测到自己网络有问题的时候，立即停止服务，避免在网络故障期间还有新数据进来（可以参考Redis的min-slaves-to-write和min-slaves-max-lag这两个配置项）。</p>\n<p>至此，我们就用3台机器搭建了一个高可用的Redis服务。其实网上还有更加节省机器的办法，就是把一个Sentinel进程放在Client机器上，而不是服务提供方的机器上。只不过在公司里面，一般服务的提供方和调用方并不来自同一个团队。两个团队共同操作同一个机器，很容易因为沟通问题导致一些误操作，所以出于这种人为因素的考虑，我们还是采用了方案4的架构。并且由于服务器3上面只跑了一个Sentinel进程，对服务器资源消耗并不多，还可以用服务器3来跑一些其他的服务。</p>\n<p>易用性：像使用单机版Redis一样使用Redis Sentinel</p>\n<p>作为服务的提供方，我们总是会讲到用户体验问题。在上述方案当中始终有一个让Client端用的不是那么舒服的地方。对于单机版Redis，Client端直接连接Redis Server，我们只需要给一个ip和port，Client就可以使用我们的服务了。而改造成Sentinel模式之后，Client不得不采用一些支持Sentinel模式的外部依赖包，并且还要修改自己的Redis连接配置，这对于“矫情”的用户来讲显然是不能接收的。有没有办法还是像在使用单机版的Redis那样，只给Client一个固定的ip和port就可以提供服务呢？</p>\n<p><img src=\"@source/java/redis/assets/20220414/analysis-and-construction-of-redis-1649874689906.png\" alt=\"使用单机版一样使用redis\" loading=\"lazy\"></p>\n<p>答案当然是肯定的。这可能就要引入虚拟IP（Virtual IP，VIP），如上图所示。我们可以把虚拟IP指向Redis Server master所在的服务器，在发生Redis主从切换的时候，会触发一个回调脚本，回调脚本中将VIP切换至slave所在的服务器。这样对于Client端来说，他仿佛在使用的依然是一个单机版的高可用Redis服务。</p>\n<h2 id=\"结语\" tabindex=\"-1\"> 结语</h2>\n<p>搭建任何一个服务，做到“能用”其实是非常简单的，就像我们运行一个单机版的Redis。不过一旦要做到“高可用”，事情就会变得复杂起来。业务中使用了额外的两台服务器，3个Sentinel进程+1个Slave进程，只是为了保证在那小概率的事故中依然做到服务可用。在实际业务中我们还启用了supervisor做进程监控，一旦进程意外退出，会自动尝试重新启动。</p>\n",
      "date_published": "2018-06-11T00:00:00.000Z",
      "date_modified": "2022-04-14T05:48:05.000Z",
      "authors": [
        {
          "name": "HorstXu"
        }
      ],
      "tags": [
        "redis"
      ]
    },
    {
      "title": "redis实现分布式锁",
      "url": "http://www.zhangsj.xyz/blog/java/redis/Content%20to%20be%20added.html",
      "id": "http://www.zhangsj.xyz/blog/java/redis/Content%20to%20be%20added.html",
      "content_html": "<h3 id=\"redis-分布式锁依赖于-redis-如果-redis-宕机则锁失效。如何解决\" tabindex=\"-1\"> redis 分布式锁依赖于 redis，如果 redis 宕机则锁失效。如何解决？</h3>\n<p>可以做搭建主从集群，做数据备份。</p>\n<p>但如果搭建主从集群做数据备份时，进程 A 获取锁，master 还没有把数据备份到 slave，master 宕机，slave 升级为 master，此时原来锁失效，其它进程也可以获取锁，出现安全问题。如何解决？</p>\n<p>关于这个问题，Redis 官网给出了解决方案，使用 RedLock 思路可以解决：</p>\n<p>在 Redis 的分布式环境中，我们假设有 N 个 Redis master。</p>\n<p>这些节点完全互相独立，不存在主从复制或者其他集群协调机制。</p>\n<p>之前我们已经描述了在 Redis 单实例下怎么安全地获取和释放锁。</p>\n<p>我们确保将在每（N)个实例上使用此方法获取和释放锁。</p>\n<p>在这个样例中，我们假设有 5 个 Redis master 节点，这是一个比较合理的设置，所以我们需要在 5 台机器上面或者 5 台虚拟机上面运行这些实例，</p>\n<p>这样保证他们不会同时都宕掉。</p>\n<p>为了取到锁，客户端应该执行以下操作:</p>\n<p>1、获取当前 Unix 时间，以毫秒为单位。</p>\n<p>2、依次尝试从 N 个实例，使用相同的 key 和随机值获取锁。在步骤 2，当向 Redis 设置锁时,客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为 10 秒，则超时时间应该在 5-50 毫秒之间。这样可以避免服务器端 Redis 已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个 Redis 实例。</p>\n<p>3、客户端使用当前时间减去开始获取锁时间(步骤 1 记录的时间)就得到获取锁使用的时间。当且仅当从大多数(这里是 3 个节点)的 Redis 节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。</p>\n<p>5、如果取到了锁，key 的真正有效时间等于有效时间减去获取锁所使用的时间(步骤 3 计算的结果)。\n6、如果因为某些原因，获取锁失败（<em>没有</em>在至少 N/2+1 个 Redis 实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的 Redis 实例上进行解锁(即便某些 Redis 实例根本就没有加锁成功)。</p>\n",
      "date_published": "2022-04-13T18:37:08.000Z",
      "date_modified": "2022-04-14T05:48:05.000Z",
      "authors": [],
      "tags": [
        "分布式"
      ]
    },
    {
      "title": "redis分布式锁",
      "url": "http://www.zhangsj.xyz/blog/java/redis/redis-distributed%20lock.html",
      "id": "http://www.zhangsj.xyz/blog/java/redis/redis-distributed%20lock.html",
      "content_html": "<h3 id=\"分布式锁\" tabindex=\"-1\"> 分布式锁</h3>\n<p>Redis 中的乐观锁机制，可以帮助我们实现分布式锁的效果，用于解决分布式系统下的多线程安全问题</p>\n<CodeGroup>\n<CodeGroupItem title=\"基于Redis的分布式锁\">\n<div><pre><code><span>public</span> <span>void</span> <span>UserRegWithLock</span><span>(</span><span>UserRegDto</span> dto<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n    <span>//精心设计并构造SETNX中的key, 一定要跟实际的业务或共享资源挂钩</span>\n    <span>final</span> <span>String</span> key <span>=</span> dto<span>.</span><span>getUserName</span><span>(</span><span>)</span> <span>+</span> <span>\"-lock\"</span><span>;</span>\n    <span>//设计key对应的value应该具有随机性</span>\n    <span>final</span> <span>String</span> value <span>=</span> <span>System</span><span>.</span><span>nanoTime</span><span>(</span><span>)</span> <span>+</span> <span>\"\"</span> <span>+</span> UUID<span>.</span><span>randomUUID</span><span>(</span><span>)</span><span>;</span>\n    <span>//调用SETNX操作获取锁, 如果返回true, 代表获取锁成功</span>\n    <span>boolean</span> res <span>=</span> redisUtils<span>.</span><span>setIfAbsent</span><span>(</span>key<span>,</span> value<span>)</span><span>;</span>\n    <span>if</span> <span>(</span>res<span>)</span> <span>{</span>\n        <span>//为了防止出现死锁, 加上EXPIRE操作, 即key的过期时间, 在这里设置为20s, 实际开发是情况而定</span>\n        redisUtils<span>.</span><span>expire</span><span>(</span>key<span>,</span> <span>20L</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>)</span><span>;</span>\n        <span>try</span> <span>{</span>\n            <span>UserReg</span> userReg <span>=</span> userRegMapper<span>.</span><span>selectByUserName</span><span>(</span>dto<span>.</span><span>getUserName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>if</span> <span>(</span>userReg <span>==</span> <span>null</span><span>)</span> <span>{</span>\n                log<span>.</span><span>info</span><span>(</span><span>\"---加分布式锁---, 当前用户名为:{}\"</span><span>,</span> dto<span>.</span><span>getUserName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                <span>UserReg</span> entity <span>=</span> <span>new</span> <span>UserReg</span><span>(</span><span>)</span><span>;</span>\n                <span>BeanUtils</span><span>.</span><span>copyProperties</span><span>(</span>dto<span>,</span> entity<span>)</span><span>;</span>\n                entity<span>.</span><span>setCreateTime</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                userRegMapper<span>.</span><span>insertSelective</span><span>(</span>entity<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            <span>throw</span> e<span>;</span>\n        <span>}</span> <span>finally</span> <span>{</span>\n            <span>//不管发生任何状况, 都需要在redis加锁成功并访问操作完成共享资源后释放资源</span>\n            <span>if</span> <span>(</span>value<span>.</span><span>equals</span><span>(</span>redisUtils<span>.</span><span>get</span><span>(</span>key<span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>\n                redisUtils<span>.</span><span>del</span><span>(</span>key<span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div></CodeGroupItem>\n<CodeGroupItem title=\"不带锁\">\n<div><pre><code><span>/**\n * 处理用户提交注册\n *\n * <span>@param</span> <span>dto</span> UserRegDto(用户名, 密码)\n * <span>@throws</span> <span><span>Exception</span></span> 账户已注册\n */</span>\n<span>public</span> <span>void</span> <span>userRegNoLock</span><span>(</span><span>UserRegDto</span> dto<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n    <span>UserReg</span> userReg <span>=</span> userRegMapper<span>.</span><span>selectByUserName</span><span>(</span>dto<span>.</span><span>getUserName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>userReg <span>==</span> <span>null</span><span>)</span> <span>{</span>\n        log<span>.</span><span>info</span><span>(</span><span>\"---不加分布式锁---, 当前用户名为:{}\"</span><span>,</span> dto<span>.</span><span>getUserName</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>UserReg</span> entity <span>=</span> <span>new</span> <span>UserReg</span><span>(</span><span>)</span><span>;</span>\n        <span>BeanUtils</span><span>.</span><span>copyProperties</span><span>(</span>dto<span>,</span> entity<span>)</span><span>;</span>\n        entity<span>.</span><span>setCreateTime</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        userRegMapper<span>.</span><span>insertSelective</span><span>(</span>entity<span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n        <span>throw</span> <span>new</span> <span>Exception</span><span>(</span><span>\"用户信息已经存在\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n<h3 id=\"redisson\" tabindex=\"-1\"> Redisson</h3>\n<h4 id=\"典型应用场景之高性能点赞\" tabindex=\"-1\"> 典型应用场景之高性能点赞</h4>\n<p>一般情况下, 一个完整的点赞业务模块包含两大核心操作: 点赞和取消点赞.</p>\n<p>用户点赞文章</p>\n<ol>\n<li>校验文章，用户等基本信息</li>\n<li>校验通过，查询当前用户-当前文章的点赞记录</li>\n<li>插入当前用户-当前文档的点赞记录 返回相应结果被</li>\n</ol>\n<p>先查询当前用户是否已经点赞过了, 如果已经点赞过了, 就直接返回点赞成功; 如果没有点赞过, 当用户点赞时系统后端会记录一条该文章的点赞记录至数据库中, 并设置该记录当前的状态为1, 表示当前用户已点赞该文章.</p>\n<CodeGroup>\n<CodeGroupItem title=\"分布式锁\">\n<div><pre><code> <span>public</span> <span>void</span> <span>addPraiseLock</span><span>(</span><span>PraiseDto</span> dto<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n    <span>//定义用于获取分布式锁的Redis的key</span>\n    <span>final</span> <span>String</span> lockName <span>=</span> keyAddBlogLock <span>+</span> dto<span>.</span><span>getBlogId</span><span>(</span><span>)</span> <span>+</span> <span>\"-\"</span> <span>+</span> dto<span>.</span><span>getUserId</span><span>(</span><span>)</span><span>;</span>\n    <span>//获取一次性锁对象</span>\n    <span>RLock</span> lock <span>=</span> redissonClient<span>.</span><span>getLock</span><span>(</span>lockName<span>)</span><span>;</span>\n    <span>//上锁并在10秒钟自动释放,可用于避免Redis节点宕机时出现死锁</span>\n    lock<span>.</span><span>lock</span><span>(</span><span>10L</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>)</span><span>;</span>\n\n    <span>try</span> <span>{</span>\n        <span>Praise</span> praise <span>=</span> praiseMapper<span>.</span><span>selectByBlogUserId</span><span>(</span>dto<span>.</span><span>getBlogId</span><span>(</span><span>)</span><span>,</span> dto<span>.</span><span>getUserId</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>if</span> <span>(</span>praise <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            <span>//如果没有点赞记录, 则创建点赞实体信息</span>\n            <span>Praise</span> p <span>=</span> <span>new</span> <span>Praise</span><span>(</span><span>)</span><span>;</span>\n            <span>BeanUtils</span><span>.</span><span>copyProperties</span><span>(</span>dto<span>,</span> p<span>)</span><span>;</span>\n            <span>Date</span> date <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>;</span>\n            p<span>.</span><span>setPraiseTime</span><span>(</span>date<span>)</span><span>;</span>\n            p<span>.</span><span>setStatus</span><span>(</span><span>1</span><span>)</span><span>;</span>\n            p<span>.</span><span>setCreateTime</span><span>(</span>date<span>)</span><span>;</span>\n            p<span>.</span><span>setUpdateTime</span><span>(</span>date<span>)</span><span>;</span>\n            <span>//插入点赞记录</span>\n            <span>int</span> total <span>=</span> praiseMapper<span>.</span><span>insertSelective</span><span>(</span>p<span>)</span><span>;</span>\n            <span>if</span><span>(</span>total <span>></span> <span>0</span><span>)</span> <span>{</span>\n                <span>//如果插入成功, 则输出打印相应的信息, 并将用户点赞记录添加至缓存中</span>\n                log<span>.</span><span>info</span><span>(</span><span>\"--点赞博客,-{}-加分布式锁-插入点赞记录成功---\"</span><span>,</span>dto<span>.</span><span>getBlogId</span><span>(</span><span>)</span><span>)</span><span>;</span>\n                redisPraise<span>.</span><span>cachePraiseBlog</span><span>(</span>dto<span>.</span><span>getBlogId</span><span>(</span><span>)</span><span>,</span> dto<span>.</span><span>getUserId</span><span>(</span><span>)</span><span>,</span> <span>1</span><span>)</span><span>;</span>\n                <span>this</span><span>.</span><span>cachePraiseTotal</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n        log<span>.</span><span>error</span><span>(</span><span>\"--点赞博客,-{}-分布式锁-发生未知异常--\"</span><span>,</span>dto<span>.</span><span>getBlogId</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>throw</span> e<span>;</span>\n    <span>}</span> <span>finally</span> <span>{</span>\n        <span>if</span> <span>(</span>lock<span>.</span><span>isLocked</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>lock<span>.</span><span>isHeldByCurrentThread</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div></CodeGroupItem>\n<CodeGroupItem title=\"无分布式锁\">\n<div><pre><code> <span>@Transactional</span><span>(</span>rollbackFor <span>=</span> <span>Exception</span><span>.</span><span>class</span><span>)</span>\n<span>public</span> <span>void</span> <span>addPraise</span><span>(</span><span>PraiseDto</span> dto<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n    <span>Praise</span> praise <span>=</span> praiseMapper<span>.</span><span>selectByBlogUserId</span><span>(</span>dto<span>.</span><span>getBlogId</span><span>(</span><span>)</span><span>,</span> dto<span>.</span><span>getUserId</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>if</span> <span>(</span>praise <span>==</span> <span>null</span><span>)</span> <span>{</span>\n        <span>//如果没有点赞记录, 则创建点赞实体信息</span>\n        <span>Praise</span> p <span>=</span> <span>new</span> <span>Praise</span><span>(</span><span>)</span><span>;</span>\n        <span>BeanUtils</span><span>.</span><span>copyProperties</span><span>(</span>dto<span>,</span> p<span>)</span><span>;</span>\n        <span>Date</span> date <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>;</span>\n        p<span>.</span><span>setPraiseTime</span><span>(</span>date<span>)</span><span>;</span>\n        p<span>.</span><span>setStatus</span><span>(</span><span>1</span><span>)</span><span>;</span>\n        p<span>.</span><span>setCreateTime</span><span>(</span>date<span>)</span><span>;</span>\n        p<span>.</span><span>setUpdateTime</span><span>(</span>date<span>)</span><span>;</span>\n        <span>//插入点赞记录</span>\n        <span>int</span> total <span>=</span> praiseMapper<span>.</span><span>insertSelective</span><span>(</span>p<span>)</span><span>;</span>\n        <span>if</span><span>(</span>total <span>></span> <span>0</span><span>)</span> <span>{</span>\n            <span>//如果插入成功, 则输出打印相应的信息, 并将用户点赞记录添加至缓存中</span>\n            log<span>.</span><span>info</span><span>(</span><span>\"--点赞博客,-{}-无锁-插入点赞记录成功---\"</span><span>,</span>dto<span>.</span><span>getBlogId</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            redisPraise<span>.</span><span>cachePraiseBlog</span><span>(</span>dto<span>.</span><span>getBlogId</span><span>(</span><span>)</span><span>,</span> dto<span>.</span><span>getUserId</span><span>(</span><span>)</span><span>,</span> <span>1</span><span>)</span><span>;</span>\n            <span>this</span><span>.</span><span>cachePraiseTotal</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n</code></pre><div aria-hidden=\"true\"><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n",
      "date_published": "2022-04-13T18:37:08.000Z",
      "date_modified": "2022-04-14T05:48:05.000Z",
      "authors": [],
      "tags": [
        "redis"
      ]
    },
    {
      "title": "算法目录",
      "url": "http://www.zhangsj.xyz/blog/algo/",
      "id": "http://www.zhangsj.xyz/blog/algo/",
      "content_html": "<h2 id=\"算法目录\" tabindex=\"-1\"> 算法目录</h2>\n<ul>\n<li><a href=\"/algo/docs/algo/maximum-depth-of-a-binary-tree.html\">二叉树的最大深度</a></li>\n<li><a href=\"/algo/summary-of-eight-sorting-algorithms.html\">八种排序算法总结</a></li>\n<li><a href=\"/algo/docs/algo/algorithm-eight-queens.html\">算法-八皇后</a></li>\n<li><a href=\"/algo/linked-list-determines-that-there-is-a-cycle-recursive-inversion.html\">链表判断有环、递归反转</a></li>\n</ul>\n",
      "date_published": "2022-04-13T01:38:50.000Z",
      "date_modified": "2022-04-14T05:48:05.000Z",
      "authors": [],
      "tags": []
    }
  ]
}