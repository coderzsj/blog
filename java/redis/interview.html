<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.38" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="http://www.zhangsj.xyz/blog/java/redis/interview.html"><meta property="og:site_name" content="ShijingSpace"><meta property="og:title" content="Redis知识点汇总"><meta property="og:type" content="article"><meta property="og:image" content="http://www.zhangsj.xyz/blog/"><meta property="og:updated_time" content="2022-04-16T23:42:59.000Z"><meta property="og:locale" content="zh-CN"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image:alt" content="Redis知识点汇总"><meta property="article:tag" content="redis"><meta property="article:tag" content="分布式"><meta property="article:modified_time" content="2022-04-16T23:42:59.000Z"><link rel="stylesheet" href="//at.alicdn.com/t/font_3166858_nfzh5q0te6g.css"><title>Redis知识点汇总 | ShijingSpace</title><meta name="description" content="Java学习&&面试指南">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/blog/assets/style.49bb0069.css">
    <link rel="modulepreload" href="/blog/assets/app.9da19d67.js"><link rel="modulepreload" href="/blog/assets/interview.html.2879fe2c.js"><link rel="modulepreload" href="/blog/assets/interview.html.35e851bc.js"><link rel="modulepreload" href="/blog/assets/plugin-vue_export-helper.21dcd24c.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc sidebar-open"><!--[--><header class="navbar"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><a href="/blog/" class="home-link"><img class="logo" src="/blog/logo.svg" alt="ShijingSpace"><!----><span class="site-name hide-in-pad">ShijingSpace</span><!--[--><!----><!--]--></a><nav class="nav-links" style=""><div class="nav-item hide-in-mobile"><a href="/blog/" class="nav-link" arialabel="主页"><i class="icon iconfont icon-bloghome"></i>主页<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="java"><span class="title"><i class="icon iconfont icon-blogguide"></i>java</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/blog/java/basic" class="nav-link" arialabel="基础"><!---->基础<!----></a></li><li class="dropdown-item"><a href="/blog/java/concurrent" class="nav-link" arialabel="并发"><!---->并发<!----></a></li><li class="dropdown-item"><a href="/blog/java/datasource" class="nav-link" arialabel="数据库"><!---->数据库<!----></a></li><li class="dropdown-item"><a href="/blog/java/design-patterns" class="nav-link" arialabel="设计模式"><!---->设计模式<!----></a></li><li class="dropdown-item"><a href="/blog/java/interview.html" class="nav-link" arialabel="面经"><!---->面经<!----></a></li><li class="dropdown-item"><a href="/blog/java/jvm" class="nav-link" arialabel="JVM"><!---->JVM<!----></a></li><li class="dropdown-item"><a href="/blog/java/message-queue" class="nav-link" arialabel="消息队列"><!---->消息队列<!----></a></li><li class="dropdown-item"><a href="/blog/java/redis" class="nav-link active" arialabel="缓存"><!---->缓存<!----></a></li><li class="dropdown-item"><a href="/blog/java/soa" class="nav-link" arialabel="分布式"><!---->分布式<!----></a></li><li class="dropdown-item"><a href="/blog/java/spring" class="nav-link" arialabel="spring"><!---->spring<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="其他"><span class="title"><i class="icon iconfont icon-blogguide"></i>其他</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/blog/note" class="nav-link" arialabel="随笔"><!---->随笔<!----></a></li><li class="dropdown-item"><a href="/blog/vue" class="nav-link" arialabel="前端"><!---->前端<!----></a></li><li class="dropdown-item"><a href="/blog/tool" class="nav-link" arialabel="工具"><!---->工具<!----></a></li><li class="dropdown-item"><a href="/blog/algo" class="nav-link" arialabel="算法"><!---->算法<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="工具"><span class="title"><i class="icon iconfont icon-blogtool"></i>工具</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/blog/tool/idea-plugin.html" class="nav-link" arialabel="idea"><!---->idea<!----></a></li><li class="dropdown-item"><a href="/blog/tool/vscode-plugins-and-configuration.html" class="nav-link" arialabel="vscode"><!---->vscode<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a href="https://blog.csdn.net/qq_43183527" rel="noopener noreferrer" target="_blank" arialabel="博客" class="nav-link"><i class="icon iconfont icon-blogblog"></i>博客<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="nav-item hide-in-mobile"><a href="/blog/about" class="nav-link" arialabel="关于作者"><i class="icon iconfont icon-blogguide"></i>关于作者<!----></a></div></nav><div class="nav-actions-wrapper"><!--[--><!----><!--]--><div class="nav-item"><!----></div><div class="nav-item"><a class="repo-link" href="https://github.com/coderzsj/blog" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewbox="0 0 1024 1024" arialabelledby="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><title id="github" lang="en">github icon</title><g fill="currentColor"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></g></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" arialabelledby="auto" style="display:block;"><title id="auto" lang="en">auto icon</title><g fill="currentColor"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></g></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" arialabelledby="dark" style="display:none;"><title id="dark" lang="en">dark icon</title><g fill="currentColor"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></g></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" arialabelledby="light" style="display:none;"><title id="light" lang="en">light icon</title><g fill="currentColor"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></g></svg></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button><!--[--><!----><!--]--></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a href="/blog/java/" class="nav-link sidebar-link sidebar-page" arialabel="java"><i class="icon iconfont icon-blogmulu"></i>java<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><i class="icon iconfont icon-blogbasic"></i><span class="title">基础</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/blog/java/basic/java-exception.html" class="nav-link sidebar-link sidebar-page" arialabel="java异常"><i class="icon iconfont icon-blogexception"></i>java异常<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/basic/hashmap.html" class="nav-link sidebar-link sidebar-page" arialabel="hashMap知识点汇总"><i class="icon iconfont icon-bloghashmap"></i>hashMap知识点汇总<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/basic/still-using-SimpleDateFormat.html" class="nav-link sidebar-link sidebar-page" arialabel="仍在使用SimpleDateFormat？"><!---->仍在使用SimpleDateFormat？<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><!----><span class="title">设计模式</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/blog/java/design-patterns/let-me-tell-you-what-design-patterns-are-used-in-spring.html" class="nav-link sidebar-link sidebar-page" arialabel="spring中涉及到九种设计模式"><!---->spring中涉及到九种设计模式<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/design-patterns/singleton-design.html" class="nav-link sidebar-link sidebar-page" arialabel="Java设计模式--单例模式！"><!---->Java设计模式--单例模式！<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/design-patterns/six-principles-of-design-patterns.html" class="nav-link sidebar-link sidebar-page" arialabel="设计模式遵循的一些原则"><!---->设计模式遵循的一些原则<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading active"><i class="icon iconfont icon-blogredis"></i><span class="title">缓存</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/blog/java/redis/redis.html" class="nav-link sidebar-link sidebar-page" arialabel="Redis调优"><!---->Redis调优<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/blog/java/redis/interview.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" arialabel="Redis知识点汇总"><i class="icon iconfont icon-bloginterview"></i>Redis知识点汇总<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/redis/interview.html#为什么说redis是单线程的" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="为什么说REDIS是单线程的？?"><!---->为什么说REDIS是单线程的？?<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/redis/interview.html#缓存预热" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="缓存预热"><!---->缓存预热<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/redis/interview.html#缓存穿透" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="缓存穿透"><!---->缓存穿透<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/redis/interview.html#缓存降级" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="缓存降级"><!---->缓存降级<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/redis/interview.html#redis到底有多快" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="REDIS到底有多快？"><!---->REDIS到底有多快？<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/redis/interview.html#redis-16-个常见使用场景" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="Redis 16 个常见使用场景"><!---->Redis 16 个常见使用场景<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/redis/interview.html#redis-的集群方式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="Redis 的集群方式"><!---->Redis 的集群方式<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/redis/interview.html#redis-的常用数据类型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="Redis 的常用数据类型"><!---->Redis 的常用数据类型<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/redis/interview.html#redis-事务机制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="Redis 事务机制"><!---->Redis 事务机制<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/redis/interview.html#redis-不支持回滚" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="Redis 不支持回滚"><!---->Redis 不支持回滚<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/redis/interview.html#redis-事务" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="Redis 事务"><!---->Redis 事务<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/redis/interview.html#事务执行一半的时候-redis-宕机怎么办" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="事务执行一半的时候 Redis 宕机怎么办？"><!---->事务执行一半的时候 Redis 宕机怎么办？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/redis/interview.html#redis-的-key-过期策略" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="Redis 的 Key 过期策略"><!---->Redis 的 Key 过期策略<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/redis/interview.html#为什么需要内存回收" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="为什么需要内存回收？"><!---->为什么需要内存回收？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/redis/interview.html#过期删除策略" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="过期删除策略"><!---->过期删除策略<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/redis/interview.html#内存淘汰策略" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="内存淘汰策略"><!---->内存淘汰策略<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/redis/interview.html#maxmemory-policy-可以配置要使用哪一个淘汰机制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="maxmemory-policy 可以配置要使用哪一个淘汰机制"><!---->maxmemory-policy 可以配置要使用哪一个淘汰机制<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/redis/interview.html#redis-过期策略" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="Redis 过期策略"><!---->Redis 过期策略<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/redis/interview.html#redis-在项目使用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="Redis 在项目使用"><!---->Redis 在项目使用<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/redis/interview.html#共享-session" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="共享 session"><!---->共享 session<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/redis/interview.html#数据缓存" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="数据缓存"><!---->数据缓存<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/redis/interview.html#异步队列" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="异步队列"><!---->异步队列<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/redis/interview.html#redis-的缓存击穿、缓存雪崩、缓存穿透" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="Redis 的缓存击穿、缓存雪崩、缓存穿透"><!---->Redis 的缓存击穿、缓存雪崩、缓存穿透<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/redis/interview.html#缓存穿透-1" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="缓存穿透"><!---->缓存穿透<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/redis/interview.html#缓存击穿" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="缓存击穿"><!---->缓存击穿<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/redis/interview.html#缓存雪崩" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="缓存雪崩"><!---->缓存雪崩<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/redis/interview.html#数据库与缓存数据一致性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="数据库与缓存数据一致性"><!---->数据库与缓存数据一致性<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/redis/interview.html#redis-存储对象信息是用-hash-还是-string" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="Redis 存储对象信息是用 Hash 还是 String"><!---->Redis 存储对象信息是用 Hash 还是 String<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/redis/interview.html#hash" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="Hash"><!---->Hash<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/redis/interview.html#适合用-string-存储的情况" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="适合用 String 存储的情况："><!---->适合用 String 存储的情况：<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><i class="icon iconfont icon-blogbingfazheng"></i><span class="title">并发编程</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html" class="nav-link sidebar-link sidebar-page" arialabel="synchronized"><!---->synchronized<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/concurrent/thread-life-cycle.html" class="nav-link sidebar-link sidebar-page" arialabel="线程生命周期"><!---->线程生命周期<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/concurrent/4-reference-types.html" class="nav-link sidebar-link sidebar-page" arialabel="四种引用类型"><!---->四种引用类型<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/concurrent/aqs-source-code-reading-notes.html" class="nav-link sidebar-link sidebar-page" arialabel="AQS"><!---->AQS<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/concurrent/threadpool-code-analysis.html" class="nav-link sidebar-link sidebar-page" arialabel="线程池分析"><!---->线程池分析<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/concurrent/threadlocal.html" class="nav-link sidebar-link sidebar-page" arialabel="ThreadLocal的介绍与使用"><!---->ThreadLocal的介绍与使用<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><i class="icon iconfont icon-blogbxl-spring-boot"></i><span class="title">spring</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/blog/java/spring/spring.html" class="nav-link sidebar-link sidebar-page" arialabel="Spring MVC 运行及启动流程"><i class="icon iconfont icon-blogbxl-spring-boot"></i>Spring MVC 运行及启动流程<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/spring/springboot-startup-process.html" class="nav-link sidebar-link sidebar-page" arialabel="springboot自动装配原理"><i class="icon iconfont icon-blogzidong-02"></i>springboot自动装配原理<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/spring/spring-transaction.html" class="nav-link sidebar-link sidebar-page" arialabel="spring事务"><i class="icon iconfont icon-blogguanli"></i>spring事务<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/spring/@RequestBody&amp;ResponseBody.html" class="nav-link sidebar-link sidebar-page" arialabel="请求正文&amp;响应正文"><i class="icon iconfont icon-blogannotation"></i>请求正文&amp;响应正文<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><i class="icon iconfont icon-blogmqxiaoxiduilieMQ"></i><span class="title">消息队列</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/blog/java/message-queue/kafka.html" class="nav-link sidebar-link sidebar-page" arialabel="kafka概念，使用，架构"><!---->kafka概念，使用，架构<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/message-queue/rabbit.html" class="nav-link sidebar-link sidebar-page" arialabel="RabbitMQ知识点总结"><!---->RabbitMQ知识点总结<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><i class="icon iconfont icon-blogdatasource"></i><span class="title">数据库</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/blog/java/datasource/detailed-explanation-of-b-tree-and-b+-tree.html" class="nav-link sidebar-link sidebar-page" arialabel="b-tree和b+tree的详细解释"><i class="icon iconfont icon-blogtree"></i>b-tree和b+tree的详细解释<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/datasource/mysql-tuning.html" class="nav-link sidebar-link sidebar-page" arialabel="sql优化"><i class="icon iconfont icon-blogyouhuayunhang"></i>sql优化<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/datasource/mysql-transaction.html" class="nav-link sidebar-link sidebar-page" arialabel="MySQL事务"><i class="icon iconfont icon-blogshiwu"></i>MySQL事务<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/datasource/storage-engine.html" class="nav-link sidebar-link sidebar-page" arialabel="dataource"><!---->dataource<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/datasource/explain-execution-plan.html" class="nav-link sidebar-link sidebar-page" arialabel="explain执行计划"><!---->explain执行计划<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><i class="icon iconfont icon-blogfenbushi"></i><span class="title">分布式</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/blog/java/soa/dubbo.html" class="nav-link sidebar-link sidebar-page" arialabel="dubbo知识点总结"><i class="icon iconfont icon-blogdubbo"></i>dubbo知识点总结<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/soa/distributed-transaction.html" class="nav-link sidebar-link sidebar-page" arialabel="分布式事务"><i class="icon iconfont icon-blogfubuhi"></i>分布式事务<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/soa/distributed-id.html" class="nav-link sidebar-link sidebar-page" arialabel="分布式 id"><i class="icon iconfont icon-blogid"></i>分布式 id<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/soa/Zookeeper.html" class="nav-link sidebar-link sidebar-page" arialabel="ZooKeeper"><i class="icon iconfont icon-blogZooKeeper"></i>ZooKeeper<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/soa/spring-cloud.html" class="nav-link sidebar-link sidebar-page" arialabel="spring cloud笔记"><i class="icon iconfont icon-blogcloud"></i>spring cloud笔记<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/soa/take-you-step-by-step-to-understand-the-jwt.html" class="nav-link sidebar-link sidebar-page" arialabel="前后端分离利器之JWT"><!---->前后端分离利器之JWT<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><i class="icon iconfont icon-blogxuniji"></i><span class="title">虚拟机</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/blog/java/jvm/jvm-tuning.html" class="nav-link sidebar-link sidebar-page" arialabel="jvm调优"><i class="icon iconfont icon-blogyouhuayunhang"></i>jvm调优<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/jvm/jvm-memory-structure.html" class="nav-link sidebar-link sidebar-page" arialabel="JVM内存结构"><!---->JVM内存结构<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/jvm/jvm-garbage-collection.html" class="nav-link sidebar-link sidebar-page" arialabel="jvm-gc"><!---->jvm-gc<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/jvm/jvm-class-loading&amp;bytecode-technology.html" class="nav-link sidebar-link sidebar-page" arialabel="JVM类加载与字节码技术&amp;内存模型"><!---->JVM类加载与字节码技术&amp;内存模型<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><i class="icon iconfont icon-bloginterview"></i>Redis知识点汇总</h1><div class="article-info"><span class="author-info" arialabel="作者🖊" isoriginal="false" pageview="false" color="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" arialabelledby="author"><title id="author" lang="en">author icon</title><g fill="currentColor"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></g></svg><span><span class="author-item">shijing</span></span><span property="author" content="shijing"></span></span><!----><span class="date-info" arialabel="写作日期📅" isoriginal="false" pageview="false" color="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" arialabelledby="calendar"><title id="calendar" lang="en">calendar icon</title><g fill="currentColor"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></g></svg><span>2022年4月13日</span><meta property="datePublished" content="2022-04-13T01:38:50.000Z"></span><span class="category-info" arialabel="分类🌈" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewbox="0 0 1024 1024" arialabelledby="category"><title id="category" lang="en">category icon</title><g fill="currentColor"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></g></svg><ul class="categories-wrapper"><li class="category clickable" role="navigation">缓存</li><meta property="articleSection" content="缓存"></ul></span><span arialabel="标签🏷" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewbox="0 0 1024 1024" arialabelledby="tag"><title id="tag" lang="en">tag icon</title><g fill="currentColor"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></g></svg><ul class="tags-wrapper"><li class="tag clickable" role="navigation">redis</li><li class="tag clickable" role="navigation">分布式</li></ul><meta property="keywords" content="redis,分布式"></span><span class="reading-time-info" arialabel="阅读时间⌛" isoriginal="false" pageview="false" color="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewbox="0 0 1024 1024" arialabelledby="timer"><title id="timer" lang="en">timer icon</title><g fill="currentColor"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></g></svg><span>大约 26 分钟</span><meta property="timeRequired" content="PT26M"></span></div><hr></div><div class="toc-place-holder"><aside id="toc-list"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/redis/interview.html#为什么说redis是单线程的" class="router-link-active router-link-exact-active toc-link level2">为什么说REDIS是单线程的？?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/redis/interview.html#缓存预热" class="router-link-active router-link-exact-active toc-link level2">缓存预热</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/redis/interview.html#缓存穿透" class="router-link-active router-link-exact-active toc-link level2">缓存穿透</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/redis/interview.html#缓存降级" class="router-link-active router-link-exact-active toc-link level2">缓存降级</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/redis/interview.html#redis到底有多快" class="router-link-active router-link-exact-active toc-link level2">REDIS到底有多快？</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/redis/interview.html#redis-16-个常见使用场景" class="router-link-active router-link-exact-active toc-link level3">Redis 16 个常见使用场景</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/redis/interview.html#redis-的集群方式" class="router-link-active router-link-exact-active toc-link level2">Redis 的集群方式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/redis/interview.html#redis-的常用数据类型" class="router-link-active router-link-exact-active toc-link level2">Redis 的常用数据类型</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/redis/interview.html#redis-事务机制" class="router-link-active router-link-exact-active toc-link level2">Redis 事务机制</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/redis/interview.html#redis-不支持回滚" class="router-link-active router-link-exact-active toc-link level3">Redis 不支持回滚</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/redis/interview.html#redis-事务" class="router-link-active router-link-exact-active toc-link level2">Redis 事务</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/redis/interview.html#事务执行一半的时候-redis-宕机怎么办" class="router-link-active router-link-exact-active toc-link level2">事务执行一半的时候 Redis 宕机怎么办？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/redis/interview.html#redis-的-key-过期策略" class="router-link-active router-link-exact-active toc-link level2">Redis 的 Key 过期策略</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/redis/interview.html#为什么需要内存回收" class="router-link-active router-link-exact-active toc-link level3">为什么需要内存回收？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/redis/interview.html#过期删除策略" class="router-link-active router-link-exact-active toc-link level3">过期删除策略</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/redis/interview.html#内存淘汰策略" class="router-link-active router-link-exact-active toc-link level3">内存淘汰策略</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/redis/interview.html#maxmemory-policy-可以配置要使用哪一个淘汰机制" class="router-link-active router-link-exact-active toc-link level3">maxmemory-policy 可以配置要使用哪一个淘汰机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/redis/interview.html#redis-过期策略" class="router-link-active router-link-exact-active toc-link level3">Redis 过期策略</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/redis/interview.html#redis-在项目使用" class="router-link-active router-link-exact-active toc-link level2">Redis 在项目使用</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/redis/interview.html#共享-session" class="router-link-active router-link-exact-active toc-link level3">共享 session</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/redis/interview.html#数据缓存" class="router-link-active router-link-exact-active toc-link level3">数据缓存</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/redis/interview.html#异步队列" class="router-link-active router-link-exact-active toc-link level3">异步队列</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/redis/interview.html#redis-的缓存击穿、缓存雪崩、缓存穿透" class="router-link-active router-link-exact-active toc-link level2">Redis 的缓存击穿、缓存雪崩、缓存穿透</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/redis/interview.html#缓存穿透-1" class="router-link-active router-link-exact-active toc-link level3">缓存穿透</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/redis/interview.html#缓存击穿" class="router-link-active router-link-exact-active toc-link level3">缓存击穿</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/redis/interview.html#缓存雪崩" class="router-link-active router-link-exact-active toc-link level3">缓存雪崩</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/redis/interview.html#数据库与缓存数据一致性" class="router-link-active router-link-exact-active toc-link level2">数据库与缓存数据一致性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/redis/interview.html#redis-存储对象信息是用-hash-还是-string" class="router-link-active router-link-exact-active toc-link level2">Redis 存储对象信息是用 Hash 还是 String</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/redis/interview.html#hash" class="router-link-active router-link-exact-active toc-link level2">Hash</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/redis/interview.html#适合用-string-存储的情况" class="router-link-active router-link-exact-active toc-link level2">适合用 String 存储的情况：</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><!--[--><h2 id="为什么说redis是单线程的" tabindex="-1"><a class="header-anchor" href="#为什么说redis是单线程的" aria-hidden="true">#</a> 为什么说REDIS是单线程的？?</h2><p>近乎所有与Java相关的面试都会问到缓存的问题，基础一点的会问到什么是“二八定律”、什么是”热数据和冷数据“，复杂一点的会问到缓存雪崩、缓存穿透，缓存预热，缓存更新、缓存降级等问题，这些看似不常见的概念，都会与我们的缓存服务器相关，一般常见的缓存服务器有Redis，Memcached等，而笔者目前最常用的也只有Redis这一种。</p><p>数据库、缓存和消息中间件。</p><p>它支持多种类型的数据结构，如字符串（Strings），散列（Hash)、列表、集合、有序集合与范围查找，位图，地图空间索引半径查询。</p><p>内置了复制，LUA脚本，LRU驱动事件，事务（不同级别的磁盘持久化，并通过REDIS哨兵和自动分区提供高可用性。</p><h1 id="redis" tabindex="-1"><a class="header-anchor" href="#redis" aria-hidden="true">#</a> Redis</h1><p>缓存主要用来存放那些读写比很高、很少变化的数据。 没有热点的访问。 缓存使用的内存资源非常宝贵，只能将最新访问的数据缓存起来，而把历史数据清理出缓存。即缓存资源应该留给 20%的热点数据。 数据不一致与脏读。 一般会对缓存设置失效时间，超过失效时间，就要从数据库重新加载。因此应用要忍受一定时间的数据不一致。另一种策略是数据更新时立即更新缓存，不过这也会带来更多的系统开销和事务一致性的问题。 缓存可用性。 业务发展到一定阶段时，缓存会承担大部分数据访问的压力，数据库已经习惯了有缓存的日子，所以当缓存服务器崩溃时，数据库会因为完全不能承受如此大的压力而宕机，进而导致整个网站不可用。这种情况被称作缓存雪崩，发生这种故障，甚至不能简单地重启缓存服务器和数据库服务器来恢复网站访问。 解决方式：1、缓存热备(当某台服务器宕机时，将缓存访问切换到热备服务器上。)；2、缓存服务器集群。</p><h2 id="缓存预热" tabindex="-1"><a class="header-anchor" href="#缓存预热" aria-hidden="true">#</a> 缓存预热</h2><p>系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p><p>解决思路：</p><ol><li>直接写个缓存刷新页面，上线时手工操作下；</li><li>数据量不大，可以在项目启动的时候自动进行加载；</li><li>定时刷新缓存。</li></ol><p>缓存中存放的是热点数据，热点数据是缓存系统用 LRU 对不断访问的数据筛选出来的，这个过程需要较长的时间。新启动的缓存系统没有任何数据，此时系统的性能和数据库负载都不太好。因此可以选择在启动缓存是就把热点数据预加载好。</p><p>LRU 是 Least Recently Used 的缩写，即最近最少使用</p><h2 id="缓存穿透" tabindex="-1"><a class="header-anchor" href="#缓存穿透" aria-hidden="true">#</a> 缓存穿透</h2><p>因为不恰当的业务或恶意攻击，持续高并发地访问某一个不存在的数据，如果缓存不保存该数据，就会有大量的请求压力落在数据库上。简单的解决方式是把请求的不存在的数据也放进缓存，其 value 是 null。</p><h2 id="缓存降级" tabindex="-1"><a class="header-anchor" href="#缓存降级" aria-hidden="true">#</a> 缓存降级</h2><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p><p>降级的目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p><p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案；</p><ol><li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li><li>警告：有些服务在一段时间内成功率有波动（如在95~100%）之间），可以自动降级或人工降级，并发送告警；</li><li>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阈值，此时可以根据情况自动降级或者人工降级。</li><li>严重错误：比如因为特殊原因数据操作了，此时需要紧急人工降级。</li></ol><ul><li>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memecache 把数据全部存在内存之中。</li><li>集群模式：memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的.</li></ul><h2 id="redis到底有多快" tabindex="-1"><a class="header-anchor" href="#redis到底有多快" aria-hidden="true">#</a> REDIS到底有多快？</h2><p>REDIS采用的是基于NCP的采用的是单进程单线程模型的KV数据库，由C语言编写，官方提供的数据是可以达到100000+的QPS（每秒查询次数）。这个数据不必担进行多线程的同样基于内存的KV数据库差！</p><p>多路IO服用模型，非阻塞IO。</p><p>使用底层模型不同，它们之间底层实现方式以及客户端之间通信的应用协议不一样，</p><ul><li>Redis 使用单线程：Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</li></ul><p><img src="/blog/assets/1574821356723.3e830b1e.png" alt="1574821356723" loading="lazy"></p><ol><li>完全基于内存</li><li>数据结构简单，对数据操作也简单</li><li>使用多路 I/O 复用模型，充分利用 CPU 资源</li></ol><ul><li>代码更清晰，处理逻辑更简单</li><li>不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为锁而导致的性能消耗</li><li>不存在多进程或者多线程导致的 CPU 切换，充分利用 CPU 资源</li></ul><h3 id="redis-16-个常见使用场景" tabindex="-1"><a class="header-anchor" href="#redis-16-个常见使用场景" aria-hidden="true">#</a> Redis 16 个常见使用场景</h3><p>1、缓存 2、数据共享分布式 3、分布式锁 4、全局ID 5、计数器 6、限流 7、位统计 8、购物车 9、用户消息时间线timeline 10、消息队列 11、抽奖 12、点赞、签到、打卡 13、商品标签 14、商品筛选 15、用户关注、推荐模型 16、排行榜</p><h2 id="redis-的集群方式" tabindex="-1"><a class="header-anchor" href="#redis-的集群方式" aria-hidden="true">#</a> Redis 的集群方式</h2><p>Redis 集群可以分为<strong>主从集群</strong>和<strong>分片集群</strong>两类。</p><p><strong>主从集群</strong></p><p>一般一主多从，主库用来写数据，从库用来读数据。结合哨兵，可以再主库宕机时从新选主，<strong>目的是保证 Redis 的高可用</strong>。</p><p><strong>分片集群</strong></p><p>是数据分片，我们会让多个 Redis 节点组成集群，并将 16383 个插槽分到不同的节点上。存储数据时利用对 key 做 hash 运算，得到插槽值后存储到对应的节点即可。因为存储数据面向的是插槽而非节点本身，因此可以做到集群动态伸缩。<strong>目的是让 Redis 能存储更多数据。</strong></p><p>1）主从集群</p><p>主从集群，也是读写分离集群。一般都是一主多从方式。</p><p>Redis 的复制(replication)功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器(master)，而通过复制创建出来的服务器复制品则为从服务器(slave)。</p><p>只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步 给从服务器，从而一直保证主从服务器的数据相同。</p><ul><li>写数据时只能通过主节点完成</li><li>读数据可以从任何节点完成</li><li>如果配置了<code>哨兵节点</code>，当 master 宕机时，哨兵会从 salve 节点选出一个新的主。</li></ul><p>主从集群分两种：</p><p><img src="/blog/assets/1574821993599.26a27e53.png" alt="1574821993599" loading="lazy"> <img src="/blog/assets/1574822026037.d5d35633.png" alt="1574822026037" loading="lazy"></p><p>带有哨兵的集群：</p><p><img src="/blog/assets/1574822077190.51a95b15.png" alt="1574822077190" loading="lazy"></p><p>2）分片集群</p><p>主从集群中，每个节点都要保存所有信息，容易形成木桶效应。并且当数据量较大时，单个机器无法满足需求。此时我们就要使用分片集群了。</p><p><img src="/blog/assets/1574822184467.48e319ba.png" alt="1574822184467" loading="lazy"></p><p>集群特征：</p><ul><li><p>每个节点都保存不同数据</p></li><li><p>所有的 redis 节点彼此互联(PING-PONG 机制),内部使用二进制协议优化传输速度和带宽.</p></li><li><p>节点的 fail 是通过集群中超过半数的节点检测失效时才生效.</p></li><li><p>客户端与 redis 节点直连,不需要中间 proxy 层连接集群中任何一个可用节点都可以访问到数据</p></li><li><p>redis-cluster 把所有的物理节点映射到[0-16383]slot(插槽)上，实现动态伸缩</p></li></ul><p>为了保证 Redis 中每个节点的高可用，我们还可以给每个节点创建 replication(slave 节点)，如图：</p><p><img src="/blog/assets/1574822584357.8b0b8721.png" alt="1574822584357" loading="lazy"></p><p>出现故障时，主从可以及时切换：</p><p><img src="/blog/assets/1574822602109.5a1e734d.png" alt="1574822602109" loading="lazy"></p><h2 id="redis-的常用数据类型" tabindex="-1"><a class="header-anchor" href="#redis-的常用数据类型" aria-hidden="true">#</a> Redis 的常用数据类型</h2><p>支持多种类型的数据结构，主要区别是 value 存储的数据格式不同：</p><ul><li>string：最基本的数据类型，二进制安全的字符串，最大 512M。</li><li>list：按照添加顺序保持顺序的字符串列表。</li><li>set：无序的字符串集合，不存在重复的元素。</li><li>sorted set：已排序的字符串集合。</li><li>hash：key-value 对格式</li></ul><h2 id="redis-事务机制" tabindex="-1"><a class="header-anchor" href="#redis-事务机制" aria-hidden="true">#</a> Redis 事务机制</h2><p>Redis 事务功能是通过 MULTI、EXEC、DISCARD 和 WATCH 四个原语实现的。</p><p>Redis 会将一个事务中的所有命令序列化，然后按顺序执行。但是 Redis 事务不支持回滚操作，命令运行出错后，正确的命令会继续执行。</p><ul><li><code>MULTI</code>: 用于开启一个事务，它总是返回 OK。 MULTI 执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个<strong>待执行命令队列</strong>中</li><li><code>EXEC</code>：按顺序执行命令队列内的所有命令。返回所有命令的返回值。事务执行过程中，Redis 不会执行其它事务的命令。</li><li><code>DISCARD</code>：清空命令队列，并放弃执行事务， 并且客户端会从事务状态中退出</li><li><code>WATCH</code>：Redis 的乐观锁机制，利用 compare-and-set(CAS)原理，可以监控一个或多个键，一旦其中有一个键被修改，之后的事务就不会执行</li></ul><p>使用事务时可能会遇上以下两种错误：</p><ul><li>执行 EXEC 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误(参数数量错误，参数名错误，等等)，或者其他更严重的错误，比如内存不足（如果服务器使用 <code>maxmemory</code> 设置了最大内存限制的话）。 <ul><li>Redis 2.6.5 开始，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务。</li></ul></li><li>命令可能在 EXEC 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。 <ul><li>即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行，不会回滚。</li></ul></li></ul><h3 id="redis-不支持回滚" tabindex="-1"><a class="header-anchor" href="#redis-不支持回滚" aria-hidden="true">#</a> Redis 不支持回滚</h3><p>优点：</p><ul><li>Redis 命令只会因为错误的语法而失败(并且这些问题不能在入队时发现)，或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由<strong>编程错误</strong>造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li><li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li></ul><p>鉴于没有任何机制能避免程序员自己造成的错误， 并且这类错误通常不会在生产环境中出现， 所以 Redis 选择了更简单、更快速的无回滚方式来处理事务。</p><h2 id="redis-事务" tabindex="-1"><a class="header-anchor" href="#redis-事务" aria-hidden="true">#</a> Redis 事务</h2><p>其实是把一系列 Redis 命令放入队列，然后批量执行，执行过程中不会有其它事务来打断。不过与关系型数据库的事务不同，Redis 事务不支持回滚操作，事务中某个命令执行失败，其它命令依然会执行。</p><p>为了弥补不能回滚的问题，Redis 会在事务入队时就检查命令，如果命令异常则会放弃整个事务。</p><p>因此，只要程序员编程是正确的，理论上说 Redis 会正确执行所有事务，无需回滚。</p><h2 id="事务执行一半的时候-redis-宕机怎么办" tabindex="-1"><a class="header-anchor" href="#事务执行一半的时候-redis-宕机怎么办" aria-hidden="true">#</a> 事务执行一半的时候 Redis 宕机怎么办？</h2><p>Redis 有持久化机制，因为可靠性问题，我们一般使用 AOF 持久化。</p><p>事务的所有命令也会写入 AOF 文件，但是如果在执行 EXEC 命令之前，Redis 已经宕机，则 AOF 文件中事务不完整。使用 <code>redis-check-aof</code> 程序可以移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。</p><h2 id="redis-的-key-过期策略" tabindex="-1"><a class="header-anchor" href="#redis-的-key-过期策略" aria-hidden="true">#</a> Redis 的 Key 过期策略</h2><h3 id="为什么需要内存回收" tabindex="-1"><a class="header-anchor" href="#为什么需要内存回收" aria-hidden="true">#</a> 为什么需要内存回收？</h3><ul><li>1、在 Redis 中，set 指令可以指定 key 的过期时间，当过期时间到达以后，key 就失效了；</li><li>2、Redis 是基于内存操作的，所有的数据都是保存在内存中，一台机器的内存是有限且很宝贵的。</li></ul><p>基于以上两点，为了保证 Redis 能继续提供可靠的服务，Redis 需要一种机制清理掉不常用的、无效的、多余的数据，失效后的数据需要及时清理，这就需要内存回收了。</p><p>Redis 的内存回收主要分为过期删除策略和内存淘汰策略两部分。</p><h3 id="过期删除策略" tabindex="-1"><a class="header-anchor" href="#过期删除策略" aria-hidden="true">#</a> 过期删除策略</h3><p>删除达到过期时间的 key。</p><ul><li>1）定时删除</li></ul><p>对于每一个设置了过期时间的 key 都会创建一个定时器，一旦到达过期时间就立即删除。该策略可以立即清除过期的数据，对内存较友好，但是缺点是占用了大量的 CPU 资源去处理过期的数据，会影响 Redis 的吞吐量和响应时间。</p><ul><li>2）惰性删除</li></ul><p>当访问一个 key 时，才判断该 key 是否过期，过期则删除。该策略能最大限度地节省 CPU 资源，但是对内存却十分不友好。有一种极端的情况是可能出现大量的过期 key 没有被再次访问，因此不会被清除，导致占用了大量的内存。</p><blockquote><p>在计算机科学中，懒惰删除(英文：lazy deletion)指的是从一个散列表(也称哈希表)中删除元素的一种方法。在这个方法中，删除仅仅是指标记一个元素被删除，而不是整个清除它。被删除的位点在插入时被当作空元素，在搜索之时被当作已占据。</p></blockquote><ul><li>3）定期删除</li></ul><p>每隔一段时间，扫描 Redis 中过期 key 字典，并清除部分过期的 key。该策略是前两者的一个折中方案，还可以通过调整定时扫描的时间间隔和每次扫描的限定耗时，在不同情况下使得 CPU 和内存资源达到最优的平衡效果。</p><p>在 Redis 中，<code>同时使用了定期删除和惰性删除</code>。不过 Redis 定期删除采用的是随机抽取的方式删除部分 Key，因此不能保证过期 key 100%的删除。</p><p>Redis 结合了定期删除和惰性删除，基本上能很好的处理过期数据的清理，但是实际上还是有点问题的，如果过期 key 较多，定期删除漏掉了一部分，而且也没有及时去查，即没有走惰性删除，那么就会有大量的过期 key 堆积在内存中，导致 redis 内存耗尽，当内存耗尽之后，有新的 key 到来会发生什么事呢？是直接抛弃还是其他措施呢？有什么办法可以接受更多的 key？</p><h3 id="内存淘汰策略" tabindex="-1"><a class="header-anchor" href="#内存淘汰策略" aria-hidden="true">#</a> 内存淘汰策略</h3><p>Redis 的内存淘汰策略，是指内存达到 maxmemory 极限时，使用某种算法来决定清理掉哪些数据，以保证新数据的存入。</p><p>Redis 的内存淘汰机制包括：</p><ul><li><p>noeviction:当内存不足以容纳新写入数据时，新写入操作会报错。</p></li><li><p>allkeys-lru：当内存不足以容纳新写入数据时，在键空间（<code>server.db[i].dict</code>）中，移除最近最少使用的key(这个是最常用的)。</p></li><li><p>allkeys-random：当内存不足以容纳新写入数据时，在键空间（<code>server.db[i].dict</code>）中，随机移除某个key。</p></li><li><p>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间（<code>server.db[i].expires</code>）中，移除最近最少使用的key。</p></li><li><p>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间（<code>server.db[i].expires</code>）中，随机移除某个key。</p></li><li><p>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间（<code>server.db[i].expires</code>）中，有更早过期时间的key优先移除。</p><p>4.0 新增 lfu</p></li></ul><p>Allkey-lfu 针对所有的 key 删除最近最不常使用 volatile-lfu 针对设置过期时间的 key 删除最近最不常使用</p><h3 id="maxmemory-policy-可以配置要使用哪一个淘汰机制" tabindex="-1"><a class="header-anchor" href="#maxmemory-policy-可以配置要使用哪一个淘汰机制" aria-hidden="true">#</a> maxmemory-policy 可以配置要使用哪一个淘汰机制</h3><p>什么时候会进行淘汰？</p><p>Redis 会在每一次处理命令的时候(processCommand 函数调用 freeMemoryIfNeeded)判断当前 redis 是否达到了内存的最大限制，如果达到限制，则使用对应的算法去处理需要删除的 key。</p><p>在淘汰 key 时，Redis 默认最常用的是 LRU 算法(Latest Recently Used)。Redis 通过在每一个 redisObject 保存 lru 属性来保存 key 最近的访问时间，在实现 LRU 算法时直接读取 key 的 lru 属性。</p><p>具体实现时，Redis 遍历每一个 db，从每一个 db 中随机抽取一批样本 key，默认是 3 个 key，再从这 3 个 key 中，删除最近最少使用的 key。</p><h3 id="redis-过期策略" tabindex="-1"><a class="header-anchor" href="#redis-过期策略" aria-hidden="true">#</a> Redis 过期策略</h3><p>包含定期删除和惰性删除两部分。定期删除是在 Redis 内部有一个定时任务，会定期删除一些过期的 key。惰性删除是当用户查询某个 Key 时，会检查这个 Key 是否已经过期，如果没过期则返回用户，如果过期则删除。</p><p>但是这两个策略都无法保证过期 key 一定删除，漏网之鱼越来越多，还可能导致内存溢出。当发生内存不足问题时，Redis 还会做内存回收。内存回收采用 LRU 策略，就是最近最少使用。其原理就是记录每个 Key 的最近使用时间，内存回收时，随机抽取一些 Key，比较其使用时间，把最老的几个删除。</p><p>Redis 的逻辑是：最近使用过的，很可能再次被使用</p><h2 id="redis-在项目使用" tabindex="-1"><a class="header-anchor" href="#redis-在项目使用" aria-hidden="true">#</a> Redis 在项目使用</h2><h3 id="共享-session" tabindex="-1"><a class="header-anchor" href="#共享-session" aria-hidden="true">#</a> 共享 session</h3><p>在分布式系统下，服务会部署在不同的 tomcat，因此多个 tomcat 的 session 无法共享，以前存储在 session 中的数据无法实现共享，可以用 redis 代替 session，解决分布式系统间数据共享问题。</p><h3 id="数据缓存" tabindex="-1"><a class="header-anchor" href="#数据缓存" aria-hidden="true">#</a> 数据缓存</h3><p>Redis 采用内存存储，读写效率较高。我们可以把数据库的访问频率高的热点数据存储到 redis 中，这样用户请求时优先从 redis 中读取，减少数据库压力，提高并发能力。</p><h3 id="异步队列" tabindex="-1"><a class="header-anchor" href="#异步队列" aria-hidden="true">#</a> 异步队列</h3><p>Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis 能作为一个很好的消息队列平台来使用。而且 Redis 中还有 pub/sub 这样的专用结构，用于 1 对 N 的消息通信模式。</p><h2 id="redis-的缓存击穿、缓存雪崩、缓存穿透" tabindex="-1"><a class="header-anchor" href="#redis-的缓存击穿、缓存雪崩、缓存穿透" aria-hidden="true">#</a> Redis 的缓存击穿、缓存雪崩、缓存穿透</h2><h3 id="缓存穿透-1" tabindex="-1"><a class="header-anchor" href="#缓存穿透-1" aria-hidden="true">#</a> 缓存穿透</h3><blockquote><p>什么是缓存穿透 正常情况下，我们去查询数据都是存在。那么请求去查询一条压根儿数据库中根本就不存在的数据，也就是缓存和数据库都查询不到这条数据，但是请求每次都会打到数据库上面去。这种查询不存在数据的现象我们称为<strong>缓存穿透</strong>。</p><p>穿透带来的问题</p><p>如果有黑客会对你的系统进行攻击，拿一个不存在的 id 去查询数据，会产生大量的请求到数据库去查询。可能会导致你的数据库由于压力过大而宕掉。</p></blockquote><h4 id="解决办法" tabindex="-1"><a class="header-anchor" href="#解决办法" aria-hidden="true">#</a> 解决办法</h4><p>缓存空值：之所以会发生穿透，就是因为缓存中没有存储这些空数据的 key。从而导致每次查询都到数据库去了。那么我们就可以为这些 key 对应的值设置为 null 丢到缓存里面去。后面再出现查询这个 key 的请求的时候，直接返回 null 。这样，就不用在到数据库中去走一圈了，但是别忘了设置过期时间。</p><p>BloomFilter(布隆过滤)：将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被 这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。在缓存之前在加一层 BloomFilter ，在查询的时候先去 BloomFilter 去查询 key 是否存在，如果不存在就直接返回，存在再走查缓存 -&gt; 查 DB。</p><p>缓存穿透有两种解决方案：</p><p>其一、是把不存在的 key 设置 null 值到缓存中。</p><p>其二、使用布隆过滤器，将所有可能存在的数据哈希到一个足够大的BITMAP中，一个一定不存在的数据会被这个BITMAP拦截掉，从而避免了对底层存储系统的查询压力。</p><p>如果一个查询返回的数据为空（不管使数据存在，还是系统故障），我们仍然把这个空结果进行缓存，但他的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放在缓存，这样第二次缓存中获取就会有值了，而不会继续访问数据库。</p><p>设置 null 值可能被恶意针对，攻击者使用大量不存在的不重复 key ，那么方案一就会缓存大量不存在 key 数据。此时我们还可以对 Key 规定格式模板，然后对不存在的 key 做<strong>正则规范</strong>匹配，如果完全不符合就不用存 null 值到 redis，而是直接返回错误。</p><h3 id="缓存击穿" tabindex="-1"><a class="header-anchor" href="#缓存击穿" aria-hidden="true">#</a> 缓存击穿</h3><p>概念：key 可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。</p><p>这个时候，需要考虑一个问题：缓存被“击穿”的问题。当这个 key 在失效的瞬间，redis 查询失败，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p><p>解决方案：</p><p>使用互斥锁(mutex key)：就是在缓存失效的时候(判断拿出来的值为空)，不是立即去 load db，而是先使用 Redis 的 SETNX 去 set 一个互斥 key，当操作返回成功时，再进行 load db 的操作并回设缓存；否则，就重试整个 get 缓存的方法。SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现互斥的效果。</p><p>软过期：也就是逻辑过期，不使用 redis 提供的过期时间，而是业务层在数据中存储过期时间信息。查询时由业务程序判断是否过期，如果数据即将过期时，将缓存的时效延长，程序可以派遣一个线程去数据库中获取最新的数据，其他线程这时看到延长了的过期时间，就会继续使用旧数据，等派遣的线程获取最新数据后再更新缓存。</p><p>推荐使用互斥锁，因为软过期会有业务逻辑侵入和额外的判断。</p><p>缓存击穿主要担心的是某个 Key 过期，更新缓存时引起对数据库的突发高并发访问。</p><p>因此我们可以在更新缓存时采用互斥锁控制，只允许一个线程去更新缓存，其它线程等待并重新读取缓存。例如 Redis 的 setnx 命令就能实现互斥效果。</p><h3 id="缓存雪崩" tabindex="-1"><a class="header-anchor" href="#缓存雪崩" aria-hidden="true">#</a> 缓存雪崩</h3><p>概念：是指在某一个时间段，缓存集中过期失效。对这批数据的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰（波动）。</p><p>解决方案：</p><ul><li>数据分类分批处理：采取不同分类数据，缓存不同周期</li><li>相同分类数据：采用固定时长加随机数方式设置缓存</li><li>热点数据缓存时间长一些，冷门数据缓存时间短一些</li><li>避免 redis 节点宕机引起雪崩，搭建主从集群，保证高可用</li></ul><div class="custom-container tip"><p class="custom-container-title">总结</p><p>解决缓存雪崩问题的关键是让缓存 Key 的过期时间分散。因此我们可以把数据按照业务分类，然后设置不同过期时间。相同业务类型的 key，设置固定时长加随机数。尽可能保证每个 Key 的过期时间都不相同。</p></div><p>另外，Redis 宕机也可能导致缓存雪崩，因此我们还要搭建 Redis 主从集群及哨兵监控，保证 Redis 的高可用。</p><h2 id="数据库与缓存数据一致性" tabindex="-1"><a class="header-anchor" href="#数据库与缓存数据一致性" aria-hidden="true">#</a> 数据库与缓存数据一致性</h2><p>实现方案：</p><ul><li>本地缓存同步：当前微服务的数据库数据与缓存数据同步，可以直接在数据库修改时加入对 Redis 的修改逻辑，保证一致。</li><li>跨服务缓存同步：服务 A 调用了服务 B，并对查询结果缓存。服务 B 数据库修改，可以通过 MQ 通知服务 A，服务 A 修改 Redis 缓存数据</li><li>通用方案：使用 Canal 框架，伪装成 MySQL 的 salve 节点，监听 MySQL 的 binLog 变化，然后修改 Redis 缓存数据</li></ul><h2 id="redis-存储对象信息是用-hash-还是-string" tabindex="-1"><a class="header-anchor" href="#redis-存储对象信息是用-hash-还是-string" aria-hidden="true">#</a> Redis 存储对象信息是用 Hash 还是 String</h2><p>Redis 内部使用一个 RedisObject 对象来表示所有的 key 和 value，RedisObject 中的 type，则是代表一个 value 对象具体是何种数据类型，它包含字符串（String）、链表（List）、哈希结构（Hash）、集合（Set）、有序集合（Sorted set）。</p><p>日常工作中我们存储对象信息的时候，一般有两种做法，一种是用 Hash 存储，另一种是 String 存储。但好像并没有所谓的最佳实践，那么实际上到底用什么数据结构存储更好呢？</p><p>首先简单回顾下，Redis 的 Hash 和 String 结构。</p><p>String String 数据结构是简单的 key-value 类型，value 其实不仅是 String，也可以是数字。Redis 中的 String 可以表示很多语义：</p><p>字符串（bits）</p><p>整数</p><p>浮点数</p><p>这三种类型，Redis 会根据具体的场景完成自动转换，并且根据需要选取底层的承载方式。String 在Redis 内部存储默认就是一个字符串，被 RedisObject 所引用，当遇到 incr、decr 等操作时会转成数值型进行计算，此时 RedisObject 的 encoding 字段为int。</p><p>在存储过程中，我们可以将用户信息使用 Json 序列化成字符串，然后将序列化后的字符串存入 Redis 进行缓存。</p><p>由于 Redis 的字符串是动态字符串，可以修改，内部结构类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。如上图所示，内部为当前字符串实际分配的空间 capacity，一般高于实际字符串长度 len。</p><p>假设我们要存储的结构是：</p><div class="language-json ext-json line-numbers-mode"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;xiaowang&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;age&quot;</span><span class="token operator">:</span> <span class="token string">&quot;35&quot;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>如果此时将此用户信息的 name 改为“xiaoli”，再存到 Redis 中，Redis 是不需要重新分配空间的。而且我们在读取和存储数据的时候只需要对做 Json 序列化与反序列化，比较方便。</p><h2 id="hash" tabindex="-1"><a class="header-anchor" href="#hash" aria-hidden="true">#</a> Hash</h2><p>Hash在很多编程语言中都有着很广泛的应用，而在Redis中也是如此。在Redis中，Hash常常用来缓存一些对象信息，如用户信息、商品信息、配置信息等，因此也被称为字典（dictionary），Redis的字典使用Hashtable作为底层实现，一个Hashtable里面可以有多个哈希表节点，而每个哈希表节点保存了字典中的一个键值对。实际上，Redis数据库底层也是采用Hashtable来存储键值对的。</p><p>Redis的Hash相当于Java的HashMap，内部结构实现与HashMap一致，即数组+链表结构。只是reHash方式不一样。</p><p>前面说到String适合存储用户信息，而Hash结构也可以存储用户信息，不过是对每个字段单独存储，因此可以在查询时获取部分字段的信息，节省网络流量。不过Redis的Hash的值只能是字符串，存储上面的那个例子还好，如果存储的用户信息变为：</p><div class="language-json ext-json line-numbers-mode"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;xiaowang&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;age&quot;</span><span class="token operator">:</span> <span class="token number">25</span><span class="token punctuation">,</span>
  <span class="token property">&quot;clothes&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;shirt&quot;</span><span class="token operator">:</span> <span class="token string">&quot;gray&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;pants&quot;</span><span class="token operator">:</span> <span class="token string">&quot;read&quot;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>那么该如何存储&quot;clothes&quot;属性又变成了该用 String 还是 Hash 的问题。</p><h2 id="适合用-string-存储的情况" tabindex="-1"><a class="header-anchor" href="#适合用-string-存储的情况" aria-hidden="true">#</a> 适合用 String 存储的情况：</h2><ul><li>每次需要访问大量的字段</li><li>存储的结构具有多层嵌套的时候</li></ul><p>适合用 Hash 存储的情况：</p><ul><li>在大多数情况中只需要访问少量字段</li><li>自己始终知道哪些字段可用，防止使用 <code>mget</code> 时获取不到想要的数据</li></ul><div class="custom-container info"><p class="custom-container-title">总结</p><p>介绍了Redis 存储对象信息是用 Hash 还是 String，建议是大部分情况下使用 String 存储就好，毕竟在存储具有多层嵌套的对象时方便很多，占用的空间也比 Hash 小。当我们需要存储一个特别大的对象时，而且在大多数情况中只需要访问该对象少量的字段时，可以考虑使用 Hash。</p></div><!--]--></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/coderzsj/blog/edit/dev/docs/java/redis/interview.md" rel="noopener noreferrer" target="_blank" arialabel="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" arialabelledby="edit"><title id="edit" lang="en">edit icon</title><g fill="currentColor"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></g></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/4/17 07:42:59</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: 945892500@qq.com">SHIJINGSPACE</span><!--]--><!--]--></div></footer><nav class="page-nav"><a href="/blog/java/redis/redis.html" class="nav-link prev" arialabel="Redis调优"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><!---->Redis调优</div></a><!----></nav><!----><!----></main><!--]--><footer class="footer-wrapper"><div class="footer"><a href="https://beian.miit.gov.cn/" target="_blank">晋ICP备2021007439号</a></div><div class="copyright">Copyright © 2022 shijing</div></footer></div><!--]--><!----><!--]--></div>
    <script type="module" src="/blog/assets/app.9da19d67.js" defer></script>
  </body>
</html>
