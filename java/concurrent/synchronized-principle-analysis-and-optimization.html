<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.38" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="http://www.zhangsj.xyz/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html"><meta property="og:site_name" content="ShijingSpace"><meta property="og:title" content="synchronized"><meta property="og:type" content="article"><meta property="og:image" content="http://www.zhangsj.xyz/blog/"><meta property="og:updated_time" content="2022-05-24T07:41:09.000Z"><meta property="og:locale" content="zh-CN"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image:alt" content="synchronized"><meta property="article:tag" content="synchronized"><meta property="article:published_time" content="2022-01-28T00:00:00.000Z"><meta property="article:modified_time" content="2022-05-24T07:41:09.000Z"><link rel="stylesheet" href="//at.alicdn.com/t/font_3166858_nfzh5q0te6g.css"><title>synchronized | ShijingSpace</title><meta name="description" content="Java学习&&面试指南">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/blog/assets/style.49bb0069.css">
    <link rel="modulepreload" href="/blog/assets/app.9da19d67.js"><link rel="modulepreload" href="/blog/assets/synchronized-principle-analysis-and-optimization.html.e0970258.js"><link rel="modulepreload" href="/blog/assets/synchronized-principle-analysis-and-optimization.html.f23b3428.js"><link rel="modulepreload" href="/blog/assets/plugin-vue_export-helper.21dcd24c.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc sidebar-open"><!--[--><header class="navbar"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><a href="/blog/" class="home-link"><img class="logo" src="/blog/logo.svg" alt="ShijingSpace"><!----><span class="site-name hide-in-pad">ShijingSpace</span><!--[--><!----><!--]--></a><nav class="nav-links" style=""><div class="nav-item hide-in-mobile"><a href="/blog/" class="nav-link" arialabel="主页"><i class="icon iconfont icon-bloghome"></i>主页<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="java"><span class="title"><i class="icon iconfont icon-blogguide"></i>java</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/blog/java/basic" class="nav-link" arialabel="基础"><!---->基础<!----></a></li><li class="dropdown-item"><a href="/blog/java/concurrent" class="nav-link active" arialabel="并发"><!---->并发<!----></a></li><li class="dropdown-item"><a href="/blog/java/datasource" class="nav-link" arialabel="数据库"><!---->数据库<!----></a></li><li class="dropdown-item"><a href="/blog/java/design-patterns" class="nav-link" arialabel="设计模式"><!---->设计模式<!----></a></li><li class="dropdown-item"><a href="/blog/java/interview.html" class="nav-link" arialabel="面经"><!---->面经<!----></a></li><li class="dropdown-item"><a href="/blog/java/jvm" class="nav-link" arialabel="JVM"><!---->JVM<!----></a></li><li class="dropdown-item"><a href="/blog/java/message-queue" class="nav-link" arialabel="消息队列"><!---->消息队列<!----></a></li><li class="dropdown-item"><a href="/blog/java/redis" class="nav-link" arialabel="缓存"><!---->缓存<!----></a></li><li class="dropdown-item"><a href="/blog/java/soa" class="nav-link" arialabel="分布式"><!---->分布式<!----></a></li><li class="dropdown-item"><a href="/blog/java/spring" class="nav-link" arialabel="spring"><!---->spring<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="其他"><span class="title"><i class="icon iconfont icon-blogguide"></i>其他</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/blog/note" class="nav-link" arialabel="随笔"><!---->随笔<!----></a></li><li class="dropdown-item"><a href="/blog/vue" class="nav-link" arialabel="前端"><!---->前端<!----></a></li><li class="dropdown-item"><a href="/blog/tool" class="nav-link" arialabel="工具"><!---->工具<!----></a></li><li class="dropdown-item"><a href="/blog/algo" class="nav-link" arialabel="算法"><!---->算法<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="工具"><span class="title"><i class="icon iconfont icon-blogtool"></i>工具</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/blog/tool/idea-plugin.html" class="nav-link" arialabel="idea"><!---->idea<!----></a></li><li class="dropdown-item"><a href="/blog/tool/vscode-plugins-and-configuration.html" class="nav-link" arialabel="vscode"><!---->vscode<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a href="https://blog.csdn.net/qq_43183527" rel="noopener noreferrer" target="_blank" arialabel="博客" class="nav-link"><i class="icon iconfont icon-blogblog"></i>博客<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="nav-item hide-in-mobile"><a href="/blog/about" class="nav-link" arialabel="关于作者"><i class="icon iconfont icon-blogguide"></i>关于作者<!----></a></div></nav><div class="nav-actions-wrapper"><!--[--><!----><!--]--><div class="nav-item"><!----></div><div class="nav-item"><a class="repo-link" href="https://github.com/coderzsj/blog" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewbox="0 0 1024 1024" arialabelledby="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><title id="github" lang="en">github icon</title><g fill="currentColor"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></g></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" arialabelledby="auto" style="display:block;"><title id="auto" lang="en">auto icon</title><g fill="currentColor"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></g></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" arialabelledby="dark" style="display:none;"><title id="dark" lang="en">dark icon</title><g fill="currentColor"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></g></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" arialabelledby="light" style="display:none;"><title id="light" lang="en">light icon</title><g fill="currentColor"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></g></svg></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button><!--[--><!----><!--]--></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a href="/blog/java/" class="nav-link sidebar-link sidebar-page" arialabel="java"><i class="icon iconfont icon-blogmulu"></i>java<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><i class="icon iconfont icon-blogbasic"></i><span class="title">基础</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/blog/java/basic/java-exception.html" class="nav-link sidebar-link sidebar-page" arialabel="java异常"><i class="icon iconfont icon-blogexception"></i>java异常<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/basic/hashmap.html" class="nav-link sidebar-link sidebar-page" arialabel="hashMap知识点汇总"><i class="icon iconfont icon-bloghashmap"></i>hashMap知识点汇总<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/basic/still-using-SimpleDateFormat.html" class="nav-link sidebar-link sidebar-page" arialabel="仍在使用SimpleDateFormat？"><!---->仍在使用SimpleDateFormat？<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><!----><span class="title">设计模式</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/blog/java/design-patterns/let-me-tell-you-what-design-patterns-are-used-in-spring.html" class="nav-link sidebar-link sidebar-page" arialabel="spring中涉及到九种设计模式"><!---->spring中涉及到九种设计模式<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/design-patterns/singleton-design.html" class="nav-link sidebar-link sidebar-page" arialabel="Java设计模式--单例模式！"><!---->Java设计模式--单例模式！<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/design-patterns/six-principles-of-design-patterns.html" class="nav-link sidebar-link sidebar-page" arialabel="设计模式遵循的一些原则"><!---->设计模式遵循的一些原则<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><i class="icon iconfont icon-blogredis"></i><span class="title">缓存</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/blog/java/redis/redis.html" class="nav-link sidebar-link sidebar-page" arialabel="Redis调优"><!---->Redis调优<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/redis/interview.html" class="nav-link sidebar-link sidebar-page" arialabel="Redis知识点汇总"><i class="icon iconfont icon-bloginterview"></i>Redis知识点汇总<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading active"><i class="icon iconfont icon-blogbingfazheng"></i><span class="title">并发编程</span><!----></p><ul class="sidebar-links"><li><!--[--><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" arialabel="synchronized"><!---->synchronized<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#可见性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="可见性"><!---->可见性<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#原子性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="原子性"><!---->原子性<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#有序性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="有序性"><!---->有序性<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#二、java-内存模型-jmm" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="二、Java 内存模型(JMM)"><!---->二、Java 内存模型(JMM)<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#cpu-缓存-内存与-jmm的关系" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="CPU 缓存，内存与 JMM的关系"><!---->CPU 缓存，内存与 JMM的关系<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#主内存与工作内存之间的交互" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="主内存与工作内存之间的交互"><!---->主内存与工作内存之间的交互<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#三、synchronized-保证三大特性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="三、synchronized 保证三大特性"><!---->三、synchronized 保证三大特性<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#synchronized与原子性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="synchronized与原子性"><!---->synchronized与原子性<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#保证原子性的原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="保证原子性的原理"><!---->保证原子性的原理<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#synchronized-与可见性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="synchronized 与可见性"><!---->synchronized 与可见性<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#synchronized-与有序性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="synchronized 与有序性"><!---->synchronized 与有序性<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#可重入特性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="可重入特性"><!---->可重入特性<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#不可中断特性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="不可中断特性"><!---->不可中断特性<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#monitorenter" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="monitorenter"><!---->monitorenter<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#monitorexit" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="monitorexit"><!---->monitorexit<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#同步方法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="同步方法"><!---->同步方法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#问题-synchronized-与-lock-的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="问题：synchronized 与 Lock 的区别"><!---->问题：synchronized 与 Lock 的区别<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#深入jvm源码分析synchronized的原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="深入JVM源码分析synchronized的原理"><!---->深入JVM源码分析synchronized的原理<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#monitor-监视器锁" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="monitor 监视器锁"><!---->monitor 监视器锁<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#monitor-竞争" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="monitor 竞争"><!---->monitor 竞争<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#monitor-等待" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="monitor 等待"><!---->monitor 等待<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#monitor-释放" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="monitor 释放"><!---->monitor 释放<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#monitor是重量级锁" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="monitor是重量级锁"><!---->monitor是重量级锁<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#六、jdk6-synchronized优化" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="六、JDK6 synchronized优化"><!---->六、JDK6 synchronized优化<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#cas和volatile实现无锁并发" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="CAS和volatile实现无锁并发"><!---->CAS和volatile实现无锁并发<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#cas原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="CAS原理"><!---->CAS原理<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#synchronized-锁升级过程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="synchronized 锁升级过程"><!---->synchronized 锁升级过程<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#java对象的布局" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="Java对象的布局"><!---->Java对象的布局<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#对象头" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="对象头"><!---->对象头<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#mark-word" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="Mark Word"><!---->Mark Word<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#klass-pointer" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="klass pointer"><!---->klass pointer<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#查看-java-对象布局" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="查看 Java 对象布局"><!---->查看 Java 对象布局<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#什么是偏向锁" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="什么是偏向锁"><!---->什么是偏向锁<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#偏向锁原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="偏向锁原理"><!---->偏向锁原理<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#偏向锁的撤销" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="偏向锁的撤销"><!---->偏向锁的撤销<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#偏向锁好处" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="偏向锁好处"><!---->偏向锁好处<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#什么是轻量级锁" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="什么是轻量级锁"><!---->什么是轻量级锁<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#轻量级锁原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="轻量级锁原理"><!---->轻量级锁原理<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#轻量级锁的释放" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="轻量级锁的释放"><!---->轻量级锁的释放<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#轻量级锁好处" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="轻量级锁好处"><!---->轻量级锁好处<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#自旋锁" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="自旋锁"><!---->自旋锁<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#适应性自旋锁" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="适应性自旋锁"><!---->适应性自旋锁<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#锁消除" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="锁消除"><!---->锁消除<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#锁粗化" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="锁粗化"><!---->锁粗化<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#平时写代码如何对-synchronized-优化" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="平时写代码如何对 synchronized 优化"><!---->平时写代码如何对 synchronized 优化<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#读写分离" class="router-link-active router-link-exact-active nav-link sidebar-link heading" arialabel="读写分离"><!---->读写分离<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li><li><!--[--><a href="/blog/java/concurrent/thread-life-cycle.html" class="nav-link sidebar-link sidebar-page" arialabel="线程生命周期"><!---->线程生命周期<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/concurrent/4-reference-types.html" class="nav-link sidebar-link sidebar-page" arialabel="四种引用类型"><!---->四种引用类型<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/concurrent/aqs-source-code-reading-notes.html" class="nav-link sidebar-link sidebar-page" arialabel="AQS"><!---->AQS<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/concurrent/threadpool-code-analysis.html" class="nav-link sidebar-link sidebar-page" arialabel="线程池分析"><!---->线程池分析<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/concurrent/threadlocal.html" class="nav-link sidebar-link sidebar-page" arialabel="ThreadLocal的介绍与使用"><!---->ThreadLocal的介绍与使用<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><i class="icon iconfont icon-blogbxl-spring-boot"></i><span class="title">spring</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/blog/java/spring/spring.html" class="nav-link sidebar-link sidebar-page" arialabel="Spring MVC 运行及启动流程"><i class="icon iconfont icon-blogbxl-spring-boot"></i>Spring MVC 运行及启动流程<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/spring/springboot-startup-process.html" class="nav-link sidebar-link sidebar-page" arialabel="springboot自动装配原理"><i class="icon iconfont icon-blogzidong-02"></i>springboot自动装配原理<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/spring/spring-transaction.html" class="nav-link sidebar-link sidebar-page" arialabel="spring事务"><i class="icon iconfont icon-blogguanli"></i>spring事务<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/spring/@RequestBody&amp;ResponseBody.html" class="nav-link sidebar-link sidebar-page" arialabel="请求正文&amp;响应正文"><i class="icon iconfont icon-blogannotation"></i>请求正文&amp;响应正文<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><i class="icon iconfont icon-blogmqxiaoxiduilieMQ"></i><span class="title">消息队列</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/blog/java/message-queue/kafka.html" class="nav-link sidebar-link sidebar-page" arialabel="kafka概念，使用，架构"><!---->kafka概念，使用，架构<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/message-queue/rabbit.html" class="nav-link sidebar-link sidebar-page" arialabel="RabbitMQ知识点总结"><!---->RabbitMQ知识点总结<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><i class="icon iconfont icon-blogdatasource"></i><span class="title">数据库</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/blog/java/datasource/detailed-explanation-of-b-tree-and-b+-tree.html" class="nav-link sidebar-link sidebar-page" arialabel="b-tree和b+tree的详细解释"><i class="icon iconfont icon-blogtree"></i>b-tree和b+tree的详细解释<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/datasource/mysql-tuning.html" class="nav-link sidebar-link sidebar-page" arialabel="sql优化"><i class="icon iconfont icon-blogyouhuayunhang"></i>sql优化<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/datasource/mysql-transaction.html" class="nav-link sidebar-link sidebar-page" arialabel="MySQL事务"><i class="icon iconfont icon-blogshiwu"></i>MySQL事务<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/datasource/storage-engine.html" class="nav-link sidebar-link sidebar-page" arialabel="dataource"><!---->dataource<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/datasource/explain-execution-plan.html" class="nav-link sidebar-link sidebar-page" arialabel="explain执行计划"><!---->explain执行计划<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><i class="icon iconfont icon-blogfenbushi"></i><span class="title">分布式</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/blog/java/soa/dubbo.html" class="nav-link sidebar-link sidebar-page" arialabel="dubbo知识点总结"><i class="icon iconfont icon-blogdubbo"></i>dubbo知识点总结<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/soa/distributed-transaction.html" class="nav-link sidebar-link sidebar-page" arialabel="分布式事务"><i class="icon iconfont icon-blogfubuhi"></i>分布式事务<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/soa/distributed-id.html" class="nav-link sidebar-link sidebar-page" arialabel="分布式 id"><i class="icon iconfont icon-blogid"></i>分布式 id<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/soa/Zookeeper.html" class="nav-link sidebar-link sidebar-page" arialabel="ZooKeeper"><i class="icon iconfont icon-blogZooKeeper"></i>ZooKeeper<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/soa/spring-cloud.html" class="nav-link sidebar-link sidebar-page" arialabel="spring cloud笔记"><i class="icon iconfont icon-blogcloud"></i>spring cloud笔记<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/soa/take-you-step-by-step-to-understand-the-jwt.html" class="nav-link sidebar-link sidebar-page" arialabel="前后端分离利器之JWT"><!---->前后端分离利器之JWT<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><p class="sidebar-heading"><i class="icon iconfont icon-blogxuniji"></i><span class="title">虚拟机</span><!----></p><ul class="sidebar-links"><li><!--[--><a href="/blog/java/jvm/jvm-tuning.html" class="nav-link sidebar-link sidebar-page" arialabel="jvm调优"><i class="icon iconfont icon-blogyouhuayunhang"></i>jvm调优<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/jvm/jvm-memory-structure.html" class="nav-link sidebar-link sidebar-page" arialabel="JVM内存结构"><!---->JVM内存结构<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/jvm/jvm-garbage-collection.html" class="nav-link sidebar-link sidebar-page" arialabel="jvm-gc"><!---->jvm-gc<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/java/jvm/jvm-class-loading&amp;bytecode-technology.html" class="nav-link sidebar-link sidebar-page" arialabel="JVM类加载与字节码技术&amp;内存模型"><!---->JVM类加载与字节码技术&amp;内存模型<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->synchronized</h1><div class="article-info"><span class="author-info" arialabel="作者🖊" isoriginal="false" pageview="false" color="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" arialabelledby="author"><title id="author" lang="en">author icon</title><g fill="currentColor"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></g></svg><span><span class="author-item">shijing</span></span><span property="author" content="shijing"></span></span><!----><span class="date-info" arialabel="写作日期📅" isoriginal="false" pageview="false" color="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" arialabelledby="calendar"><title id="calendar" lang="en">calendar icon</title><g fill="currentColor"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></g></svg><span>2022年1月28日</span><meta property="datePublished" content="2022-01-28T00:00:00.000Z"></span><span class="category-info" arialabel="分类🌈" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewbox="0 0 1024 1024" arialabelledby="category"><title id="category" lang="en">category icon</title><g fill="currentColor"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></g></svg><ul class="categories-wrapper"><li class="category clickable" role="navigation">锁机制</li><meta property="articleSection" content="锁机制"></ul></span><span arialabel="标签🏷" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewbox="0 0 1024 1024" arialabelledby="tag"><title id="tag" lang="en">tag icon</title><g fill="currentColor"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></g></svg><ul class="tags-wrapper"><li class="tag clickable" role="navigation">synchronized</li></ul><meta property="keywords" content="synchronized"></span><span class="reading-time-info" arialabel="阅读时间⌛" isoriginal="false" pageview="false" color="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewbox="0 0 1024 1024" arialabelledby="timer"><title id="timer" lang="en">timer icon</title><g fill="currentColor"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></g></svg><span>大约 39 分钟</span><meta property="timeRequired" content="PT39M"></span></div><hr></div><div class="toc-place-holder"><aside id="toc-list"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#可见性" class="router-link-active router-link-exact-active toc-link level2">可见性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#原子性" class="router-link-active router-link-exact-active toc-link level2">原子性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#有序性" class="router-link-active router-link-exact-active toc-link level2">有序性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#二、java-内存模型-jmm" class="router-link-active router-link-exact-active toc-link level2">二、Java 内存模型(JMM)</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#cpu-缓存-内存与-jmm的关系" class="router-link-active router-link-exact-active toc-link level3">CPU 缓存，内存与 JMM的关系</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#主内存与工作内存之间的交互" class="router-link-active router-link-exact-active toc-link level3">主内存与工作内存之间的交互</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#三、synchronized-保证三大特性" class="router-link-active router-link-exact-active toc-link level2">三、synchronized 保证三大特性</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#synchronized与原子性" class="router-link-active router-link-exact-active toc-link level3">synchronized与原子性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#保证原子性的原理" class="router-link-active router-link-exact-active toc-link level3">保证原子性的原理</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#synchronized-与可见性" class="router-link-active router-link-exact-active toc-link level2">synchronized 与可见性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#synchronized-与有序性" class="router-link-active router-link-exact-active toc-link level2">synchronized 与有序性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#可重入特性" class="router-link-active router-link-exact-active toc-link level2">可重入特性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#不可中断特性" class="router-link-active router-link-exact-active toc-link level2">不可中断特性</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#monitorenter" class="router-link-active router-link-exact-active toc-link level3">monitorenter</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#monitorexit" class="router-link-active router-link-exact-active toc-link level3">monitorexit</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#同步方法" class="router-link-active router-link-exact-active toc-link level3">同步方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#问题-synchronized-与-lock-的区别" class="router-link-active router-link-exact-active toc-link level3">问题：synchronized 与 Lock 的区别</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#深入jvm源码分析synchronized的原理" class="router-link-active router-link-exact-active toc-link level2">深入JVM源码分析synchronized的原理</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#monitor-监视器锁" class="router-link-active router-link-exact-active toc-link level3">monitor 监视器锁</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#monitor-竞争" class="router-link-active router-link-exact-active toc-link level3">monitor 竞争</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#monitor-等待" class="router-link-active router-link-exact-active toc-link level3">monitor 等待</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#monitor-释放" class="router-link-active router-link-exact-active toc-link level3">monitor 释放</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#monitor是重量级锁" class="router-link-active router-link-exact-active toc-link level3">monitor是重量级锁</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#六、jdk6-synchronized优化" class="router-link-active router-link-exact-active toc-link level2">六、JDK6 synchronized优化</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#cas和volatile实现无锁并发" class="router-link-active router-link-exact-active toc-link level3">CAS和volatile实现无锁并发</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#cas原理" class="router-link-active router-link-exact-active toc-link level3">CAS原理</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#synchronized-锁升级过程" class="router-link-active router-link-exact-active toc-link level2">synchronized 锁升级过程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#java对象的布局" class="router-link-active router-link-exact-active toc-link level2">Java对象的布局</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#对象头" class="router-link-active router-link-exact-active toc-link level3">对象头</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#mark-word" class="router-link-active router-link-exact-active toc-link level3">Mark Word</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#klass-pointer" class="router-link-active router-link-exact-active toc-link level3">klass pointer</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#查看-java-对象布局" class="router-link-active router-link-exact-active toc-link level3">查看 Java 对象布局</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#什么是偏向锁" class="router-link-active router-link-exact-active toc-link level3">什么是偏向锁</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#偏向锁原理" class="router-link-active router-link-exact-active toc-link level3">偏向锁原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#偏向锁的撤销" class="router-link-active router-link-exact-active toc-link level3">偏向锁的撤销</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#偏向锁好处" class="router-link-active router-link-exact-active toc-link level3">偏向锁好处</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#什么是轻量级锁" class="router-link-active router-link-exact-active toc-link level3">什么是轻量级锁</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#轻量级锁原理" class="router-link-active router-link-exact-active toc-link level3">轻量级锁原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#轻量级锁的释放" class="router-link-active router-link-exact-active toc-link level3">轻量级锁的释放</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#轻量级锁好处" class="router-link-active router-link-exact-active toc-link level3">轻量级锁好处</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#自旋锁" class="router-link-active router-link-exact-active toc-link level2">自旋锁</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#适应性自旋锁" class="router-link-active router-link-exact-active toc-link level3">适应性自旋锁</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#锁消除" class="router-link-active router-link-exact-active toc-link level2">锁消除</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#锁粗化" class="router-link-active router-link-exact-active toc-link level2">锁粗化</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#平时写代码如何对-synchronized-优化" class="router-link-active router-link-exact-active toc-link level2">平时写代码如何对 synchronized 优化</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/blog/java/concurrent/synchronized-principle-analysis-and-optimization.html#读写分离" class="router-link-active router-link-exact-active toc-link level3">读写分离</a></li><!----><!--]--></ul><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><!--[--><h2 id="可见性" tabindex="-1"><a class="header-anchor" href="#可见性" aria-hidden="true">#</a> 可见性</h2><p>可见性是指一个线程对共享变量进行修改，另一个线程先立即获取到修改后的最新值。</p><p>并发编程时，会出现可见性问题，当一个线程对共享变量进行了修改，另外的线程并没有立即看到修改 后的最新值。Synchronized和volatile可解决</p><h2 id="原子性" tabindex="-1"><a class="header-anchor" href="#原子性" aria-hidden="true">#</a> 原子性</h2><p>在一次或多次操作中，要么所有的操作都执行并且不会受其他因素干扰而中断，要么所有的操作都不执行。</p><p>并发编程时，会出现原子性问题，当一个线程对共享变量操作到一半时，另外的线程也有可能来操作共享变量，干扰了前一个线程的操作。</p><p>代码演示：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token doc-comment comment">/**
 案例演示:5个线程各执行1000次 i++;
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test02Atomicity</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token class-name">Runnable</span> increment <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                number<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Thread</span><span class="token punctuation">&gt;</span></span> ts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>increment<span class="token punctuation">)</span><span class="token punctuation">;</span>
            t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            ts<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span> t <span class="token operator">:</span> ts<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;number = &quot;</span> <span class="token operator">+</span> number<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>使用 javap 反汇编 class 文件，得到下面的字节码指令：</p><p>其中，对于 number++ 而言(<code>number</code>为静态变量)，实际会产生如下的JVM字节码指令：由此可见 number++是由多条语句组成，以上多条指令在一个线程的情况下是不会出问题的，但是在多 线程情况下就可能会出现问题。比如一个线程在执行 13: iadd 时，另一个线程又执行 9: getstatic。会导 致两次 number++，实际上只加了 1。</p><p><img src="/blog/assets/1-2-1.2021b711.png" alt="字节码指令" loading="lazy"></p><h2 id="有序性" tabindex="-1"><a class="header-anchor" href="#有序性" aria-hidden="true">#</a> 有序性</h2><p>有序性：是指程序中代码的执行顺序，Java在编译时和运行时会对代码进行优化，会导致程序最终的执行顺序不一定就是我们编写代码时的顺序。</p><p>程序代码在执行过程中的先后顺序，由于 Java 在编译期以及运行期的优化，导致了代码的执行顺序未必就是开发者编写代码时的顺序。</p><p><a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress" target="_blank" rel="noopener noreferrer">Jcstress<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>是java并发压测工具。修改pom文件，添加依赖：</p><p>导入依赖</p><div class="language-xml ext-xml line-numbers-mode"><pre class="language-xml"><code>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.openjdk.jcstress<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jcstress-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${jcstress.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>代码演示</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jcstress<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jcstress<span class="token punctuation">.</span>infra<span class="token punctuation">.</span>results<span class="token punctuation">.</span></span><span class="token class-name">I_Result</span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@JCStressTest</span>
<span class="token annotation punctuation">@Outcome</span><span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;4&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> expect <span class="token operator">=</span> <span class="token class-name">Expect</span><span class="token punctuation">.</span>ACCEPTABLE<span class="token punctuation">,</span> desc <span class="token operator">=</span> <span class="token string">&quot;ok&quot;</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Outcome</span><span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token string">&quot;0&quot;</span><span class="token punctuation">,</span> expect <span class="token operator">=</span> <span class="token class-name">Expect</span><span class="token punctuation">.</span>ACCEPTABLE_INTERESTING<span class="token punctuation">,</span> desc <span class="token operator">=</span> <span class="token string">&quot;danger&quot;</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@State</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test03Orderliness</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> ready <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment">// 线程一执行的代码</span>
    <span class="token annotation punctuation">@Actor</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actor1</span><span class="token punctuation">(</span><span class="token class-name">I_Result</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ready<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            r<span class="token punctuation">.</span>r1 <span class="token operator">=</span> num <span class="token operator">+</span> num<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            r<span class="token punctuation">.</span>r1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 线程2执行的代码</span>
    <span class="token annotation punctuation">@Actor</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actor2</span><span class="token punctuation">(</span><span class="token class-name">I_Result</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        num <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        ready <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>I_Result 是一个对象，有一个属性r1用来保存结果，在多线程情况下可能出现几种结果？</p><ul><li>情况 1：线程1先执行 actor1，这时 ready = false，所以进入 else 分支结果为 1。</li><li>情况 2：线程2执行到actor2，执行了 num = 2;和 ready = true，线程 1 执行，这回进入 if 分支，结果为 4。</li><li>情况 3：线程2先执行actor2，只执行num=2；但没来得及执行 ready = true，线程 1 执行，还是进入Else分支，结果为1。</li><li>还有一种结果 0。</li></ul><h2 id="二、java-内存模型-jmm" tabindex="-1"><a class="header-anchor" href="#二、java-内存模型-jmm" aria-hidden="true">#</a> 二、Java 内存模型(JMM)</h2><p>关于“Java 内存模型”的权威解释，请<a href="https://download.oracle.com/otn-pub/jcp/memory_model1.0-pfd-spec-oth-JSpec/memory_model-1_0-pfd-spec.PDF" target="_blank" rel="noopener noreferrer">参考<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>；</p><p><img src="/blog/assets/2-2-1.1f17c327.png" alt="内存模型" loading="lazy"></p><p>Java内存模型，是Java虚拟机规范中所定义的一种内存模型，Java内存模型是标准化的，屏蔽掉了底层不同计算机的区别。</p><p>Java 内存模型是一套规范，描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节，具体如下。</p><ul><li>主内存 主内存是所有线程都共享的，都能访问的。所有的共享变量都存储于主内存。</li><li>工作内存 每一个线程有自己的工作内存，工作内存只存储该线程对共享变量的副本。线程对变量的所有的操 作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量，不同线程之间也不能直接 访问对方工作内存中的变量。</li></ul><p>Java内存模型是一套在多线程读写共享数据时，对共享数据的可见性、有序性、和原子性的规则和保障。Synchronized,volatile</p><h3 id="cpu-缓存-内存与-jmm的关系" tabindex="-1"><a class="header-anchor" href="#cpu-缓存-内存与-jmm的关系" aria-hidden="true">#</a> CPU 缓存，内存与 JMM的关系</h3><p>通过对前面的CPU硬件内存架构、Java内存模型以及Java多线程的实现原理的了解，我们应该已经意识到，多线程的执行最终都会映射到硬件处理器上进行执行。</p><p>但 Java 内存模型和硬件内存架构并不完全一致。</p><p>对于硬件内存来说只有寄存器、缓存内存、主内存的概念，并没有工作内存和主内存之分，也就是说Java内存模型对内存的划分对硬件内存并没有任何影响，因为JMM只是一种抽象的概念，是一组规则，不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中，当然也有可能存储到CPU缓存或者寄存器中，因此总体上来说，Java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉。</p><p>JMM内存模型与CPU硬件内存架构的关系：</p><p><img src="/blog/assets/2-2-2.35cca066.png" alt="JMM内存模型与CPU硬件内存架构的关系" loading="lazy"></p><div class="custom-container tip"><p class="custom-container-title">总结</p><p>Java 内存模型是一套规范，描述了 Java 程序中各种变量(线程共享变量)的访问规则，以及在 JVM 中将变量 存储到内存和从内存中读取变量这样的底层细节，Java 内存模型是对共享数据的可见性、有序性、和原 子性的规则和保障。</p></div><h3 id="主内存与工作内存之间的交互" tabindex="-1"><a class="header-anchor" href="#主内存与工作内存之间的交互" aria-hidden="true">#</a> 主内存与工作内存之间的交互</h3><p><img src="/blog/assets/2-3-1.30f7e39d.png" alt="主内存与工作内存之间的数据交互" loading="lazy"></p><p>Java内存模型中定义了以下 8 种操作来完成，主内存与工作内存之间具体的交互协议，即一个变量如何 从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，虚拟机实现时必须保证下面 提及的每一种操作都是原子的、不可再分的。</p><p>对应如下的流程图：</p><p><img src="/blog/assets/2-3-2.8a9add90.png" alt="流程图" loading="lazy"></p><ol><li>如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值</li><li>对一个变量执行 unlock 操作之前，必须先把此变量同步到主内存中</li></ol><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>lock -&gt; read -&gt; load -&gt; use -&gt; assign -&gt; store -&gt; write -&gt; unlock
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="三、synchronized-保证三大特性" tabindex="-1"><a class="header-anchor" href="#三、synchronized-保证三大特性" aria-hidden="true">#</a> 三、synchronized 保证三大特性</h2><p>Synchronized能够保证在同一时刻最多只有一个线程执行synchronize修饰的代码，以达到保证并发安全的效果。</p><h3 id="synchronized与原子性" tabindex="-1"><a class="header-anchor" href="#synchronized与原子性" aria-hidden="true">#</a> synchronized与原子性</h3><p>案例演示: 5个线程各执行1000次i++;</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test01Atomicity</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token class-name">Runnable</span> increment <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Test01Atomicity</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        number<span class="token operator">++</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Thread</span><span class="token punctuation">&gt;</span></span> ts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">50</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>increment<span class="token punctuation">)</span><span class="token punctuation">;</span>
            t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            ts<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span> t <span class="token operator">:</span> ts<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;number = &quot;</span> <span class="token operator">+</span> number<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><h3 id="保证原子性的原理" tabindex="-1"><a class="header-anchor" href="#保证原子性的原理" aria-hidden="true">#</a> 保证原子性的原理</h3><p>对<code>number++;</code>增加同步代码块后，保证同一时间只有一个线程操作 number++;。就不会出现安全问题。</p><p>Synchronized 保证原子性的原理，synchronized 保证只有一个线程拿到锁，能够进入同步代码块。</p><h2 id="synchronized-与可见性" tabindex="-1"><a class="header-anchor" href="#synchronized-与可见性" aria-hidden="true">#</a> synchronized 与可见性</h2><p>一个线程根据boolean类型的标记flag，while循环，另一个线程改变这个flag变量的值，另一个线程并不会停止循环。</p><p>Synchronized保证可见性的原理，执行synchronized时，会对应lock原子操作会刷新工作内存中共享变量的值</p><p>代码：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test01Visibility</span> <span class="token punctuation">{</span>
    <span class="token comment">// 多个线程都会访问的数据，我们称为线程的共享数据</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> run <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>run<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 增加对象共享数据的打印，println是同步方法</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;run = &quot;</span> <span class="token operator">+</span> run<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            run <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;时间到，线程2设置为false&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p><img src="/blog/assets/synchronized-principle-analysis-and-optimization-1649899273782.9bd9b4d1.png" alt="synchronize可见性" loading="lazy"></p><h2 id="synchronized-与有序性" tabindex="-1"><a class="header-anchor" href="#synchronized-与有序性" aria-hidden="true">#</a> synchronized 与有序性</h2><p>为了提高程序的执行效率，编译器和 CPU 会对程序中代码进行重排序。</p><p>As-if-serial语义的意思是：不管编译器和CPU如何重排序，必须保证在单线程情况下程序的结果是正确的。</p><p>以下数据有依赖关系，不能重排序。</p><ul><li>写后读：<code>int a = 1; int b = a;</code></li><li>写后写：<code>int a = 1; int a = 2;</code></li><li>读后写：<code>int a = 1; int b = a; int a = 2;</code></li></ul><p>编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如 果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。</p><p><code>int a = 1; int b = 2; int c = a + b;</code></p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@JCStressTest</span>
<span class="token annotation punctuation">@Outcome</span><span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;4&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span>expect <span class="token operator">=</span> <span class="token class-name">Expect</span><span class="token punctuation">.</span>ACCEPTABLE<span class="token punctuation">,</span>desc <span class="token operator">=</span> <span class="token string">&quot;ok&quot;</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Outcome</span><span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token string">&quot;0&quot;</span><span class="token punctuation">,</span>expect <span class="token operator">=</span> <span class="token class-name">Expect</span><span class="token punctuation">.</span>ACCEPTABLE_INTERESTING<span class="token punctuation">,</span>desc <span class="token operator">=</span> <span class="token string">&quot;danger&quot;</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@State</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test03Ordering</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> ready <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token comment">// 线程一执行的代码</span>
    <span class="token annotation punctuation">@Actor</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actor1</span><span class="token punctuation">(</span><span class="token class-name">I_Result</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ready<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            r<span class="token punctuation">.</span>r1 <span class="token operator">=</span> num <span class="token operator">+</span> num<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            r<span class="token punctuation">.</span>r1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 线程2执行的代码</span>
    <span class="token annotation punctuation">@Actor</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actor2</span><span class="token punctuation">(</span><span class="token class-name">I_Result</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        num <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        ready <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>Synchronized后，虽然进行了重排序，保证只有一个线程会进入同步代码块，也能保证有序性。</p><div class="custom-container tip"><p class="custom-container-title">总结</p><p>Synchronized 保证有序性的原理，我们加 synchronized 后，依然会发生重排序，只不过，我们有同步 代码块，可以保证只有一个线程执行同步代码中的代码。保证有序性。</p></div><h2 id="可重入特性" tabindex="-1"><a class="header-anchor" href="#可重入特性" aria-hidden="true">#</a> 可重入特性</h2><p>一个线程可以多次执行synchronized,重复获取同一把锁。</p><p>可重入特性指的是同一个线程获得锁之后，可以直接再次获取该锁。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Runnable</span> sellTicket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;我是run&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;我是test01&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>sellTicket<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>sellTicket<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>可重入的好处：一、可以避免死锁；二、可以让我们更好的来封装代码。</p><p>可重入原理：Synchronized的锁对象中有一个计数器(<code>recursions变量</code>)会记录线程获得几次锁.</p><div class="custom-container tip"><p class="custom-container-title">总结</p><p>Synchronized是可重入锁，内部锁对象中会有一个计数器记录线程获取几次锁啦，在执行完同步代码块时，计数器的数量会-1，知道计数器的数量为0，就释放这个锁。</p></div><h2 id="不可中断特性" tabindex="-1"><a class="header-anchor" href="#不可中断特性" aria-hidden="true">#</a> 不可中断特性</h2><p>一个线程获得锁后，另一个线程想要获得锁，必须处于阻塞或等待状态，如果第一个线程不释放锁，第二个线程会一直阻塞或等待，不可被中断。</p><p>Synchronized是不可中断，处于阻塞状态的线程会一直等待锁。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo02_Uninterruptible</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token class-name">Runnable</span> run <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">&quot;进入同步代码块&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">888888</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token class-name">Runnable</span> run <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">boolean</span> b <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                b <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">&quot;获得锁,进入锁执行&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">88888</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">&quot;在指定时间没有得到锁做其他操作&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">&quot;释放锁&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>


        <span class="token comment">// 开启一个线程来执行同步代码块</span>
        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>run<span class="token punctuation">)</span><span class="token punctuation">;</span>
        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>run<span class="token punctuation">)</span><span class="token punctuation">;</span>
        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;停止线程前&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        t2<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;停止线程后&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>t2<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br></div></div><p>不可中断是指，当一个线程获得锁后，另一个线程一直处于阻塞或等待状态，前一个线程不释放锁，后一个线程会一直阻塞或等待，不可被中断。</p><ul><li>Synchronized属于不可被中断</li><li>Lock 的 lock 方法是不可中断的,tryLock方法是可中断的</li></ul><h1 id="五、synchronized原理" tabindex="-1"><a class="header-anchor" href="#五、synchronized原理" aria-hidden="true">#</a> 五、synchronized原理</h1><p>通过javap反汇编学习synchronized的原理</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>demo04_synchronized_monitor</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>我们要看synchronized的原理，但是synchronized是一个关键字，看不到源码。我们可以将class文件进行反汇编。</p><p>JDK自带的一个工具：javap，对字节码进行反汇编，查看字节码指令。</p><p>反汇编后的效果如下：<code>Javap -p -v -c</code></p><p><img src="/blog/assets/5-1-1.d02399d6.png" alt="反汇编后的效果" loading="lazy"></p><h3 id="monitorenter" tabindex="-1"><a class="header-anchor" href="#monitorenter" aria-hidden="true">#</a> monitorenter</h3><p>首先我们来看一下 JVM 规范中对于 monitorenter 的描述：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorenter" target="_blank" rel="noopener noreferrer">参考<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>每一个对象都会和一个监视器monitor关联。监视器被占用时会被锁住，其他线程无法来获取该monitor。当JVM执行某个线程的某个方法内部的monitorenter时，它会尝试去获取当前对象对应的monitor的所有权。其过程如下：</p><ol><li>若monior的进入数为0，线程可以进入monitor，并将monitor的进入数置为1。当前线程成为monitor的owner(所有者)</li><li>若线程已拥有monitor的所有权，允许它重入monitor，则进入monitor的进入数加1</li><li>若其他线程已经占有monitor的所有权，那么当前尝试获取monitor的所有权的线程会被阻塞，直到monitor的进入数变为0，才能重新尝试获取monitor的所有权。</li></ol><div class="custom-container info"><p class="custom-container-title">Monitorenter 小结</p><p>Synchronized的锁对象会关联一个monitor,这个monitor不是我们主动创建的,是JVM的线程执行到这个同步代码块,发现锁对象没有monitor就会创建monitor,monitor内部有两个重要的成员变量owner:拥有这把锁的线程,recursions会记录线程拥有锁的次数,当一个线程拥有monitor后其他线程只能等待。</p></div><h3 id="monitorexit" tabindex="-1"><a class="header-anchor" href="#monitorexit" aria-hidden="true">#</a> monitorexit</h3><p>首先我们来看一下 JVM 规范中对于 monitorexit 的描述：</p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit" target="_blank" rel="noopener noreferrer">参考<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><ol><li>能执行monitorexit指令的线程一定是拥有当前对象的monitor的所有权的线程。</li><li>执行monitorexit时会将monitor的进入数减1。当monitor的进入数减为0时，当前线程退出monitor，不再拥有monitor的所有权，此时其他被这个monitor阻塞的线程可以尝试去获取这个monitor的所有权monitorexit释放锁。</li></ol><p>Monitorexit插入在方法结束处和异常处，JVM保证每个monitorenter必须有对应的monitorexit。</p><p>问题synchroznied出现异常会释放锁吗? 会释放锁</p><h3 id="同步方法" tabindex="-1"><a class="header-anchor" href="#同步方法" aria-hidden="true">#</a> 同步方法</h3><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10" target="_blank" rel="noopener noreferrer">参考<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>可以看到同步方法在反汇编后，会增加ACC_SYNCHRONIZED修饰。会隐式调用monitorenter和monitorexit。在执行同步方法前会调用monitorenter，在执行完同步方法后会调用monitorexit。</p><div class="custom-container tip"><p class="custom-container-title">总结</p><p>通过 javap 反汇编我们看到 synchronized 使用编程了 monitorentor 和 monitorexit 两个指令。</p><p>每个锁对象都会关联一个monitor(监视器,它才是真正的锁对象),它内部有两个重要的成员变量：</p><ul><li>owner会保存获得锁的线程；</li><li>recursions会保存线程获得锁的次数；</li></ul><p>当执行到 monitorexit 时,recursions 会-1,当计数器减到 0 时这个线程就会释放锁。</p></div><h3 id="问题-synchronized-与-lock-的区别" tabindex="-1"><a class="header-anchor" href="#问题-synchronized-与-lock-的区别" aria-hidden="true">#</a> 问题：synchronized 与 Lock 的区别</h3><ol><li>synchronized是关键字，而Lock是一个接口。</li><li>synchronized会自动释放锁，而Lock必须手动释放锁。</li><li>synchronized是不可中断的，Lock可以中断也可以不中断。</li><li>通过Lock可以知道线程有没有拿到锁，而synchronized不能。</li><li>synchronized能锁住方法和代码块，而Lock只能锁住代码块。</li><li>Lock可以使用读锁提高多线程读效率。</li><li>synchronized是非公平锁，<code>ReentrantLock</code>可以控制是否是公平锁。</li></ol><h2 id="深入jvm源码分析synchronized的原理" tabindex="-1"><a class="header-anchor" href="#深入jvm源码分析synchronized的原理" aria-hidden="true">#</a> 深入JVM源码分析<code>synchronized</code>的原理</h2><p><a href="http://openjdk.java.net" target="_blank" rel="noopener noreferrer">JVM 源码下载<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>Mercurial --&gt; jdk8 --&gt; hotspot --&gt; zip</p><h3 id="monitor-监视器锁" tabindex="-1"><a class="header-anchor" href="#monitor-监视器锁" aria-hidden="true">#</a> monitor 监视器锁</h3><p>可以看出无论是<code>synchronized</code>代码块还是<code>synchronized</code>方法，其线程安全的语义实现最终依赖一个叫<code>monitor</code>的东西，那么这个神秘的东西是什么呢？下面让我们来详细介绍一下。</p><p>在 HotSpot 虚拟机中，monitor 是由 ObjectMonitor 实现的。其源码是用 c++来实现的，<code>src/share/vm/runtime/objectMonitor.hpp</code></p><p>ObjectMonitor主要数据结构如下：</p><ol><li>_owner：初始时为 NULL。当有线程占有该 monitor 时，owner 标记为该线程的唯一标识。当线程释放 monitor 时，owner 又恢复为 NULL。owner 是一个临界资源，JVM 是通过 CAS 操作来保证其线程安全的。</li><li>_cxq：竞争队列，所有请求锁的线程首先会被放在这个队列中(单向链接)。cxq是一个临界资源，JVM通过CAS原子指令来修改<code>cxq</code>队列。修改前<code>cxq</code> 的旧值填入了 <code>Node.js</code> 的 <code>next</code> 字段，<code>_cxq</code>指向新值(新线程)。因此cxq 是一个后进先出的 stack(栈)。</li><li>_EntryList：_cxq 队列中有资格成为候选资源的线程会被移动到该队列中。</li><li>_WaitSet：因为调用wait方法而被阻塞的线程会被放在该队列中。</li></ol><p>每一个 Java 对象都可以与一个监视器 monitor 关联，我们可以把它理解成为一把锁，当一个线程想要执行一段被synchronized圈起来的同步方法或者代码块时，该线程得先获取到 synchronized 修饰的对象 对应的 monitor。</p><p>我们的Java代码里不会显示地去创造这么一个monitor对象，我们也无需创建，事实上可以这么理解：monitor并不是随着对象创建而创建的。我们是通过synchronized修饰符告诉JVM需要为我们的某个对象创建关联的monitor对象。每个线程都存在两个ObjectMonitor对象列表，分别为free和used列表。同时JVM中也维护着global locklist。当线程需要ObjectMonitor对象时，首先从线程自身的free表中申请，若存在则使用，若不存在则从<code>global list</code>中申请。</p><p><code>ObjectMonitor</code>的数据结构中包含：<code>owner</code>、<code>WaitSet</code>和<code>EntryList</code>，它们之间的关系转换可以用下图表示：</p><p><img src="/blog/assets/5-2-1.1d54a3e2.png" alt="ObjectMonitor" loading="lazy"></p><h3 id="monitor-竞争" tabindex="-1"><a class="header-anchor" href="#monitor-竞争" aria-hidden="true">#</a> monitor 竞争</h3><ol><li>执行 monitorenter 时，会调用 InterpreterRuntime.cpp (位于：src/share/vm/interpreter/interpreterRuntime.cpp)的InterpreterRuntime::monitorenter 函数。具体代码可参见 HotSpot 源码。</li><li>对于重量级锁，monitorenter 函数中会调用 ObjectSynchronizer::slow_enter</li><li>最终调用 ObjectMonitor::enter(位于：src/share/vm/runtime/objectMonitor.cpp)，源码如下：</li></ol><p>此处省略锁的自旋优化等操作，统一放在后面 synchronzied 优化中说。 以上代码的具体流程概括如下：</p><ol><li>通过 CAS 尝试把 monitor 的 owner 字段设置为当前线程。</li><li>如果设置之前的 owner 指向当前线程，说明当前线程再次进入 monitor，即重入锁，执行recursions ++ ，记录重入的次数。</li><li>如果当前线程是第一次进入该 monitor，设置 recursions 为 1，owner 为当前线程，该线程成功获得锁并返回。</li><li>如果获取锁失败，则等待锁的释放。</li></ol><h3 id="monitor-等待" tabindex="-1"><a class="header-anchor" href="#monitor-等待" aria-hidden="true">#</a> monitor 等待</h3><p>竞争失败等待调用的是<code>ObjectMonitor</code>对象的<code>EnterI</code>方法（位于：<code>src/share/vm/runtime/objectMonitor.cpp</code>），源码如下所示：</p><p>当该线程被唤醒时，会从挂起的点继续执行，通过 ObjectMonitor::TryLock 尝试获取锁，<code>TryLock</code>方法实现如下：</p><ol><li>当前线程被封装成<code>ObjectWaiter</code>对象<code>node</code>，状态设置成<code>ObjectWaiter::TS_CXQ</code>。</li><li>在 for 循环中，通过 CAS 把 Node.js 节点 push 到cxq 列表中，同一时刻可能有多个线程把自己的<code>node</code>节点 push 到cxq 列表中。</li><li>Node.js节点<code>push</code>到<code>cxq</code>列表之后，通过自旋尝试获取锁，如果还是没有获取到锁，则通过 park 将当前线程挂起，等待被唤醒。</li><li>当该线程被唤醒时，会从挂起的点继续执行，通过<code>ObjectMonitor::TryLock</code>尝试获取锁。</li></ol><h3 id="monitor-释放" tabindex="-1"><a class="header-anchor" href="#monitor-释放" aria-hidden="true">#</a> monitor 释放</h3><p>当某个持有锁的线程执行完同步代码块时，会进行锁的释放，给其它线程机会执行同步代码，在HotSpot中，通过退出<code>monitor</code>的方式实现锁的释放，并通知被阻塞的线程，具体实现位于<code>ObjectMonitor</code>的<code>exit</code>方法中。(位于：<code>src/share/vm/runtime/objectMonitor.cpp</code>)，源码如下所示：</p><ol><li>退出同步代码块时会让<code>recursions</code>减1，当<code>recursions</code>的值减为0时，说明线程释放了锁。</li><li>根据不同的策略(由<code>QMode</code>指定)，从<code>cxq</code>或 <code>EntryList</code> 中获取头节点，通过<code>ObjectMonitor::ExitEpilog</code>方法唤醒该节点封装的线程，唤醒操作最终由<code>unpark</code>完成，实现如下： 被唤醒的线程，会回到<code>void ATTR ObjectMonitor::EnterI (TRAPS)</code>的第600行，继续执行<code>monitor</code>的竞争。</li></ol><h3 id="monitor是重量级锁" tabindex="-1"><a class="header-anchor" href="#monitor是重量级锁" aria-hidden="true">#</a> monitor是重量级锁</h3><p>可以看到 ObjectMonitor 的函数调用中会涉及到 <code>Atomic::cmpxchg_ptr</code>，<code>Atomic::inc_ptr</code>等内核函数， 执行同步代码块，没有竞争到锁的对象会<code>park()</code>被挂起，竞争到锁的线程会<code>unpark()</code>唤醒。</p><p>这个时候就会存在操作系统用户态和内核态的转换，这种切换会消耗大量的系统资源。 所以synchronized是 Java 语 言中是一个重量级(Heavyweight)的操作。</p><h4 id="用户态和和内核态" tabindex="-1"><a class="header-anchor" href="#用户态和和内核态" aria-hidden="true">#</a> 用户态和和内核态</h4><p>Linux 系统的体系架构</p><p><img src="/blog/assets/synchronized-principle-analysis-and-optimization-1649899349761.4ee41ada.png" alt="用户态和内核态" loading="lazy"></p><p>1.操作系统需要两种CPU状态</p><ul><li>内核态（Kernel Mode）：运行操作系统程序，操作硬件</li><li>用户态（User Mode）：运行用户程序</li></ul><p>当程序运行在3级特权级上时，就可以称之为运行在用户态。因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；</p><p>当程序运行在0级特权级上时，就可以称之为运行在内核态。</p><p>运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态（比如操作硬件）。</p><p>这两种状态的主要差别是</p><ul><li>处于用户态执行时，进程所能访问的内存空间和对象受到限制，其<strong>所处于占有的处理器是可被抢占的</strong></li><li>处于内核态执行时，则能访问所有的内存空间和对象，且<strong>所占有的处理器是不允许被抢占</strong>的。</li></ul><p>从上图可以看出，Linux操作系统的体系架构分为：用户空间(应用程序的活动空间)和内核。内核：本质上可以理解为一种软件，控制计算机的硬件资源，并提供上层应用程序运行的环境。</p><p>用户空间：上层应用程序活动的空间。应用程序的执行必须依托于内核提供的资源，包括CPU资源、存储资源、I/O资源等。</p><p>系统调用：为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即系统调用。</p><p>所有进程初始都运行于用户空间，此时即为用户运行状态(简称：用户态)；但是当它调用系统调用执行某些操作时，例如I/O调用，此时需要陷入内核中运行，我们就称进程处于内核运行态（或简称为内核态）。系统调用的过程可以简单理解为：</p><ol><li>用户态程序将一些数据值放在寄存器中，或者使用参数创建一个堆栈，以此表明需要操作系统提供的服务。</li><li>用户态程序执行系统调用。</li><li>CPU切换到内核态，并跳到位于内存指定位置的指令。</li><li>系统调用处理器(<code>systemcallhandler</code>)会读取程序放入内存的数据参数，并执行程序请求的服务。</li><li>系统调用完成后，操作系统会重置<code>CPU</code>为用户态并返回系统调用的结果。</li></ol><p>由此可见用户态切换至内核态需要传递许多变量，同时内核还需要保护好用户态在切换时的一些寄存器值、变量等，以备内核态切换回用户态。这种切换就带来了大量的系统资源消耗，这就是在 <code>synchronized</code>未优化之前，效率低的原因。</p><h2 id="六、jdk6-synchronized优化" tabindex="-1"><a class="header-anchor" href="#六、jdk6-synchronized优化" aria-hidden="true">#</a> 六、JDK6 synchronized优化</h2><p>CAS的全成是：CompareAndSwap(比较相同再交换)。是现代CPU广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。</p><p>CAS的作用：CAS可以将比较和交换转换为原子操作，这个原子操作直接由CPU保证。CAS可以保证共享变量赋值时的原子操作。</p><p>CAS操作依赖3个值：内存中的值V，旧的预估值X，要修改的新值B，如果旧的预估值X等于内存中的值V，就将新的值B保存到内存中。</p><h3 id="cas和volatile实现无锁并发" tabindex="-1"><a class="header-anchor" href="#cas和volatile实现无锁并发" aria-hidden="true">#</a> CAS和volatile实现无锁并发</h3><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span></span><span class="token class-name">AtomicInteger</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token class-name">AtomicInteger</span> atomicInteger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Runnable</span> mr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                atomicInteger<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Thread</span><span class="token punctuation">&gt;</span></span> ts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>mr<span class="token punctuation">)</span><span class="token punctuation">;</span>
            t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            ts<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span> t <span class="token operator">:</span> ts<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;number = &quot;</span> <span class="token operator">+</span> atomicInteger<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h3 id="cas原理" tabindex="-1"><a class="header-anchor" href="#cas原理" aria-hidden="true">#</a> CAS原理</h3><p>通过刚才<code>AtomicInteger</code>的源码我们可以看到，<code>Unsafe</code>类提供了原子操作。</p><p>Unsafe 类使<code>Java</code>拥有了像C语言的指针一样操作内存空间的能力，同时也带来了指针的问题。过度的使用<code>Unsafe</code>类会使得出错的几率变大，因此Java官方并不建议使用的，官方文档也几乎没有。Unsafe 对象不能直接调用，只能通过反射获得。</p><p><img src="/blog/assets/6-1-1.7e9ec5bb.png" alt="Unsafe" loading="lazy"></p><h4 id="unsafe实现cas" tabindex="-1"><a class="header-anchor" href="#unsafe实现cas" aria-hidden="true">#</a> Unsafe实现CAS</h4><p><img src="/blog/assets/synchronized-principle-analysis-and-optimization-1649899407190.886e96f8.png" alt="Unsafe实现CAS" loading="lazy"></p><h4 id="乐观锁和悲观锁" tabindex="-1"><a class="header-anchor" href="#乐观锁和悲观锁" aria-hidden="true">#</a> 乐观锁和悲观锁</h4><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞。因此<code>synchronized</code>我们也将其称之为悲观锁。JDK中的 <code>ReentrantLock</code>也是一种悲观锁。性能较差！</p><p>乐观锁从乐观的角度出发: 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，就算改了也没关系，再重试即可。所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去修改这个数据，如何没有人修改则更新，如果有人修改则重试。CAS这种机制我们也可以将其称之为乐观锁。综合性能较好！</p><p>CAS获取共享变量时，为了保证该变量的可见性，需要使用<code>volatile</code>修饰。结合CAS和volatile可以实现无锁并发，适用于竞争不激烈、多核CPU的场景下。</p><ol><li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一。</li><li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响。</li></ol><div class="custom-container tip"><p class="custom-container-title">总结 CAS 可以将比较和交换转换为原子操作，这个原子操作直接由处理器保证。</p><p>CAS需要3个值:内存地址V，旧的预期值A，要修改的新值B，如果内存地址V和旧的预期值A相等就修改内存地址值为B</p></div><h2 id="synchronized-锁升级过程" tabindex="-1"><a class="header-anchor" href="#synchronized-锁升级过程" aria-hidden="true">#</a> synchronized 锁升级过程</h2><p>高效并发是从 JDK 5 到 JDK 6 的一个重要改进，<code>HotSpot</code>虛拟机开发团队在这个版本上花费了大量的精力 去实现各种锁优化技术，包括偏向锁( Biased Locking )、轻量级锁(<code>Lightweight Locking</code>)和如适应性 自旋(<code>Adaptive Spinning</code>)、锁消除(<code>Lock Elimination</code>)、锁粗化(<code>Lock Coarsening</code>)等，这些技术都是为 了在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。</p><!--[--><div class="flowchart-loading-wrapper"><svg xmlns="http://www.w3.org/2000/svg" class="loading-icon" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid"><circle cx="50" cy="50" r="0" fill="none" stroke="currentColor" stroke-width="2"><animate attributeName="r" repeatCount="indefinite" dur="1s" values="0;40" keyTimes="0;1" keySplines="0 0.2 0.8 1" calcMode="spline" begin="0s"/><animate attributeName="opacity" repeatCount="indefinite" dur="1s" values="1;0" keyTimes="0;1" keySplines="0.2 0 0.8 1" calcMode="spline" begin="0s"/></circle><circle cx="50" cy="50" r="0" fill="none" stroke="currentColor" stroke-width="2"><animate attributeName="r" repeatCount="indefinite" dur="1s" values="0;40" keyTimes="0;1" keySplines="0 0.2 0.8 1" calcMode="spline" begin="-0.3333333333333333s"/><animate attributeName="opacity" repeatCount="indefinite" dur="1s" values="1;0" keyTimes="0;1" keySplines="0.2 0 0.8 1" calcMode="spline" begin="-0.3333333333333333s"/></circle><circle cx="50" cy="50" r="0" fill="none" stroke="currentColor" stroke-width="2"><animate attributeName="r" repeatCount="indefinite" dur="1s" values="0;40" keyTimes="0;1" keySplines="0 0.2 0.8 1" calcMode="spline" begin="-0.6666666666666666s"/><animate attributeName="opacity" repeatCount="indefinite" dur="1s" values="1;0" keyTimes="0;1" keySplines="0.2 0 0.8 1" calcMode="spline" begin="-0.6666666666666666s"/></circle></svg></div><div class="flowchart-wrapper vue" id="flowchart-64a542a6" style="display:none;"></div><!--]--><h2 id="java对象的布局" tabindex="-1"><a class="header-anchor" href="#java对象的布局" aria-hidden="true">#</a> Java对象的布局</h2><p>在 JVM 中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。如下图所示：</p><p><img src="/blog/assets/6-3-1.ce0e9cb1.png" alt="对象的布局" loading="lazy"></p><h3 id="对象头" tabindex="-1"><a class="header-anchor" href="#对象头" aria-hidden="true">#</a> 对象头</h3><p>当一个线程尝试访问<code>synchronized</code>修饰的代码块时，它首先要获得锁，那么这个锁到底存在哪里呢？ 是存在锁对象的对象头中的。</p><p>HotSpot采用<code>instanceOopDesc</code>和<code>arrayOopDesc</code>来描述对象头，<code>arrayOopDesc</code>对象用来描述数组类型。<code>InstanceOopDesc</code>的定义的在<code>Hotspot</code>源码的<code>instanceOop.hpp</code>文件中，另外，<code>arrayOopDesc</code>的定义对应<code>arrayOop.hpp</code>。</p><p>从<code>instanceOopDesc</code>代码中可以看到<code>instanceOopDesc</code>继承自<code>oopDesc</code>，<code>oopDesc</code>的定义载<code>Hotspot</code>源码中的<code>oop.hpp</code>文件中。</p><p><img src="/blog/assets/6-3-2.eacb7404.png" alt="Java对象的布局" loading="lazy"></p><p><code>_mark</code>表示对象标记、属于<code>markOop</code>类型，也就是接下来要讲解的<code>Mark World</code>，它记录了对象和锁有关的信息</p><p><code>_metadata</code>表示类元信息，类元信息存储的是对象指向它的类元数据(Klass)的首地址，其中 Klass 表示 普通指针、<code>_compressed_klass</code>表示压缩类指针。</p><div class="custom-container info"><p class="custom-container-title">小结</p><p>对象头由两部分组成，一部分用于存储自身的运行时数据，称之为<code>Mark Word</code>，另外一部分是类型指针，及对象指向它的类元数据的指针。</p></div><h3 id="mark-word" tabindex="-1"><a class="header-anchor" href="#mark-word" aria-hidden="true">#</a> Mark Word</h3><p><code>Mark Word</code>用于存储对象自身的运行时数据，如哈希码(<code>HashCode</code>)、GC 分代年龄、锁状态标志、 线程持有的锁、偏向线程 ID、偏向时间戳等等，占用内存大小与虚拟机位长一致。Mark Word 对应的类型是<code>markOop</code>。源码位于<code>markOop.hpp</code>中。</p><p><img src="/blog/assets/6-3-3.3387c6e1.png" alt="64位虚拟机下Mark Word" loading="lazy"></p><p>在64位虚拟机下，<code>Mark Word</code>是<code>64bit</code>大小的，其存储结构如下：</p><p><img src="/blog/assets/6-3-4.a7f5783b.png" alt="Mark Word" loading="lazy"></p><p>在 32位虚拟机下，<code>Mark Word</code>是<code>32bit</code>大小的，其存储结构如下：</p><p><img src="/blog/assets/6-3-5.7e245bb1.png" alt="32位虚拟机Mark Word" loading="lazy"></p><h3 id="klass-pointer" tabindex="-1"><a class="header-anchor" href="#klass-pointer" aria-hidden="true">#</a> klass pointer</h3><p>这一部分用于存储对象的类型指针，该指针指向它的类元数据，JVM 通过这个指针确定对象是哪个类的 实例。</p><p>该指针的位长度为JVM 的一个字大小，即32位的 JVM为32位，64位的JVM为64位。</p><p>如果应用的对 象过多，使用 64 位的指针将浪费大量内存，统计而言，64位的JVM将会比32 位的 JVM 多耗费 50%的内 存。为了节约内存可以使用选项 -XX:+UseCompressedOops 开启指针压缩，其中，oop 即 ordinary object pointer 普通对象指针。开启该选项后，下列指针将压缩至 32 位：</p><ol><li>每个 Class 的属性指针(即静态变量)</li><li>每个对象的属性指针(即对象变量)</li><li>普通对象数组的每个元素指针</li></ol><p>当然，也不是所有的指针都会压缩，一些特殊类型的指针 <code>JVM</code> 不会优化，比如指向 <code>PermGen</code> 的 <code>Class</code>对象指针(JDK8中指向元空间的<code>Class</code>对象指针)、本地变量、堆栈元素、入参、返回值和 NULL 指针等。<code>对象头=Mark Word+类型指针</code>(未开启指针压缩的情况下)</p><ul><li><p>在32位系统中，Mark Word = 4 bytes，类型指针 = 4bytes，对象头 = 8 bytes = 64 bits；</p></li><li><p>在64位系统中，Mark Word = 8 bytes，类型指针 = 8bytes，对象头 = 16 bytes = 128bits；</p></li><li><p>实例数据：类中定义的成员变量；</p></li><li><p>对齐填充：对齐填充并不是必然存在的，也没有什么特别的意义，他仅仅起着占位符的作用；</p></li></ul><p>由于<code>HotSpot-VM</code>的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头正好是8字节的倍数，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h3 id="查看-java-对象布局" tabindex="-1"><a class="header-anchor" href="#查看-java-对象布局" aria-hidden="true">#</a> 查看 Java 对象布局</h3><div class="language-xml ext-xml line-numbers-mode"><pre class="language-xml"><code>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.openjdk.jol<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jol-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>0.9<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>Java对象由3部分组成：对象头，实例数据，对齐数据。对象头分成两部分：<code>Mark World</code> + <code>Klass pointer</code></p><h3 id="什么是偏向锁" tabindex="-1"><a class="header-anchor" href="#什么是偏向锁" aria-hidden="true">#</a> 什么是偏向锁</h3><p>偏向锁是JDK6中的重要引进，因为HotSpot作者经过研究实践发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低，引进了偏向锁。</p><p>偏向锁的“偏”，就是偏心的“偏”、偏袒的“偏”，它的意思是这个锁会偏向于第一个获得它的线程，会在对象头存储锁偏向的线程ID，以后该线程进入和退出同步块时只需要检查是否为偏向锁、锁标志位以及ThreadID即可。</p><p><img src="/blog/assets/6-4-1.8151c670.png" alt="偏向锁" loading="lazy"></p><p>不过一旦出现多个线程竞争时必须撤销偏向锁，所以撤销偏向锁消耗的性能必须小于之前节省下来的<code>CAS</code>原子操作的性能消耗，不然就得不偿失了。</p><h3 id="偏向锁原理" tabindex="-1"><a class="header-anchor" href="#偏向锁原理" aria-hidden="true">#</a> 偏向锁原理</h3><p>当线程第一次访问同步块并获取锁时，偏向锁处理流程如下：</p><ol><li>虚拟机将会把对象头中的标志位设为“01”，即偏向模式。</li><li>同时使用<code>CAS</code>操作把获取到这个锁的线程的ID记录在对象的<code>Mark Word</code>之中 ，如果<code>CAS</code>操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。</li></ol><p><img src="/blog/assets/6-4-2.de50a179.png" alt="" loading="lazy"></p><p>持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。</p><h3 id="偏向锁的撤销" tabindex="-1"><a class="header-anchor" href="#偏向锁的撤销" aria-hidden="true">#</a> 偏向锁的撤销</h3><ol><li>偏向锁的撤销动作必须等待全局安全点</li><li>暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态</li><li>撤销偏向锁，恢复到无锁(标志位为01)或轻量级锁(标志位为00)的状态</li></ol><p>偏向锁在 Java6之后是默认启用的，但在应用程序启动几秒钟之后才激活，可以使用 -</p><p><code>XX:BiasedLockingStartupDelay=0</code>参数关闭延迟，如果确定应用程序中所有锁通常情况下处于竞争 状态，可以通过 <code>XX:-UseBiasedLocking=false</code> 参数关闭偏向锁。</p><h3 id="偏向锁好处" tabindex="-1"><a class="header-anchor" href="#偏向锁好处" aria-hidden="true">#</a> 偏向锁好处</h3><p>偏向锁是在只有一个线程执行同步块时进一步提高性能，适用于一个线程反复获得同一锁的情况。偏向锁可以提高带有同步但无竞争的程序性能。 它同样是一个带有效益权衡性质的优化，也就是说，它并不一定总是对程序运行有利，如果程序中大多数的锁总是被多个不同的线程访问比如线程池，那偏向模式就是多余的。</p><p>在JDK5中偏向锁默认是关闭的，而到了<code>JDK6</code>中偏向锁已经默认开启。</p><p>但在应用程序启动几秒钟之后才激活，可以使用 <code>-XX:BiasedLockingStartupDelay=0</code>参数关闭延迟，如果确定应用程序中所有锁通常 情况下处于竞争状态，可以通过<code>XX:-UseBiasedLocking=false</code>参数关闭偏向锁。</p><h3 id="什么是轻量级锁" tabindex="-1"><a class="header-anchor" href="#什么是轻量级锁" aria-hidden="true">#</a> 什么是轻量级锁</h3><p>轻量级锁是JDK6之中加入的新型锁机制，它名字中的“轻量级”是相对于使用<code>monitor</code>的传统锁而言的， 因此传统的锁机制就称为“重量级”锁。</p><p>首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的。</p><p>引入轻量级锁的目的：在多线程交替执行同步块的情况下，尽量避免重量级锁引起的性能消耗，但是如果多个线程在同一时刻进入临界区，会导致轻量级锁膨胀升级重量级锁，所以轻量级锁的出现并非是要替代重量级锁。</p><h3 id="轻量级锁原理" tabindex="-1"><a class="header-anchor" href="#轻量级锁原理" aria-hidden="true">#</a> 轻量级锁原理</h3><p>当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，其步骤如下：</p><p>获取锁当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的<code>Mark Word</code>之中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。</p><p>偏向锁是在只有一个线程执行同步块时进一步提高性能，适用于一个线程反复获得同一锁的情况。</p><p>偏向锁可以提高带有同步但无竞争的程序性能。</p><ol><li>判断当前对象是否处于无锁状态(hashcode、0、01)，如果是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录(<code>Lock Record</code>)的空间，用于存储锁对象目前的Mark Word的拷贝（官方 把这份拷贝加了一个<code>Displaced</code>前缀，即<code>Displaced Mark Word</code>），将对象的<code>Mark Word</code>复制到栈帧中的<code>Lock Record</code>中，将<code>Lock Reocrd</code>中的owner指向当前对象。</li><li>JVM利用CAS操作尝试将对象的<code>Mark Word</code>更新为指向<code>Lock Record</code>的指针，如果成功表示竞争到锁，则将锁标志位变成<code>00</code>，执行同步操作。</li><li>如果失败则判断当前对象的<code>Mark Word</code>是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻 量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态。</li></ol><p><img src="/blog/assets/6-5-1.f536e40e.png" alt="偏向锁" loading="lazy"></p><p><img src="/blog/assets/6-5-2.c175ab53.png" alt="偏向锁" loading="lazy"></p><h3 id="轻量级锁的释放" tabindex="-1"><a class="header-anchor" href="#轻量级锁的释放" aria-hidden="true">#</a> 轻量级锁的释放</h3><p>轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下：</p><ol><li>取出在获取轻量级锁保存在<code>Displaced Mark Word</code>中的数据。</li><li>用CAS操作将取出的数据替换当前对象的<code>Mark Word</code>中，如果成功，则说明释放锁成功。</li><li>如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要将轻量级锁需要膨胀升级为重量级 锁。</li></ol><p>对于轻量级锁，其性能提升的依据是“对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”，如果打破这个依据则除了互斥的开销外，还有额外的<code>CAS</code>操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢。</p><h3 id="轻量级锁好处" tabindex="-1"><a class="header-anchor" href="#轻量级锁好处" aria-hidden="true">#</a> 轻量级锁好处</h3><p>在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。将对象的<code>Mark Word</code>复制到栈帧中的<code>Lock Recod</code>中。<code>Mark Word</code>更新为指向<code>Lock Record</code>的指针。在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。</p><h2 id="自旋锁" tabindex="-1"><a class="header-anchor" href="#自旋锁" aria-hidden="true">#</a> 自旋锁</h2><p><code>monitor</code>实现锁的时候，知道<code>monitor</code>会阻塞和唤醒线程，线程的阻塞和唤醒需要<code>CPU</code>从用户态转为核心态，频繁的阻塞和唤醒对<code>CPU</code>来说是一件负担很重的工作，这些操作给系统的并发性能带来了很大的压力。</p><p>同时，虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间阻塞和唤醒线程并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。</p><p>为了让线程等待，这个线程会在原地循环等待，这项技术就是所谓的自旋锁。自旋锁在<code>JDK1.4.2</code>中就已经引入，只不过默认是关闭的，可以使用<code>-XX:+UseSpinning</code>参数来开启，在<code>JDK6</code>中就已经改为默认开启了。</p><p>自旋等待不能代替阻塞，且先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果锁被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间很长。</p><p>那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费。因此，自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。</p><p>自旋次数的默认值是10次，用户可以使用参数<code>-XX:PreBlockSpin</code>来更改。</p><h3 id="适应性自旋锁" tabindex="-1"><a class="header-anchor" href="#适应性自旋锁" aria-hidden="true">#</a> 适应性自旋锁</h3><p>在<code>JDK6</code>中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持 续相对更长的时间，比如100次循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取 这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控 信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确，虛拟机就会变得越来越“聪明”了。</p><h2 id="锁消除" tabindex="-1"><a class="header-anchor" href="#锁消除" aria-hidden="true">#</a> 锁消除</h2><p>锁消除是指虚拟机即时编译器(<code>JIT</code>)在运行时，对一些代码上要求同步，但是检测到不可能存在共享数据竞争的锁进行消除。</p><p>锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中， 堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们 是线程私有的，同步加锁自然就无须进行。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是程序员自己应该是很清楚的，怎么会在明知道不存在数据争用的情况下要求同步呢?</p><p>实际上有许多同步措施并不是程序员自己加入的，同步的代码在Java程序中的普遍程度也许超过了大部分读者的 想象。下面这段非常简单的代码仅仅是输出3个字符串相加的结果，无论是源码字面上还是程序语义上都没有同步。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">contactString</span><span class="token punctuation">(</span><span class="token string">&quot;aa&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;bb&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;cc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">contactString</span><span class="token punctuation">(</span><span class="token class-name">String</span> s1<span class="token punctuation">,</span> <span class="token class-name">String</span> s2<span class="token punctuation">,</span> <span class="token class-name">String</span> s3<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s3<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><code>StringBuffer</code>的<code>append ()</code> 是一个同步方法，锁就是<code>this</code>也就是<code>new StringBuilder()</code>。</p><p>虚拟机发现它的 动态作用域被限制在<code>concatString()</code>方法内部。</p><p>也就是说, <code>new StringBuilder()</code>对象的引用永远不会“逃逸”到<code>concatString()</code>方法之外，其他线程无法访问到它，因此，虽然这里有锁，但是可以被安全地消除5掉，在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了。</p><h2 id="锁粗化" tabindex="-1"><a class="header-anchor" href="#锁粗化" aria-hidden="true">#</a> 锁粗化</h2><p>将同步块的作用范围限制得尽量小，只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。</p><p>大部分情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;aa&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><code>JVM</code>会探测到一连串细小的操作都使用同一个对象加锁，将同步代码块的范围放大，放到这串操作的外面，这样只需要加一次锁即可。</p><h2 id="平时写代码如何对-synchronized-优化" tabindex="-1"><a class="header-anchor" href="#平时写代码如何对-synchronized-优化" aria-hidden="true">#</a> 平时写代码如何对 synchronized 优化</h2><p>减少synchronized的范围：同步代码块中尽量短，减少同步代码块中代码的执行时间，减少锁的竞争；</p><p>降低synchronized锁的粒度：将一个锁拆分为多个锁提高并发度；</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Hashtable</span> hs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hashtable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        hs<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;aa&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;bb&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        hs<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;xx&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;yy&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><img src="/blog/assets/6-9-1.1bf8072d.png" alt="元素上锁" loading="lazy"></p><p><img src="/blog/assets/6-9-2.93469094.png" alt="元素上锁" loading="lazy"></p><p><img src="/blog/assets/6-9-3.9bcd1310.png" alt="元素上锁" loading="lazy"></p><p><code>LinkedBlockingQueue</code> 入队和出队使用不同的锁，相对于读写只有一个锁效率要高</p><p><img src="/blog/assets/6-9-4.a6cd1fad.png" alt="元素上锁" loading="lazy"></p><h3 id="读写分离" tabindex="-1"><a class="header-anchor" href="#读写分离" aria-hidden="true">#</a> 读写分离</h3><p>读取时不加锁，写入和删除时加锁：<code>ConcurrentHashMap</code>，<code>CopyOnWriteArrayList</code> 和 <code>ConyOnWriteSet</code></p><p>workbench.action.openEditorAtIndex4</p><!--]--></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/coderzsj/blog/edit/dev/docs/java/concurrent/synchronized-principle-analysis-and-optimization.md" rel="noopener noreferrer" target="_blank" arialabel="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" arialabelledby="edit"><title id="edit" lang="en">edit icon</title><g fill="currentColor"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></g></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/5/24 15:41:09</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: 945892500@qq.com">SHIJINGSPACE</span>,<!--]--><!--[--><span class="contributor" title="email: 945892500@qq.com">zhangshijing</span><!--]--><!--]--></div></footer><nav class="page-nav"><!----><a href="/blog/java/concurrent/thread-life-cycle.html" class="nav-link next" arialabel="线程生命周期"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">线程生命周期<!----></div></a></nav><!----><!----></main><!--]--><footer class="footer-wrapper"><div class="footer"><a href="https://beian.miit.gov.cn/" target="_blank">晋ICP备2021007439号</a></div><div class="copyright">Copyright © 2022 shijing</div></footer></div><!--]--><!----><!--]--></div>
    <script type="module" src="/blog/assets/app.9da19d67.js" defer></script>
  </body>
</html>
