(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{624:function(_,v,t){"use strict";t.r(v);var e=t(1),s=Object(e.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("p",[_._v("写操作，系统保证接口的幂等性和关联数据的一致性。")]),_._v(" "),t("p",[_._v("业务数据中有一个唯一字段 businessCode 作为幂等字段。")]),_._v(" "),t("p",[_._v("新增保存")]),_._v(" "),t("p",[_._v("业务数据中唯一字段作为幂等字段 直接交给数据库层面处理。")]),_._v(" "),t("p",[_._v("更新")]),_._v(" "),t("p",[_._v("系统中有一张异常订单表，订单表 ex_order 有字段 status，如果 status 为 1，代表待处理，就能对该订单做异常登记处理，生成异常登记记录表 ex_reg，并更新订单表 status 为 2，代表已处理。")]),_._v(" "),t("p",[_._v("常见错误处理")]),_._v(" "),t("p",[_._v("用户做订单异常登记时，会回传订单 ID 和登记信息作为接口参数，先根据订单 ID 查询订单，再判断订单状态，如果订单状态为待处理，则根据订单 ID 和登记信息生成异常登记记录并插入记录表 B。")]),_._v(" "),t("p",[_._v("乐观锁")]),_._v(" "),t("p",[_._v("Update ex_order set status =2 where ID =1 and status = 1,")]),_._v(" "),t("p",[_._v("并判断返回影响行数，如果影响行数不符合预期则抛异常让数据库回滚已经执行的 sql 语句。")]),_._v(" "),t("p",[_._v("优点：这种方案本质上是乐观锁的处理方案，适合读多写少的场景，可以根据更新语句返回的数据判断，做合适的业务处理，比如重试，抛异常等；")]),_._v(" "),t("p",[_._v("缺点：如果没有预期状态 status 值则无法完成这种操作，必须新增真正的乐观锁字段 version，如果需要回滚的业务操作太多，则会加大数据库压力。")]),_._v(" "),t("p",[_._v("悲观锁方案 update")]),_._v(" "),t("p",[_._v("先根据订单 ID 和预期状态更新订单，再判断影响行数是否等于预期行数，如果符合预期，则根据订单 ID 和登记信息生成异常登记记录并插入记录表 B。")]),_._v(" "),t("p",[_._v("优点：")]),_._v(" "),t("p",[_._v("这种方案本质上是悲观锁的处理方案，适合读少写多的场景，当一个事务执行 update 的操作的时候，会在这行记录上加锁，阻塞其他事务的 update 操作；")]),_._v(" "),t("p",[_._v("缺点：")]),_._v(" "),t("p",[_._v("如果订单表不止更新状态字段，且其他字段的更新需要额外的计算，且异常登记记录表也需要其他额外字段，这种方案就没法做了。")]),_._v(" "),t("h2",{attrs:{id:"悲观锁方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#悲观锁方案"}},[_._v("#")]),_._v(" 悲观锁方案")]),_._v(" "),t("p",[t("code",[_._v("select for update")])]),_._v(" "),t("p",[_._v("先使用 select for update")]),_._v(" "),t("p",[_._v("一开始就对订单加上锁，查询订单表 A 并加锁，在根据查询返回的字段进行逻辑计算，并生成异常登记记录，然后插入数据，最后更新订单状态。因为这时候不会有别其他事务更新这条商品库存。")]),_._v(" "),t("p",[_._v("这种本质上也是悲观锁方案，适用于更新操作时需要复杂的逻辑计算。")])])}),[],!1,null,null,null);v.default=s.exports}}]);