(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{664:function(v,e,t){"use strict";t.r(e);var _=t(1),r=Object(_.a)({},(function(){var v=this,e=v.$createElement,t=v._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"netty-nio"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#netty-nio"}},[v._v("#")]),v._v(" Netty&NIO")]),v._v(" "),t("p",[v._v("Netty 是一个异步的、基于事件驱动的网络应用框架，它可以用来开发高性能服务端和客户端。")]),v._v(" "),t("h3",{attrs:{id:"问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[v._v("#")]),v._v(" 问题")]),v._v(" "),t("p",[v._v("以前编写网络调用程序的时候，我们都会在客户端创建一个 Socket，通过这个 Socket 连接到服务端。")]),v._v(" "),t("p",[v._v("服务端根据这个 Socket 创建一个 Thread，用来发出请求。客户端在发起调用以后，需要等待服务端处理完成，才能继续后面的操作。这样线程会出现等待的状态。")]),v._v(" "),t("p",[v._v("如果客户端请求数越多，服务端创建的处理线程也会越多，JVM 如此多的线程并不是一件容易的事。")]),v._v(" "),t("h2",{attrs:{id:"nio"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nio"}},[v._v("#")]),v._v(" NIO")]),v._v(" "),t("p",[v._v("为了解决上述的问题，推出了 NIO 的概念，也就是(Non-blocking I/O)。其中，Selector 机制就是 NIO 的核心。")]),v._v(" "),t("p",[v._v("当每次客户端请求时，会创建一个 Socket Channel，并将其注册到 Selector 上(多路复用器)。")]),v._v(" "),t("p",[v._v("然后，Selector 关注服务端 IO 读写事件，此时客户端并不用等待 IO 事件完成，可以继续做接下来的工作。")]),v._v(" "),t("p",[v._v("一旦，服务端完成了 IO 读写操作，Selector 会接到通知，同时告诉客户端 IO 操作已经完成。")]),v._v(" "),t("p",[v._v("接到通知的客户端，就可以通过 SocketChannel 获取需要的数据了。")]),v._v(" "),t("p",[v._v("上面描述的过程有点异步的意思，不过，Selector 实现的并不是真正意义上的异步操作。")]),v._v(" "),t("p",[v._v("因为 Selector 需要通过线程阻塞的方式监听 IO 事件变更，只是这种方式没有让客户端等待，是 Selector 在等待 IO 返回，并且通知客户端去获取数据。真正“异步 IO”(AIO)这里不展开介绍，有兴趣可以自行查找。")]),v._v(" "),t("p",[v._v("说好了 NIO 再来谈谈 Netty，Netty 作为 NIO 的实现，它适用于服务器/客户端通讯的场景，以及针对于 TCP 协议下的高并发应用。")]),v._v(" "),t("p",[v._v("对于开发者来说，它具有以下特点：")]),v._v(" "),t("p",[v._v("对 NIO 进行封装，开发者不需要关注 NIO 的底层原理，只需要调用 Netty 组件就能够完成工作。")]),v._v(" "),t("p",[v._v("对网络调用透明，从 Socket 建立 TCP 连接到网络异常的处理都做了包装。")]),v._v(" "),t("p",[v._v("对数据处理灵活， Netty 支持多种序列化框架，通过“ChannelHandler”机制，可以自定义“编/解码器”。")]),v._v(" "),t("p",[v._v("对性能调优友好，Netty 提供了线程池模式以及 Buffer 的重用机制(对象池化)，不需要构建复杂的多线程模型和操作队列。")]),v._v(" "),t("h2",{attrs:{id:"从一个简单的例子开始"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#从一个简单的例子开始"}},[v._v("#")]),v._v(" 从一个简单的例子开始")]),v._v(" "),t("p",[v._v("开篇讲到了，为了满足高并发下网络请求，引入了 NIO 的概念。Netty 是针对 NIO 的实现，在 NIO 封装，网络调用，数据处理以及性能优化等方面都有不俗的表现。")]),v._v(" "),t("p",[v._v("学习架构最容易的方式就是从实例入手，从客户端访问服务端的代码来看看 Netty 是如何运作的。再一次介绍代码中调用的组件以及组件的工作原理。")]),v._v(" "),t("p",[v._v("假设有一个客户端去调用一个服务端，假设服务端叫做 EchoServer，客户端叫做 EchoClient，用 Netty 架构实现代码如下。")]),v._v(" "),t("p",[v._v("服务端代码")]),v._v(" "),t("p",[v._v("构建服务器端，假设服务器接受客户端传来的信息，然后在控制台打印。首先，生成 EchoServer，在构造函数中传入需要监听的端口号。")]),v._v(" "),t("p",[v._v("接下来就是服务的启动方法：")]),v._v(" "),t("p",[v._v("Server 的启动方法涉及到了一些组件的调用，例如 EventLoopGroup，Channel。这些会在后面详细讲解。")]),v._v(" "),t("p",[v._v("这里有个大致的印象就好：")]),v._v(" "),t("p",[v._v("创建 EventLoopGroup。")]),v._v(" "),t("p",[v._v("创建 ServerBootstrap。")]),v._v(" "),t("p",[v._v("指定所使用的 NIO 传输 Channel。")]),v._v(" "),t("p",[v._v("使用指定的端口设置套接字地址。")]),v._v(" "),t("p",[v._v("添加一个 ServerHandler 到 Channel 的 ChannelPipeline。")]),v._v(" "),t("p",[v._v("异步地绑定服务器；调用 sync() 方法阻塞等待直到绑定完成。")]),v._v(" "),t("p",[v._v("获取 Channel 的 CloseFuture，并且阻塞当前线程直到它完成。")]),v._v(" "),t("p",[v._v("关闭 EventLoopGroup，释放所有的资源。")]),v._v(" "),t("p",[v._v("NettyServer 启动以后会监听某个端口的请求，当接受到了请求就需要处理了。在 Netty 中客户端请求服务端，被称为“入站”操作。")]),v._v(" "),t("p",[v._v("可以通过 ChannelInboundHandlerAdapter 实现，具体内容如下：")]),v._v(" "),t("p",[v._v("从上面的代码可以看出，服务端处理的代码包含了三个方法。这三个方法都是根据事件触发的。")]),v._v(" "),t("p",[v._v("他们分别是：")]),v._v(" "),t("p",[v._v("当接收到消息时的操作，channelRead。")]),v._v(" "),t("p",[v._v("消息读取完成时的方法，channelReadComplete。")]),v._v(" "),t("p",[v._v("出现异常时的方法，exceptionCaught。")]),v._v(" "),t("p",[v._v("客户端代码")]),v._v(" "),t("p",[v._v("客户端和服务端的代码基本相似，在初始化时需要输入服务端的 IP 和 Port。")])])}),[],!1,null,null,null);e.default=r.exports}}]);