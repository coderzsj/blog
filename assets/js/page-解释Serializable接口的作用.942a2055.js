(window.webpackJsonp=window.webpackJsonp||[]).push([[131],{601:function(v,_,a){"use strict";a.r(_);var t=a(1),s=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h2",{attrs:{id:"解释serializable-接口的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解释serializable-接口的作用"}},[v._v("#")]),v._v(" 解释Serializable 接口的作用")]),v._v(" "),a("p",[v._v("在JAVA中的这个Serializable是给JVM看的，告诉JVM，代码不做这个类的序列化了，JVM给我序列化，序列化就是变成二进制流，例如云计算、HADOOP、特别是Hadoop完全就是分布式环境，那么就是涉及到对象要在网络中传输，里面的全是二进制流，当然你来做着这个序列化操作也可以，但是这个类里面可能还有一个类，如果你把外面的类对象的PERSON变成二进制，那么里面也要序列化（这要用到深度遍历，很麻烦），干脆告诉JVM，让他来帮你做。")]),v._v(" "),a("h2",{attrs:{id:"礼貌"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#礼貌"}},[v._v("#")]),v._v(" 礼貌")]),v._v(" "),a("p",[v._v("礼貌点总是没错的，这也很容易做到。主动打招呼，站直、做好、男生不要翘二郎腿，不亢不卑，面试时双眼直视对方，但也不能直勾勾地盯着人家妹子或者帅哥看，会引起面试官的不适，要适合而止，游刃有余！")]),v._v(" "),a("p",[v._v("了解ID发号器是什么、为什么、如何做？")]),v._v(" "),a("h2",{attrs:{id:"数据库集群、分库分表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库集群、分库分表"}},[v._v("#")]),v._v(" 数据库集群、分库分表")]),v._v(" "),a("p",[v._v("数据库达到一定规模的时候，主键ID的唯一性，这一点很好理解。这是因为，我们的一张表被分割到不同机器上的数据库中，如果还依靠与数据库自带的自增功能的话很难保证ID唯一性！")]),v._v(" "),a("p",[v._v("可以看出，USER表中的一百万数据备份到两个数据库中，在每个一个数据库内部主键ID是自增的，")]),v._v(" "),a("p",[v._v("1、使用UUID")]),v._v(" "),a("p",[v._v("本地生成的，所以相对性能较高、时延低、扩展性高，完全不受分库分表的影响！")]),v._v(" "),a("p",[v._v("无法保证趋势递增，")]),v._v(" "),a("p",[v._v("UUID过长，往往用三十二位字符串表示，占用数据库空间较大，做主键的时候索引中主键ID占据的空间较大；")]),v._v(" "),a("p",[v._v("UUID作为主键建立索引查询效率低，常见的优化方案转换为64整数存储；")]),v._v(" "),a("p",[v._v("由于使用实现版本的不一样，在高并发情况下可能会出UUID重复的情况；")]),v._v(" "),a("h2",{attrs:{id:"vesta框架简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vesta框架简介"}},[v._v("#")]),v._v(" VESTA框架简介")]),v._v(" "),a("p",[v._v("通用的ID产生器，互联网俗称统一发号器，它具有全局唯一、粗略有序、可反解和可制造等特性，它支持三种发布模式：嵌入发布模式、中心服务器发布模式、REST发布模式，根据业务的性能需求，它可以产生最大峰值型和最小粒度型的两种类型的ID，它的实现架构使其具有高性能，可用和可伸缩等互联网产品需要的质量属性，是一款通用的高性能的发号器产品。")]),v._v(" "),a("h2",{attrs:{id:"hashmap多线程下发生死循环原因及解决"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hashmap多线程下发生死循环原因及解决"}},[v._v("#")]),v._v(" HashMap多线程下发生死循环原因及解决")]),v._v(" "),a("p",[v._v("HASHMAP在多线程环境下，同时进行PUT操作，并且同时进行扩容时，会出现链表环，导致死循环")]),v._v(" "),a("p",[v._v("因为JDK8之前采用的是头插法，新加入的冲突元素将会查到原有链表的头部。")]),v._v(" "),a("p",[v._v("扩容之后，链表的元素顺序会反过来，这也是造成死循环的原因之一")]),v._v(" "),a("p",[v._v("JDK8解决之前版本出现的死循环：")]),v._v(" "),a("p",[v._v("JDK8后是直接把节点放到扩容后原有链表的尾部")]),v._v(" "),a("p",[v._v("链表转换为树，")]),v._v(" "),a("p",[v._v("对树进行操作时")]),v._v(" "),a("p",[v._v("面试题 ConcurrentHashMap 的工作原理及代码实现,如何统计所有的元素个数")]),v._v(" "),a("p",[v._v("面试题什么是ABA问题,出现ABA问题JDK是如何解决的")]),v._v(" "),a("p",[v._v("若线程A第一次读取的值为A，线程T1准备对A执行写操作，但这段时间，线程T2完成了A到B到A的更改，当线程A准备写时，A已经不是原来的A了；")]),v._v(" "),a("p",[v._v("举个栗子：")]),v._v(" "),a("p",[v._v("一个单链表，T1和T2分别取出A")]),v._v(" "),a("p",[v._v("T1把A改成ACD，此时A->next=C")]),v._v(" "),a("p",[v._v("但是T2不知道，当T2尝试把A换成B时，由于B->next是null（T1以为A->next也是null呢）替换后就会造成C、D游离状态。")])])}),[],!1,null,null,null);_.default=s.exports}}]);