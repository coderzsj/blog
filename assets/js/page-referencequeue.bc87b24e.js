(window.webpackJsonp=window.webpackJsonp||[]).push([[99],{601:function(t,a,s){"use strict";s.r(a);var e=s(1),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"referencequeue"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#referencequeue"}},[t._v("#")]),t._v(" referencequeue")]),t._v(" "),s("h2",{attrs:{id:"_1-强引用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-强引用"}},[t._v("#")]),t._v(" 1. 强引用")]),t._v(" "),s("p",[t._v("强引用是使用最普遍的引用。")]),t._v(" "),s("p",[t._v("如果一个对象具有强引用，那垃圾收集器绝不会回收它。")]),t._v(" "),s("p",[t._v("但是如果这个"),s("code",[t._v("strongReference")]),t._v("是全局变量时，就需要在不用这个对象时赋值为 null，因为强引用不会被垃圾回收。")]),t._v(" "),s("p",[t._v("例如："),s("code",[t._v("ArrayList")]),t._v("的 "),s("code",[t._v("Clear")]),t._v(" 方法：")]),t._v(" "),s("p",[t._v("在 ArrayList 类中定义了一个 elementData 数组，在调用 clear 方法清空数组时，每个数组元素被赋值为 null。不同于 elementData=null，强引用仍然存在，避免在后续调用 add()等方法添加元素时进行内存的重新分配。使用如 clear()方法内存数组中存放的引用类型进行内存释放特别适用，这样就可以及时释放内存。")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("clear")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    modCount"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// clear to let 垃圾收集器 do its work")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" size"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        elementData"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    size "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br")])]),s("h2",{attrs:{id:"_2-软引用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-软引用"}},[t._v("#")]),t._v(" 2. 软引用")]),t._v(" "),s("p",[t._v("SoftReference 的主要特点就是在当内存不够的时候，垃圾收集器会回收软引用所引用的对象。")]),t._v(" "),s("p",[t._v("在内存敏感的项目中将某些数据设置成 SoftReference 可以避免内存的溢出。")]),t._v(" "),s("h2",{attrs:{id:"_3-弱引用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-弱引用"}},[t._v("#")]),t._v(" 3. 弱引用")]),t._v(" "),s("p",[t._v("当一个对象仅被弱引用指向, 而没有任何其他强引用指向的时候, 如果这时垃圾收集器运行, 那么这个对象就会被回收，不论当前的内存空间是否足够，这个对象都会被回收。")]),t._v(" "),s("p",[t._v("引用队列注册引用的对象，在适当的可达的改变被监听")]),t._v(" "),s("h2",{attrs:{id:"_4-phantomreference-虚引用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-phantomreference-虚引用"}},[t._v("#")]),t._v(" 4. PhantomReference 虚引用")]),t._v(" "),s("p",[t._v("虚引用顾名思义，就是形同虚设。")]),t._v(" "),s("p",[t._v("如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾收集器回收。")]),t._v(" "),s("p",[t._v("与其他几种引用都不同，虚引用并不会决定对象的生命周期。")]),t._v(" "),s("h3",{attrs:{id:"应用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[t._v("#")]),t._v(" 应用场景")]),t._v(" "),s("p",[t._v("虚引用主要用来跟踪对象被垃圾收集器回收的活动。")]),t._v(" "),s("p",[t._v("如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。")])])}),[],!1,null,null,null);a.default=n.exports}}]);