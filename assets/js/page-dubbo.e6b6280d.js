(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{651:function(a,v,_){"use strict";_.r(v);var e=_(1),t=Object(e.a)({},(function(){var a=this,v=a.$createElement,_=a._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h2",{attrs:{id:"dubbo"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dubbo"}},[a._v("#")]),a._v(" Dubbo")]),a._v(" "),_("h2",{attrs:{id:"协议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#协议"}},[a._v("#")]),a._v(" 协议")]),a._v(" "),_("p",[a._v("Dubbo: 单一长连接和 NIO 异步通讯，适合大并发小数据量的服务调用， 以及消费者远大于提供者。传输协议 "),_("code",[a._v("TCP")]),a._v("，异步，"),_("code",[a._v("Hessian")]),a._v(" 序列化;")]),a._v(" "),_("p",[a._v("Rmi: 采用 JDK 标准的 rmi 协议实现，传输参数和返回参数对象需要实现 Serializable 接口，使用 java 标准序列化机制，使用阻塞式短连接，传输数 据包大小混合，消费者和提供者个数差不多，可传文件，传输协议 TCP。 多个短连接，TCP 协议传输，同步传输，适用常规的远程服务调用和 rmi 互 操作。在依赖低版本的 Common-Collections 包，java 序列化存在安全漏 洞;")]),a._v(" "),_("p",[a._v("Webservice: 基于 WebService 的远程调用协议，集成 CXF 实现，提供和 原生 WebService 的互操作。多个短连接，基于 HTTP 传输，同步传输，适 用系统集成和跨语言调用;")]),a._v(" "),_("p",[a._v("Http: 基于 Http 表单提交的远程调用协议，使用 Spring 的 HttpInvoke 实 现。多个短连接，传输协议 HTTP，传入参数大小混合，提供者个数多于消 费者，需要给应用程序和浏览器 JS 调用;")]),a._v(" "),_("p",[a._v("Hessian:集成 Hessian 服务，基于 HTTP 通讯，采用 Servlet 暴露服务， Dubbo 内嵌 Jetty 作为服务器时默认实现，提供与 Hession 服务互操作。多 个短连接，同步 HTTP 传输，Hessian 序列化，传入参数较大，提供者大于 消费者，提供者压力较大，可传文件;")]),a._v(" "),_("p",[a._v("Memcache: 基于 memcached 实现的 RPC 协议")]),a._v(" "),_("p",[a._v("Redis: 基于 redis 实现的 RPC 协议")]),a._v(" "),_("h2",{attrs:{id:"dubbo-超时时间"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dubbo-超时时间"}},[a._v("#")]),a._v(" Dubbo 超时时间")]),a._v(" "),_("p",[a._v("Dubbo 超时时间设置有两种方式:")]),a._v(" "),_("p",[a._v("服务提供者端设置超时时间，在 Dubbo 的用户文档中，推荐如果能在服务 端多配置就尽量多配置，因为服务提供者比消费者更清楚自己提供的服务特 性。")]),a._v(" "),_("p",[a._v("服务消费者端设置超时时间，如果在消费者端设置了超时时间，以消费者端为主，即优先级更高。因为服务调用方设置超时时间控制性更灵活。如果消费方超时，服务端线程不会定制，会产生警告。")]),a._v(" "),_("h2",{attrs:{id:"注册中心"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#注册中心"}},[a._v("#")]),a._v(" 注册中心")]),a._v(" "),_("p",[a._v("Zookeeper 注册中心:")]),a._v(" "),_("p",[a._v("基于分布式协调系统 Zookeeper 实现，采用 Zookeeper 的 watch 机制实现数据变更;")]),a._v(" "),_("h2",{attrs:{id:"dubbo-和-spring-cloud"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dubbo-和-spring-cloud"}},[a._v("#")]),a._v(" Dubbo 和 Spring Cloud")]),a._v(" "),_("p",[a._v("Dubbo 是 SOA 时代的产物，它的关注点主要在于服务的调用，流 量分发、流量监控和熔断。而 Spring Cloud 诞生于微服务架构时 代，考虑的是微服务治理的方方面面，另外由于依托了 Spirng、 Spirng Boot 的优势之上，两个框架在开始目标就不一致，Dubbo 定位服务治理、")]),a._v(" "),_("p",[a._v("Spirng Cloud 是一个生态。")]),a._v(" "),_("p",[a._v("最大的区别:Dubbo 底层是使用 "),_("code",[a._v("Netty")]),a._v(" 这样的 "),_("code",[a._v("NIO")]),a._v(" 框架，是基于 TCP 协议传输的，配合以 Hession 序列化完成 RPC 通信。")]),a._v(" "),_("h2",{attrs:{id:"负载均衡策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#负载均衡策略"}},[a._v("#")]),a._v(" 负载均衡策略")]),a._v(" "),_("p",[a._v("Dubbo提供了4中负载均衡策略")]),a._v(" "),_("h3",{attrs:{id:"_1-random-loadbalance-随机均衡算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-random-loadbalance-随机均衡算法"}},[a._v("#")]),a._v(" ① Random LoadBalance（随机均衡算法）")]),a._v(" "),_("p",[a._v("随机，按权重设置随机概率。")]),a._v(" "),_("p",[a._v("在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。")]),a._v(" "),_("h3",{attrs:{id:"_2-roundrobin-loadbalance-权重轮询均衡算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-roundrobin-loadbalance-权重轮询均衡算法"}},[a._v("#")]),a._v(" ② RoundRobin LoadBalance（权重轮询均衡算法）")]),a._v(" "),_("p",[a._v("轮询，按公约后的权重设置轮询比率。")]),a._v(" "),_("p",[a._v("存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调用第二台时就卡在那里，久而久之，所有请求都卡在第二台机器上。")]),a._v(" "),_("p",[a._v("Round Robin轮询算法，是按照公约后的权重设置轮询比率，即权重轮询算法（Weighted Round-Robin），它是基于轮询算法改进而来的")]),a._v(" "),_("p",[a._v("轮询调度算法的原理是：每一次把来自用户的请求轮流分配给内部中的服务器。如从1开始，一直到N（其中N是内部服务器的总个数），然后重新开始循环。")]),a._v(" "),_("p",[a._v("该算法的优点：")]),a._v(" "),_("p",[a._v("简洁，无需记录当前所有连接的状态，所以它是一种无状态调度。")]),a._v(" "),_("p",[a._v("缺点：")]),a._v(" "),_("p",[a._v("轮询调度算法假设所有服务器的处理性能都相同，不关心每台服务器的当前连接数和相应速度。当请求服务间隔时间变化比较大时，轮询调度算法容易导致服务器间的负载不平衡。")]),a._v(" "),_("h3",{attrs:{id:"_3-leastaction-loadbalance-最少活跃调用数均衡算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-leastaction-loadbalance-最少活跃调用数均衡算法"}},[a._v("#")]),a._v(" ③ LeastAction LoadBalance（最少活跃调用数均衡算法）")]),a._v(" "),_("p",[a._v("最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。")]),a._v(" "),_("p",[a._v("使慢的提供者收到更少请求，因为越慢的提供者的调用前后技术差会越大。")]),a._v(" "),_("h3",{attrs:{id:"_4-consistenthash-loadbalance-一致性hash均衡算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-consistenthash-loadbalance-一致性hash均衡算法"}},[a._v("#")]),a._v(" ④ ConsistentHash LoadBalance（一致性Hash均衡算法）")]),a._v(" "),_("p",[a._v("一致性hash，相同参数的请求总是发送到同一提供者")]),a._v(" "),_("p",[a._v("当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其他提供者，不会引起剧烈变动弄。")]),a._v(" "),_("p",[a._v("一致性hash算法可以解决服务提供者的增加、移除及挂掉时的情况，能尽可能小的改变已存在key的映射关系，尽可能的满足单调性的要求。")]),a._v(" "),_("p",[a._v("一致性hash通过构建虚拟节点，能尽可能避免分配失衡，具有很好的平衡性。")]),a._v(" "),_("p",[a._v("以下示例假设对象（Object）就相当于Client发的请求，cache相当于服务提供者。")]),a._v(" "),_("p",[a._v("环形hash空间")]),a._v(" "),_("p",[a._v("考虑通常的hash算法都是将value映射到一个32位的key值，也即是0~2"),_("sup",[a._v("32-1次方的数值空间。可以将这个空间想象成一个首（0）尾(2")]),a._v("32-1)相接的圆环，如：")]),a._v(" "),_("div",{staticClass:"custom-block info"},[_("p",{staticClass:"custom-block-title"},[a._v("总结")]),a._v(" "),_("p",[a._v("一致性hash，相同参数的请求总是发送到同一提供者")]),a._v(" "),_("p",[a._v("当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其他提供者，不会引起剧烈变动弄。")]),a._v(" "),_("p",[a._v("一致性hash算法可以解决服务提供者的增加、移除及挂掉时的情况，能尽可能小的改变已存在key的映射关系，尽可能的满足单调性的要求。")]),a._v(" "),_("p",[a._v("一致性hash通过构建虚拟节点，能尽可能避免分配失衡，具有很好的平衡性。")]),a._v(" "),_("p",[a._v("以下示例假设对象（Object）就相当于Client发的请求，cache相当于服务提供者。")]),a._v(" "),_("p",[a._v("环形hash空间")]),a._v(" "),_("p",[a._v("考虑通常的hash算法都是将value映射到一个32位的key值，也即是0~2"),_("sup",[a._v("32-1次方的数值空间。可以将这个空间想象成一个首（0）尾(2")]),a._v("32-1)相接的圆环，如：")])])])}),[],!1,null,null,null);v.default=t.exports}}]);